{
  "description": "Consolidated booking flow frontend runtime code (guest reservation experience).",
  "generatedAt": "2025-11-16T14:48:20.476Z",
  "baseDir": "/Users/amankumarshrestha/Downloads/SajiloReserveX",
  "includeRoots": [
    "src/app/(guest-public)/(guest-experience)/reserve",
    "reserve/app",
    "reserve/pages",
    "reserve/features/reservations/wizard",
    "reserve/shared/config",
    "reserve/shared/error",
    "reserve/shared/hooks",
    "reserve/shared/lib",
    "reserve/shared/api",
    "reserve/shared/formatting",
    "reserve/shared/ui",
    "reserve/entities/reservation"
  ],
  "exclusions": {
    "skipDirNames": [
      "__tests__",
      "__stories__",
      "node_modules",
      ".git",
      ".next",
      "dist",
      "build",
      "coverage",
      "playwright-report",
      "playwright-component-report"
    ],
    "skipFilePatterns": [
      "/\\.test\\./i",
      "/\\.spec\\./i",
      "/\\.stories\\./i",
      "/\\.snap$/i",
      "/\\.mock\\./i"
    ],
    "allowedExts": [".ts", ".tsx", ".js", ".jsx", ".mjs", ".cjs"]
  },
  "totalFiles": 104,
  "files": [
    {
      "path": "reserve/app/index.tsx",
      "category": "reserve-router",
      "content": "'use client';\n\nimport { ReserveRouter } from './router';\n\nexport function ReserveApp() {\n  return <ReserveRouter />;\n}\n\nexport default ReserveApp;\n"
    },
    {
      "path": "reserve/app/providers.tsx",
      "category": "reserve-router",
      "content": "'use client';\n\nimport { QueryClient, QueryClientProvider } from '@tanstack/react-query';\nimport { ReactQueryDevtools } from '@tanstack/react-query-devtools';\nimport { useState, type PropsWithChildren } from 'react';\n\nconst defaultQueryOptions = {\n  queries: {\n    staleTime: 5 * 60 * 1000,\n    refetchOnWindowFocus: false,\n    retry: 1,\n  },\n};\n\nexport function ReserveProviders({ children }: PropsWithChildren) {\n  const [queryClient] = useState(() => new QueryClient({ defaultOptions: defaultQueryOptions }));\n\n  return (\n    <QueryClientProvider client={queryClient}>\n      {children}\n      <ReactQueryDevtools initialIsOpen={false} buttonPosition=\"bottom-left\" />\n    </QueryClientProvider>\n  );\n}\n"
    },
    {
      "path": "reserve/app/router.tsx",
      "category": "reserve-router",
      "content": "'use client';\n\nimport React, { useMemo } from 'react';\nimport { RouterProvider, createBrowserRouter } from 'react-router-dom';\n\nimport { env } from '@shared/config/env';\n\nimport { reserveRoutes } from './routes';\n\nconst sanitizedBasename = env.ROUTER_BASE_PATH;\n\nexport function ReserveRouter() {\n  const router = useMemo(() => {\n    // Only create router on client side\n    if (typeof window === 'undefined') {\n      return null;\n    }\n    return createBrowserRouter(reserveRoutes, {\n      basename: sanitizedBasename === '/' ? '/' : sanitizedBasename,\n    });\n  }, []);\n\n  if (!router) {\n    return null;\n  }\n\n  return <RouterProvider router={router} />;\n}\n"
    },
    {
      "path": "reserve/app/routes.tsx",
      "category": "reserve-router",
      "content": "import React, { lazy } from 'react';\n\nimport { ReserveRootLayout } from '@pages/RootLayout';\nimport { ReserveErrorBoundary } from '@pages/RouteError';\n\nimport type { RouteObject } from 'react-router-dom';\n\nconst WizardPage = lazy(() => import('@pages/WizardPage'));\nconst ReservationDetailsPage = lazy(() => import('@pages/ReservationDetailsPage'));\n\nexport const reserveRoutes: RouteObject[] = [\n  {\n    path: '/',\n    element: <ReserveRootLayout />,\n    errorElement: <ReserveErrorBoundary />,\n    children: [\n      {\n        index: true,\n        element: <WizardPage />,\n      },\n      {\n        path: 'new',\n        lazy: async () => ({\n          Component: (await import('@pages/WizardPage')).default,\n        }),\n      },\n      {\n        path: 'r/:slug',\n        lazy: async () => ({\n          Component: (await import('@pages/WizardPage')).default,\n        }),\n      },\n      {\n        path: ':reservationId',\n        element: <ReservationDetailsPage />,\n      },\n    ],\n  },\n  {\n    path: '*',\n    lazy: async () => ({\n      Component: (await import('@pages/NotFoundPage')).default,\n    }),\n  },\n];\n"
    },
    {
      "path": "reserve/entities/reservation/adapter.ts",
      "category": "reservation-entities",
      "content": "import { z } from 'zod';\n\nimport {\n  reservationListSchema,\n  reservationSchema,\n  type ReservationMetadata,\n} from './reservation.schema';\n\nimport type { BookingOption } from '@reserve/shared/booking';\n\nconst apiReservationSchema = z\n  .object({\n    id: z.string(),\n    restaurant_id: z.string(),\n    booking_date: z.string(),\n    start_time: z.string(),\n    end_time: z.string().optional().nullable(),\n    start_at: z.string().optional().nullable(),\n    end_at: z.string().optional().nullable(),\n    booking_type: z.string(),\n    seating_preference: z.string(),\n    status: z.string(),\n    party_size: z.number(),\n    customer_name: z.string(),\n    customer_email: z.string(),\n    customer_phone: z.string(),\n    marketing_opt_in: z.boolean().optional(),\n    notes: z.string().nullable().optional(),\n    reference: z.string().optional(),\n    client_request_id: z.string().optional().nullable(),\n    idempotency_key: z.string().optional().nullable(),\n    pending_ref: z.string().optional().nullable(),\n    details: z.unknown().optional(),\n    created_at: z.string().optional().nullable(),\n    updated_at: z.string().optional().nullable(),\n    restaurants: z\n      .union([\n        z\n          .object({\n            name: z.string().optional().nullable(),\n          })\n          .passthrough(),\n        z.array(\n          z\n            .object({\n              name: z.string().optional().nullable(),\n            })\n            .passthrough(),\n        ),\n      ])\n      .optional(),\n  })\n  .passthrough();\n\nconst apiReservationListSchema = z.array(apiReservationSchema);\n\nconst isRecord = (value: unknown): Record<string, unknown> | null => {\n  if (typeof value === 'object' && value !== null && !Array.isArray(value)) {\n    return value as Record<string, unknown>;\n  }\n  return null;\n};\n\nconst toIsoString = (date: string, time: string | null | undefined): string => {\n  if (!time) {\n    return new Date(date).toISOString();\n  }\n\n  // Combine date and time as UTC-safe ISO string. The server usually provides start_at/end_at,\n  // but this acts as a fallback to avoid returning \"Invalid Date\".\n  const isoCandidate = `${date}T${time.length === 5 ? `${time}:00` : time}`;\n  const parsed = new Date(isoCandidate);\n  if (Number.isNaN(parsed.getTime())) {\n    return new Date(date).toISOString();\n  }\n  return parsed.toISOString();\n};\n\nconst parseMetadata = (details: unknown): ReservationMetadata => {\n  const record = isRecord(details);\n  if (!record) {\n    return null;\n  }\n\n  const requestRecord = isRecord(record.request);\n\n  const metadata: ReservationMetadata = {\n    channel: typeof record.channel === 'string' ? record.channel : null,\n    request: requestRecord\n      ? {\n          idempotencyKey:\n            typeof requestRecord.idempotency_key === 'string'\n              ? requestRecord.idempotency_key\n              : null,\n          clientRequestId:\n            typeof requestRecord.client_request_id === 'string'\n              ? requestRecord.client_request_id\n              : null,\n          userAgent: typeof requestRecord.user_agent === 'string' ? requestRecord.user_agent : null,\n        }\n      : undefined,\n  };\n\n  const conflictRecord = isRecord(record.conflict);\n  if (conflictRecord) {\n    metadata.conflict = {\n      reason: typeof conflictRecord.reason === 'string' ? conflictRecord.reason : null,\n      detectedAt:\n        typeof conflictRecord.detected_at === 'string' ? conflictRecord.detected_at : undefined,\n      resolvedAt:\n        typeof conflictRecord.resolved_at === 'string' ? conflictRecord.resolved_at : undefined,\n    };\n  }\n\n  if (typeof record.rescheduled_from === 'string') {\n    metadata.rescheduledFrom = record.rescheduled_from;\n  }\n\n  if (typeof record.rescheduled_at === 'string') {\n    metadata.rescheduledAt = record.rescheduled_at;\n  }\n\n  return metadata;\n};\n\nconst extractRestaurantName = (input: unknown): string | null => {\n  if (!input) return null;\n  if (Array.isArray(input)) {\n    return extractRestaurantName(input[0]);\n  }\n  const record = isRecord(input);\n  if (!record) return null;\n  const { name } = record;\n  return typeof name === 'string' ? name : null;\n};\n\nconst normalizeReservation = (input: z.infer<typeof apiReservationSchema>) => {\n  const metadata = parseMetadata(input.details);\n  const startAt =\n    typeof input.start_at === 'string' && input.start_at.length > 0\n      ? input.start_at\n      : toIsoString(input.booking_date, input.start_time);\n  const endAtRaw =\n    typeof input.end_at === 'string' && input.end_at.length > 0\n      ? input.end_at\n      : input.end_time\n        ? toIsoString(input.booking_date, input.end_time)\n        : null;\n\n  return {\n    id: input.id,\n    restaurantId: input.restaurant_id,\n    restaurantName: extractRestaurantName(input.restaurants),\n    bookingDate: input.booking_date,\n    startTime: input.start_time,\n    endTime: input.end_time ?? undefined,\n    startAt,\n    endAt: endAtRaw,\n    bookingType: input.booking_type as BookingOption,\n    seatingPreference: input.seating_preference,\n    status: input.status,\n    partySize: input.party_size,\n    customerName: input.customer_name,\n    customerEmail: input.customer_email,\n    customerPhone: input.customer_phone,\n    marketingOptIn: Boolean(input.marketing_opt_in),\n    notes: input.notes ?? null,\n    reference: input.reference,\n    clientRequestId:\n      typeof input.client_request_id === 'string' && input.client_request_id.length > 0\n        ? input.client_request_id\n        : null,\n    idempotencyKey:\n      typeof input.idempotency_key === 'string' && input.idempotency_key.length > 0\n        ? input.idempotency_key\n        : null,\n    pendingRef:\n      typeof input.pending_ref === 'string' && input.pending_ref.length > 0\n        ? input.pending_ref\n        : null,\n    metadata,\n    createdAt:\n      typeof input.created_at === 'string' && input.created_at.length > 0 ? input.created_at : null,\n    updatedAt:\n      typeof input.updated_at === 'string' && input.updated_at.length > 0 ? input.updated_at : null,\n  };\n};\n\nexport function reservationAdapter(payload: unknown) {\n  const parsed = apiReservationSchema.parse(payload);\n  return reservationSchema.parse(normalizeReservation(parsed));\n}\n\nexport function reservationListAdapter(payload: unknown) {\n  const parsed = apiReservationListSchema.parse(payload);\n  return reservationListSchema.parse(parsed.map(normalizeReservation));\n}\n"
    },
    {
      "path": "reserve/entities/reservation/reservation.schema.ts",
      "category": "reservation-entities",
      "content": "import { z } from 'zod';\n\nconst reservationMetadataSchema = z\n  .object({\n    channel: z.string().nullable().optional(),\n    request: z\n      .object({\n        idempotencyKey: z.string().nullable().optional(),\n        clientRequestId: z.string().nullable().optional(),\n        userAgent: z.string().nullable().optional(),\n      })\n      .optional(),\n    conflict: z\n      .object({\n        reason: z.string().nullable().optional(),\n        detectedAt: z.string().datetime({ offset: true }).nullable().optional(),\n        resolvedAt: z.string().datetime({ offset: true }).nullable().optional(),\n      })\n      .optional(),\n    rescheduledFrom: z.string().datetime({ offset: true }).nullable().optional(),\n    rescheduledAt: z.string().datetime({ offset: true }).nullable().optional(),\n  })\n  .partial()\n  .nullable();\n\nexport const reservationSchema = z.object({\n  id: z.string().uuid(),\n  restaurantId: z.string().uuid(),\n  restaurantName: z.string().nullable().optional(),\n  bookingDate: z.string().regex(/^\\d{4}-\\d{2}-\\d{2}$/),\n  startTime: z.string().regex(/^\\d{2}:\\d{2}(:\\d{2})?$/), // Allow HH:MM or HH:MM:SS\n  endTime: z\n    .string()\n    .regex(/^\\d{2}:\\d{2}(:\\d{2})?$/) // Allow HH:MM or HH:MM:SS\n    .optional(),\n  startAt: z.string().datetime({ offset: true }), // Allow both Z and offset formats\n  endAt: z.string().datetime({ offset: true }).nullable().optional(),\n  partySize: z.number().int().positive(),\n  bookingType: z.enum(['lunch', 'dinner', 'drinks']),\n  seatingPreference: z.string(),\n  status: z.string(),\n  customerName: z.string(),\n  customerEmail: z.string().email(),\n  customerPhone: z.string(),\n  marketingOptIn: z.boolean(),\n  notes: z.string().nullable(),\n  reference: z.string().optional(),\n  clientRequestId: z.string().uuid().nullable(),\n  idempotencyKey: z.string().nullable(),\n  pendingRef: z.string().nullable(),\n  metadata: reservationMetadataSchema,\n  createdAt: z.string().datetime({ offset: true }).nullable().optional(),\n  updatedAt: z.string().datetime({ offset: true }).nullable().optional(),\n});\n\nexport type ReservationMetadata = z.infer<typeof reservationMetadataSchema>;\nexport type Reservation = z.infer<typeof reservationSchema>;\n\nexport const reservationListSchema = z.array(reservationSchema);\n\nexport type ReservationList = z.infer<typeof reservationListSchema>;\n"
    },
    {
      "path": "reserve/features/reservations/wizard/api/fetchBookingsByContact.ts",
      "category": "booking-wizard",
      "content": "import { reservationListAdapter } from '@entities/reservation/adapter';\nimport { apiClient } from '@shared/api/client';\n\nimport type { Reservation } from '@entities/reservation/reservation.schema';\n\ntype FetchBookingsByContactParams = {\n  restaurantId: string;\n  email: string;\n  phone: string;\n};\n\nexport async function fetchBookingsByContact(\n  params: FetchBookingsByContactParams,\n): Promise<Reservation[]> {\n  const { restaurantId, email, phone } = params;\n  const search = new URLSearchParams({ email, phone });\n  if (restaurantId?.length) {\n    search.set('restaurantId', restaurantId);\n  }\n\n  const response = await apiClient.get<{ bookings?: unknown }>(`/bookings?${search.toString()}`);\n  const rawBookings = Array.isArray(response?.bookings) ? response.bookings : [];\n  return reservationListAdapter(rawBookings);\n}\n\nexport type { FetchBookingsByContactParams };\n"
    },
    {
      "path": "reserve/features/reservations/wizard/api/types.ts",
      "category": "booking-wizard",
      "content": "import type { Reservation } from '@entities/reservation/reservation.schema';\n\nexport type ReservationSubmissionResult = {\n  booking: Reservation | null;\n  bookings: Reservation[];\n};\n"
    },
    {
      "path": "reserve/features/reservations/wizard/api/useCreateOpsReservation.ts",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useRef } from 'react';\n\nimport { emit } from '@/lib/analytics/emit';\nimport { reservationAdapter, reservationListAdapter } from '@entities/reservation/adapter';\nimport { apiClient, type ApiError } from '@shared/api/client';\nimport { reservationKeys } from '@shared/api/queryKeys';\nimport { track } from '@shared/lib/analytics';\n\nimport type { ReservationSubmissionResult } from './types';\nimport type { ReservationDraft } from '../model/reducer';\n\nexport function useCreateOpsReservation() {\n  const queryClient = useQueryClient();\n  const idempotencyKeyRef = useRef<string | null>(null);\n\n  return useMutation<\n    ReservationSubmissionResult,\n    ApiError,\n    { draft: ReservationDraft; bookingId?: string }\n  >({\n    networkMode: 'offlineFirst',\n    meta: { persist: true },\n    mutationFn: async ({ draft, bookingId }) => {\n      if (bookingId) {\n        throw Object.assign(new Error('Editing bookings is not supported in ops wizard'), {\n          code: 'UNSUPPORTED_OPERATION',\n        });\n      }\n\n      const payload = {\n        restaurantId: draft.restaurantId,\n        restaurantSlug: draft.restaurantSlug,\n        date: draft.date,\n        time: draft.time,\n        party: draft.party,\n        bookingType: draft.bookingType,\n        seating: draft.seating,\n        notes: draft.notes ?? undefined,\n        name: draft.name,\n        email: draft.email ?? undefined,\n        phone: draft.phone ?? undefined,\n        marketingOptIn: draft.marketingOptIn,\n      } as const;\n\n      const idempotencyKey =\n        idempotencyKeyRef.current ??\n        (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function'\n          ? crypto.randomUUID()\n          : `${Date.now()}-${Math.random().toString(36).slice(2)}`);\n      idempotencyKeyRef.current = idempotencyKey;\n\n      try {\n        const response = await apiClient.post<{\n          booking?: unknown;\n          bookings?: unknown;\n        }>('/ops/bookings', payload, {\n          headers: { 'Idempotency-Key': idempotencyKey },\n        });\n\n        const booking = response?.booking ? reservationAdapter(response.booking) : null;\n        const bookings = response?.bookings ? reservationListAdapter(response.bookings) : [];\n\n        return {\n          booking,\n          bookings,\n        } satisfies ReservationSubmissionResult;\n      } finally {\n        idempotencyKeyRef.current = null;\n      }\n    },\n    onSuccess: (result) => {\n      queryClient.invalidateQueries({ queryKey: reservationKeys.all() });\n      if (result.booking) {\n        queryClient.setQueryData(reservationKeys.detail(result.booking.id), result.booking);\n      }\n    },\n    onError: (error) => {\n      idempotencyKeyRef.current = null;\n      const payload = {\n        code: error?.code ?? 'UNKNOWN',\n        status: error?.status,\n        context: 'ops',\n      };\n      track('wizard_submit_failed', payload);\n      emit('wizard_submit_failed', payload);\n    },\n  });\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/api/useCreateReservation.ts",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport { useMutation, useQueryClient } from '@tanstack/react-query';\nimport { useRef } from 'react';\n\nimport { emit } from '@/lib/analytics/emit';\nimport { reservationAdapter, reservationListAdapter } from '@entities/reservation/adapter';\nimport { apiClient, type ApiError } from '@shared/api/client';\nimport { reservationKeys } from '@shared/api/queryKeys';\nimport { env } from '@shared/config/env';\nimport { track } from '@shared/lib/analytics';\n\nimport type { ReservationSubmissionResult } from './types';\nimport type { ReservationDraft } from '../model/reducer';\n\nexport function useCreateReservation() {\n  const queryClient = useQueryClient();\n  const idempotencyKeyRef = useRef<string | null>(null);\n\n  return useMutation<\n    ReservationSubmissionResult,\n    ApiError,\n    { draft: ReservationDraft; bookingId?: string }\n  >({\n    networkMode: 'offlineFirst',\n    meta: { persist: true },\n    mutationFn: async ({ draft, bookingId }) => {\n      const payload = {\n        restaurantId: draft.restaurantId,\n        restaurantSlug: draft.restaurantSlug,\n        date: draft.date,\n        time: draft.time,\n        party: draft.party,\n        bookingType: draft.bookingType,\n        seating: draft.seating,\n        notes: draft.notes ?? undefined,\n        name: draft.name,\n        email: draft.email ?? undefined,\n        phone: draft.phone ?? undefined,\n        marketingOptIn: draft.marketingOptIn,\n      };\n\n      const path = bookingId ? `/bookings/${bookingId}` : '/bookings';\n      const method = bookingId ? apiClient.put : apiClient.post;\n      const submissionTimeoutMs = Math.max(env.API_TIMEOUT_MS * 2, 30_000);\n      const idempotencyKey =\n        idempotencyKeyRef.current ??\n        (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function'\n          ? crypto.randomUUID()\n          : `${Date.now()}-${Math.random().toString(36).slice(2)}`);\n      idempotencyKeyRef.current = idempotencyKey;\n      const response = await method<{\n        booking?: unknown;\n        bookings?: unknown;\n      }>(path, payload, {\n        headers: { 'Idempotency-Key': idempotencyKey },\n        timeoutMs: submissionTimeoutMs,\n      });\n\n      const booking = response?.booking ? reservationAdapter(response.booking) : null;\n      const bookings = response?.bookings ? reservationListAdapter(response.bookings) : [];\n\n      return {\n        booking,\n        bookings,\n      } satisfies ReservationSubmissionResult;\n    },\n    onSuccess: (result) => {\n      idempotencyKeyRef.current = null;\n      queryClient.invalidateQueries({ queryKey: reservationKeys.all() });\n      if (result.booking) {\n        queryClient.setQueryData(reservationKeys.detail(result.booking.id), result.booking);\n      }\n    },\n    onError: (error, variables) => {\n      if (error?.code !== 'TIMEOUT') {\n        idempotencyKeyRef.current = null;\n      }\n      if (error?.code === 'REQUEST_ABORTED') {\n        return;\n      }\n      const payload = {\n        code: error?.code ?? 'UNKNOWN',\n        status: error?.status,\n        bookingId: variables?.bookingId ?? null,\n        context: 'customer' as const,\n      };\n      track('wizard_submit_failed', payload);\n      emit('wizard_submit_failed', payload);\n    },\n  });\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/api/useReservation.ts",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport { useQuery } from '@tanstack/react-query';\n\nimport { reservationAdapter } from '@entities/reservation/adapter';\nimport { apiClient, type ApiError } from '@shared/api/client';\nimport { reservationKeys } from '@shared/api/queryKeys';\n\nimport type { Reservation } from '@entities/reservation/reservation.schema';\n\nexport function useReservation(reservationId: string | undefined) {\n  return useQuery<Reservation, ApiError>({\n    queryKey: reservationKeys.detail(reservationId),\n    enabled: Boolean(reservationId),\n    queryFn: async ({ signal }) => {\n      if (!reservationId) {\n        throw {\n          code: 'MISSING_ID',\n          message: 'Reservation id is required',\n        } satisfies ApiError;\n      }\n      const response = await apiClient.get<{ booking: unknown }>(`/bookings/${reservationId}`, {\n        signal,\n      });\n      if (!response?.booking) {\n        throw {\n          code: 'NOT_FOUND',\n          message: 'Reservation not found',\n        } satisfies ApiError;\n      }\n      return reservationAdapter(response.booking);\n    },\n    staleTime: 5 * 60 * 1000,\n    refetchOnWindowFocus: true,\n  });\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/context/WizardContext.tsx",
      "category": "booking-wizard",
      "content": "import React, { createContext, useCallback, useContext, useMemo } from 'react';\n\nimport type { State } from '../model/reducer';\nimport type { WizardActions } from '../model/store';\n\ninterface WizardContextValue {\n  state: State;\n  actions: WizardActions;\n  goToStep: (step: number) => void;\n  goToNextStep: () => void;\n  goToPreviousStep: () => void;\n  canGoBack: boolean;\n  canGoForward: boolean;\n  currentStepIndex: number;\n  totalSteps: number;\n}\n\nconst WizardContext = createContext<WizardContextValue | null>(null);\n\nexport function useWizardContext() {\n  const context = useContext(WizardContext);\n  if (!context) {\n    throw new Error('useWizardContext must be used within WizardProvider');\n  }\n  return context;\n}\n\ninterface WizardProviderProps {\n  children: React.ReactNode;\n  state: State;\n  actions: WizardActions;\n}\n\nexport function WizardProvider({ children, state, actions }: WizardProviderProps) {\n  const totalSteps = 4;\n  const currentStepIndex = state.step;\n\n  const canGoBack = useMemo(() => {\n    return currentStepIndex > 1 && !state.submitting && !state.loading;\n  }, [currentStepIndex, state.loading, state.submitting]);\n\n  const canGoForward = useMemo(() => {\n    return currentStepIndex < totalSteps && !state.submitting && !state.loading;\n  }, [currentStepIndex, state.loading, state.submitting, totalSteps]);\n\n  const goToStep = useCallback(\n    (step: number) => {\n      if (step < 1 || step > totalSteps) {\n        if (process.env.NODE_ENV !== 'production') {\n          console.warn('[wizard-context] Invalid step requested', step);\n        }\n        return;\n      }\n      actions.goToStep(step as State['step']);\n    },\n    [actions, totalSteps],\n  );\n\n  const goToNextStep = useCallback(() => {\n    if (canGoForward) {\n      goToStep(currentStepIndex + 1);\n    }\n  }, [canGoForward, currentStepIndex, goToStep]);\n\n  const goToPreviousStep = useCallback(() => {\n    if (canGoBack) {\n      goToStep(currentStepIndex - 1);\n    }\n  }, [canGoBack, currentStepIndex, goToStep]);\n\n  const value = useMemo<WizardContextValue>(\n    () => ({\n      state,\n      actions,\n      goToStep,\n      goToNextStep,\n      goToPreviousStep,\n      canGoBack,\n      canGoForward,\n      currentStepIndex,\n      totalSteps,\n    }),\n    [\n      state,\n      actions,\n      goToStep,\n      goToNextStep,\n      goToPreviousStep,\n      canGoBack,\n      canGoForward,\n      currentStepIndex,\n      totalSteps,\n    ],\n  );\n\n  return <WizardContext.Provider value={value}>{children}</WizardContext.Provider>;\n}\n\nexport function useWizardState() {\n  return useWizardContext().state;\n}\n\nexport function useWizardActions() {\n  return useWizardContext().actions;\n}\n\nexport function useWizardNavigation() {\n  const {\n    goToStep,\n    goToNextStep,\n    goToPreviousStep,\n    canGoBack,\n    canGoForward,\n    currentStepIndex,\n    totalSteps,\n  } = useWizardContext();\n\n  return {\n    goToStep,\n    goToNextStep,\n    goToPreviousStep,\n    canGoBack,\n    canGoForward,\n    currentStepIndex,\n    totalSteps,\n  };\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/di/context.tsx",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport React, { createContext, useContext, useMemo } from 'react';\n\nimport { defaultWizardDependencies, type WizardDependencies } from './types';\n\nconst WizardDependenciesContext = createContext<WizardDependencies>(defaultWizardDependencies);\n\nexport type WizardDependenciesProviderProps = {\n  value?: Partial<WizardDependencies>;\n  children: React.ReactNode;\n};\n\nexport function WizardDependenciesProvider({ value, children }: WizardDependenciesProviderProps) {\n  const merged = useMemo<WizardDependencies>(() => {\n    if (!value) {\n      return defaultWizardDependencies;\n    }\n\n    return {\n      analytics: value.analytics ?? defaultWizardDependencies.analytics,\n      haptics: value.haptics ?? defaultWizardDependencies.haptics,\n      navigator: value.navigator ?? defaultWizardDependencies.navigator,\n      errorReporter: value.errorReporter ?? defaultWizardDependencies.errorReporter,\n    };\n  }, [value]);\n\n  return (\n    <WizardDependenciesContext.Provider value={merged}>\n      {children}\n    </WizardDependenciesContext.Provider>\n  );\n}\n\nexport function useWizardDependencies(): WizardDependencies {\n  return useContext(WizardDependenciesContext);\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/di/index.ts",
      "category": "booking-wizard",
      "content": "export * from './types';\nexport * from './context';\n"
    },
    {
      "path": "reserve/features/reservations/wizard/di/types.ts",
      "category": "booking-wizard",
      "content": "import { defaultErrorReporter, type ErrorReporter } from '@reserve/shared/error';\nimport { triggerSubtleHaptic } from '@reserve/shared/lib/haptics';\nimport { track, type AnalyticsEvent } from '@shared/lib/analytics';\nexport interface AnalyticsTracker {\n  track: (event: AnalyticsEvent, payload?: Record<string, unknown>) => void;\n}\n\nexport interface HapticsClient {\n  trigger: (pattern?: number | number[]) => void;\n}\n\nexport interface Navigator {\n  push: (path: string) => void;\n  replace: (path: string) => void;\n  back: () => void;\n}\n\nexport type WizardDependencies = {\n  analytics: AnalyticsTracker;\n  haptics: HapticsClient;\n  navigator: Navigator;\n  errorReporter: ErrorReporter;\n};\n\nexport const defaultAnalyticsTracker: AnalyticsTracker = {\n  track: (event, payload) => {\n    track(event, payload);\n  },\n};\n\nexport const defaultHapticsClient: HapticsClient = {\n  trigger: (pattern) => {\n    triggerSubtleHaptic(pattern);\n  },\n};\n\nexport const defaultNavigator: Navigator = {\n  push: (path) => {\n    if (typeof window !== 'undefined') {\n      window.location.assign(path);\n    }\n  },\n  replace: (path) => {\n    if (typeof window !== 'undefined') {\n      window.location.replace(path);\n    }\n  },\n  back: () => {\n    if (typeof window !== 'undefined') {\n      window.history.back();\n    }\n  },\n};\n\nexport const defaultWizardDependencies: WizardDependencies = {\n  analytics: defaultAnalyticsTracker,\n  haptics: defaultHapticsClient,\n  navigator: defaultNavigator,\n  errorReporter: defaultErrorReporter,\n};\n"
    },
    {
      "path": "reserve/features/reservations/wizard/hooks/useConfirmationStep.ts",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\n\nimport { downloadCalendarEvent, shareReservationDetails } from '@/lib/reservations/share';\nimport { reservationConfigResult } from '@reserve/shared/config/reservations';\nimport {\n  formatReservationSummaryDate,\n  formatReservationTime,\n} from '@reserve/shared/formatting/booking';\nimport { normalizeTime } from '@reserve/shared/time';\nimport { DEFAULT_VENUE } from '@shared/config/venue';\n\nimport { useWizardState } from '../context/WizardContext';\nimport { useWizardDependencies } from '../di';\n\nimport type { State } from '../model/reducer';\nimport type {\n  ConfirmationFeedback,\n  ConfirmationStatus,\n  ConfirmationStepController,\n  ConfirmationStepProps,\n} from '../ui/steps/confirmation-step/types';\nimport type { Dispatch, SetStateAction } from 'react';\n\nconst buildReservationWindow = (state: State) => {\n  const booking = state.lastConfirmed;\n  const date = booking?.booking_date ?? state.details.date ?? '';\n\n  if (!date) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn('[confirmation-step] Missing reservation date.');\n    }\n    return null;\n  }\n\n  const time = booking?.start_time ?? normalizeTime(state.details.time);\n  const normalizedTime = normalizeTime(time);\n\n  if (!normalizedTime) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn('[confirmation-step] Invalid reservation time.', { time });\n    }\n    return null;\n  }\n\n  const iso = `${date}T${normalizedTime}:00`;\n  const start = new Date(iso);\n\n  if (Number.isNaN(start.getTime())) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error('[confirmation-step] Unable to parse reservation start date.', { iso });\n    }\n    return null;\n  }\n\n  const durationMinutes = state.details.reservationDurationMinutes;\n  const fallbackDuration = reservationConfigResult.config.defaultDurationMinutes;\n  const safeDuration = durationMinutes > 0 ? durationMinutes : fallbackDuration;\n\n  if (!Number.isFinite(safeDuration) || safeDuration <= 0) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error('[confirmation-step] Invalid reservation duration.', { safeDuration });\n    }\n    return null;\n  }\n\n  const end = new Date(start.getTime() + safeDuration * 60 * 1000);\n\n  if (Number.isNaN(end.getTime())) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error('[confirmation-step] Unable to derive reservation end date.');\n    }\n    return null;\n  }\n\n  if (end <= start) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.error('[confirmation-step] Reservation end precedes start.', { start, end });\n    }\n    return null;\n  }\n\n  return { start, end };\n};\n\nexport function useConfirmationStep({\n  state: providedState,\n  onNewBooking,\n  onClose,\n  onActionsChange,\n}: ConfirmationStepProps): ConfirmationStepController {\n  const { errorReporter } = useWizardDependencies();\n  const contextState = useWizardState();\n  const state = providedState ?? contextState;\n  const isMountedRef = useRef(true);\n  const abortControllerRef = useRef<AbortController | null>(null);\n  const booking = state.lastConfirmed;\n  const details = state.details;\n  const isLoading = state.loading;\n\n  const venue = useMemo(\n    () => ({\n      ...DEFAULT_VENUE,\n      id: details.restaurantId || DEFAULT_VENUE.id,\n      name: details.restaurantName || DEFAULT_VENUE.name,\n      address: details.restaurantAddress || DEFAULT_VENUE.address,\n      timezone: details.restaurantTimezone || DEFAULT_VENUE.timezone,\n    }),\n    [\n      details.restaurantAddress,\n      details.restaurantId,\n      details.restaurantName,\n      details.restaurantTimezone,\n    ],\n  );\n\n  const [calendarLoading, setCalendarLoading] = useState(false);\n  const [walletLoading, setWalletLoading] = useState(false);\n  const [feedback, setFeedback] = useState<ConfirmationFeedback | null>(null);\n\n  useEffect(() => {\n    isMountedRef.current = true;\n    return () => {\n      isMountedRef.current = false;\n      abortControllerRef.current?.abort();\n      abortControllerRef.current = null;\n    };\n  }, []);\n\n  const safeSetState = useCallback(<T>(setter: Dispatch<SetStateAction<T>>) => {\n    return (value: SetStateAction<T>) => {\n      if (isMountedRef.current) {\n        setter(value);\n      }\n    };\n  }, []);\n\n  const safeSetCalendarLoading = useMemo(() => safeSetState(setCalendarLoading), [safeSetState]);\n  const safeSetWalletLoading = useMemo(() => safeSetState(setWalletLoading), [safeSetState]);\n  const safeSetFeedback = useMemo(() => safeSetState(setFeedback), [safeSetState]);\n\n  const dismissFeedback = useCallback(() => {\n    safeSetFeedback(null);\n  }, [safeSetFeedback]);\n\n  const reference = booking?.reference ?? 'Pending';\n  const guestName = booking?.customer_name ?? details.name;\n  const summaryDate = details.date ? formatReservationSummaryDate(details.date) : 'TBC';\n  const summaryTime = details.time ? formatReservationTime(details.time) : 'TBC';\n  const partyText = `${details.party} ${details.party === 1 ? 'guest' : 'guests'}`;\n\n  const status: ConfirmationStatus = isLoading\n    ? 'pending'\n    : booking?.status === 'pending' || booking?.status === 'pending_allocation'\n      ? 'pending'\n      : state.lastAction === 'update'\n        ? 'updated'\n        : 'confirmed';\n\n  const heading =\n    status === 'pending'\n      ? 'Booking pending'\n      : status === 'updated'\n        ? 'Booking updated'\n        : 'Booking confirmed';\n\n  const description =\n    status === 'pending'\n      ? `Your request has been received. You'll shortly get a confirmation email at ${details.email}.`\n      : status === 'updated'\n        ? `Your reservation was updated. A confirmation email has been sent to ${details.email}.`\n        : `A confirmation email has been sent to ${details.email}.`;\n\n  const reservationWindow = useMemo(() => buildReservationWindow(state), [state]);\n\n  const showFeedback = useCallback(\n    (variant: ConfirmationFeedback['variant'], message: string) => {\n      safeSetFeedback({ variant, message });\n    },\n    [safeSetFeedback],\n  );\n\n  const sharePayload = useMemo(\n    () => ({\n      reservationId: booking?.id ?? state.details.bookingId ?? 'reservation',\n      reference: booking?.reference ?? null,\n      guestName,\n      partySize: booking?.party_size ?? details.party,\n      startAt: reservationWindow?.start.toISOString() ?? null,\n      endAt: reservationWindow?.end.toISOString() ?? null,\n      venueName: venue.name,\n      venueAddress: venue.address,\n      venueTimezone: venue.timezone,\n    }),\n    [\n      booking?.id,\n      booking?.reference,\n      booking?.party_size,\n      details.party,\n      state.details.bookingId,\n      guestName,\n      reservationWindow?.start,\n      reservationWindow?.end,\n      venue.name,\n      venue.address,\n      venue.timezone,\n    ],\n  );\n\n  const handleAddToCalendar = useCallback(() => {\n    safeSetCalendarLoading(true);\n    try {\n      const result = downloadCalendarEvent(sharePayload);\n      showFeedback(result.variant, result.message);\n    } catch (error) {\n      errorReporter.capture(error, {\n        scope: 'confirmation.calendar',\n        reservationId: state.lastConfirmed?.id,\n      });\n      showFeedback('error', 'Failed to download calendar event. Please try again.');\n    } finally {\n      safeSetCalendarLoading(false);\n    }\n  }, [errorReporter, sharePayload, showFeedback, state.lastConfirmed?.id, safeSetCalendarLoading]);\n\n  const handleAddToWallet = useCallback(async () => {\n    abortControllerRef.current?.abort();\n    const controller = new AbortController();\n    abortControllerRef.current = controller;\n\n    safeSetWalletLoading(true);\n    try {\n      const result = await shareReservationDetails(sharePayload, {\n        signal: controller.signal,\n      });\n\n      if (!controller.signal.aborted) {\n        showFeedback(result.variant, result.message);\n      }\n    } catch (error) {\n      if (controller.signal.aborted) {\n        return;\n      }\n\n      errorReporter.capture(error, {\n        scope: 'confirmation.share',\n        reservationId: state.lastConfirmed?.id,\n      });\n      showFeedback('error', \"We couldn't share the reservation details. Please try again.\");\n    } finally {\n      if (!controller.signal.aborted) {\n        safeSetWalletLoading(false);\n      }\n      abortControllerRef.current = null;\n    }\n  }, [errorReporter, sharePayload, showFeedback, state.lastConfirmed?.id, safeSetWalletLoading]);\n\n  const handleClose = useCallback(() => {\n    onClose();\n  }, [onClose]);\n\n  const handleNewBooking = useCallback(() => {\n    onNewBooking();\n  }, [onNewBooking]);\n\n  useEffect(() => {\n    onActionsChange([\n      {\n        id: 'confirmation-close',\n        label: 'Close confirmation',\n        ariaLabel: 'Close confirmation',\n        variant: 'ghost',\n        icon: 'X',\n        onClick: handleClose,\n        disabled: isLoading,\n        role: 'secondary',\n      },\n      {\n        id: 'confirmation-calendar',\n        label: 'Add reservation to calendar',\n        ariaLabel: 'Add reservation to calendar',\n        variant: 'outline',\n        icon: 'Calendar',\n        onClick: handleAddToCalendar,\n        loading: calendarLoading,\n        disabled: isLoading,\n        role: 'support',\n      },\n      {\n        id: 'confirmation-wallet',\n        label: 'Add reservation to wallet',\n        ariaLabel: 'Add reservation to wallet',\n        variant: 'outline',\n        icon: 'Wallet',\n        onClick: handleAddToWallet,\n        loading: walletLoading,\n        disabled: isLoading,\n        role: 'support',\n      },\n      {\n        id: 'confirmation-new',\n        label: 'Start a new booking',\n        ariaLabel: 'Start a new booking',\n        variant: 'default',\n        icon: 'Plus',\n        onClick: handleNewBooking,\n        disabled: isLoading,\n        role: 'primary',\n      },\n    ]);\n  }, [\n    calendarLoading,\n    handleAddToCalendar,\n    handleAddToWallet,\n    handleClose,\n    handleNewBooking,\n    isLoading,\n    onActionsChange,\n    walletLoading,\n  ]);\n\n  return {\n    booking,\n    details,\n    venue,\n    status,\n    isLoading,\n    heading,\n    description,\n    reference,\n    guestName,\n    summaryDate,\n    summaryTime,\n    partyText,\n    reservationWindow,\n    calendarLoading,\n    walletLoading,\n    feedback,\n    dismissFeedback,\n    handleAddToCalendar,\n    handleAddToWallet,\n    handleClose,\n    handleNewBooking,\n  };\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/hooks/useDetailsStepForm.ts",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { useCallback, useEffect, useMemo } from 'react';\nimport { useForm } from 'react-hook-form';\n\nimport { track } from '@shared/lib/analytics';\n\nimport { useWizardActions, useWizardState } from '../context/WizardContext';\nimport {\n  createDetailsFormSchema,\n  type DetailsFormInputValues,\n  type DetailsFormValues,\n} from '../model/schemas';\n\nimport type { BookingDetails, StepAction } from '../model/reducer';\nimport type { DetailsStepProps, DetailsStepController } from '../ui/steps/details-step/types';\n\nexport function useDetailsStepForm({\n  state: providedState,\n  actions: providedActions,\n  onActionsChange,\n  onTrack = track,\n  mode = 'customer',\n}: DetailsStepProps): DetailsStepController {\n  const contextState = useWizardState();\n  const contextActions = useWizardActions();\n  const state = providedState ?? contextState;\n  const actions = providedActions ?? contextActions;\n  const schema = useMemo(() => createDetailsFormSchema(mode), [mode]);\n  const form = useForm<DetailsFormInputValues, unknown, DetailsFormValues>({\n    resolver: zodResolver(schema),\n    mode: 'onChange',\n    reValidateMode: 'onBlur',\n    defaultValues: {\n      name: state.details.name ?? '',\n      email: state.details.email ?? '',\n      phone: state.details.phone ?? '',\n      rememberDetails: state.details.rememberDetails ?? true,\n      marketingOptIn: state.details.marketingOptIn ?? true,\n      agree: state.details.agree ?? false,\n    },\n  });\n\n  const normalizeValues = useCallback(\n    (values: DetailsFormInputValues): DetailsFormValues => ({\n      ...values,\n      rememberDetails: values.rememberDetails ?? true,\n      marketingOptIn: values.marketingOptIn ?? true,\n      agree: values.agree ?? false,\n    }),\n    [],\n  );\n\n  useEffect(() => {\n    const current = normalizeValues(form.getValues());\n    const nextInput: DetailsFormInputValues = {\n      name: state.details.name ?? '',\n      email: state.details.email ?? '',\n      phone: state.details.phone ?? '',\n      rememberDetails: state.details.rememberDetails ?? true,\n      marketingOptIn: state.details.marketingOptIn ?? true,\n      agree: state.details.agree ?? false,\n    };\n    const next = normalizeValues(nextInput);\n\n    if (\n      current.name !== next.name ||\n      current.email !== next.email ||\n      current.phone !== next.phone ||\n      current.rememberDetails !== next.rememberDetails ||\n      current.marketingOptIn !== next.marketingOptIn ||\n      current.agree !== next.agree\n    ) {\n      form.reset(nextInput, { keepDirty: false, keepTouched: false });\n    }\n  }, [\n    form,\n    normalizeValues,\n    state.details.agree,\n    state.details.email,\n    state.details.marketingOptIn,\n    state.details.name,\n    state.details.phone,\n    state.details.rememberDetails,\n  ]);\n\n  const updateField = useCallback(\n    <K extends keyof BookingDetails>(key: K, value: BookingDetails[K]) => {\n      actions.updateDetails(key, value);\n    },\n    [actions],\n  );\n\n  const handleBack = useCallback(() => {\n    actions.goToStep(1);\n  }, [actions]);\n\n  const handleError = useCallback(\n    (errors: Record<string, unknown>) => {\n      const firstKey = Object.keys(errors)[0];\n      if (firstKey) {\n        form.setFocus(firstKey as keyof DetailsFormValues, { shouldSelect: true });\n      }\n    },\n    [form],\n  );\n\n  const handleSubmit = useCallback(\n    (values: DetailsFormValues) => {\n      const trimmedName = values.name.trim();\n      const trimmedEmail = values.email.trim();\n      const trimmedPhone = values.phone.trim();\n\n      updateField('name', trimmedName);\n      updateField('email', trimmedEmail);\n      updateField('phone', trimmedPhone);\n      updateField('rememberDetails', values.rememberDetails);\n      updateField('marketingOptIn', values.marketingOptIn);\n      updateField('agree', values.agree);\n\n      onTrack('details_submit', {\n        marketing_opt_in: values.marketingOptIn ? 1 : 0,\n        terms_checked: values.agree ? 1 : 0,\n      });\n\n      actions.goToStep(3);\n    },\n    [actions, onTrack, updateField],\n  );\n\n  const { isSubmitting, isValid } = form.formState;\n\n  const handleReview = useCallback(() => {\n    form.handleSubmit(handleSubmit, handleError)();\n  }, [form, handleError, handleSubmit]);\n\n  const detailsActions = useMemo<StepAction[]>(\n    () => [\n      {\n        id: 'details-back',\n        label: 'Back',\n        icon: 'ChevronLeft',\n        variant: 'outline',\n        disabled: isSubmitting,\n        onClick: handleBack,\n        role: 'secondary',\n      },\n      {\n        id: 'details-review',\n        label: 'Review booking',\n        icon: 'Check',\n        variant: 'default',\n        disabled: isSubmitting || !isValid,\n        loading: isSubmitting,\n        onClick: handleReview,\n        role: 'primary',\n      },\n    ],\n    [handleBack, handleReview, isSubmitting, isValid],\n  );\n\n  useEffect(() => {\n    onActionsChange(detailsActions);\n  }, [detailsActions, onActionsChange]);\n\n  return {\n    form,\n    handleBack,\n    handleSubmit,\n    handleError,\n    isSubmitting,\n    isValid,\n    handlers: {\n      changeName: (value: string) => updateField('name', value),\n      changeEmail: (value: string) => updateField('email', value),\n      changePhone: (value: string) => updateField('phone', value),\n      toggleRemember: (value: boolean) => updateField('rememberDetails', value),\n      toggleMarketing: (value: boolean) => updateField('marketingOptIn', value),\n      toggleAgree: (value: boolean) => updateField('agree', value),\n    },\n  };\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/hooks/usePlanStepForm.ts",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { useQueryClient } from '@tanstack/react-query';\nimport { DateTime } from 'luxon';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { useForm } from 'react-hook-form';\n\nimport { emit } from '@/lib/analytics/emit';\nimport { MAX_ONLINE_PARTY_SIZE, MIN_ONLINE_PARTY_SIZE } from '@/lib/bookings/partySize';\nimport { useTimeSlots } from '@reserve/features/reservations/wizard/services';\nimport {\n  fetchReservationSchedule,\n  scheduleQueryKey,\n  fetchCalendarMask,\n  calendarMaskQueryKey,\n  type CalendarMask,\n} from '@reserve/features/reservations/wizard/services/schedule';\nimport { formatDateForInput } from '@reserve/shared/formatting/booking';\nimport { toMinutes } from '@reserve/shared/time';\n\nimport { useWizardActions, useWizardState } from '../context/WizardContext';\nimport { planFormSchema, type PlanFormValues } from '../model/schemas';\nimport { useDebounce } from '../utils/debounce';\n\nimport type { BookingDetails, StepAction } from '../model/reducer';\nimport type {\n  PlanStepFormProps,\n  PlanStepFormState,\n  PlanStepUnavailableReason,\n} from '../ui/steps/plan-step/types';\nimport type { BookingOption } from '@reserve/shared/booking';\n\nconst MONTH_KEY_FORMATTER = (value: Date) =>\n  `${value.getFullYear()}-${String(value.getMonth() + 1).padStart(2, '0')}`;\n\nconst toMonthStart = (value: Date) => new Date(value.getFullYear(), value.getMonth(), 1);\n\nconst deriveUnavailableReason = (\n  nextSchedule: { isClosed: boolean; slots: { disabled: boolean }[] } | null,\n): PlanStepUnavailableReason | null => {\n  if (!nextSchedule) {\n    return 'unknown';\n  }\n  if (nextSchedule.isClosed) {\n    return 'closed';\n  }\n  const hasEnabledSlot = nextSchedule.slots.some((slot) => !slot.disabled);\n  return hasEnabledSlot ? null : 'no-slots';\n};\n\nconst buildMonthDateKeys = (\n  monthStart: Date,\n  minSelectableDate: Date,\n  limit?: number,\n): string[] => {\n  const start = toMonthStart(monthStart);\n  const end = new Date(start.getFullYear(), start.getMonth() + 1, 0);\n  const keys: string[] = [];\n\n  const normalizedMin = new Date(minSelectableDate);\n  normalizedMin.setHours(0, 0, 0, 0);\n  const maxEntries =\n    typeof limit === 'number' && Number.isFinite(limit) && limit > 0\n      ? Math.floor(limit)\n      : Number.POSITIVE_INFINITY;\n\n  for (let cursor = new Date(start); cursor <= end; cursor.setDate(cursor.getDate() + 1)) {\n    if (cursor < normalizedMin) {\n      continue;\n    }\n    keys.push(formatDateForInput(new Date(cursor)));\n    if (maxEntries > 0 && keys.length >= maxEntries) {\n      break;\n    }\n  }\n\n  return keys;\n};\n\nconst parseDateKey = (value: string | null | undefined): Date | null => {\n  if (!value) {\n    return null;\n  }\n  const [yearPart, monthPart, dayPart] = value.split('-');\n  const year = Number.parseInt(yearPart ?? '', 10);\n  const month = Number.parseInt(monthPart ?? '', 10);\n  const day = Number.parseInt(dayPart ?? '', 10);\n  if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) {\n    return null;\n  }\n  const next = new Date(year, month - 1, day);\n  return Number.isNaN(next.getTime()) ? null : next;\n};\n\nconst isAbortError = (error: unknown): boolean => {\n  if (!error) {\n    return false;\n  }\n  if (error instanceof DOMException) {\n    return error.name === 'AbortError';\n  }\n  if (error instanceof Error) {\n    const normalizedName = error.name?.toLowerCase() ?? '';\n    if (\n      normalizedName === 'aborterror' ||\n      normalizedName === 'cancellederror' ||\n      normalizedName === 'cancelederror'\n    ) {\n      return true;\n    }\n    const normalizedMessage = error.message?.toLowerCase() ?? '';\n    if (\n      normalizedMessage.includes('abort') ||\n      normalizedMessage.includes('cancelled') ||\n      normalizedMessage.includes('canceled')\n    ) {\n      return true;\n    }\n  }\n  if (typeof error === 'object') {\n    const { name, code, message } = error as { name?: unknown; code?: unknown; message?: unknown };\n    if (typeof name === 'string') {\n      const normalizedName = name.toLowerCase();\n      if (\n        normalizedName === 'aborterror' ||\n        normalizedName.includes('cancelled') ||\n        normalizedName.includes('canceled')\n      ) {\n        return true;\n      }\n    }\n    if (typeof code === 'string') {\n      const normalizedCode = code.toUpperCase();\n      if (\n        normalizedCode === 'REQUEST_ABORTED' ||\n        normalizedCode === 'CANCELLED' ||\n        normalizedCode === 'CANCELED'\n      ) {\n        return true;\n      }\n    }\n    if (typeof message === 'string') {\n      const normalizedMessage = message.toLowerCase();\n      if (\n        normalizedMessage.includes('abort') ||\n        normalizedMessage.includes('cancelled') ||\n        normalizedMessage.includes('canceled')\n      ) {\n        return true;\n      }\n    }\n  }\n  if (typeof error === 'string') {\n    const normalized = error.toLowerCase();\n    if (\n      normalized.includes('abort') ||\n      normalized.includes('cancelled') ||\n      normalized.includes('canceled')\n    ) {\n      return true;\n    }\n  }\n  return false;\n};\n\nconst linkAbortSignals = (controller: AbortController, querySignal?: AbortSignal) => {\n  if (!querySignal) {\n    return undefined;\n  }\n  if (querySignal.aborted) {\n    controller.abort();\n    return undefined;\n  }\n\n  const abortHandler = () => controller.abort();\n  querySignal.addEventListener('abort', abortHandler, { once: true });\n\n  return () => {\n    querySignal.removeEventListener('abort', abortHandler);\n  };\n};\n\ntype UnavailableDateTrackingArgs = {\n  restaurantSlug: string | null | undefined;\n  date: string | null | undefined;\n  minDate: Date;\n  initialCalendarMask?: CalendarMask | null;\n};\n\ntype UnavailableDateTrackingResult = {\n  unavailableDates: Map<string, PlanStepUnavailableReason>;\n  prefetchVisibleMonth: (value: Date | null | undefined) => void;\n  updateUnavailableDate: (dateKey: string, reason: PlanStepUnavailableReason | null) => void;\n  normalizedMinDate: Date;\n  currentUnavailabilityReason: PlanStepUnavailableReason | null;\n  loadingDates: Set<string>;\n};\n\nfunction useUnavailableDateTracking({\n  restaurantSlug,\n  date,\n  minDate,\n  initialCalendarMask,\n}: UnavailableDateTrackingArgs): UnavailableDateTrackingResult {\n  const queryClient = useQueryClient();\n  const prefetchedMonthsRef = useRef<Set<string>>(new Set());\n  const maskPrefetchedMonthsRef = useRef<Set<string>>(new Set());\n  const abortControllersRef = useRef<Map<string, AbortController>>(new Map());\n  const pendingFetchesRef = useRef<Map<string, Promise<void>>>(new Map());\n  const [unavailableDates, setUnavailableDates] = useState<Map<string, PlanStepUnavailableReason>>(\n    () => new Map(),\n  );\n  const [loadingDates, setLoadingDates] = useState<Set<string>>(() => new Set());\n\n  const normalizedMinDate = useMemo(() => {\n    const hasTime =\n      minDate.getHours() !== 0 ||\n      minDate.getMinutes() !== 0 ||\n      minDate.getSeconds() !== 0 ||\n      minDate.getMilliseconds() !== 0;\n\n    if (!hasTime) {\n      return minDate;\n    }\n\n    const normalized = new Date(minDate);\n    normalized.setHours(0, 0, 0, 0);\n    return normalized;\n  }, [minDate]);\n\n  const normalizedMinTimestamp = useMemo(() => normalizedMinDate.getTime(), [normalizedMinDate]);\n\n  const updateUnavailableDate = useCallback(\n    (dateKey: string, reason: PlanStepUnavailableReason | null) => {\n      setUnavailableDates((prev) => {\n        const existing = prev.get(dateKey) ?? null;\n        if (existing === reason) {\n          return prev;\n        }\n        const nextMap = new Map(prev);\n        if (reason) {\n          nextMap.set(dateKey, reason);\n        } else {\n          nextMap.delete(dateKey);\n        }\n        return nextMap;\n      });\n    },\n    [],\n  );\n\n  const applyCalendarMask = useCallback(\n    (mask: CalendarMask) => {\n      const zone = mask.timezone?.trim() || 'UTC';\n      const start = DateTime.fromISO(mask.from, { zone }).startOf('day');\n      const end = DateTime.fromISO(mask.to, { zone }).startOf('day');\n      if (!start.isValid || !end.isValid) {\n        return;\n      }\n\n      const closedDateSet = new Set(mask.closedDates ?? []);\n      const closedDaySet = new Set(\n        (mask.closedDaysOfWeek ?? []).map((value) => ((value % 7) + 7) % 7),\n      );\n\n      for (let cursor = start; cursor <= end; cursor = cursor.plus({ days: 1 })) {\n        const isoKey = cursor.toISODate();\n        if (!isoKey) {\n          continue;\n        }\n\n        const timestamp = new Date(cursor.year, cursor.month - 1, cursor.day).getTime();\n        if (timestamp < normalizedMinTimestamp) {\n          continue;\n        }\n\n        const weekday = cursor.weekday % 7;\n        if (closedDateSet.has(isoKey) || closedDaySet.has(weekday)) {\n          updateUnavailableDate(isoKey, 'closed');\n        }\n      }\n    },\n    [normalizedMinTimestamp, updateUnavailableDate],\n  );\n\n  const prefetchCalendarMask = useCallback(\n    (month: Date) => {\n      const slug = restaurantSlug?.trim();\n      if (!slug) {\n        return;\n      }\n      const monthKey = MONTH_KEY_FORMATTER(month);\n      if (maskPrefetchedMonthsRef.current.has(monthKey)) {\n        return;\n      }\n      maskPrefetchedMonthsRef.current.add(monthKey);\n\n      const rangeStart = new Date(month.getFullYear(), month.getMonth(), 1);\n      const rangeEnd = new Date(month.getFullYear(), month.getMonth() + 1, 0);\n      const fromKey = formatDateForInput(rangeStart);\n      const toKey = formatDateForInput(rangeEnd);\n\n      void queryClient\n        .fetchQuery({\n          queryKey: calendarMaskQueryKey(slug, fromKey, toKey),\n          queryFn: ({ signal }) => fetchCalendarMask(slug, fromKey, toKey, signal),\n          staleTime: 5 * 60_000,\n        })\n        .then((mask) => {\n          applyCalendarMask(mask);\n        })\n        .catch((error) => {\n          maskPrefetchedMonthsRef.current.delete(monthKey);\n          if (process.env.NODE_ENV !== 'production') {\n            console.warn('[plan-step] failed to fetch calendar mask', {\n              restaurantSlug: slug,\n              from: fromKey,\n              to: toKey,\n              error,\n            });\n          }\n        });\n    },\n    [applyCalendarMask, queryClient, restaurantSlug],\n  );\n\n  useEffect(() => {\n    if (!initialCalendarMask) {\n      return;\n    }\n    const slug = restaurantSlug?.trim();\n    if (!slug) {\n      return;\n    }\n    const monthStart = DateTime.fromISO(initialCalendarMask.from, {\n      zone: initialCalendarMask.timezone ?? 'UTC',\n    });\n    if (!monthStart.isValid) {\n      return;\n    }\n    const jsMonthStart = new Date(monthStart.year, monthStart.month - 1, 1);\n    const monthKey = MONTH_KEY_FORMATTER(jsMonthStart);\n    if (maskPrefetchedMonthsRef.current.has(monthKey)) {\n      return;\n    }\n    maskPrefetchedMonthsRef.current.add(monthKey);\n    applyCalendarMask(initialCalendarMask);\n  }, [applyCalendarMask, initialCalendarMask, restaurantSlug]);\n\n  const prefetchVisibleMonth = useCallback(\n    (value: Date | null | undefined) => {\n      if (!value) {\n        return;\n      }\n\n      const slug = restaurantSlug?.trim();\n      if (!slug) {\n        return;\n      }\n\n      const monthStart = toMonthStart(value);\n      const monthStarts: Date[] = [monthStart];\n\n      const previousMonth = new Date(monthStart.getFullYear(), monthStart.getMonth() - 1, 1);\n      if (previousMonth.getTime() >= normalizedMinTimestamp) {\n        monthStarts.push(previousMonth);\n      }\n\n      const nextMonth = new Date(monthStart.getFullYear(), monthStart.getMonth() + 1, 1);\n      monthStarts.push(nextMonth);\n\n      monthStarts.forEach((month) => {\n        prefetchCalendarMask(month);\n\n        const monthKey = MONTH_KEY_FORMATTER(month);\n        if (prefetchedMonthsRef.current.has(monthKey)) {\n          return;\n        }\n\n        prefetchedMonthsRef.current.add(monthKey);\n\n        const dateKeys = buildMonthDateKeys(month, normalizedMinDate);\n        if (dateKeys.length === 0) {\n          return;\n        }\n\n        dateKeys.forEach((dateKey) => {\n          if (pendingFetchesRef.current.has(dateKey)) {\n            return;\n          }\n\n          const controller = new AbortController();\n          abortControllersRef.current.set(dateKey, controller);\n\n          setLoadingDates((prev) => {\n            const next = new Set(prev);\n            next.add(dateKey);\n            return next;\n          });\n\n          const fetchPromise = (async () => {\n            let unlinkAbort: (() => void) | undefined;\n            try {\n              const scheduleResult = await queryClient.fetchQuery({\n                queryKey: scheduleQueryKey(slug, dateKey),\n                queryFn: ({ signal: querySignal }) => {\n                  unlinkAbort = linkAbortSignals(controller, querySignal);\n                  return fetchReservationSchedule(slug, dateKey, controller.signal);\n                },\n                staleTime: 60_000,\n              });\n\n              if (!controller.signal.aborted) {\n                const reason = deriveUnavailableReason(scheduleResult);\n                updateUnavailableDate(dateKey, reason);\n              }\n            } catch (error) {\n              if (controller.signal.aborted || isAbortError(error)) {\n                return;\n              }\n\n              if (process.env.NODE_ENV !== 'production') {\n                console.error('[plan-step] failed to prefetch schedule', { date: dateKey, error });\n              }\n\n              emit('schedule.fetch.miss', { restaurantSlug: slug, date: dateKey });\n              updateUnavailableDate(dateKey, 'unknown');\n            } finally {\n              unlinkAbort?.();\n              if (!controller.signal.aborted) {\n                setLoadingDates((prev) => {\n                  const next = new Set(prev);\n                  next.delete(dateKey);\n                  return next;\n                });\n              }\n\n              abortControllersRef.current.delete(dateKey);\n              pendingFetchesRef.current.delete(dateKey);\n            }\n          })();\n\n          pendingFetchesRef.current.set(dateKey, fetchPromise);\n        });\n      });\n    },\n    [\n      normalizedMinDate,\n      normalizedMinTimestamp,\n      prefetchCalendarMask,\n      queryClient,\n      restaurantSlug,\n      updateUnavailableDate,\n    ],\n  );\n\n  useEffect(() => {\n    const initialMonth = parseDateKey(date) ?? normalizedMinDate;\n    prefetchVisibleMonth(initialMonth);\n  }, [date, normalizedMinDate, prefetchVisibleMonth]);\n\n  useEffect(() => {\n    const abortControllers = abortControllersRef.current;\n    const pendingFetches = pendingFetchesRef.current;\n\n    return () => {\n      abortControllers.forEach((controller) => controller.abort());\n      abortControllers.clear();\n      pendingFetches.clear();\n    };\n  }, []);\n\n  useEffect(() => {\n    const abortControllers = abortControllersRef.current;\n    const pendingFetches = pendingFetchesRef.current;\n    const prefetchedMonths = prefetchedMonthsRef.current;\n    abortControllers.forEach((controller) => controller.abort());\n    abortControllers.clear();\n    pendingFetches.clear();\n    prefetchedMonths.clear();\n    maskPrefetchedMonthsRef.current.clear();\n    setLoadingDates(new Set());\n    setUnavailableDates(new Map());\n  }, [restaurantSlug]);\n\n  const currentUnavailabilityReason = useMemo<PlanStepUnavailableReason | null>(() => {\n    if (!date) {\n      return null;\n    }\n    return unavailableDates.get(date) ?? null;\n  }, [date, unavailableDates]);\n\n  return {\n    unavailableDates,\n    prefetchVisibleMonth,\n    updateUnavailableDate,\n    normalizedMinDate,\n    currentUnavailabilityReason,\n    loadingDates,\n  };\n}\n\ntype PlanSlotDataArgs = {\n  restaurantSlug: string | null | undefined;\n  date: string | null | undefined;\n  time: string | null | undefined;\n};\n\ntype PlanSlotDataResult = {\n  slots: ReturnType<typeof useTimeSlots>['slots'];\n  serviceAvailability: ReturnType<typeof useTimeSlots>['serviceAvailability'];\n  inferBookingOption: ReturnType<typeof useTimeSlots>['inferBookingOption'];\n  schedule: ReturnType<typeof useTimeSlots>['schedule'];\n  availableBookingOptions: ReturnType<typeof useTimeSlots>['availableBookingOptions'];\n  isScheduleLoading: boolean;\n  enabledSlots: ReturnType<typeof useTimeSlots>['slots'];\n  hasAvailableSlots: boolean;\n  intervalMinutes: number | null;\n  latestSelectableMinutes: number | null;\n};\n\nfunction usePlanSlotData({ restaurantSlug, date, time }: PlanSlotDataArgs): PlanSlotDataResult {\n  const {\n    slots,\n    serviceAvailability,\n    inferBookingOption,\n    schedule,\n    availableBookingOptions,\n    isLoading: isScheduleLoading,\n  } = useTimeSlots({\n    restaurantSlug,\n    date,\n    selectedTime: time,\n  });\n\n  const enabledSlots = useMemo(() => slots.filter((slot) => !slot.disabled), [slots]);\n  const hasAvailableSlots = enabledSlots.length > 0;\n  const intervalMinutes =\n    typeof schedule?.intervalMinutes === 'number' && schedule.intervalMinutes > 0\n      ? schedule.intervalMinutes\n      : null;\n  const closingMinutes = schedule?.window?.closesAt ? toMinutes(schedule.window.closesAt) : null;\n  const configuredBufferMinutes =\n    typeof schedule?.lastSeatingBufferMinutes === 'number' && schedule.lastSeatingBufferMinutes > 0\n      ? schedule.lastSeatingBufferMinutes\n      : null;\n  const guardMinutes =\n    closingMinutes !== null\n      ? Math.max(\n          0,\n          Math.max(\n            configuredBufferMinutes ?? 0,\n            typeof schedule?.defaultDurationMinutes === 'number'\n              ? schedule.defaultDurationMinutes\n              : 0,\n          ),\n        )\n      : null;\n  const latestSelectableMinutes =\n    closingMinutes !== null && guardMinutes !== null\n      ? Math.max(0, closingMinutes - guardMinutes)\n      : null;\n\n  return {\n    slots,\n    serviceAvailability,\n    inferBookingOption,\n    schedule,\n    availableBookingOptions,\n    isScheduleLoading,\n    enabledSlots,\n    hasAvailableSlots,\n    intervalMinutes,\n    latestSelectableMinutes,\n  };\n}\n\nexport function usePlanStepForm({\n  state: providedState,\n  actions: providedActions,\n  onActionsChange,\n  onTrack,\n  minDate,\n  initialCalendarMask,\n}: PlanStepFormProps): PlanStepFormState {\n  const contextState = useWizardState();\n  const contextActions = useWizardActions();\n  const state = providedState ?? contextState;\n  const actions = providedActions ?? contextActions;\n  const form = useForm<PlanFormValues>({\n    resolver: zodResolver(planFormSchema),\n    mode: 'onChange',\n    reValidateMode: 'onBlur',\n    defaultValues: {\n      date: state.details.date ?? '',\n      time: state.details.time ?? '',\n      party: state.details.party ?? 1,\n      bookingType: state.details.bookingType,\n      notes: state.details.notes ?? '',\n    },\n  });\n  const initialPrefetchSlugRef = useRef<string | null>(null);\n\n  const {\n    unavailableDates,\n    prefetchVisibleMonth,\n    updateUnavailableDate,\n    normalizedMinDate,\n    currentUnavailabilityReason,\n    loadingDates,\n  } = useUnavailableDateTracking({\n    restaurantSlug: state.details.restaurantSlug,\n    date: state.details.date,\n    minDate,\n    initialCalendarMask,\n  });\n\n  useEffect(() => {\n    const slug = state.details.restaurantSlug?.trim();\n    if (!slug) {\n      return;\n    }\n    if (initialPrefetchSlugRef.current === slug) {\n      return;\n    }\n    const initialMonth = parseDateKey(state.details.date) ?? normalizedMinDate;\n    prefetchVisibleMonth(initialMonth);\n    initialPrefetchSlugRef.current = slug;\n  }, [normalizedMinDate, prefetchVisibleMonth, state.details.date, state.details.restaurantSlug]);\n\n  const {\n    slots,\n    serviceAvailability,\n    inferBookingOption,\n    schedule,\n    availableBookingOptions,\n    isScheduleLoading,\n    enabledSlots,\n    hasAvailableSlots,\n    intervalMinutes,\n    latestSelectableMinutes,\n  } = usePlanSlotData({\n    restaurantSlug: state.details.restaurantSlug,\n    date: state.details.date,\n    time: state.details.time,\n  });\n\n  const debouncedPrefetch = useDebounce(prefetchVisibleMonth, 300);\n\n  const lastValidDateRef = useRef<string | null>(state.details.date ?? null);\n\n  useEffect(() => {\n    form.reset(\n      {\n        date: state.details.date ?? '',\n        time: state.details.time ?? enabledSlots[0]?.value ?? '',\n        party: state.details.party ?? 1,\n        bookingType: state.details.bookingType,\n        notes: state.details.notes ?? '',\n      },\n      { keepDirty: false, keepTouched: false },\n    );\n  }, [\n    form,\n    state.details.date,\n    state.details.time,\n    state.details.party,\n    state.details.bookingType,\n    state.details.notes,\n    enabledSlots,\n  ]);\n\n  const updateField = useCallback(\n    <K extends keyof BookingDetails>(key: K, value: BookingDetails[K]) => {\n      if (state.details[key] === value) {\n        return;\n      }\n      actions.updateDetails(key, value);\n    },\n    [actions, state.details],\n  );\n\n  const fallbackTime = enabledSlots[0]?.value ?? '';\n\n  useEffect(() => {\n    if (!state.details.time && fallbackTime) {\n      updateField('time', fallbackTime);\n      form.setValue('time', fallbackTime, { shouldDirty: false, shouldValidate: true });\n    }\n  }, [fallbackTime, form, state.details.time, updateField]);\n\n  const normalizeToInterval = useCallback(\n    (value: string) => {\n      if (!value) {\n        return '';\n      }\n\n      const [hoursPart, minutesPart] = value.split(':');\n      const hours = Number.parseInt(hoursPart ?? '', 10);\n      const minutes = Number.parseInt(minutesPart ?? '', 10);\n\n      if (Number.isNaN(hours) || Number.isNaN(minutes) || hours < 0 || hours > 23 || minutes < 0) {\n        return value;\n      }\n\n      if (!intervalMinutes || intervalMinutes <= 0) {\n        return value;\n      }\n\n      const totalMinutes = Math.max(0, hours * 60 + minutes);\n      const cappedMinutes =\n        typeof latestSelectableMinutes === 'number'\n          ? Math.min(totalMinutes, latestSelectableMinutes)\n          : totalMinutes;\n      const normalizedMinutes = Math.floor(cappedMinutes / intervalMinutes) * intervalMinutes;\n      const nextHours = Math.floor(normalizedMinutes / 60);\n      const nextMinutes = normalizedMinutes % 60;\n\n      return `${nextHours.toString().padStart(2, '0')}:${nextMinutes.toString().padStart(2, '0')}`;\n    },\n    [intervalMinutes, latestSelectableMinutes],\n  );\n\n  const submitForm = useCallback(\n    (values: PlanFormValues) => {\n      const normalizedTime = normalizeToInterval(values.time);\n\n      updateField('date', values.date);\n      updateField('time', normalizedTime);\n      updateField('party', values.party);\n      updateField('bookingType', values.bookingType);\n      updateField('notes', values.notes ?? '');\n      form.setValue('time', normalizedTime, { shouldDirty: false, shouldValidate: true });\n      actions.goToStep(2);\n    },\n    [actions, form, normalizeToInterval, updateField],\n  );\n\n  const handleError = useCallback(\n    (errors: Record<string, unknown>) => {\n      const firstKey = Object.keys(errors)[0];\n      if (firstKey) {\n        form.setFocus(firstKey as keyof PlanFormValues, { shouldSelect: true });\n      }\n    },\n    [form],\n  );\n\n  const selectDate = useCallback(\n    (value: Date | undefined | null) => {\n      const formatted = value ? formatDateForInput(value) : '';\n      form.setValue('date', formatted, { shouldDirty: true, shouldValidate: true });\n      updateField('date', formatted);\n      if (formatted) {\n        onTrack?.('select_date', { date: formatted });\n      }\n    },\n    [form, onTrack, updateField],\n  );\n\n  const selectTime = useCallback(\n    (value: string, options?: { commit?: boolean }) => {\n      if (!hasAvailableSlots) {\n        return;\n      }\n\n      if (options?.commit === false) {\n        form.setValue('time', value, { shouldDirty: true, shouldValidate: false });\n        return;\n      }\n\n      const normalized = normalizeToInterval(value);\n      form.setValue('time', normalized, { shouldDirty: true, shouldValidate: true });\n      updateField('time', normalized);\n\n      const inferredService = inferBookingOption(normalized);\n      form.setValue('bookingType', inferredService, { shouldDirty: true, shouldValidate: true });\n      updateField('bookingType', inferredService);\n\n      onTrack?.('select_time', {\n        time: normalized,\n        booking_type: inferredService,\n      });\n    },\n    [form, hasAvailableSlots, inferBookingOption, normalizeToInterval, onTrack, updateField],\n  );\n\n  const changeParty = useCallback(\n    (direction: 'decrement' | 'increment') => {\n      const current = form.getValues('party');\n      const next =\n        direction === 'decrement'\n          ? Math.max(MIN_ONLINE_PARTY_SIZE, current - 1)\n          : Math.min(MAX_ONLINE_PARTY_SIZE, current + 1);\n      form.setValue('party', next, { shouldDirty: true, shouldValidate: true });\n      updateField('party', next);\n      onTrack?.('select_party', { party: next });\n    },\n    [form, onTrack, updateField],\n  );\n\n  const changeOccasion = useCallback(\n    (value: BookingOption) => {\n      form.setValue('bookingType', value, { shouldDirty: true, shouldValidate: true });\n      updateField('bookingType', value);\n      onTrack?.('select_time', {\n        time: form.getValues('time'),\n        booking_type: value,\n      });\n    },\n    [form, onTrack, updateField],\n  );\n\n  const commitNotes = useCallback(\n    (value: string) => {\n      updateField('notes', value ?? '');\n    },\n    [updateField],\n  );\n\n  useEffect(() => {\n    if (!schedule) {\n      return;\n    }\n\n    const scheduleDate = schedule.date;\n    const derivedReason = deriveUnavailableReason(schedule);\n\n    updateUnavailableDate(scheduleDate, derivedReason);\n\n    const isCurrentDate = scheduleDate === state.details.date;\n\n    if (derivedReason) {\n      if (derivedReason === 'closed') {\n        emit('selection.blocked.closed', {\n          restaurantSlug: state.details.restaurantSlug,\n          date: scheduleDate,\n        });\n      }\n      if (isCurrentDate) {\n        const fallbackDate = lastValidDateRef.current;\n        if (fallbackDate && fallbackDate !== scheduleDate) {\n          form.setValue('date', fallbackDate, { shouldDirty: true, shouldValidate: true });\n          updateField('date', fallbackDate);\n        } else if (!fallbackDate) {\n          form.setValue('date', '', { shouldDirty: true, shouldValidate: true });\n          updateField('date', '');\n        }\n\n        if (form.getValues('time')) {\n          form.setValue('time', '', { shouldDirty: true, shouldValidate: true });\n          updateField('time', '');\n        }\n\n        const dateMessage =\n          derivedReason === 'closed'\n            ? 'Were closed on the selected date. Please choose a different day.'\n            : derivedReason === 'no-slots'\n              ? 'No reservation times are available for the selected date. Please choose another day.'\n              : 'Schedule not loaded yetscroll to load month.';\n        form.setError('date', { type: 'manual', message: dateMessage });\n        form.setError('time', {\n          type: 'manual',\n          message: 'Select another date to continue.',\n        });\n      }\n      return;\n    }\n\n    if (isCurrentDate) {\n      form.clearErrors(['date', 'time']);\n      lastValidDateRef.current = scheduleDate;\n\n      const currentTime = form.getValues('time');\n      const hasCurrentSlot =\n        currentTime && enabledSlots.some((slot) => slot.value === currentTime && !slot.disabled);\n\n      if (!hasCurrentSlot) {\n        const nextSlot = enabledSlots[0]?.value ?? '';\n        if (nextSlot) {\n          form.setValue('time', nextSlot, { shouldDirty: false, shouldValidate: true });\n          updateField('time', nextSlot);\n          const inferredService = inferBookingOption(nextSlot);\n          form.setValue('bookingType', inferredService, {\n            shouldDirty: false,\n            shouldValidate: true,\n          });\n          updateField('bookingType', inferredService);\n        } else if (form.getValues('time')) {\n          form.setValue('time', '', { shouldDirty: true, shouldValidate: true });\n          updateField('time', '');\n        }\n      }\n    } else if (!derivedReason && !schedule.isClosed) {\n      lastValidDateRef.current = scheduleDate;\n    }\n  }, [\n    enabledSlots,\n    form,\n    inferBookingOption,\n    schedule,\n    state.details.date,\n    state.details.restaurantSlug,\n    updateField,\n    updateUnavailableDate,\n  ]);\n\n  useEffect(() => {\n    const duration = schedule?.defaultDurationMinutes;\n    if (!duration || duration <= 0) {\n      return;\n    }\n    if (state.details.reservationDurationMinutes === duration) {\n      return;\n    }\n    updateField('reservationDurationMinutes', duration);\n  }, [schedule?.defaultDurationMinutes, state.details.reservationDurationMinutes, updateField]);\n\n  const handleContinue = useCallback(() => {\n    form.handleSubmit(submitForm, handleError)();\n  }, [form, handleError, submitForm]);\n\n  const planStepActions = useMemo<StepAction[]>(\n    () => [\n      {\n        id: 'plan-continue',\n        label: 'Continue',\n        icon: 'ChevronDown',\n        variant: 'default',\n        disabled: form.formState.isSubmitting || !form.formState.isValid,\n        loading: form.formState.isSubmitting,\n        onClick: handleContinue,\n        role: 'primary',\n      },\n    ],\n    [form.formState.isSubmitting, form.formState.isValid, handleContinue],\n  );\n\n  useEffect(() => {\n    onActionsChange(planStepActions);\n  }, [onActionsChange, planStepActions]);\n\n  return {\n    form,\n    slots,\n    availability: serviceAvailability,\n    availableBookingOptions,\n    occasionCatalog: schedule?.occasionCatalog ?? [],\n    handlers: {\n      selectDate,\n      selectTime,\n      changeParty,\n      changeOccasion,\n      commitNotes,\n      prefetchMonth: (month: Date) => {\n        debouncedPrefetch(month);\n      },\n    },\n    minDate: normalizedMinDate,\n    intervalMinutes,\n    unavailableDates,\n    loadingDates,\n    hasAvailableSlots,\n    isScheduleLoading,\n    schedule,\n    currentUnavailabilityReason,\n    isSubmitting: form.formState.isSubmitting,\n    isValid: form.formState.isValid,\n    submitForm,\n    handleError,\n  } as const;\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/hooks/useRememberedContacts.ts",
      "category": "booking-wizard",
      "content": "import { useEffect } from 'react';\n\nimport { storageKeys } from '@reserve/shared/booking';\n\nimport { useWizardDependencies } from '../di';\n\nimport type { BookingDetails } from '../model/reducer';\nimport type { WizardActions } from '../model/store';\n\ntype ContactDetails = Pick<BookingDetails, 'name' | 'email' | 'phone' | 'rememberDetails'>;\n\ntype RememberedContactsConfig = {\n  details: ContactDetails;\n  actions: Pick<WizardActions, 'hydrateContacts' | 'updateDetails'>;\n  enabled?: boolean;\n};\n\nconst STORAGE_KEY = storageKeys.contacts;\nconst CONTACT_VERSION = 1;\nconst REMEMBERED_CONTACT_TTL_MS = 30 * 24 * 60 * 60 * 1000; // 30 days\n\ntype StoredContacts = {\n  version: typeof CONTACT_VERSION;\n  savedAt: number;\n  expiresAt: number;\n  remember: boolean;\n  data: Pick<BookingDetails, 'name' | 'email' | 'phone'>;\n};\n\nconst sanitizeContactValue = (value: string) => value.trim();\n\nconst normalizeContactPayload = (details: ContactDetails): StoredContacts | null => {\n  const name = sanitizeContactValue(details.name);\n  const email = sanitizeContactValue(details.email);\n  const phone = sanitizeContactValue(details.phone);\n\n  if (!name && !email && !phone) {\n    return null;\n  }\n\n  return {\n    version: CONTACT_VERSION,\n    savedAt: Date.now(),\n    expiresAt: Date.now() + REMEMBERED_CONTACT_TTL_MS,\n    remember: details.rememberDetails,\n    data: { name, email, phone },\n  };\n};\n\nconst readStoredContacts = (): StoredContacts | null => {\n  if (typeof window === 'undefined') {\n    return null;\n  }\n\n  const raw = window.localStorage.getItem(STORAGE_KEY);\n  if (!raw) {\n    return null;\n  }\n\n  try {\n    const parsed = JSON.parse(raw) as StoredContacts | undefined;\n    if (!parsed || parsed.version !== CONTACT_VERSION || !parsed.data) {\n      return null;\n    }\n\n    if (parsed.expiresAt <= Date.now()) {\n      window.localStorage.removeItem(STORAGE_KEY);\n      return null;\n    }\n\n    return parsed;\n  } catch {\n    window.localStorage.removeItem(STORAGE_KEY);\n    return null;\n  }\n};\n\nconst writeStoredContacts = (payload: StoredContacts | null) => {\n  if (typeof window === 'undefined') {\n    return;\n  }\n\n  if (!payload) {\n    window.localStorage.removeItem(STORAGE_KEY);\n    return;\n  }\n\n  try {\n    window.localStorage.setItem(STORAGE_KEY, JSON.stringify(payload));\n  } catch (error) {\n    console.warn('[remembered-contacts] failed to persist payload', error);\n  }\n};\n\nexport const useRememberedContacts = ({\n  details,\n  actions,\n  enabled = true,\n}: RememberedContactsConfig) => {\n  const { errorReporter } = useWizardDependencies();\n\n  useEffect(() => {\n    if (!enabled || typeof window === 'undefined') return;\n\n    try {\n      const stored = readStoredContacts();\n      if (!stored) return;\n\n      const { data, remember } = stored;\n      const name = typeof data.name === 'string' ? data.name : '';\n      const email = typeof data.email === 'string' ? data.email : '';\n      const phone = typeof data.phone === 'string' ? data.phone : '';\n\n      if (name || email || phone) {\n        actions.hydrateContacts({ name, email, phone, rememberDetails: remember ?? true });\n      }\n    } catch (error) {\n      errorReporter.capture(error, { scope: 'rememberedContacts.hydrate' });\n    }\n  }, [actions, enabled, errorReporter]);\n\n  useEffect(() => {\n    if (!enabled || typeof window === 'undefined') return;\n\n    try {\n      if (!details.rememberDetails) {\n        writeStoredContacts(null);\n        return;\n      }\n\n      const sanitized = normalizeContactPayload(details);\n      writeStoredContacts(sanitized);\n    } catch (error) {\n      errorReporter.capture(error, { scope: 'rememberedContacts.persist' });\n    }\n  }, [details, enabled, errorReporter]);\n};\n"
    },
    {
      "path": "reserve/features/reservations/wizard/hooks/useReservationWizard.ts",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\n\nimport { emit } from '@/lib/analytics/emit';\nimport { BOOKING_IN_PAST_CUSTOMER_MESSAGE } from '@/lib/bookings/messages';\nimport { mapErrorToMessage } from '@reserve/shared/error';\nimport { useStickyProgress } from '@reserve/shared/hooks/useStickyProgress';\nimport { BOOKING_TYPES_UI, SEATING_PREFERENCES_UI } from '@shared/config/booking';\nimport { runtime } from '@shared/config/runtime';\nimport { DEFAULT_RESTAURANT_SLUG } from '@shared/config/venue';\n\nimport { useRememberedContacts } from './useRememberedContacts';\nimport { clearWizardDraft, loadWizardDraft, saveWizardDraft } from './useWizardDraftStorage';\nimport { fetchBookingsByContact } from '../api/fetchBookingsByContact';\nimport { useCreateOpsReservation } from '../api/useCreateOpsReservation';\nimport { useCreateReservation } from '../api/useCreateReservation';\nimport { useWizardDependencies } from '../di';\nimport { createSelectionSummary } from '../model/selectors';\nimport { useWizardStore } from '../model/store';\nimport { buildReservationDraft, reservationToApiBooking } from '../model/transformers';\nimport { recoverBookingAfterTimeout, type TimeoutRecoveryResult } from '../utils/timeoutRecovery';\n\nimport type { AnalyticsTracker } from '../di/types';\nimport type {\n  BookingDetails,\n  BookingWizardMode,\n  ReservationDraft,\n  StepAction,\n} from '../model/reducer';\n\nconst EMPTY_ACTIONS: StepAction[] = [];\n\nconst DEFAULT_BOOKING_OPTION = BOOKING_TYPES_UI[0];\nconst DEFAULT_SEATING_OPTION = SEATING_PREFERENCES_UI[0];\n\nconst hasMeaningfulDraft = (details: BookingDetails): boolean => {\n  return (\n    Boolean(details.time?.trim()?.length) ||\n    Boolean(details.notes?.trim()?.length) ||\n    details.party > 1 ||\n    details.bookingType !== DEFAULT_BOOKING_OPTION ||\n    details.seating !== DEFAULT_SEATING_OPTION ||\n    Boolean(details.name.trim().length) ||\n    Boolean(details.email.trim().length) ||\n    Boolean(details.phone.trim().length)\n  );\n};\n\nconst OFFLINE_QUEUE_MESSAGE = 'Youre offline. Well submit this booking as soon as you reconnect.';\n\ntype BookingError = { code?: string | number | null | undefined };\n\nfunction isBookingInPastError(error: unknown): error is BookingError {\n  if (!error || typeof error !== 'object') {\n    return false;\n  }\n  const code = (error as BookingError).code;\n  return code === 'BOOKING_IN_PAST';\n}\n\nconst isRequestAbortedError = (error: unknown): error is { code?: string | number | null } => {\n  if (!error || typeof error !== 'object') {\n    return false;\n  }\n  const code = (error as { code?: string | number | null | undefined }).code;\n  return code === 'REQUEST_ABORTED';\n};\n\nconst isTimeoutError = (error: unknown): error is { code?: string | number | null } => {\n  if (!error || typeof error !== 'object') {\n    return false;\n  }\n  const code = (error as { code?: string | number | null | undefined }).code;\n  return code === 'TIMEOUT';\n};\n\nconst TIMEOUT_RECOVERY_ATTEMPTS = 3;\nconst TIMEOUT_RECOVERY_DELAY_MS = 2_000;\n\nexport function useReservationWizard(\n  initialDetails?: Partial<BookingDetails>,\n  mode: BookingWizardMode = 'customer',\n) {\n  const { state, actions } = useWizardStore(initialDetails);\n  const draftHydratedRef = useRef(false);\n  const offlineEventRef = useRef(false);\n  const [planAlert, setPlanAlert] = useState<string | null>(null);\n  const heroRef = useRef<HTMLSpanElement | null>(null);\n  const [stickyActions, setStickyActions] = useState<StepAction[]>(EMPTY_ACTIONS);\n  const [stickyHeight, setStickyHeight] = useState(0);\n  const { analytics, haptics, navigator, errorReporter } = useWizardDependencies();\n\n  useRememberedContacts({ details: state.details, actions, enabled: mode === 'customer' });\n\n  const wizardRestaurantSlug = useMemo(\n    () => initialDetails?.restaurantSlug ?? DEFAULT_RESTAURANT_SLUG ?? null,\n    [initialDetails?.restaurantSlug],\n  );\n\n  useEffect(() => {\n    if (draftHydratedRef.current || mode !== 'customer') {\n      return;\n    }\n    if (initialDetails?.bookingId) {\n      draftHydratedRef.current = true;\n      return;\n    }\n    const stored = loadWizardDraft(wizardRestaurantSlug);\n    draftHydratedRef.current = true;\n    if (!stored) {\n      return;\n    }\n    if (!hasMeaningfulDraft(stored.details)) {\n      clearWizardDraft(wizardRestaurantSlug);\n      return;\n    }\n    if (stored.slugMismatch) {\n      clearWizardDraft(wizardRestaurantSlug);\n      setPlanAlert('Switched restaurantslets refresh availability.');\n      emit('wizard.reset.triggered', {\n        reason: 'slug-mismatch',\n        fromSlug: stored.slugMismatch.stored ?? null,\n        toSlug: stored.slugMismatch.expected ?? wizardRestaurantSlug ?? null,\n      });\n      actions.resetForm();\n      return;\n    }\n    if (stored.expired) {\n      clearWizardDraft(wizardRestaurantSlug);\n      setPlanAlert('Draft expiredlets refresh availability.');\n      emit('wizard.reset.triggered', { reason: 'draft-expired' });\n      actions.resetForm();\n      return;\n    }\n    actions.hydrateDetails(stored.details);\n  }, [actions, initialDetails?.bookingId, mode, wizardRestaurantSlug]);\n\n  const stepsMeta = useMemo(\n    () => [\n      { id: 1, label: 'Plan', helper: 'Pick date, time, and party' },\n      { id: 2, label: 'Details', helper: 'Share contact information' },\n      { id: 3, label: 'Review', helper: 'Double-check and confirm' },\n      { id: 4, label: 'Confirmation', helper: 'Your reservation status' },\n    ],\n    [],\n  );\n\n  const { shouldShow: stickyVisible } = useStickyProgress(heroRef);\n\n  const handleStickyHeightChange = useCallback((height: number) => {\n    setStickyHeight((prev) => (Math.abs(prev - height) < 1 ? prev : height));\n  }, []);\n\n  const previousStepRef = useRef(state.step);\n  useEffect(() => {\n    if (previousStepRef.current !== state.step) {\n      haptics.trigger();\n      previousStepRef.current = state.step;\n    }\n  }, [haptics, state.step]);\n\n  const previousVisibilityRef = useRef(stickyVisible);\n  useEffect(() => {\n    if (stickyVisible && !previousVisibilityRef.current) {\n      haptics.trigger(5);\n    }\n    previousVisibilityRef.current = stickyVisible;\n  }, [haptics, stickyVisible]);\n\n  const handleActionsChange = useCallback((actions: StepAction[]) => {\n    setStickyActions((prev) => {\n      const isSameLength = prev.length === actions.length;\n      if (\n        isSameLength &&\n        prev.every((action, index) => {\n          const next = actions[index];\n          if (!next) {\n            return false;\n          }\n          return (\n            action.id === next.id &&\n            action.label === next.label &&\n            action.variant === next.variant &&\n            action.disabled === next.disabled &&\n            action.loading === next.loading &&\n            action.icon === next.icon &&\n            action.ariaLabel === next.ariaLabel\n            // `onClick` handlers are intentionally excluded because they are often\n            // recreated between renders and would cause unnecessary state churn.\n          );\n        })\n      ) {\n        return prev;\n      }\n      if (runtime.isDev) {\n        console.log('[reserve][sticky-actions] updating', { prev, next: actions });\n      }\n      return actions;\n    });\n  }, []);\n\n  useEffect(() => {\n    setStickyActions(EMPTY_ACTIONS);\n  }, [state.step]);\n\n  const selectionSummary = useMemo(() => createSelectionSummary(state.details), [state.details]);\n\n  // effects depending on mutation are registered after mutation creation\n\n  const customerMutation = useCreateReservation();\n  const opsMutation = useCreateOpsReservation();\n  const mutation = mode === 'ops' ? opsMutation : customerMutation;\n  const submitting = state.submitting || mutation.isPending || mutation.isPaused;\n\n  useEffect(() => {\n    if (mode !== 'customer') {\n      return;\n    }\n    if (mutation.isSuccess) {\n      clearWizardDraft(state.details.restaurantSlug ?? wizardRestaurantSlug);\n      return;\n    }\n    if (!hasMeaningfulDraft(state.details)) {\n      clearWizardDraft(state.details.restaurantSlug ?? wizardRestaurantSlug);\n      return;\n    }\n    saveWizardDraft(state.details);\n  }, [mode, mutation.isSuccess, state.details, wizardRestaurantSlug]);\n\n  useEffect(() => {\n    if (mode !== 'customer') {\n      return;\n    }\n    if (mutation.isPaused) {\n      if (!offlineEventRef.current) {\n        emit('mutation.retry.offline', {\n          bookingId: state.details.bookingId,\n        });\n        offlineEventRef.current = true;\n      }\n      setPlanAlert((prev) => prev ?? OFFLINE_QUEUE_MESSAGE);\n    } else {\n      offlineEventRef.current = false;\n      setPlanAlert((prev) => (prev === OFFLINE_QUEUE_MESSAGE ? null : prev));\n    }\n  }, [mode, mutation.isPaused, state.details.bookingId]);\n\n  const handleConfirm = useCallback(async () => {\n    if (submitting || state.loading) {\n      return;\n    }\n\n    const result = buildReservationDraft(state.details, mode);\n    if (!result.ok) {\n      if ('error' in result) {\n        errorReporter.capture(result.error, { scope: 'wizard.buildReservationDraft' });\n      }\n      const message = mapErrorToMessage(\n        'error' in result ? result.error : null,\n        'Unable to process booking',\n      );\n      actions.setError(message);\n      return;\n    }\n\n    const draft = result.draft;\n    const originStep = state.step;\n\n    actions.clearError();\n    setPlanAlert(null);\n    actions.setLoading(true);\n    actions.setSubmitting(true);\n    actions.goToStep(4);\n\n    try {\n      const submission = await mutation.mutateAsync({\n        draft,\n        bookingId: state.editingId ?? undefined,\n      });\n\n      const bookings = submission.bookings.map(reservationToApiBooking);\n      const booking = submission.booking ? reservationToApiBooking(submission.booking) : null;\n\n      actions.applyConfirmation({\n        bookings,\n        booking,\n        lastAction: submission.booking ? (state.editingId ? 'update' : 'create') : 'create',\n      });\n\n      analytics.track('booking_created', {\n        party: draft.party,\n        start_time: draft.time,\n        reference: submission.booking?.reference ?? 'pending',\n        context: mode,\n        recovered: false,\n      });\n    } catch (error) {\n      if (isRequestAbortedError(error)) {\n        actions.setLoading(false);\n        actions.setSubmitting(false);\n        actions.goToStep(originStep);\n        setPlanAlert(null);\n        return;\n      }\n      if (isTimeoutError(error)) {\n        emit('wizard.submit.timeout', {\n          bookingId: state.editingId ?? null,\n          context: mode,\n        });\n        setPlanAlert('Finalizing your booking please keep this tab open while we complete it.');\n        try {\n          const recovery = await recoverBookingAfterTimeout({\n            draft,\n            fetchBookings: fetchBookingsByContact,\n            attempts: TIMEOUT_RECOVERY_ATTEMPTS,\n            delayMs: TIMEOUT_RECOVERY_DELAY_MS,\n            logger: (lookupError) => {\n              errorReporter.capture(lookupError, { scope: 'wizard.timeoutRecovery' });\n            },\n          });\n          if (recovery) {\n            hydrateRecoveredBooking({\n              recovery,\n              draft,\n              applyConfirmation: actions.applyConfirmation,\n              analytics,\n              mode,\n              lastAction: state.editingId ? 'update' : 'create',\n            });\n            actions.setLoading(false);\n            actions.setSubmitting(false);\n            setPlanAlert(null);\n            emit('wizard.timeout.recovered', {\n              bookingId: recovery.booking.id,\n              context: mode,\n            });\n            return;\n          }\n        } catch (recoveryError) {\n          errorReporter.capture(recoveryError, { scope: 'wizard.timeoutRecovery.unexpected' });\n        }\n\n        actions.setLoading(false);\n        actions.setSubmitting(false);\n        actions.goToStep(originStep);\n        actions.setError(\n          'We could not confirm the booking in time. Please check your email before trying again.',\n        );\n        setPlanAlert('If you received a confirmation email you are all setotherwise retry now.');\n        analytics.track('booking_timeout_unrecovered', {\n          context: mode,\n          party: draft.party,\n          start_time: draft.time,\n        });\n        emit('wizard.timeout.unrecovered', {\n          bookingId: state.editingId ?? null,\n          context: mode,\n        });\n        return;\n      }\n      const isPastBooking = isBookingInPastError(error);\n      if (!isPastBooking) {\n        errorReporter.capture(error, {\n          scope: 'wizard.submitReservation',\n          bookingId: state.editingId ?? undefined,\n        });\n      }\n      const fallbackMessage = mapErrorToMessage(error, 'Unable to process booking');\n      const message = isPastBooking ? BOOKING_IN_PAST_CUSTOMER_MESSAGE : fallbackMessage;\n      actions.setLoading(false);\n      actions.setSubmitting(false);\n      if (isPastBooking) {\n        actions.goToStep(1);\n        setPlanAlert(message);\n        actions.setError(null);\n      } else {\n        actions.goToStep(originStep);\n        actions.setError(message);\n        setPlanAlert(null);\n      }\n    }\n  }, [\n    actions,\n    analytics,\n    errorReporter,\n    mode,\n    mutation,\n    state.details,\n    state.editingId,\n    state.loading,\n    state.step,\n    submitting,\n  ]);\n\n  useEffect(() => {\n    if (state.step !== 1 && planAlert) {\n      setPlanAlert(null);\n    }\n  }, [planAlert, state.step]);\n\n  const handleNewBooking = useCallback(() => {\n    actions.clearError();\n    actions.resetForm();\n    setPlanAlert(null);\n  }, [actions]);\n\n  const handleClose = useCallback(() => {\n    if (mode === 'ops') {\n      navigator.push('/ops');\n      return;\n    }\n    navigator.push('/thank-you');\n    setPlanAlert(null);\n  }, [mode, navigator]);\n\n  return {\n    state,\n    actions,\n    heroRef,\n    stepsMeta,\n    stickyVisible,\n    stickyActions,\n    stickyHeight,\n    handleStickyHeightChange,\n    handleActionsChange,\n    selectionSummary,\n    handleConfirm,\n    handleNewBooking,\n    handleClose,\n    isSubmitting: submitting,\n    mode,\n    planAlert,\n  };\n}\n\ntype HydrateRecoveredBookingParams = {\n  recovery: TimeoutRecoveryResult;\n  draft: ReservationDraft;\n  applyConfirmation: ReturnType<typeof useWizardStore>['actions']['applyConfirmation'];\n  analytics: AnalyticsTracker;\n  mode: BookingWizardMode;\n  lastAction: 'create' | 'update';\n};\n\nfunction hydrateRecoveredBooking(params: HydrateRecoveredBookingParams) {\n  const { recovery, draft, applyConfirmation, analytics, mode, lastAction } = params;\n  const normalizedBookings = recovery.bookings.map(reservationToApiBooking);\n  const normalizedBooking = reservationToApiBooking(recovery.booking);\n\n  applyConfirmation({\n    bookings: normalizedBookings,\n    booking: normalizedBooking,\n    lastAction,\n  });\n\n  analytics.track('booking_created', {\n    party: draft.party,\n    start_time: draft.time,\n    reference: recovery.booking.reference ?? 'pending',\n    context: mode,\n    recovered: true,\n  });\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/hooks/useReviewStep.ts",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport { useCallback, useEffect, useMemo } from 'react';\n\nimport {\n  formatReservationSummaryDate,\n  formatReservationTime,\n} from '@reserve/shared/formatting/booking';\n\nimport { useWizardActions, useWizardState } from '../context/WizardContext';\nimport { useWizardDependencies } from '../di';\n\nimport type {\n  ReviewStepProps,\n  ReviewStepController,\n  ReviewSummary,\n} from '../ui/steps/review-step/types';\n\nexport function useReviewStep({\n  state: providedState,\n  actions: providedActions,\n  onConfirm,\n  onActionsChange,\n}: ReviewStepProps): ReviewStepController {\n  const contextState = useWizardState();\n  const contextActions = useWizardActions();\n  const state = providedState ?? contextState;\n  const actions = providedActions ?? contextActions;\n  const details = state.details;\n  const { analytics } = useWizardDependencies();\n\n  useEffect(() => {\n    if (details.date && details.time) {\n      analytics.track('confirm_open', {\n        date: details.date,\n        time: details.time,\n        party: details.party,\n      });\n    } else {\n      analytics.track('confirm_open');\n    }\n  }, [analytics, details.date, details.party, details.time]);\n\n  const summary: ReviewSummary = useMemo(() => {\n    const summaryDate = details.date ? formatReservationSummaryDate(details.date) : 'TBC';\n    const summaryTime = details.time ? formatReservationTime(details.time) : 'TBC';\n    const partyText = `${details.party} ${details.party === 1 ? 'guest' : 'guests'}`;\n    const summaryValue =\n      details.date && details.time\n        ? `${details.party} at ${formatReservationTime(details.time)} on ${formatReservationSummaryDate(details.date)}`\n        : partyText;\n\n    return {\n      summaryValue,\n      summaryDate,\n      summaryTime,\n      partyText,\n    };\n  }, [details.date, details.party, details.time]);\n\n  const handleEdit = useCallback(() => {\n    actions.goToStep(1);\n  }, [actions]);\n\n  const handleConfirm = useCallback(() => {\n    onConfirm();\n  }, [onConfirm]);\n\n  useEffect(() => {\n    onActionsChange([\n      {\n        id: 'review-edit',\n        label: 'Edit details',\n        icon: 'Pencil',\n        variant: 'outline',\n        onClick: handleEdit,\n        role: 'secondary',\n      },\n      {\n        id: 'review-confirm',\n        label: state.submitting ? 'Processing' : 'Confirm booking',\n        icon: state.submitting ? undefined : 'Check',\n        variant: 'default',\n        disabled: state.submitting,\n        loading: state.submitting,\n        onClick: handleConfirm,\n        role: 'primary',\n      },\n    ]);\n  }, [handleConfirm, handleEdit, onActionsChange, state.submitting]);\n\n  return {\n    details,\n    summary,\n    isSubmitting: state.submitting,\n    error: state.error,\n    handleEdit,\n    handleConfirm,\n  };\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/hooks/useWizardDraftStorage.ts",
      "category": "booking-wizard",
      "content": "import type { BookingDetails } from '../model/reducer';\n\nconst DRAFT_STORAGE_KEY = 'reserve.wizard.draft';\nconst CONTACT_STORAGE_KEY = 'reserve.wizard.contacts';\nexport const WIZARD_DRAFT_TTL_MS = 6 * 60 * 60 * 1000; // 6 hours\n\ntype StoredDraft = {\n  version: 1;\n  savedAt: number;\n  expiresAt: number;\n  details: BookingDetails;\n};\n\nconst CURRENT_VERSION = 1;\nconst CONTACT_VERSION = 1;\n\nconst isBrowser = () => typeof window !== 'undefined';\n\nconst normalizeSlug = (value: string | null | undefined): string | null => {\n  if (!value) {\n    return null;\n  }\n  const trimmed = value.trim().toLowerCase();\n  return trimmed.length > 0 ? trimmed : null;\n};\n\nconst buildStorageKey = (slug: string | null | undefined): string => {\n  const normalized = normalizeSlug(slug);\n  return normalized ? `${DRAFT_STORAGE_KEY}.${normalized}` : DRAFT_STORAGE_KEY;\n};\n\nconst buildContactStorageKey = (slug: string | null | undefined): string => {\n  const normalized = normalizeSlug(slug);\n  return normalized ? `${CONTACT_STORAGE_KEY}.${normalized}` : CONTACT_STORAGE_KEY;\n};\n\nconst parseStoredDraft = (raw: string | null): StoredDraft | null => {\n  if (!raw) {\n    return null;\n  }\n  try {\n    const parsed = JSON.parse(raw) as StoredDraft | undefined;\n    if (!parsed || parsed.version !== CURRENT_VERSION || !parsed.details) {\n      return null;\n    }\n    return parsed;\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn('[wizard-draft] failed to parse draft payload', error);\n    }\n    return null;\n  }\n};\n\nconst parseStoredContact = (raw: string | null): StoredContact | null => {\n  if (!raw) {\n    return null;\n  }\n  try {\n    const parsed = JSON.parse(raw) as StoredContact | undefined;\n    if (!parsed || parsed.version !== CONTACT_VERSION || !parsed.data) {\n      return null;\n    }\n    return parsed;\n  } catch {\n    return null;\n  }\n};\n\nconst sanitizeContactValue = (value: string | null | undefined): string => value?.trim() ?? '';\n\nconst saveContactDraft = (\n  details: Pick<BookingDetails, 'name' | 'email' | 'phone'>,\n  slug: string | null | undefined,\n  expiresAt: number,\n) => {\n  if (!isBrowser()) {\n    return;\n  }\n\n  const payload: StoredContact = {\n    version: CONTACT_VERSION,\n    savedAt: Date.now(),\n    expiresAt,\n    slug: normalizeSlug(slug),\n    data: {\n      name: sanitizeContactValue(details.name),\n      email: sanitizeContactValue(details.email),\n      phone: sanitizeContactValue(details.phone),\n    },\n  };\n\n  try {\n    window.sessionStorage.setItem(buildContactStorageKey(slug), JSON.stringify(payload));\n  } catch {\n    // Ignore session storage failures.\n  }\n};\n\nconst loadContactDraft = (slug: string | null | undefined): StoredContact | null => {\n  if (!isBrowser()) {\n    return null;\n  }\n\n  const key = buildContactStorageKey(slug);\n  const parsed = parseStoredContact(window.sessionStorage.getItem(key));\n  if (!parsed) {\n    return null;\n  }\n\n  if (parsed.expiresAt <= Date.now()) {\n    try {\n      window.sessionStorage.removeItem(key);\n    } catch {\n      // ignore cleanup errors\n    }\n    return null;\n  }\n\n  return parsed;\n};\n\nconst clearContactDraft = (slug: string | null | undefined, includeLegacy = true) => {\n  if (!isBrowser()) {\n    return;\n  }\n\n  const removeKey = (key: string) => {\n    try {\n      window.sessionStorage.removeItem(key);\n    } catch {\n      // ignore\n    }\n  };\n\n  if (slug) {\n    removeKey(buildContactStorageKey(slug));\n  }\n  if (includeLegacy) {\n    removeKey(CONTACT_STORAGE_KEY);\n  }\n};\n\ntype DraftSource = 'namespaced' | 'legacy';\n\nexport type LoadedDraft = {\n  details: BookingDetails;\n  expired: boolean;\n  expiresAt: number;\n  source: DraftSource;\n  slugMismatch?: {\n    expected: string | null;\n    stored: string | null;\n  };\n};\n\ntype StoredContact = {\n  version: typeof CONTACT_VERSION;\n  savedAt: number;\n  expiresAt: number;\n  slug: string | null;\n  data: Pick<BookingDetails, 'name' | 'email' | 'phone'>;\n};\n\nconst readDraftFromKey = (key: string): LoadedDraft | null => {\n  if (!isBrowser()) {\n    return null;\n  }\n  const parsed = parseStoredDraft(window.localStorage.getItem(key));\n  if (!parsed) {\n    return null;\n  }\n\n  let needsRewrite = false;\n  if (parsed.details) {\n    const legacyContact = {\n      name: parsed.details.name,\n      email: parsed.details.email,\n      phone: parsed.details.phone,\n    };\n\n    if (legacyContact.name || legacyContact.email || legacyContact.phone) {\n      saveContactDraft(\n        {\n          name: legacyContact.name ?? '',\n          email: legacyContact.email ?? '',\n          phone: legacyContact.phone ?? '',\n        },\n        normalizeSlug(parsed.details.restaurantSlug),\n        parsed.expiresAt,\n      );\n      needsRewrite = true;\n    }\n\n    if (parsed.details.name) {\n      parsed.details.name = '';\n    }\n    if (parsed.details.email) {\n      parsed.details.email = '';\n    }\n    if (parsed.details.phone) {\n      parsed.details.phone = '';\n    }\n  }\n\n  if (needsRewrite) {\n    try {\n      window.localStorage.setItem(key, JSON.stringify(parsed));\n    } catch {\n      // ignore rewrite failures\n    }\n  }\n\n  return {\n    details: parsed.details,\n    expired: parsed.expiresAt <= Date.now(),\n    expiresAt: parsed.expiresAt,\n    source: key === DRAFT_STORAGE_KEY ? 'legacy' : 'namespaced',\n  };\n};\n\nexport function loadWizardDraft(expectedSlug?: string | null): LoadedDraft | null {\n  if (!isBrowser()) {\n    return null;\n  }\n\n  const normalizedExpectedSlug = normalizeSlug(expectedSlug);\n  const namespacedKey = normalizedExpectedSlug ? buildStorageKey(normalizedExpectedSlug) : null;\n\n  if (namespacedKey) {\n    const namespacedDraft = readDraftFromKey(namespacedKey);\n    if (namespacedDraft) {\n      return mergeDraftWithContacts(namespacedDraft, normalizedExpectedSlug);\n    }\n  }\n\n  const legacyDraft = readDraftFromKey(DRAFT_STORAGE_KEY);\n  if (!legacyDraft) {\n    return null;\n  }\n\n  if (normalizedExpectedSlug) {\n    const storedSlug = normalizeSlug(legacyDraft.details.restaurantSlug);\n    if (storedSlug && storedSlug !== normalizedExpectedSlug) {\n      return {\n        ...legacyDraft,\n        slugMismatch: {\n          expected: normalizedExpectedSlug,\n          stored: storedSlug,\n        },\n      };\n    }\n  }\n\n  return mergeDraftWithContacts(legacyDraft, normalizedExpectedSlug);\n}\n\nexport function saveWizardDraft(details: BookingDetails): void {\n  if (!isBrowser()) {\n    return;\n  }\n  const normalizedSlug = normalizeSlug(details.restaurantSlug);\n  const key = normalizedSlug ? `${DRAFT_STORAGE_KEY}.${normalizedSlug}` : DRAFT_STORAGE_KEY;\n  const payload: StoredDraft = {\n    version: CURRENT_VERSION,\n    savedAt: Date.now(),\n    expiresAt: Date.now() + WIZARD_DRAFT_TTL_MS,\n    details: {\n      ...details,\n      name: '',\n      email: '',\n      phone: '',\n    },\n  };\n  try {\n    window.localStorage.setItem(key, JSON.stringify(payload));\n    saveContactDraft(details, normalizedSlug, payload.expiresAt);\n    if (key !== DRAFT_STORAGE_KEY) {\n      window.localStorage.removeItem(DRAFT_STORAGE_KEY);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn('[wizard-draft] failed to persist draft', error);\n    }\n  }\n}\n\ntype ClearOptions = {\n  includeLegacy?: boolean;\n};\n\nexport function clearWizardDraft(slug?: string | null, options?: ClearOptions): void {\n  if (!isBrowser()) {\n    return;\n  }\n\n  const normalizedSlug = normalizeSlug(slug);\n  const includeLegacy = options?.includeLegacy ?? true;\n\n  try {\n    if (normalizedSlug) {\n      window.localStorage.removeItem(buildStorageKey(normalizedSlug));\n      clearContactDraft(normalizedSlug, false);\n    }\n    if (includeLegacy) {\n      window.localStorage.removeItem(DRAFT_STORAGE_KEY);\n      clearContactDraft(null, true);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn('[wizard-draft] failed to clear draft', error);\n    }\n  }\n}\n\nconst mergeDraftWithContacts = (draft: LoadedDraft, expectedSlug: string | null): LoadedDraft => {\n  const contactSlug = normalizeSlug(draft.details.restaurantSlug) ?? expectedSlug;\n  const storedContacts = loadContactDraft(contactSlug);\n  if (!storedContacts) {\n    return draft;\n  }\n\n  return {\n    ...draft,\n    details: {\n      ...draft.details,\n      ...storedContacts.data,\n    },\n  };\n};\n"
    },
    {
      "path": "reserve/features/reservations/wizard/model/reducer.ts",
      "category": "booking-wizard",
      "content": "import { reservationConfigResult } from '@reserve/shared/config/reservations';\nimport { formatDateForInput } from '@reserve/shared/formatting/booking';\nimport { normalizeTime } from '@reserve/shared/time';\nimport {\n  BOOKING_TYPES_UI,\n  SEATING_PREFERENCES_UI,\n  type BookingType,\n  type SeatingPreference,\n} from '@shared/config/booking';\nimport {\n  DEFAULT_RESTAURANT_ID,\n  DEFAULT_RESTAURANT_SLUG,\n  DEFAULT_VENUE,\n} from '@shared/config/venue';\n\nimport type { BookingOption } from '@reserve/shared/booking';\nimport type { IconKey } from '@reserve/shared/ui/icons';\n\nexport type SeatingOption = (typeof SEATING_PREFERENCES_UI)[number];\n\nexport type ApiBooking = {\n  id: string;\n  restaurant_id: string;\n  customer_id: string;\n  booking_date: string;\n  start_time: string;\n  end_time: string;\n  reference: string;\n  party_size: number;\n  booking_type: BookingType;\n  seating_preference: SeatingPreference;\n  status: string;\n  customer_name: string;\n  customer_email: string;\n  customer_phone: string;\n  notes: string | null;\n  source: string;\n  marketing_opt_in: boolean;\n  loyalty_points_awarded: number;\n  created_at: string;\n  updated_at: string;\n};\n\nexport type StepAction = {\n  id: string;\n  label: string;\n  onClick: () => void;\n  variant?: 'default' | 'outline' | 'ghost' | 'destructive';\n  disabled?: boolean;\n  loading?: boolean;\n  icon?: IconKey;\n  ariaLabel?: string;\n  role?: 'primary' | 'secondary' | 'support';\n  fullWidth?: boolean;\n  srLabel?: string;\n};\n\nexport type BookingDetails = {\n  bookingId: string | null;\n  restaurantId: string;\n  restaurantSlug: string;\n  restaurantName: string;\n  restaurantAddress: string;\n  restaurantTimezone: string;\n  reservationDurationMinutes: number;\n  date: string;\n  time: string;\n  party: number;\n  bookingType: BookingOption;\n  seating: SeatingOption;\n  notes: string;\n  name: string;\n  email: string;\n  phone: string;\n  rememberDetails: boolean;\n  agree: boolean;\n  marketingOptIn: boolean;\n};\n\nexport type BookingWizardMode = 'customer' | 'ops';\n\nexport type LastAction = 'create' | 'update' | null;\n\nexport type WizardStep = 1 | 2 | 3 | 4;\n\nexport type State = {\n  step: WizardStep;\n  submitting: boolean;\n  loading: boolean;\n  error: string | null;\n  editingId: string | null;\n  lastAction: LastAction;\n  bookings: ApiBooking[];\n  details: BookingDetails;\n  lastConfirmed: ApiBooking | null;\n};\n\nexport type Action =\n  | { type: 'SET_STEP'; step: State['step'] }\n  | { type: 'SET_FIELD'; key: keyof BookingDetails; value: BookingDetails[keyof BookingDetails] }\n  | { type: 'SET_SUBMITTING'; value: boolean }\n  | { type: 'SET_LOADING'; value: boolean }\n  | { type: 'SET_ERROR'; message: string | null }\n  | { type: 'SET_BOOKINGS'; bookings: ApiBooking[] }\n  | {\n      type: 'SET_CONFIRMATION';\n      payload: {\n        bookings: ApiBooking[];\n        booking: ApiBooking | null;\n        lastAction: Exclude<LastAction, null>;\n      };\n    }\n  | { type: 'START_EDIT'; bookingId: string }\n  | { type: 'RESET_FORM'; initialDetails?: Partial<BookingDetails> }\n  | {\n      type: 'HYDRATE_CONTACTS';\n      payload: Pick<BookingDetails, 'name' | 'email' | 'phone'> & { rememberDetails?: boolean };\n    }\n  | {\n      type: 'HYDRATE_DETAILS';\n      details: BookingDetails;\n    };\n\nexport type ReservationDraft = {\n  restaurantId?: string;\n  restaurantSlug?: string;\n  date: string;\n  time: string;\n  party: number;\n  bookingType: BookingOption;\n  seating: SeatingOption;\n  notes?: string | null;\n  name: string;\n  email: string | null;\n  phone: string | null;\n  marketingOptIn: boolean;\n};\n\nconst SEATING_OPTIONS_SET = new Set<SeatingOption>(SEATING_PREFERENCES_UI);\n\nexport function toBookingOption(value: BookingType): BookingOption {\n  const normalized = (value ?? '').toString().trim();\n  return (normalized.length > 0 ? normalized : BOOKING_TYPES_UI[0]) as BookingOption;\n}\n\nexport function toSeatingOption(value: SeatingPreference): SeatingOption {\n  if (SEATING_OPTIONS_SET.has(value as SeatingOption)) {\n    return value as SeatingOption;\n  }\n  if (value === 'window' || value === 'booth' || value === 'bar') {\n    return 'indoor';\n  }\n  return SEATING_PREFERENCES_UI[0];\n}\n\nexport const getInitialDetails = (overrides?: Partial<BookingDetails>): BookingDetails => {\n  const base: BookingDetails = {\n    bookingId: null,\n    restaurantId: DEFAULT_RESTAURANT_ID,\n    restaurantSlug: DEFAULT_RESTAURANT_SLUG,\n    restaurantName: DEFAULT_VENUE.name,\n    restaurantAddress: DEFAULT_VENUE.address,\n    restaurantTimezone: DEFAULT_VENUE.timezone,\n    reservationDurationMinutes: reservationConfigResult.config.defaultDurationMinutes,\n    date: formatDateForInput(new Date()),\n    time: '',\n    party: 1,\n    bookingType: BOOKING_TYPES_UI[0],\n    seating: SEATING_PREFERENCES_UI[0],\n    notes: '',\n    name: '',\n    email: '',\n    phone: '',\n    rememberDetails: true,\n    agree: true,\n    marketingOptIn: true,\n  };\n\n  if (!overrides) {\n    return base;\n  }\n\n  return {\n    ...base,\n    ...overrides,\n    restaurantId: overrides.restaurantId ?? base.restaurantId,\n    restaurantSlug: overrides.restaurantSlug ?? base.restaurantSlug,\n    restaurantName: overrides.restaurantName ?? base.restaurantName,\n    restaurantAddress: overrides.restaurantAddress ?? base.restaurantAddress,\n    restaurantTimezone: overrides.restaurantTimezone ?? base.restaurantTimezone,\n    reservationDurationMinutes:\n      overrides.reservationDurationMinutes ?? base.reservationDurationMinutes,\n  } satisfies BookingDetails;\n};\n\nexport const getInitialState = (overrides?: Partial<BookingDetails>): State => ({\n  step: 1,\n  submitting: false,\n  loading: false,\n  error: null,\n  editingId: null,\n  lastAction: null,\n  bookings: [],\n  details: getInitialDetails(overrides),\n  lastConfirmed: null,\n});\n\nexport function reducer(state: State, action: Action): State {\n  switch (action.type) {\n    case 'SET_STEP':\n      return { ...state, step: action.step, error: null };\n    case 'SET_FIELD':\n      return {\n        ...state,\n        error: null,\n        details: {\n          ...state.details,\n          [action.key]: action.value,\n        },\n      };\n    case 'SET_SUBMITTING':\n      return { ...state, submitting: action.value };\n    case 'SET_LOADING':\n      return { ...state, loading: action.value };\n    case 'SET_ERROR':\n      return { ...state, error: action.message };\n    case 'SET_BOOKINGS':\n      return { ...state, bookings: action.bookings };\n    case 'SET_CONFIRMATION': {\n      const { bookings, booking, lastAction } = action.payload;\n      const updatedDetails = {\n        ...state.details,\n        bookingId: booking ? booking.id : null,\n        restaurantId: booking ? booking.restaurant_id : state.details.restaurantId,\n        restaurantName: state.details.restaurantName,\n        restaurantAddress: state.details.restaurantAddress,\n        restaurantTimezone: state.details.restaurantTimezone,\n        date: booking ? booking.booking_date : state.details.date,\n        time: booking\n          ? (normalizeTime(booking.start_time) ?? state.details.time)\n          : state.details.time,\n        party: booking ? booking.party_size : state.details.party,\n        bookingType: booking ? toBookingOption(booking.booking_type) : state.details.bookingType,\n        seating: booking ? toSeatingOption(booking.seating_preference) : state.details.seating,\n        notes: booking?.notes ?? state.details.notes,\n        marketingOptIn: booking ? booking.marketing_opt_in : state.details.marketingOptIn,\n      };\n\n      return {\n        ...state,\n        step: 4,\n        submitting: false,\n        loading: false,\n        editingId: null,\n        bookings,\n        lastAction,\n        lastConfirmed: booking ?? state.lastConfirmed,\n        details: updatedDetails,\n        error: null,\n      };\n    }\n    case 'START_EDIT': {\n      const booking = state.bookings.find((entry) => entry.id === action.bookingId);\n      if (!booking) return state;\n      return {\n        ...state,\n        step: 1,\n        submitting: false,\n        editingId: booking.id,\n        lastAction: null,\n        error: null,\n        details: {\n          ...state.details,\n          bookingId: booking.id,\n          restaurantId: booking.restaurant_id,\n          restaurantName: state.details.restaurantName,\n          restaurantAddress: state.details.restaurantAddress,\n          restaurantTimezone: state.details.restaurantTimezone,\n          date: booking.booking_date,\n          time: normalizeTime(booking.start_time) ?? state.details.time,\n          party: booking.party_size,\n          bookingType: toBookingOption(booking.booking_type),\n          seating: toSeatingOption(booking.seating_preference),\n          notes: booking.notes ?? '',\n          name: booking.customer_name,\n          email: booking.customer_email,\n          phone: booking.customer_phone,\n          marketingOptIn: booking.marketing_opt_in,\n        },\n      };\n    }\n    case 'RESET_FORM': {\n      const base = getInitialDetails(action.initialDetails);\n      const shouldRemember = state.details.rememberDetails;\n      return {\n        ...state,\n        step: 1,\n        submitting: false,\n        loading: false,\n        editingId: null,\n        lastAction: null,\n        error: null,\n        details: {\n          ...base,\n          rememberDetails: shouldRemember,\n          name: shouldRemember ? state.details.name : '',\n          email: shouldRemember ? state.details.email : '',\n          phone: shouldRemember ? state.details.phone : '',\n        },\n      };\n    }\n    case 'HYDRATE_CONTACTS':\n      return {\n        ...state,\n        details: {\n          ...state.details,\n          name: action.payload.name,\n          email: action.payload.email,\n          phone: action.payload.phone,\n          rememberDetails: action.payload.rememberDetails ?? true,\n        },\n      };\n    case 'HYDRATE_DETAILS':\n      return {\n        ...state,\n        step: 1,\n        editingId: null,\n        error: null,\n        details: {\n          ...state.details,\n          ...action.details,\n        },\n      };\n    default:\n      return state;\n  }\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/model/schemas.ts",
      "category": "booking-wizard",
      "content": "import { z } from 'zod';\n\nimport { MAX_ONLINE_PARTY_SIZE, ONLINE_PARTY_SIZE_LIMIT_COPY } from '@/lib/bookings/partySize';\nimport { isEmail, isUKPhone } from '@reserve/shared/validation';\n\nimport type { BookingWizardMode } from './reducer';\nimport type { BookingOption } from '@reserve/shared/booking';\n\nconst TIME_REGEX = /^([01]\\d|2[0-3]):([0-5]\\d)$/;\n\nexport const planFormSchema = z.object({\n  date: z\n    .string()\n    .min(1, { message: 'Please select a date.' })\n    .refine((value) => !Number.isNaN(new Date(`${value}T00:00:00`).getTime()), {\n      message: 'Please choose a valid date.',\n    }),\n  time: z\n    .string()\n    .min(1, { message: 'Please select a time.' })\n    .regex(TIME_REGEX, { message: 'Please select a valid time.' }),\n  party: z\n    .number()\n    .min(1, { message: 'Minimum of one guest required.' })\n    .max(MAX_ONLINE_PARTY_SIZE, { message: ONLINE_PARTY_SIZE_LIMIT_COPY }),\n  bookingType: z.string().min(1, { message: 'Please select an occasion.' }),\n  notes: z.string().max(500, { message: 'Notes must be 500 characters or fewer.' }).optional(),\n});\n\nexport type PlanFormValues = z.infer<typeof planFormSchema>;\n\nconst nameSchema = z\n  .string()\n  .min(2, { message: 'Please enter at least two characters.' })\n  .max(120, { message: 'Name looks too long. Shorten it a little.' });\n\nconst buildEmailSchema = (mode: BookingWizardMode) =>\n  z\n    .string()\n    .trim()\n    .superRefine((value, ctx) => {\n      if (!value) {\n        if (mode !== 'ops') {\n          ctx.addIssue({\n            code: z.ZodIssueCode.custom,\n            message: 'Please enter a valid email address.',\n          });\n        }\n        return;\n      }\n\n      if (!isEmail(value)) {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: 'Please enter a valid email address.',\n        });\n      }\n    });\n\nconst buildPhoneSchema = (mode: BookingWizardMode) =>\n  z\n    .string()\n    .trim()\n    .superRefine((value, ctx) => {\n      if (!value) {\n        if (mode !== 'ops') {\n          ctx.addIssue({\n            code: z.ZodIssueCode.custom,\n            message: 'Please enter your phone number.',\n          });\n        }\n        return;\n      }\n\n      if (!isUKPhone(value)) {\n        ctx.addIssue({\n          code: z.ZodIssueCode.custom,\n          message: 'Please enter a valid UK mobile number (e.g. 07123 456789).',\n        });\n      }\n    });\n\nexport const createDetailsFormSchema = (mode: BookingWizardMode = 'customer') =>\n  z.object({\n    name: nameSchema,\n    email: buildEmailSchema(mode),\n    phone: buildPhoneSchema(mode),\n    rememberDetails: z.boolean().default(true),\n    marketingOptIn: z.boolean().default(true),\n    agree: z.boolean().refine((value) => value, {\n      message: 'Please accept the terms to continue.',\n    }),\n  });\n\nexport const detailsFormSchema = createDetailsFormSchema('customer');\n\nexport type DetailsFormInputValues = z.input<typeof detailsFormSchema>;\nexport type DetailsFormValues = z.output<typeof detailsFormSchema>;\n\nexport type BookingOptionSchema = BookingOption;\n"
    },
    {
      "path": "reserve/features/reservations/wizard/model/selectors.ts",
      "category": "booking-wizard",
      "content": "import {\n  formatBookingLabel,\n  formatReservationSummaryDate,\n  formatReservationTime,\n} from '@reserve/shared/formatting/booking';\n\nimport type { BookingDetails } from './reducer';\n\nexport type SelectionSummary = {\n  primary: string;\n  details: string[];\n  srLabel: string;\n};\n\nexport const createSelectionSummary = (details: BookingDetails): SelectionSummary => {\n  const formattedDate = details.date\n    ? formatReservationSummaryDate(details.date)\n    : 'Date not selected';\n  const formattedTime = details.time ? formatReservationTime(details.time) : 'Time not selected';\n  const partyText = `${details.party} ${details.party === 1 ? 'guest' : 'guests'}`;\n  const serviceLabel = formatBookingLabel(details.bookingType);\n  const summaryLines = [partyText, formattedTime, formattedDate];\n\n  return {\n    primary: serviceLabel,\n    details: summaryLines,\n    srLabel: `${serviceLabel}. ${summaryLines.join(', ')}`,\n  };\n};\n"
    },
    {
      "path": "reserve/features/reservations/wizard/model/store.ts",
      "category": "booking-wizard",
      "content": "import { useCallback, useMemo, useReducer, useRef } from 'react';\n\nimport {\n  getInitialDetails,\n  getInitialState,\n  reducer,\n  type Action,\n  type BookingDetails,\n  type State,\n  type WizardStep,\n} from './reducer';\n\nimport type { Dispatch } from 'react';\n\nexport type ConfirmationPayload = {\n  bookings: State['bookings'];\n  booking: State['lastConfirmed'];\n  lastAction: Exclude<State['lastAction'], null>;\n};\n\nexport type WizardActions = {\n  goToStep: (step: WizardStep) => void;\n  updateDetails: <Key extends keyof BookingDetails>(key: Key, value: BookingDetails[Key]) => void;\n  setSubmitting: (value: boolean) => void;\n  setLoading: (value: boolean) => void;\n  setError: (message: string | null) => void;\n  clearError: () => void;\n  setBookings: (bookings: State['bookings']) => void;\n  applyConfirmation: (payload: ConfirmationPayload) => void;\n  startEdit: (bookingId: string) => void;\n  resetForm: () => void;\n  hydrateContacts: (\n    payload: Pick<BookingDetails, 'name' | 'email' | 'phone'> & { rememberDetails?: boolean },\n  ) => void;\n  hydrateDetails: (details: BookingDetails) => void;\n};\n\nconst createActions = (\n  dispatch: Dispatch<Action>,\n  resolveInitialDetails: () => Partial<BookingDetails> | undefined,\n): WizardActions => ({\n  goToStep: (step) => dispatch({ type: 'SET_STEP', step }),\n  updateDetails: (key, value) => dispatch({ type: 'SET_FIELD', key, value }),\n  setSubmitting: (value) => dispatch({ type: 'SET_SUBMITTING', value }),\n  setLoading: (value) => dispatch({ type: 'SET_LOADING', value }),\n  setError: (message) => dispatch({ type: 'SET_ERROR', message }),\n  clearError: () => dispatch({ type: 'SET_ERROR', message: null }),\n  setBookings: (bookings) => dispatch({ type: 'SET_BOOKINGS', bookings }),\n  applyConfirmation: (payload) =>\n    dispatch({\n      type: 'SET_CONFIRMATION',\n      payload: {\n        bookings: payload.bookings,\n        booking: payload.booking,\n        lastAction: payload.lastAction,\n      },\n    }),\n  startEdit: (bookingId) => dispatch({ type: 'START_EDIT', bookingId }),\n  resetForm: () => dispatch({ type: 'RESET_FORM', initialDetails: resolveInitialDetails() }),\n  hydrateContacts: (payload) => dispatch({ type: 'HYDRATE_CONTACTS', payload }),\n  hydrateDetails: (details) => dispatch({ type: 'HYDRATE_DETAILS', details }),\n});\n\nexport const useWizardStore = (initialDetails?: Partial<BookingDetails>) => {\n  const initialSnapshotRef = useRef<BookingDetails | null>(null);\n\n  if (initialSnapshotRef.current === null) {\n    initialSnapshotRef.current = getInitialDetails(initialDetails);\n  }\n\n  const [state, dispatch] = useReducer(reducer, initialSnapshotRef.current, (overrides) =>\n    getInitialState(overrides ?? undefined),\n  );\n\n  const resolveInitialDetails = useCallback(() => initialSnapshotRef.current ?? undefined, []);\n\n  const actions = useMemo(\n    () => createActions(dispatch, resolveInitialDetails),\n    [dispatch, resolveInitialDetails],\n  );\n\n  return { state, actions } as const;\n};\n\nexport type WizardStore = ReturnType<typeof useWizardStore>;\n"
    },
    {
      "path": "reserve/features/reservations/wizard/model/transformers.ts",
      "category": "booking-wizard",
      "content": "import { inferBookingOption, normalizeTime } from '@reserve/shared/time';\n\nimport type { ApiBooking, BookingDetails, BookingWizardMode, ReservationDraft } from './reducer';\nimport type { Reservation } from '@entities/reservation/reservation.schema';\n\ntype DraftSuccess = {\n  ok: true;\n  draft: ReservationDraft;\n};\n\ntype DraftFailure = {\n  ok: false;\n  error: string;\n};\n\ntype DraftResult = DraftSuccess | DraftFailure;\n\nconst buildMarketingOptIn = (marketingOptIn: boolean | undefined): boolean =>\n  Boolean(marketingOptIn);\n\nconst normalizeContactValue = (value: string, required: boolean): string | null => {\n  const trimmed = value.trim();\n  if (!trimmed) {\n    return required ? '' : null;\n  }\n  return trimmed;\n};\n\nexport const buildReservationDraft = (\n  details: BookingDetails,\n  mode: BookingWizardMode = 'customer',\n): DraftResult => {\n  const normalizedRestaurantId = details.restaurantId?.trim();\n  if (!normalizedRestaurantId) {\n    return {\n      ok: false,\n      error: 'We could not determine which restaurant to book. Please refresh and try again.',\n    };\n  }\n  const normalizedRestaurantSlug = details.restaurantSlug?.trim().toLowerCase();\n  const normalizedTime = normalizeTime(details.time);\n\n  if (!normalizedTime) {\n    return { ok: false, error: 'Please select a time for your reservation.' };\n  }\n\n  const bookingType =\n    details.bookingType === 'drinks' ? 'drinks' : inferBookingOption(normalizedTime, details.date);\n\n  return {\n    ok: true,\n    draft: {\n      restaurantId: normalizedRestaurantId,\n      restaurantSlug: normalizedRestaurantSlug ?? undefined,\n      date: details.date,\n      time: normalizedTime,\n      party: Math.max(1, details.party),\n      bookingType,\n      seating: details.seating,\n      notes: details.notes ? details.notes : null,\n      name: details.name.trim(),\n      email: normalizeContactValue(details.email, mode !== 'ops'),\n      phone: normalizeContactValue(details.phone, mode !== 'ops'),\n      marketingOptIn: buildMarketingOptIn(details.marketingOptIn),\n    },\n  };\n};\n\nexport const reservationToApiBooking = (reservation: Reservation): ApiBooking => ({\n  id: reservation.id,\n  restaurant_id: reservation.restaurantId,\n  customer_id: 'unknown',\n  booking_date: reservation.bookingDate,\n  start_time: reservation.startTime,\n  end_time: reservation.endTime ?? reservation.startTime,\n  reference: reservation.reference ?? '',\n  party_size: reservation.partySize,\n  booking_type: reservation.bookingType as ApiBooking['booking_type'],\n  seating_preference: reservation.seatingPreference as ApiBooking['seating_preference'],\n  status: reservation.status,\n  customer_name: reservation.customerName,\n  customer_email: reservation.customerEmail,\n  customer_phone: reservation.customerPhone,\n  notes: reservation.notes ?? null,\n  source: 'app',\n  marketing_opt_in: buildMarketingOptIn(reservation.marketingOptIn),\n  loyalty_points_awarded: 0,\n  created_at: new Date().toISOString(),\n  updated_at: new Date().toISOString(),\n});\n"
    },
    {
      "path": "reserve/features/reservations/wizard/services/index.ts",
      "category": "booking-wizard",
      "content": "export * from './timeSlots';\nexport * from './useTimeSlots';\nexport * from './schedule';\n"
    },
    {
      "path": "reserve/features/reservations/wizard/services/schedule.ts",
      "category": "booking-wizard",
      "content": "import { apiClient } from '@shared/api/client';\n\nimport type { ReservationSchedule } from './timeSlots';\n\nexport const scheduleQueryKey = (\n  restaurantSlug: string | null | undefined,\n  date: string | null | undefined,\n) => ['reservations', 'schedule', restaurantSlug ?? '', date ?? ''] as const;\n\nexport async function fetchReservationSchedule(\n  restaurantSlug: string,\n  date: string | null | undefined,\n  signal?: AbortSignal,\n): Promise<ReservationSchedule> {\n  const params = new URLSearchParams();\n  if (date) {\n    params.set('date', date);\n  }\n\n  const encodedSlug = encodeURIComponent(restaurantSlug);\n  const path =\n    params.size > 0\n      ? `/restaurants/${encodedSlug}/schedule?${params.toString()}`\n      : `/restaurants/${encodedSlug}/schedule`;\n\n  return apiClient.get<ReservationSchedule>(path, { signal });\n}\n\nexport type CalendarMask = {\n  timezone: string;\n  from: string;\n  to: string;\n  closedDaysOfWeek: number[];\n  closedDates: string[];\n};\n\nexport const calendarMaskQueryKey = (\n  restaurantSlug: string | null | undefined,\n  from: string | null | undefined,\n  to: string | null | undefined,\n) => ['reservations', 'calendar-mask', restaurantSlug ?? '', from ?? '', to ?? ''] as const;\n\nexport async function fetchCalendarMask(\n  restaurantSlug: string,\n  from: string,\n  to: string,\n  signal?: AbortSignal,\n): Promise<CalendarMask> {\n  const params = new URLSearchParams();\n  params.set('from', from);\n  params.set('to', to);\n\n  const encodedSlug = encodeURIComponent(restaurantSlug);\n  const path = `/restaurants/${encodedSlug}/calendar-mask?${params.toString()}`;\n\n  return apiClient.get<CalendarMask>(path, { signal });\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/services/timeSlots.ts",
      "category": "booking-wizard",
      "content": "import type { BookingOption } from '@reserve/shared/booking';\nimport type { OccasionDefinition, OccasionKey } from '@reserve/shared/occasions';\n\nexport type ServiceState = 'enabled' | 'disabled';\n\nexport type ServiceAvailability = {\n  services: Record<OccasionKey, ServiceState>;\n  labels: {\n    happyHour: boolean;\n    drinksOnly: boolean;\n    kitchenClosed: boolean;\n    lunchWindow: boolean;\n    dinnerWindow: boolean;\n  };\n};\n\nexport const EMPTY_AVAILABILITY: ServiceAvailability = {\n  services: {},\n  labels: {\n    happyHour: false,\n    drinksOnly: false,\n    kitchenClosed: false,\n    lunchWindow: false,\n    dinnerWindow: false,\n  },\n};\n\nexport type RawScheduleSlot = {\n  value: string;\n  display: string;\n  periodId: string | null;\n  periodName: string | null;\n  bookingOption: BookingOption;\n  defaultBookingOption: BookingOption;\n  availability: ServiceAvailability;\n  disabled: boolean;\n};\n\nexport type ReservationSchedule = {\n  restaurantId: string;\n  date: string;\n  timezone: string;\n  intervalMinutes: number;\n  defaultDurationMinutes: number;\n  lastSeatingBufferMinutes: number;\n  window: {\n    opensAt: string | null;\n    closesAt: string | null;\n  };\n  isClosed: boolean;\n  availableBookingOptions: BookingOption[];\n  slots: RawScheduleSlot[];\n  occasionCatalog: OccasionDefinition[];\n};\n\nexport type TimeSlotDescriptor = {\n  value: string;\n  display: string;\n  label: string;\n  bookingOption: BookingOption;\n  defaultBookingOption: BookingOption;\n  availability: ServiceAvailability;\n  disabled: boolean;\n  periodId: string | null;\n};\n\nexport function toTimeSlotDescriptor(slot: RawScheduleSlot): TimeSlotDescriptor {\n  const trimmedPeriodName = slot.periodName?.trim() ?? '';\n  const label =\n    trimmedPeriodName.length > 0\n      ? trimmedPeriodName\n      : slot.bookingOption.replace(/\\b\\w/g, (char) => char.toUpperCase());\n\n  return {\n    value: slot.value,\n    display: slot.display,\n    label,\n    bookingOption: slot.bookingOption,\n    defaultBookingOption: slot.defaultBookingOption,\n    availability: slot.availability,\n    disabled: slot.disabled,\n    periodId: slot.periodId,\n  } satisfies TimeSlotDescriptor;\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/services/useTimeSlots.ts",
      "category": "booking-wizard",
      "content": "import { useQuery } from '@tanstack/react-query';\nimport { useCallback, useMemo } from 'react';\n\nimport { normalizeTime } from '@reserve/shared/time';\n\nimport { fetchReservationSchedule, scheduleQueryKey } from './schedule';\nimport {\n  EMPTY_AVAILABILITY,\n  toTimeSlotDescriptor,\n  type ReservationSchedule,\n  type ServiceAvailability,\n  type TimeSlotDescriptor,\n} from './timeSlots';\n\nimport type { BookingOption } from '@reserve/shared/booking';\nimport type { OccasionDefinition } from '@reserve/shared/occasions';\n\nexport type UseTimeSlotsOptions = {\n  restaurantSlug: string | null | undefined;\n  date: string | null | undefined;\n  selectedTime: string | null | undefined;\n};\n\nexport type UseTimeSlotsResult = {\n  slots: TimeSlotDescriptor[];\n  serviceAvailability: ServiceAvailability;\n  inferBookingOption: (time: string | null | undefined) => BookingOption;\n  schedule: ReservationSchedule | null;\n  availableBookingOptions: BookingOption[];\n  occasionCatalog: OccasionDefinition[];\n  isLoading: boolean;\n  isError: boolean;\n};\n\nconst DEFAULT_BOOKING_OPTION: BookingOption = 'drinks';\n\nexport function useTimeSlots({\n  restaurantSlug,\n  date,\n  selectedTime,\n}: UseTimeSlotsOptions): UseTimeSlotsResult {\n  const scheduleQuery = useQuery<ReservationSchedule>({\n    queryKey: scheduleQueryKey(restaurantSlug, date ?? null),\n    enabled: Boolean(restaurantSlug),\n    queryFn: ({ signal }) => {\n      if (!restaurantSlug) {\n        throw new Error('Missing restaurant slug');\n      }\n      return fetchReservationSchedule(restaurantSlug, date ?? undefined, signal);\n    },\n    staleTime: 60_000,\n    refetchOnWindowFocus: false,\n  });\n\n  const slots = useMemo<TimeSlotDescriptor[]>(() => {\n    if (!scheduleQuery.data) {\n      return [];\n    }\n    return scheduleQuery.data.slots.map((slot) => toTimeSlotDescriptor(slot));\n  }, [scheduleQuery.data]);\n\n  const normalizedSelectedTime = useMemo(() => normalizeTime(selectedTime), [selectedTime]);\n\n  const activeSlot = useMemo(() => {\n    if (slots.length === 0) {\n      return undefined;\n    }\n    if (normalizedSelectedTime) {\n      const exact = slots.find((slot) => slot.value === normalizedSelectedTime);\n      if (exact) {\n        return exact;\n      }\n    }\n    return slots[0];\n  }, [slots, normalizedSelectedTime]);\n\n  const serviceAvailability = activeSlot?.availability ?? EMPTY_AVAILABILITY;\n  const fallbackBookingOption =\n    scheduleQuery.data?.availableBookingOptions[0] ??\n    activeSlot?.defaultBookingOption ??\n    DEFAULT_BOOKING_OPTION;\n\n  const inferBookingOption = useCallback(\n    (time: string | null | undefined): BookingOption => {\n      const normalized = normalizeTime(time);\n      if (!normalized) {\n        return activeSlot?.defaultBookingOption ?? fallbackBookingOption;\n      }\n      const slot = slots.find((entry) => entry.value === normalized);\n      if (slot) {\n        return slot.defaultBookingOption ?? slot.bookingOption;\n      }\n      return activeSlot?.defaultBookingOption ?? fallbackBookingOption;\n    },\n    [activeSlot, slots, fallbackBookingOption],\n  );\n\n  return {\n    slots,\n    serviceAvailability,\n    inferBookingOption,\n    schedule: scheduleQuery.data ?? null,\n    availableBookingOptions: scheduleQuery.data?.availableBookingOptions ?? [],\n    occasionCatalog: scheduleQuery.data?.occasionCatalog ?? [],\n    isLoading: scheduleQuery.isLoading,\n    isError: scheduleQuery.isError,\n  };\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/BookingWizard.tsx",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport { Loader2 } from 'lucide-react';\nimport React, { Suspense, useEffect, useMemo, useRef, useState } from 'react';\n\nimport { useOnlineStatus } from '@/hooks/useOnlineStatus';\nimport { useProfile } from '@/hooks/useProfile';\nimport { useSupabaseSession } from '@/hooks/useSupabaseSession';\nimport { emit } from '@/lib/analytics/emit';\n\nimport { WizardProvider } from '../context/WizardContext';\nimport { useWizardDependencies } from '../di';\nimport { useReservationWizard } from '../hooks/useReservationWizard';\nimport { ConfirmationStep } from './steps/ConfirmationStep';\nimport { DetailsStep } from './steps/DetailsStep';\nimport { PlanStep } from './steps/PlanStep';\nimport { ReviewStep } from './steps/ReviewStep';\nimport { WizardContainer } from './WizardContainer';\nimport { WizardOfflineBanner } from './WizardOfflineBanner';\nimport { DetailsStepSkeleton, PlanStepSkeleton, ReviewStepSkeleton } from './WizardSkeletons';\n\nimport type { BookingDetails, BookingWizardMode } from '../model/reducer';\nimport type { CalendarMask } from '@reserve/features/reservations/wizard/services/schedule';\n\nfunction LoadingFallback() {\n  return (\n    <main className=\"flex min-h-screen w-full items-center justify-center bg-slate-50 px-4 py-12\">\n      <div className=\"space-y-3 text-center text-slate-600\">\n        <Loader2 className=\"mx-auto h-8 w-8 animate-spin\" aria-hidden />\n        <p className=\"text-base\" role=\"status\">\n          Loading reservation flow\n        </p>\n      </div>\n    </main>\n  );\n}\n\ntype BookingWizardContentProps = {\n  initialDetails?: Partial<BookingDetails>;\n  mode?: BookingWizardMode;\n  layoutElement?: 'main' | 'div';\n  initialCalendarMask?: CalendarMask | null;\n};\n\nfunction BookingWizardContent({\n  initialDetails,\n  mode = 'customer',\n  layoutElement = 'main',\n  initialCalendarMask,\n}: BookingWizardContentProps) {\n  const {\n    state,\n    actions,\n    heroRef,\n    stepsMeta,\n    stickyVisible,\n    stickyActions,\n    stickyHeight,\n    handleStickyHeightChange,\n    handleActionsChange,\n    selectionSummary,\n    handleConfirm,\n    handleNewBooking,\n    handleClose,\n    planAlert,\n  } = useReservationWizard(initialDetails, mode);\n  const { analytics } = useWizardDependencies();\n  const { user, status: sessionStatus } = useSupabaseSession();\n  const isSessionReady = sessionStatus === 'ready';\n  const isAuthenticated = isSessionReady && Boolean(user);\n  const shouldLockContacts = isAuthenticated && mode !== 'ops';\n  const { data: profile } = useProfile({ enabled: shouldLockContacts });\n\n  const fallbackName =\n    (typeof user?.user_metadata?.full_name === 'string' && user.user_metadata.full_name.trim()) ||\n    (typeof user?.user_metadata?.name === 'string' && user.user_metadata.name.trim()) ||\n    '';\n  const lockedName = shouldLockContacts ? (profile?.name ?? fallbackName ?? '').trim() : '';\n  const lockedEmail = shouldLockContacts ? (profile?.email ?? user?.email ?? '').trim() : '';\n  const lockedPhone = shouldLockContacts ? (profile?.phone ?? '').trim() : '';\n\n  useEffect(() => {\n    if (!shouldLockContacts) {\n      return;\n    }\n\n    if (lockedEmail && state.details.email.trim() !== lockedEmail) {\n      actions.updateDetails('email', lockedEmail);\n    }\n\n    if (lockedName && state.details.name.trim() !== lockedName) {\n      actions.updateDetails('name', lockedName);\n    }\n\n    if (lockedPhone && state.details.phone.trim() !== lockedPhone) {\n      actions.updateDetails('phone', lockedPhone);\n    }\n  }, [\n    actions,\n    shouldLockContacts,\n    lockedEmail,\n    lockedName,\n    lockedPhone,\n    state.details.email,\n    state.details.name,\n    state.details.phone,\n  ]);\n\n  const contactLocks = useMemo(() => {\n    if (!shouldLockContacts) {\n      return undefined;\n    }\n\n    return {\n      name: Boolean(lockedName),\n      email: true,\n      phone: Boolean(lockedPhone),\n    } as const;\n  }, [lockedName, lockedPhone, shouldLockContacts]);\n\n  const isOnline = useOnlineStatus();\n  const isOffline = !isOnline;\n  const offlineBannerRef = useRef<HTMLDivElement | null>(null);\n  const lastOnlineAtRef = useRef<number>(Date.now());\n  const offlineTrackedRef = useRef(false);\n  const wasOfflineRef = useRef(false);\n  const [hasHydrated, setHasHydrated] = useState(false);\n\n  useEffect(() => {\n    setHasHydrated(true);\n  }, []);\n\n  useEffect(() => {\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    if (isOnline) {\n      lastOnlineAtRef.current = Date.now();\n      offlineTrackedRef.current = false;\n      return;\n    }\n\n    if (offlineTrackedRef.current) {\n      return;\n    }\n\n    const wasOnlineForMs = Date.now() - lastOnlineAtRef.current;\n    const payload = {\n      path: window.location?.pathname ?? '/reserve',\n      step: state.step,\n      wasOnlineForMs: Number.isFinite(wasOnlineForMs) ? wasOnlineForMs : undefined,\n    };\n\n    analytics.track('wizard_offline_detected', payload);\n    emit('wizard_offline_detected', payload);\n    offlineTrackedRef.current = true;\n  }, [analytics, isOnline, state.step]);\n\n  useEffect(() => {\n    if (!hasHydrated) {\n      return;\n    }\n\n    if (isOffline && !wasOfflineRef.current) {\n      setTimeout(() => {\n        offlineBannerRef.current?.focus();\n      }, 0);\n    }\n    wasOfflineRef.current = isOffline;\n  }, [hasHydrated, isOffline]);\n\n  const disableAllActions = isOffline || (state.loading && state.step !== 4);\n\n  const effectiveActions = useMemo(() => {\n    if (!disableAllActions) {\n      return stickyActions;\n    }\n\n    return stickyActions.map((action) => ({\n      ...action,\n      disabled: true,\n    }));\n  }, [disableAllActions, stickyActions]);\n\n  const banner =\n    hasHydrated && isOffline ? (\n      <WizardOfflineBanner\n        ref={offlineBannerRef}\n        description=\"Youre offline. Well keep your progress and send requests automatically when you reconnect.\"\n      />\n    ) : null;\n\n  const shouldShowSkeleton = state.loading && state.step !== 4;\n\n  const stepContent = (() => {\n    if (shouldShowSkeleton) {\n      switch (state.step) {\n        case 1:\n          return <PlanStepSkeleton />;\n        case 2:\n          return <DetailsStepSkeleton />;\n        case 3:\n          return <ReviewStepSkeleton />;\n        default:\n          return null;\n      }\n    }\n\n    switch (state.step) {\n      case 1:\n        return (\n          <PlanStep\n            onActionsChange={handleActionsChange}\n            onTrack={analytics.track}\n            planAlert={planAlert}\n            initialCalendarMask={initialCalendarMask}\n          />\n        );\n      case 2:\n        return (\n          <DetailsStep\n            onActionsChange={handleActionsChange}\n            contactLocks={contactLocks}\n            mode={mode}\n          />\n        );\n      case 3:\n        return <ReviewStep onConfirm={handleConfirm} onActionsChange={handleActionsChange} />;\n      case 4:\n        return (\n          <ConfirmationStep\n            onNewBooking={handleNewBooking}\n            onClose={handleClose}\n            onActionsChange={handleActionsChange}\n          />\n        );\n      default:\n        return null;\n    }\n  })();\n\n  return (\n    <WizardProvider state={state} actions={actions}>\n      <WizardContainer\n        steps={stepsMeta}\n        currentStep={state.step}\n        actions={effectiveActions}\n        summary={selectionSummary}\n        heroRef={heroRef}\n        stickyHeight={stickyHeight}\n        stickyVisible={stickyVisible}\n        onStickyHeightChange={handleStickyHeightChange}\n        banner={banner}\n        layoutElement={layoutElement}\n      >\n        {stepContent}\n      </WizardContainer>\n    </WizardProvider>\n  );\n}\n\ntype BookingWizardProps = {\n  initialDetails?: Partial<BookingDetails>;\n  mode?: BookingWizardMode;\n  layoutElement?: 'main' | 'div';\n  initialCalendarMask?: CalendarMask | null;\n};\n\nexport function BookingWizard({\n  initialDetails,\n  mode = 'customer',\n  layoutElement = 'main',\n  initialCalendarMask,\n}: BookingWizardProps = {}) {\n  return (\n    <Suspense fallback={<LoadingFallback />}>\n      <BookingWizardContent\n        initialDetails={initialDetails}\n        mode={mode}\n        layoutElement={layoutElement}\n        initialCalendarMask={initialCalendarMask}\n      />\n    </Suspense>\n  );\n}\n\nexport default BookingWizard;\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/ErrorBoundary.tsx",
      "category": "booking-wizard",
      "content": "import { AlertTriangle, RefreshCw } from 'lucide-react';\nimport React, { Component } from 'react';\n\nimport { Alert, AlertDescription, AlertIcon, AlertTitle } from '@shared/ui/alert';\nimport { Button } from '@shared/ui/button';\n\ninterface ErrorBoundaryProps {\n  children: React.ReactNode;\n  fallback?: React.ReactNode;\n  onError?: (error: Error, errorInfo: React.ErrorInfo) => void;\n  onReset?: () => void;\n  resetKeys?: unknown[];\n}\n\ninterface ErrorBoundaryState {\n  hasError: boolean;\n  error: Error | null;\n}\n\nexport class ErrorBoundary extends Component<ErrorBoundaryProps, ErrorBoundaryState> {\n  constructor(props: ErrorBoundaryProps) {\n    super(props);\n    this.state = { hasError: false, error: null };\n  }\n\n  static getDerivedStateFromError(error: Error): ErrorBoundaryState {\n    return { hasError: true, error };\n  }\n\n  componentDidCatch(error: Error, errorInfo: React.ErrorInfo) {\n    this.props.onError?.(error, errorInfo);\n\n    if (process.env.NODE_ENV !== 'production') {\n      console.error('[wizard] Error boundary caught exception', error, errorInfo);\n    }\n  }\n\n  componentDidUpdate(prevProps: ErrorBoundaryProps) {\n    const { resetKeys } = this.props;\n    if (!this.state.hasError || !resetKeys) {\n      return;\n    }\n\n    const prevResetKeys = prevProps.resetKeys ?? [];\n    const hasChanged = resetKeys.some((key, index) => key !== prevResetKeys[index]);\n    if (hasChanged) {\n      this.reset();\n    }\n  }\n\n  reset = () => {\n    this.props.onReset?.();\n    this.setState({ hasError: false, error: null });\n  };\n\n  render() {\n    if (this.state.hasError) {\n      if (this.props.fallback) {\n        return this.props.fallback;\n      }\n\n      return <ErrorFallback error={this.state.error} onReset={this.reset} />;\n    }\n\n    return this.props.children;\n  }\n}\n\nfunction ErrorFallback({ error, onReset }: { error: Error | null; onReset: () => void }) {\n  return (\n    <div className=\"flex min-h-[320px] items-center justify-center p-6\">\n      <div className=\"w-full max-w-md space-y-4\">\n        <Alert variant=\"destructive\">\n          <AlertIcon>\n            <AlertTriangle className=\"h-5 w-5\" aria-hidden />\n          </AlertIcon>\n          <AlertTitle className=\"text-lg font-semibold\">Something went wrong</AlertTitle>\n          <AlertDescription className=\"space-y-3 text-sm\">\n            <p>We hit an unexpected issue while loading this step. Your latest data is safe.</p>\n            {process.env.NODE_ENV !== 'production' && error ? (\n              <details className=\"rounded-md bg-destructive/10 p-3 text-xs\">\n                <summary className=\"cursor-pointer\">Error details</summary>\n                <pre className=\"mt-2 whitespace-pre-wrap text-[11px]\">\n                  {error.message}\n                  {'\\n'}\n                  {error.stack}\n                </pre>\n              </details>\n            ) : null}\n            <div className=\"flex gap-2 pt-2\">\n              <Button onClick={onReset} size=\"sm\">\n                <RefreshCw className=\"mr-2 h-4 w-4\" aria-hidden />\n                Try again\n              </Button>\n              <Button onClick={() => window.location.reload()} variant=\"outline\" size=\"sm\">\n                Reload page\n              </Button>\n            </div>\n          </AlertDescription>\n        </Alert>\n      </div>\n    </div>\n  );\n}\n\ninterface StepErrorBoundaryProps {\n  children: React.ReactNode;\n  stepName: string;\n  onReset?: () => void;\n}\n\nexport function StepErrorBoundary({ children, stepName, onReset }: StepErrorBoundaryProps) {\n  return (\n    <ErrorBoundary\n      onError={(error, info) => {\n        if (process.env.NODE_ENV !== 'production') {\n          console.error(`[wizard] Error within ${stepName}`, error, info);\n        }\n      }}\n      onReset={onReset}\n      fallback={\n        <div className=\"space-y-4 p-6\">\n          <Alert variant=\"destructive\">\n            <AlertIcon>\n              <AlertTriangle className=\"h-4 w-4\" aria-hidden />\n            </AlertIcon>\n            <AlertTitle className=\"mb-1 text-base font-semibold\">\n              Trouble loading {stepName}\n            </AlertTitle>\n            <AlertDescription className=\"space-y-3 text-sm\">\n              <p>\n                We couldnt load this step. Please try again or head back to the previous step while\n                we fix it.\n              </p>\n              <div className=\"flex gap-2\">\n                {onReset ? (\n                  <Button onClick={onReset} size=\"sm\">\n                    Try again\n                  </Button>\n                ) : null}\n                <Button onClick={() => window.history.back()} variant=\"outline\" size=\"sm\">\n                  Go back\n                </Button>\n              </div>\n            </AlertDescription>\n          </Alert>\n        </div>\n      }\n    >\n      {children}\n    </ErrorBoundary>\n  );\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/ReservationWizard.tsx",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport React, { useMemo } from 'react';\nimport { useNavigate } from 'react-router-dom';\n\nimport { WizardDependenciesProvider } from '../di';\nimport { BookingWizard } from './BookingWizard';\n\nimport type { BookingDetails, BookingWizardMode } from '../model/reducer';\n\ntype ReservationWizardProps = {\n  initialDetails?: Partial<BookingDetails>;\n  mode?: BookingWizardMode;\n};\n\nexport function ReservationWizard({\n  initialDetails,\n  mode = 'customer',\n}: ReservationWizardProps = {}) {\n  const navigate = useNavigate();\n  const navigatorDeps = useMemo(\n    () => ({\n      navigator: {\n        push: (path: string) => navigate(path),\n        replace: (path: string) => navigate(path, { replace: true }),\n        back: () => navigate(-1),\n      },\n    }),\n    [navigate],\n  );\n\n  return (\n    <WizardDependenciesProvider value={navigatorDeps}>\n      <BookingWizard initialDetails={initialDetails} mode={mode} />\n    </WizardDependenciesProvider>\n  );\n}\n\nexport default ReservationWizard;\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/steps/confirmation-step/types.ts",
      "category": "booking-wizard",
      "content": "import type { State, StepAction } from '../../../model/reducer';\n\nexport interface ConfirmationStepProps {\n  state?: State;\n  onNewBooking: () => void;\n  onClose: () => void;\n  onActionsChange: (actions: StepAction[]) => void;\n}\n\nexport type ConfirmationStatus = 'pending' | 'confirmed' | 'updated';\n\nexport type ConfirmationFeedback = {\n  variant: 'info' | 'success' | 'warning' | 'error';\n  message: string;\n};\n\nexport type ConfirmationStepController = {\n  booking: State['lastConfirmed'];\n  details: State['details'];\n  venue: {\n    id: string;\n    name: string;\n    address: string;\n    timezone: string;\n  };\n  status: ConfirmationStatus;\n  isLoading: boolean;\n  heading: string;\n  description: string;\n  reference: string;\n  guestName: string;\n  summaryDate: string;\n  summaryTime: string;\n  partyText: string;\n  reservationWindow: { start: Date; end: Date } | null;\n  calendarLoading: boolean;\n  walletLoading: boolean;\n  feedback: ConfirmationFeedback | null;\n  dismissFeedback: () => void;\n  handleAddToCalendar: () => void;\n  handleAddToWallet: () => Promise<void> | void;\n  handleClose: () => void;\n  handleNewBooking: () => void;\n};\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/steps/ConfirmationStep.tsx",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport { AlertTriangle, CheckCircle2, Info, XCircle } from 'lucide-react';\nimport React, { useCallback, useEffect, useMemo, useState } from 'react';\n\nimport { useConfirmationStep } from '@features/reservations/wizard/hooks/useConfirmationStep';\nimport { Alert, AlertDescription, AlertIcon } from '@shared/ui/alert';\nimport { Button } from '@shared/ui/button';\n\nimport { useWizardNavigation } from '../../context/WizardContext';\nimport { StepErrorBoundary } from '../ErrorBoundary';\nimport { WizardStep } from '../WizardStep';\n\nimport type { ConfirmationStepProps } from './confirmation-step/types';\n\nconst STATUS_ICON_MAP = {\n  confirmed: { Icon: CheckCircle2, className: 'text-emerald-500' },\n  updated: { Icon: CheckCircle2, className: 'text-emerald-500' },\n} as const;\n\nconst FEEDBACK_ICON_MAP = {\n  success: CheckCircle2,\n  warning: AlertTriangle,\n  error: XCircle,\n  info: Info,\n} as const;\n\nexport function ConfirmationStep(props: ConfirmationStepProps) {\n  const controller = useConfirmationStep(props);\n  const { status, handleClose } = controller;\n  const { goToStep } = useWizardNavigation();\n\n  const { Icon: StatusIcon, className: statusIconClass } =\n    controller.status === 'pending'\n      ? { Icon: Info, className: 'text-blue-600' }\n      : STATUS_ICON_MAP[controller.status];\n\n  const FeedbackIcon = useMemo(() => {\n    if (!controller.feedback) return null;\n    return FEEDBACK_ICON_MAP[controller.feedback.variant];\n  }, [controller.feedback]);\n\n  const [autoRedirectEnabled, setAutoRedirectEnabled] = useState(() => {\n    if (typeof window === 'undefined') {\n      return true;\n    }\n    return sessionStorage.getItem('autoRedirectEnabled') !== 'false';\n  });\n  const [redirectIn, setRedirectIn] = useState<number | null>(null);\n  const [redirectCanceled, setRedirectCanceled] = useState(() => {\n    if (typeof window === 'undefined') {\n      return false;\n    }\n    return sessionStorage.getItem('autoRedirectEnabled') === 'false';\n  });\n\n  const handleCancelRedirect = useCallback(() => {\n    setAutoRedirectEnabled(false);\n    setRedirectCanceled(true);\n    if (typeof window !== 'undefined') {\n      sessionStorage.setItem('autoRedirectEnabled', 'false');\n    }\n  }, []);\n\n  useEffect(() => {\n    if (status !== 'pending' || !autoRedirectEnabled) {\n      setRedirectIn(null);\n      return;\n    }\n\n    setRedirectCanceled(false);\n    setRedirectIn(5);\n\n    const interval = window.setInterval(() => {\n      setRedirectIn((prev) => {\n        if (prev === null || prev <= 0) {\n          return 0;\n        }\n        return prev - 1;\n      });\n    }, 1000);\n\n    const timeout = window.setTimeout(() => {\n      if (autoRedirectEnabled) {\n        handleClose();\n      }\n    }, 5000);\n\n    return () => {\n      clearInterval(interval);\n      clearTimeout(timeout);\n    };\n  }, [status, autoRedirectEnabled, handleClose]);\n\n  return (\n    <StepErrorBoundary\n      stepName=\"Confirmation\"\n      onReset={() => {\n        goToStep(4);\n      }}\n    >\n      <WizardStep\n        step={4}\n        title={controller.heading}\n        description={controller.description}\n        icon={<StatusIcon className={`h-6 w-6 ${statusIconClass}`} aria-hidden />}\n        contentClassName=\"space-y-6\"\n      >\n        {controller.status === 'pending' ? (\n          <div className=\"space-y-3\" aria-live=\"polite\">\n            <p className=\"text-xs text-muted-foreground\">\n              Its okay to leave this screen. Well send the confirmation via email.\n            </p>\n            {autoRedirectEnabled && !redirectCanceled ? (\n              <>\n                <div className=\"relative h-1.5 w-full overflow-hidden rounded bg-muted/50\">\n                  <div\n                    className=\"h-full bg-blue-600 transition-[width] duration-1000 ease-linear\"\n                    style={{ width: `${((5 - (redirectIn ?? 5)) / 5) * 100}%` }}\n                    role=\"progressbar\"\n                    aria-label=\"Auto-redirect progress\"\n                    aria-valuemin={0}\n                    aria-valuemax={5}\n                    aria-valuenow={5 - (redirectIn ?? 5)}\n                  />\n                </div>\n                <div className=\"flex items-center justify-between gap-3\">\n                  <p className=\"text-xs text-muted-foreground\">\n                    Redirecting to summary in <strong>{redirectIn ?? 5}s</strong>\n                  </p>\n                  <Button\n                    variant=\"ghost\"\n                    size=\"sm\"\n                    onClick={handleCancelRedirect}\n                    className=\"h-7 text-xs\"\n                  >\n                    Cancel redirect\n                  </Button>\n                </div>\n                <div className=\"sr-only\" role=\"status\" aria-live=\"polite\">\n                  Automatically redirecting in {redirectIn ?? 5} seconds. Press cancel redirect to\n                  stay on this page.\n                </div>\n              </>\n            ) : redirectCanceled ? (\n              <Alert variant=\"info\" className=\"border border-dashed\">\n                <AlertIcon>\n                  <Info className=\"h-4 w-4\" aria-hidden />\n                </AlertIcon>\n                <AlertDescription>\n                  Auto-redirect canceled. You can close this manually when ready.\n                </AlertDescription>\n              </Alert>\n            ) : null}\n          </div>\n        ) : null}\n        <p className=\"sr-only\" aria-live=\"polite\">\n          {controller.status === 'pending'\n            ? 'Reservation is being confirmed. Please wait.'\n            : `Reference ${controller.reference}. Reservation for ${controller.partyText} at ${controller.summaryTime} on ${controller.summaryDate}.`}\n        </p>\n        {controller.feedback ? (\n          <Alert\n            variant={\n              controller.feedback.variant === 'error'\n                ? 'destructive'\n                : controller.feedback.variant === 'warning'\n                  ? 'warning'\n                  : controller.feedback.variant === 'success'\n                    ? 'success'\n                    : 'info'\n            }\n            role={controller.feedback.variant === 'error' ? 'alert' : 'status'}\n            className=\"items-start gap-3\"\n          >\n            <AlertIcon>\n              {FeedbackIcon ? <FeedbackIcon className=\"h-4 w-4\" aria-hidden /> : null}\n            </AlertIcon>\n            <div className=\"flex w-full flex-col gap-3 sm:flex-row sm:items-center sm:justify-between\">\n              <AlertDescription>{controller.feedback.message}</AlertDescription>\n              <Button\n                variant=\"ghost\"\n                size=\"sm\"\n                onClick={controller.dismissFeedback}\n                disabled={controller.isLoading}\n                className=\"self-end sm:self-auto\"\n              >\n                Dismiss\n              </Button>\n            </div>\n          </Alert>\n        ) : null}\n        <div className=\"rounded-xl border border-border bg-card p-5 shadow-sm\">\n          <dl className=\"grid gap-4 sm:grid-cols-2\">\n            <div>\n              <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">\n                Reference\n              </dt>\n              <dd className=\"text-sm font-semibold text-foreground\">{controller.reference}</dd>\n            </div>\n            <div>\n              <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">Guest</dt>\n              <dd className=\"text-sm font-semibold text-foreground\">{controller.guestName}</dd>\n            </div>\n            <div>\n              <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">When</dt>\n              <dd className=\"text-sm font-medium text-foreground\">\n                {controller.summaryDate} at {controller.summaryTime}\n              </dd>\n            </div>\n            <div>\n              <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">Guests</dt>\n              <dd className=\"text-sm font-medium text-foreground\">{controller.partyText}</dd>\n            </div>\n          </dl>\n        </div>\n      </WizardStep>\n    </StepErrorBoundary>\n  );\n}\n\nexport type { ConfirmationStepProps } from './confirmation-step/types';\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/steps/details-step/types.ts",
      "category": "booking-wizard",
      "content": "import type { BookingWizardMode, State, StepAction } from '../../../model/reducer';\nimport type { DetailsFormInputValues, DetailsFormValues } from '../../../model/schemas';\nimport type { WizardActions } from '../../../model/store';\nimport type { AnalyticsEvent } from '@shared/lib/analytics';\nimport type { UseFormReturn } from 'react-hook-form';\n\nexport type DetailsContactLocks = Partial<Record<'name' | 'email' | 'phone', boolean>>;\n\nexport interface DetailsStepProps {\n  state?: State;\n  actions?: Pick<WizardActions, 'updateDetails' | 'goToStep'>;\n  onActionsChange: (actions: StepAction[]) => void;\n  onTrack?: (event: AnalyticsEvent, payload?: Record<string, unknown>) => void;\n  contactLocks?: DetailsContactLocks;\n  mode?: BookingWizardMode;\n}\n\nexport type DetailsStepController = {\n  form: UseFormReturn<DetailsFormInputValues, unknown, DetailsFormValues>;\n  handleBack: () => void;\n  handleSubmit: (values: DetailsFormValues) => void;\n  handleError: (errors: Record<string, unknown>) => void;\n  isSubmitting: boolean;\n  isValid: boolean;\n  handlers: {\n    changeName: (value: string) => void;\n    changeEmail: (value: string) => void;\n    changePhone: (value: string) => void;\n    toggleRemember: (value: boolean) => void;\n    toggleMarketing: (value: boolean) => void;\n    toggleAgree: (value: boolean) => void;\n  };\n};\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/steps/DetailsStep.tsx",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport { AlertCircle } from 'lucide-react';\nimport React, { useEffect, useMemo, useState } from 'react';\nimport { useWatch } from 'react-hook-form';\n\nimport { cn } from '@/lib/utils';\nimport { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from '@shared/ui/accordion';\nimport { Alert, AlertDescription, AlertIcon } from '@shared/ui/alert';\nimport { Checkbox } from '@shared/ui/checkbox';\nimport {\n  Form,\n  FormControl,\n  FormDescription,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from '@shared/ui/form';\nimport { Input } from '@shared/ui/input';\nimport { Label } from '@shared/ui/label';\n\nimport { useWizardNavigation } from '../../context/WizardContext';\nimport { useWizardDependencies } from '../../di';\nimport { useDetailsStepForm } from '../../hooks/useDetailsStepForm';\nimport { StepErrorBoundary } from '../ErrorBoundary';\nimport { WizardStep } from '../WizardStep';\n\nimport type { DetailsStepProps } from './details-step/types';\n\nconst CONTACT_SECTION_CLASS = 'space-y-4 rounded-xl border border-border bg-card p-5 shadow-sm';\nconst basePreferenceLabelClass =\n  'hover:bg-accent/50 flex w-full items-start gap-3 rounded-lg border p-3 transition-colors has-[[aria-checked=true]]:border-primary has-[[aria-checked=true]]:bg-primary/10 dark:has-[[aria-checked=true]]:border-primary/60 dark:has-[[aria-checked=true]]:bg-primary/20';\n\nconst optionalPreferenceLabelClass = (checked: boolean) =>\n  cn(basePreferenceLabelClass, checked ? 'border-primary/60' : 'border-border bg-muted/40');\n\nconst requiredPreferenceLabelClass = (checked: boolean) =>\n  cn(\n    basePreferenceLabelClass,\n    checked\n      ? 'border-primary/60'\n      : 'border-destructive/40 bg-destructive/10 text-destructive-foreground dark:text-destructive-foreground',\n  );\n\nexport function DetailsStep({ mode = 'customer', ...props }: DetailsStepProps) {\n  const { analytics } = useWizardDependencies();\n  const { goToStep } = useWizardNavigation();\n  const controller = useDetailsStepForm({\n    ...props,\n    mode,\n    onTrack: props.onTrack ?? analytics.track,\n  });\n  const { form, handleSubmit, handleError, handlers } = controller;\n  const { errors } = form.formState;\n  const rememberDetailsValue = useWatch({ control: form.control, name: 'rememberDetails' });\n  const marketingOptInValue = useWatch({ control: form.control, name: 'marketingOptIn' });\n  const agreeValue = useWatch({ control: form.control, name: 'agree' });\n  const contactLocks = props.contactLocks ?? {};\n  const isNameLocked = Boolean(contactLocks.name);\n  const isEmailLocked = Boolean(contactLocks.email);\n  const isPhoneLocked = Boolean(contactLocks.phone);\n\n  const preferenceSummary = useMemo(() => {\n    const parts = [\n      rememberDetailsValue ? 'Details saved' : 'Details not saved',\n      marketingOptInValue ? 'Updates on' : 'Updates off',\n      agreeValue ? 'Terms accepted' : 'Terms pending',\n    ];\n    return parts.join('  ');\n  }, [rememberDetailsValue, marketingOptInValue, agreeValue]);\n\n  const [accordionValue, setAccordionValue] = useState<string | undefined>();\n\n  useEffect(() => {\n    if (errors.agree) {\n      setAccordionValue('preferences');\n    }\n  }, [errors.agree]);\n\n  return (\n    <StepErrorBoundary\n      stepName=\"Tell us how to reach you\"\n      onReset={() => {\n        goToStep(2);\n      }}\n    >\n      <WizardStep\n        step={2}\n        title=\"Tell us how to reach you\"\n        description=\"Well send confirmation and any updates to the contact details below.\"\n        contentClassName=\"space-y-6 md:space-y-8\"\n      >\n        <Form {...form}>\n          <form\n            className=\"space-y-6 md:space-y-8\"\n            onSubmit={form.handleSubmit(handleSubmit, handleError)}\n            noValidate\n          >\n            <button type=\"submit\" className=\"hidden\" aria-hidden />\n\n            <section className={CONTACT_SECTION_CLASS}>\n              <h3 className=\"text-lg font-semibold text-foreground\">Contact details</h3>\n              <div className=\"space-y-4\">\n                <FormField\n                  control={form.control}\n                  name=\"name\"\n                  render={({ field }) => (\n                    <FormItem>\n                      <FormLabel>Full name</FormLabel>\n                      <FormControl>\n                        <Input\n                          type=\"text\"\n                          placeholder=\"Jane Smith\"\n                          autoComplete=\"name\"\n                          value={field.value}\n                          disabled={isNameLocked}\n                          onChange={(event) => {\n                            const next = event.target.value;\n                            field.onChange(next);\n                            handlers.changeName(next);\n                          }}\n                        />\n                      </FormControl>\n                      <FormMessage>{errors.name?.message}</FormMessage>\n                    </FormItem>\n                  )}\n                />\n\n                <FormField\n                  control={form.control}\n                  name=\"email\"\n                  render={({ field }) => (\n                    <FormItem>\n                      <FormLabel>Email address{mode === 'ops' ? ' (optional)' : ''}</FormLabel>\n                      <FormControl>\n                        <Input\n                          type=\"email\"\n                          placeholder=\"you@example.com\"\n                          autoComplete=\"email\"\n                          value={field.value}\n                          disabled={isEmailLocked}\n                          onChange={(event) => {\n                            const next = event.target.value;\n                            field.onChange(next);\n                            handlers.changeEmail(next);\n                          }}\n                        />\n                      </FormControl>\n                      {isEmailLocked ? (\n                        <FormDescription className=\"text-xs text-muted-foreground\">\n                          Email is linked to your account. Update it from your profile to change it.\n                        </FormDescription>\n                      ) : null}\n                      <FormMessage>{errors.email?.message}</FormMessage>\n                    </FormItem>\n                  )}\n                />\n\n                <FormField\n                  control={form.control}\n                  name=\"phone\"\n                  render={({ field }) => (\n                    <FormItem>\n                      <FormLabel>UK phone number{mode === 'ops' ? ' (optional)' : ''}</FormLabel>\n                      <FormControl>\n                        <Input\n                          type=\"tel\"\n                          placeholder=\"07123 456789\"\n                          autoComplete=\"tel\"\n                          inputMode=\"tel\"\n                          value={field.value}\n                          disabled={isPhoneLocked}\n                          onChange={(event) => {\n                            const next = event.target.value;\n                            field.onChange(next);\n                            handlers.changePhone(next);\n                          }}\n                        />\n                      </FormControl>\n                      <FormMessage>{errors.phone?.message}</FormMessage>\n                    </FormItem>\n                  )}\n                />\n              </div>\n            </section>\n\n            <section className={CONTACT_SECTION_CLASS}>\n              <Accordion\n                type=\"single\"\n                collapsible\n                value={accordionValue}\n                onValueChange={(next) => setAccordionValue(next ?? undefined)}\n                className=\"w-full\"\n              >\n                <AccordionItem value=\"preferences\">\n                  <AccordionTrigger>\n                    <span className=\"flex flex-col text-left\">\n                      <span className=\"text-base font-semibold text-foreground\">Preferences</span>\n                      <span\n                        className={\n                          agreeValue ? 'text-sm text-muted-foreground' : 'text-sm text-destructive'\n                        }\n                      >\n                        {preferenceSummary}\n                      </span>\n                    </span>\n                  </AccordionTrigger>\n                  <AccordionContent>\n                    <div className=\"space-y-4 pt-4\">\n                      <FormField\n                        control={form.control}\n                        name=\"rememberDetails\"\n                        render={({ field }) => {\n                          const checkboxId = 'remember-details';\n                          return (\n                            <FormItem className=\"space-y-1\">\n                              <Label\n                                htmlFor={checkboxId}\n                                className={optionalPreferenceLabelClass(Boolean(field.value))}\n                              >\n                                <FormControl>\n                                  <Checkbox\n                                    id={checkboxId}\n                                    checked={field.value}\n                                    onCheckedChange={(next) => {\n                                      const value = next === true;\n                                      field.onChange(value);\n                                      handlers.toggleRemember(value);\n                                    }}\n                                    className=\"h-4 w-4 rounded-[4px] border border-muted-foreground/50 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background data-[state=checked]:border-primary data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\"\n                                  />\n                                </FormControl>\n                                <div className=\"space-y-1\">\n                                  <span className=\"text-sm font-semibold text-foreground\">\n                                    Save contact details for next time\n                                  </span>\n                                  <p className=\"text-sm text-muted-foreground\">\n                                    Well pre-fill your info the next time you book on this device.\n                                  </p>\n                                </div>\n                              </Label>\n                            </FormItem>\n                          );\n                        }}\n                      />\n\n                      <FormField\n                        control={form.control}\n                        name=\"marketingOptIn\"\n                        render={({ field }) => {\n                          const checkboxId = 'marketing-opt-in';\n                          return (\n                            <FormItem className=\"space-y-1\">\n                              <Label\n                                htmlFor={checkboxId}\n                                className={optionalPreferenceLabelClass(Boolean(field.value))}\n                              >\n                                <FormControl>\n                                  <Checkbox\n                                    id={checkboxId}\n                                    checked={field.value}\n                                    onCheckedChange={(next) => {\n                                      const value = next === true;\n                                      field.onChange(value);\n                                      handlers.toggleMarketing(value);\n                                    }}\n                                    className=\"h-4 w-4 rounded-[4px] border border-muted-foreground/50 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background data-[state=checked]:border-primary data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\"\n                                  />\n                                </FormControl>\n                                <div className=\"space-y-1\">\n                                  <span className=\"text-sm font-semibold text-foreground\">\n                                    Send me occasional updates\n                                  </span>\n                                  <p className=\"text-sm text-muted-foreground\">\n                                    News on seasonal menus, experiences, and exclusive events.\n                                  </p>\n                                </div>\n                              </Label>\n                            </FormItem>\n                          );\n                        }}\n                      />\n\n                      <FormField\n                        control={form.control}\n                        name=\"agree\"\n                        render={({ field }) => {\n                          const checkboxId = 'agree-terms';\n                          return (\n                            <FormItem className=\"space-y-3\">\n                              <Label\n                                htmlFor={checkboxId}\n                                className={requiredPreferenceLabelClass(Boolean(field.value))}\n                              >\n                                <FormControl>\n                                  <Checkbox\n                                    id={checkboxId}\n                                    checked={field.value}\n                                    onCheckedChange={(next) => {\n                                      const value = next === true;\n                                      field.onChange(value);\n                                      handlers.toggleAgree(value);\n                                    }}\n                                    className=\"h-4 w-4 rounded-[4px] border border-muted-foreground/50 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background data-[state=checked]:border-primary data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\"\n                                  />\n                                </FormControl>\n                                <div className=\"space-y-1 text-sm text-muted-foreground\">\n                                  <span className=\"text-foreground font-semibold\">\n                                    I agree to the terms and privacy notice\n                                  </span>\n                                  <span>\n                                    Required to confirm your booking. View our\n                                    <a\n                                      href=\"/terms\"\n                                      className=\"ml-1 text-foreground underline underline-offset-4\"\n                                      onClick={(event) => event.stopPropagation()}\n                                    >\n                                      terms\n                                    </a>\n                                    and\n                                    <a\n                                      href=\"/privacy-policy\"\n                                      className=\"ml-1 text-foreground underline underline-offset-4\"\n                                      onClick={(event) => event.stopPropagation()}\n                                    >\n                                      privacy policy\n                                    </a>\n                                    .\n                                  </span>\n                                </div>\n                              </Label>\n                              <FormMessage className=\"sr-only\">{errors.agree?.message}</FormMessage>\n                              {errors.agree ? (\n                                <Alert\n                                  variant=\"destructive\"\n                                  role=\"alert\"\n                                  className=\"flex items-start gap-3\"\n                                >\n                                  <AlertIcon>\n                                    <AlertCircle className=\"h-4 w-4\" aria-hidden />\n                                  </AlertIcon>\n                                  <AlertDescription>{errors.agree.message}</AlertDescription>\n                                </Alert>\n                              ) : null}\n                            </FormItem>\n                          );\n                        }}\n                      />\n                    </div>\n                  </AccordionContent>\n                </AccordionItem>\n              </Accordion>\n            </section>\n          </form>\n        </Form>\n      </WizardStep>\n    </StepErrorBoundary>\n  );\n}\n\nexport type { DetailsStepProps } from './details-step/types';\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/steps/plan-step/components/Calendar24Field.tsx",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport { endOfDay } from 'date-fns';\nimport { ChevronDownIcon } from 'lucide-react';\nimport React, { useCallback, useEffect, useId, useMemo, useState } from 'react';\n\nimport { formatDateForInput, formatReservationDate } from '@reserve/shared/formatting/booking';\nimport { cn } from '@shared/lib/cn';\nimport { Button } from '@shared/ui/button';\nimport { Calendar } from '@shared/ui/calendar';\nimport { Input } from '@shared/ui/input';\nimport { Label } from '@shared/ui/label';\nimport { Popover, PopoverContent, PopoverTrigger } from '@shared/ui/popover';\n\nimport type { TimeSlotDescriptor } from '@reserve/features/reservations/wizard/services';\n\nconst DATE_DESCRIPTION = 'Pick a date to see available times.';\nconst TIME_DESCRIPTION = 'Choose the time that works best for your party.';\n\nexport type Calendar24FieldProps = {\n  date: {\n    value: string;\n    minDate: Date;\n    onSelect: (value: Date | undefined | null) => void;\n    onBlur?: () => void;\n    error?: string;\n  };\n  time: {\n    value: string;\n    onChange: (value: string, options?: { commit?: boolean }) => void;\n    onBlur?: () => void;\n    error?: string;\n  };\n  suggestions?: TimeSlotDescriptor[];\n  intervalMinutes?: number;\n  isDateUnavailable?: (date: Date) => boolean;\n  isTimeDisabled?: boolean;\n  unavailableMessage?: string;\n  onMonthChange?: (month: Date) => void;\n  loadingDates?: Set<string>;\n};\n\nexport function Calendar24Field({\n  date,\n  time,\n  suggestions = [],\n  intervalMinutes,\n  isDateUnavailable,\n  isTimeDisabled = false,\n  unavailableMessage,\n  onMonthChange,\n  loadingDates,\n}: Calendar24FieldProps) {\n  const resolvedIntervalMinutes =\n    typeof intervalMinutes === 'number' && intervalMinutes > 0 ? intervalMinutes : undefined;\n  const [open, setOpen] = useState(false);\n  const [hasHydrated, setHasHydrated] = useState(false);\n  const computedStepSeconds = resolvedIntervalMinutes\n    ? Math.max(60, Math.round(resolvedIntervalMinutes * 60))\n    : 60;\n  const timeStepSeconds = hasHydrated ? computedStepSeconds : 60;\n  const baseId = useId();\n  const dateButtonId = `${baseId}-date`;\n  const timeInputId = `${baseId}-time`;\n  const timeListId = `${baseId}-time-options`;\n  const dateDescriptionId = `${baseId}-date-description`;\n  const timeDescriptionId = `${baseId}-time-description`;\n  const dateErrorId = date.error ? `${baseId}-date-error` : undefined;\n  const timeErrorId = time.error ? `${baseId}-time-error` : undefined;\n\n  const label = useMemo(\n    () => (date.value ? formatReservationDate(date.value) : 'Select date'),\n    [date.value],\n  );\n  const selectedDate = useMemo(() => (date.value ? new Date(date.value) : undefined), [date.value]);\n  const initialMonth = useMemo(() => {\n    const base = selectedDate ?? date.minDate;\n    return new Date(base.getFullYear(), base.getMonth(), 1);\n  }, [date.minDate, selectedDate]);\n  const initialMonthTime = initialMonth.getTime();\n\n  useEffect(() => {\n    if (!onMonthChange) {\n      return;\n    }\n    onMonthChange(new Date(initialMonthTime));\n  }, [initialMonthTime, onMonthChange]);\n\n  const enabledSuggestions = useMemo(\n    () => suggestions.filter((slot) => !slot.disabled),\n    [suggestions],\n  );\n  useEffect(() => {\n    setHasHydrated(true);\n  }, []);\n\n  const showSuggestions = hasHydrated && !isTimeDisabled && enabledSuggestions.length > 0;\n  const inputValue = time.value ?? '';\n  const resolvedUnavailableMessage =\n    unavailableMessage ?? 'No available times for the selected date.';\n\n  const disabledMatcher = useCallback(\n    (day?: Date) => {\n      if (!day) {\n        return false;\n      }\n      if (endOfDay(day) < date.minDate) {\n        return true;\n      }\n      const dayKey = formatDateForInput(day);\n      if (loadingDates?.has(dayKey)) {\n        // Prevent selection while availability for that day is still loading.\n        return true;\n      }\n      if (typeof isDateUnavailable === 'function') {\n        return isDateUnavailable(day);\n      }\n      return false;\n    },\n    [date.minDate, isDateUnavailable, loadingDates],\n  );\n\n  const calendarModifiers = useMemo(() => {\n    if (!loadingDates || loadingDates.size === 0) {\n      return undefined;\n    }\n\n    return {\n      loading: (day: Date) => loadingDates.has(formatDateForInput(day)),\n    } satisfies React.ComponentProps<typeof Calendar>['modifiers'];\n  }, [loadingDates]);\n\n  const calendarModifiersClassNames = useMemo(() => {\n    if (!loadingDates || loadingDates.size === 0) {\n      return undefined;\n    }\n\n    return {\n      loading:\n        'relative after:absolute after:left-1/2 after:top-1/2 after:h-1.5 after:w-1.5 after:-translate-x-1/2 after:-translate-y-1/2 after:rounded-full after:bg-primary after:animate-pulse',\n    } satisfies React.ComponentProps<typeof Calendar>['modifiersClassNames'];\n  }, [loadingDates]);\n\n  return (\n    <div className=\"flex flex-col gap-4 md:flex-row\">\n      <div className=\"flex flex-1 flex-col gap-3\">\n        <Label htmlFor={dateButtonId} className=\"px-1\">\n          Date\n        </Label>\n        <Popover open={open} onOpenChange={setOpen}>\n          <PopoverTrigger asChild>\n            <Button\n              id={dateButtonId}\n              variant=\"outline\"\n              className=\"w-full justify-between font-normal\"\n              aria-haspopup=\"dialog\"\n              aria-expanded={open}\n              aria-invalid={Boolean(date.error)}\n              aria-describedby={\n                [dateDescriptionId, dateErrorId].filter(Boolean).join(' ') || undefined\n              }\n            >\n              <span>{label}</span>\n              <ChevronDownIcon className=\"h-4 w-4\" aria-hidden />\n            </Button>\n          </PopoverTrigger>\n          <PopoverContent className=\"w-auto overflow-hidden p-0\" align=\"start\">\n            <Calendar\n              mode=\"single\"\n              selected={selectedDate}\n              defaultMonth={initialMonth}\n              fromDate={date.minDate}\n              onSelect={(next) => {\n                date.onSelect(next);\n                date.onBlur?.();\n                setOpen(false);\n              }}\n              onMonthChange={(month) => {\n                onMonthChange?.(month);\n              }}\n              disabled={disabledMatcher}\n              modifiers={calendarModifiers}\n              modifiersClassNames={calendarModifiersClassNames}\n              initialFocus\n            />\n          </PopoverContent>\n        </Popover>\n        <p id={dateDescriptionId} className=\"px-1 text-[0.8rem] text-muted-foreground\">\n          {DATE_DESCRIPTION}\n        </p>\n        {date.error ? (\n          <p id={dateErrorId} className=\"px-1 text-[0.8rem] font-medium text-destructive\">\n            {date.error}\n          </p>\n        ) : null}\n      </div>\n\n      <div className=\"flex flex-1 flex-col gap-3\">\n        <Label htmlFor={timeInputId} className=\"px-1\">\n          Time\n        </Label>\n        <div className=\"flex flex-col gap-2\">\n          <div className=\"relative\">\n            <Input\n              id={timeInputId}\n              type=\"time\"\n              value={inputValue}\n              step={timeStepSeconds}\n              onChange={(event) => {\n                if (isTimeDisabled) {\n                  return;\n                }\n                const value = event.target.value;\n                time.onChange(value, { commit: false });\n              }}\n              onBlur={(event) => {\n                if (isTimeDisabled) {\n                  time.onBlur?.();\n                  return;\n                }\n                time.onBlur?.();\n                time.onChange(event.target.value, { commit: true });\n              }}\n              aria-invalid={Boolean(time.error)}\n              aria-describedby={\n                [timeDescriptionId, timeErrorId].filter(Boolean).join(' ') || undefined\n              }\n              list={showSuggestions ? timeListId : undefined}\n              placeholder=\"--:--\"\n              className={cn(\n                'bg-background text-base font-normal appearance-none [&::-webkit-calendar-picker-indicator]:hidden [&::-webkit-calendar-picker-indicator]:appearance-none',\n                !inputValue ? 'text-foreground' : undefined,\n              )}\n              disabled={isTimeDisabled}\n            />\n            {!inputValue ? (\n              <span\n                aria-hidden=\"true\"\n                className={cn(\n                  'pointer-events-none absolute left-3 top-1/2 -translate-y-1/2 text-base text-muted-foreground transition-opacity',\n                  isTimeDisabled ? 'opacity-70' : 'opacity-100',\n                )}\n              >\n                --:--\n              </span>\n            ) : null}\n          </div>\n          {showSuggestions ? (\n            <datalist id={timeListId}>\n              {enabledSuggestions.map((slot) => (\n                <option\n                  key={slot.value}\n                  value={slot.value}\n                  label={`${slot.display}  ${slot.label}`}\n                />\n              ))}\n            </datalist>\n          ) : (\n            <p className=\"px-1 text-[0.8rem] text-muted-foreground\" aria-live=\"polite\">\n              {resolvedUnavailableMessage}\n            </p>\n          )}\n        </div>\n        <p id={timeDescriptionId} className=\"px-1 text-[0.8rem] text-muted-foreground\">\n          {TIME_DESCRIPTION}\n        </p>\n        {time.error ? (\n          <p id={timeErrorId} className=\"px-1 text-[0.8rem] font-medium text-destructive\">\n            {time.error}\n          </p>\n        ) : null}\n      </div>\n    </div>\n  );\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/steps/plan-step/components/index.ts",
      "category": "booking-wizard",
      "content": "export * from './Calendar24Field';\nexport * from './PartySizeField';\nexport * from './NotesField';\nexport * from './OccasionPicker';\nexport * from './TimeSlotGrid';\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/steps/plan-step/components/NotesField.tsx",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport React, { useMemo } from 'react';\n\nimport { FormControl, FormDescription, FormItem, FormLabel, FormMessage } from '@shared/ui/form';\nimport { Textarea } from '@shared/ui/textarea';\n\nconst DESCRIPTION = 'Optional. Share anything we should know before you arrive.';\nconst MAX_LENGTH = 500;\n\nexport type NotesFieldProps = {\n  value: string;\n  onChange: (value: string) => void;\n  onBlur?: (value: string) => void;\n  error?: string;\n};\n\nexport function NotesField({ value, onChange, onBlur, error }: NotesFieldProps) {\n  const lengthLabel = useMemo(() => `${value.length} / ${MAX_LENGTH}`, [value.length]);\n\n  return (\n    <FormItem className=\"space-y-3\">\n      <FormLabel htmlFor=\"notes\">Notes</FormLabel>\n      <FormControl>\n        <Textarea\n          id=\"notes\"\n          placeholder=\"Birthday, accessibility needs, allergies\"\n          value={value}\n          onChange={(event) => onChange(event.target.value)}\n          onBlur={(event) => {\n            onBlur?.(event.target.value);\n          }}\n          rows={4}\n          spellCheck\n        />\n      </FormControl>\n      <FormDescription>{DESCRIPTION}</FormDescription>\n      <div className=\"text-right text-xs text-srx-ink-soft\" aria-live=\"polite\">\n        {lengthLabel}\n      </div>\n      <FormMessage>{error}</FormMessage>\n    </FormItem>\n  );\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/steps/plan-step/components/OccasionPicker.tsx",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport React from 'react';\n\nimport { FormDescription, FormItem, FormLabel, FormMessage } from '@shared/ui/form';\nimport { ToggleGroup, ToggleGroupItem } from '@shared/ui/toggle-group';\n\nimport type { ServiceAvailability } from '@reserve/features/reservations/wizard/services';\nimport type { OccasionKey } from '@reserve/shared/occasions';\n\nconst DESCRIPTION = 'Let us know the occasion so we can tailor the experience.';\n\nexport type OccasionPickerOption = {\n  key: OccasionKey;\n  label: string;\n  description?: string | null;\n};\n\nexport type OccasionPickerProps = {\n  value: OccasionKey;\n  options: OccasionPickerOption[];\n  availability: ServiceAvailability;\n  availableOptions: OccasionKey[];\n  onChange: (value: OccasionKey) => void;\n  error?: string;\n};\n\nexport function OccasionPicker({\n  value,\n  options,\n  availability: _availability,\n  availableOptions,\n  onChange,\n  error,\n}: OccasionPickerProps) {\n  const allowed = React.useMemo(() => new Set(availableOptions), [availableOptions]);\n  const services = React.useMemo(\n    () => new Map(Object.entries(_availability.services)),\n    [_availability.services],\n  );\n\n  return (\n    <FormItem className=\"space-y-3\">\n      <FormLabel>Occasion</FormLabel>\n      <ToggleGroup\n        type=\"single\"\n        className=\"grid grid-cols-2 gap-2 sm:grid-cols-3\"\n        value={value}\n        onValueChange={(next) => {\n          if (next) onChange(next as OccasionKey);\n        }}\n      >\n        {options.map((option) => {\n          const serviceState = services.get(option.key) ?? 'disabled';\n          const enabled = allowed.has(option.key) && serviceState === 'enabled';\n          const ariaDisabled = !enabled;\n          return (\n            <ToggleGroupItem\n              key={option.key}\n              value={option.key}\n              aria-disabled={ariaDisabled}\n              disabled={ariaDisabled}\n              className=\"h-11\"\n            >\n              {option.label}\n            </ToggleGroupItem>\n          );\n        })}\n      </ToggleGroup>\n      <FormDescription>{DESCRIPTION}</FormDescription>\n      <FormMessage>{error}</FormMessage>\n    </FormItem>\n  );\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/steps/plan-step/components/PartySizeField.tsx",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport React from 'react';\n\nimport { Button } from '@shared/ui/button';\nimport { FormDescription, FormItem, FormLabel, FormMessage } from '@shared/ui/form';\n\nconst DESCRIPTION = 'Tables of more than 12? Call us and well help.';\n\nexport type PartySizeFieldProps = {\n  value: number;\n  onChange: (direction: 'decrement' | 'increment') => void;\n  error?: string;\n};\n\nexport function PartySizeField({ value, onChange, error }: PartySizeFieldProps) {\n  return (\n    <FormItem className=\"space-y-3\">\n      <FormLabel>Party size</FormLabel>\n      <div className=\"flex items-center gap-3\">\n        <Button\n          type=\"button\"\n          variant=\"outline\"\n          size=\"icon\"\n          onClick={() => onChange('decrement')}\n          aria-label=\"Decrease guests\"\n        >\n          -\n        </Button>\n        <div className=\"text-lg font-semibold\" aria-live=\"polite\">\n          {value}\n        </div>\n        <Button\n          type=\"button\"\n          variant=\"outline\"\n          size=\"icon\"\n          onClick={() => onChange('increment')}\n          aria-label=\"Increase guests\"\n        >\n          +\n        </Button>\n      </div>\n      <FormDescription>{DESCRIPTION}</FormDescription>\n      <FormMessage>{error}</FormMessage>\n    </FormItem>\n  );\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/steps/plan-step/components/TimeSlotGrid.tsx",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport React, { useEffect, useMemo, useRef } from 'react';\n\nimport { cn } from '@shared/lib/cn';\nimport { Badge } from '@shared/ui/badge';\n\nimport type { TimeSlotDescriptor } from '@reserve/features/reservations/wizard/services';\n\ntype TimeSlotGridProps = {\n  slots: TimeSlotDescriptor[];\n  value: string;\n  onSelect: (value: string) => void;\n  scrollToValue?: string | null;\n};\n\nfunction buildGroups(slots: TimeSlotDescriptor[]) {\n  const groups = new Map<string, TimeSlotDescriptor[]>();\n  slots.forEach((slot) => {\n    const existing = groups.get(slot.label);\n    if (existing) {\n      existing.push(slot);\n    } else {\n      groups.set(slot.label, [slot]);\n    }\n  });\n  return groups;\n}\n\nexport function TimeSlotGrid({ slots, value, onSelect, scrollToValue }: TimeSlotGridProps) {\n  const groupedSlots = useMemo(() => buildGroups(slots), [slots]);\n  const activeValue = value;\n  const containerRef = useRef<HTMLDivElement>(null);\n  const lastScrolledValueRef = useRef<string | null>(null);\n\n  useEffect(() => {\n    if (!scrollToValue) {\n      return;\n    }\n    if (lastScrolledValueRef.current === scrollToValue) {\n      return;\n    }\n    const container = containerRef.current;\n    if (!container) {\n      return;\n    }\n    const target = container.querySelector<HTMLElement>(`[data-slot-value=\"${scrollToValue}\"]`);\n    if (!target) {\n      return;\n    }\n    lastScrolledValueRef.current = scrollToValue;\n    target.scrollIntoView({ block: 'center', inline: 'center', behavior: 'smooth' });\n  }, [scrollToValue, slots]);\n\n  if (slots.length === 0) {\n    return null;\n  }\n\n  return (\n    <section\n      aria-label=\"Available times\"\n      className=\"flex flex-col gap-3 rounded-xl border border-border bg-card/80 p-4 shadow-sm\"\n      ref={containerRef}\n    >\n      <div className=\"flex items-center justify-between\">\n        <h3 className=\"text-sm font-semibold text-foreground\">Pick a time</h3>\n        <p className=\"text-xs text-muted-foreground\" aria-live=\"polite\">\n          Showing {slots.length} {slots.length === 1 ? 'option' : 'options'}\n        </p>\n      </div>\n      {[...groupedSlots.entries()].map(([label, entries]) => (\n        <div key={label} className=\"space-y-2\">\n          <div className=\"flex items-center gap-2\">\n            <h4 className=\"text-xs font-semibold uppercase tracking-[0.22em] text-muted-foreground\">\n              {label}\n            </h4>\n            {entries[0]?.availability.labels.happyHour ? (\n              <Badge variant=\"secondary\" className=\"text-[11px] font-medium\">\n                Happy hour\n              </Badge>\n            ) : null}\n            {entries[0]?.availability.labels.drinksOnly ? (\n              <Badge variant=\"outline\" className=\"text-[11px] font-medium\">\n                Drinks only\n              </Badge>\n            ) : null}\n          </div>\n          <div className=\"grid grid-cols-2 gap-2 sm:grid-cols-3 lg:grid-cols-4\">\n            {entries.map((slot) => {\n              const isActive = slot.value === activeValue;\n              return (\n                <button\n                  key={slot.value}\n                  type=\"button\"\n                  className={cn(\n                    'flex h-12 items-center justify-center rounded-lg border text-sm font-semibold transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background',\n                    'touch-manipulation',\n                    slot.disabled\n                      ? 'cursor-not-allowed border-border/60 bg-muted text-muted-foreground'\n                      : isActive\n                        ? 'border-primary bg-primary text-primary-foreground hover:bg-primary/90'\n                        : 'border-border bg-card hover:border-primary/60 hover:bg-primary/10',\n                  )}\n                  aria-pressed={isActive}\n                  aria-label={`${slot.display}, ${label}`}\n                  disabled={slot.disabled}\n                  onClick={() => onSelect(slot.value)}\n                  data-slot-value={slot.value}\n                  style={{ WebkitTapHighlightColor: 'rgba(0,0,0,0)', touchAction: 'manipulation' }}\n                >\n                  {slot.display}\n                </button>\n              );\n            })}\n          </div>\n        </div>\n      ))}\n    </section>\n  );\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/steps/plan-step/PlanStepForm.tsx",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport { AlertCircle } from 'lucide-react';\nimport React, { useCallback, useMemo } from 'react';\nimport { useController, useWatch } from 'react-hook-form';\n\nimport { formatDateForInput } from '@reserve/shared/formatting/booking';\nimport { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from '@shared/ui/accordion';\nimport { Alert, AlertDescription, AlertIcon } from '@shared/ui/alert';\nimport { Form, FormField } from '@shared/ui/form';\n\nimport {\n  Calendar24Field,\n  NotesField,\n  OccasionPicker,\n  PartySizeField,\n  TimeSlotGrid,\n} from './components';\nimport { usePlanStepForm } from '../../../hooks/usePlanStepForm';\n\nimport type { PlanStepFormProps, PlanStepFormState } from './types';\n\ntype PlanStepFormContentProps = {\n  state: PlanStepFormState;\n};\n\nconst UNKNOWN_AVAILABILITY_COPY = 'Schedule not loaded yetscroll to load month.';\n\nfunction PlanStepFormContent({ state }: PlanStepFormContentProps) {\n  const { control, formState, handleSubmit, getValues } = state.form;\n  const {\n    field: dateField,\n    fieldState: { error: dateFieldError },\n  } = useController({ name: 'date', control });\n  const {\n    field: timeField,\n    fieldState: { error: timeFieldError },\n  } = useController({ name: 'time', control });\n  const bookingTypeValue = useWatch({ name: 'bookingType', control });\n  const notesValue = useWatch({ name: 'notes', control });\n\n  const occasionOptions = React.useMemo(\n    () =>\n      state.occasionCatalog.map((definition) => ({\n        key: definition.key,\n        label: definition.shortLabel ?? definition.label,\n        description: definition.description ?? null,\n      })),\n    [state.occasionCatalog],\n  );\n\n  const selectedOccasionLabel = React.useMemo(() => {\n    const match = occasionOptions.find((option) => option.key === bookingTypeValue);\n    if (match) {\n      return match.label;\n    }\n    if (bookingTypeValue) {\n      return bookingTypeValue.replace(/\\b\\w/g, (char) => char.toUpperCase());\n    }\n    return undefined;\n  }, [bookingTypeValue, occasionOptions]);\n\n  const isDateUnavailable = useCallback(\n    (day: Date) => {\n      const key = formatDateForInput(day);\n      const reason = state.unavailableDates.get(key) ?? null;\n      return reason === 'closed' || reason === 'no-slots';\n    },\n    [state.unavailableDates],\n  );\n\n  const timeDisabled =\n    state.currentUnavailabilityReason === 'closed' ||\n    state.currentUnavailabilityReason === 'no-slots';\n\n  const unavailableCopy = useMemo(() => {\n    switch (state.currentUnavailabilityReason) {\n      case 'closed':\n        return 'Were closed on this date. Please choose a different day.';\n      case 'no-slots':\n        return 'All reservation times are taken on this date. Please choose a different day.';\n      case 'unknown':\n        return UNKNOWN_AVAILABILITY_COPY;\n      default:\n        return null;\n    }\n  }, [state.currentUnavailabilityReason]);\n\n  const accordionSummary = useMemo(() => {\n    const selectedSlot = state.slots.find((slot) => slot.value === timeField.value);\n    const timeSummary = timeField.value\n      ? `Time: ${selectedSlot?.display ?? timeField.value}`\n      : 'Time not selected';\n\n    const label = selectedOccasionLabel;\n    const hasNotes = Boolean(notesValue?.trim()?.length);\n\n    const parts = [timeSummary];\n\n    if (label) {\n      parts.push(`Occasion: ${label}`);\n    }\n\n    if (hasNotes) {\n      parts.push('Notes added');\n    }\n\n    if (!label && !hasNotes) {\n      parts.push('Occasion or notes optional');\n    }\n\n    return parts.join('  ');\n  }, [notesValue, selectedOccasionLabel, state.slots, timeField.value]);\n\n  return (\n    <form\n      className=\"space-y-8\"\n      onSubmit={handleSubmit(state.submitForm, state.handleError)}\n      noValidate\n    >\n      <button type=\"submit\" className=\"hidden\" aria-hidden />\n      <div className=\"grid gap-6 md:grid-cols-2\">\n        <Calendar24Field\n          date={{\n            value: dateField.value,\n            minDate: state.minDate,\n            onSelect: (next) => {\n              state.handlers.selectDate(next);\n            },\n            onBlur: dateField.onBlur,\n            error: dateFieldError?.message ?? formState.errors.date?.message,\n          }}\n          time={{\n            value: timeField.value,\n            onChange: (next, options) => {\n              state.handlers.selectTime(next, options);\n            },\n            onBlur: () => {\n              timeField.onBlur?.();\n              state.handlers.selectTime(getValues('time'), { commit: true });\n            },\n            error: timeFieldError?.message ?? formState.errors.time?.message,\n          }}\n          suggestions={state.slots}\n          intervalMinutes={state.intervalMinutes ?? undefined}\n          isDateUnavailable={isDateUnavailable}\n          isTimeDisabled={timeDisabled}\n          unavailableMessage={unavailableCopy ?? undefined}\n          onMonthChange={state.handlers.prefetchMonth}\n          loadingDates={state.loadingDates}\n        />\n\n        <FormField\n          control={control}\n          name=\"party\"\n          render={({ field }) => (\n            <PartySizeField\n              value={field.value}\n              onChange={state.handlers.changeParty}\n              error={formState.errors.party?.message}\n            />\n          )}\n        />\n      </div>\n\n      {unavailableCopy ? (\n        <Alert variant=\"warning\" className=\"border border-dashed\">\n          <AlertIcon>\n            <AlertCircle className=\"h-4 w-4\" aria-hidden />\n          </AlertIcon>\n          <AlertDescription>{unavailableCopy}</AlertDescription>\n        </Alert>\n      ) : null}\n\n      <Accordion\n        type=\"single\"\n        collapsible\n        className=\"overflow-hidden rounded-xl border border-border bg-card text-card-foreground\"\n      >\n        <AccordionItem value=\"details\">\n          <AccordionTrigger>\n            <span className=\"flex flex-col text-left\">\n              <span className=\"text-base font-semibold text-foreground\">\n                Time, occasion & notes\n              </span>\n              <span className=\"text-sm font-normal text-muted-foreground\">{accordionSummary}</span>\n            </span>\n          </AccordionTrigger>\n          <AccordionContent>\n            <div className=\"space-y-6 pt-4\">\n              <TimeSlotGrid\n                slots={timeDisabled ? [] : state.slots}\n                value={timeField.value}\n                onSelect={(next) => {\n                  state.handlers.selectTime(next);\n                  timeField.onBlur?.();\n                }}\n              />\n              <FormField\n                control={control}\n                name=\"bookingType\"\n                render={({ field }) => (\n                  <OccasionPicker\n                    value={field.value}\n                    options={occasionOptions}\n                    onChange={state.handlers.changeOccasion}\n                    availability={state.availability}\n                    availableOptions={state.availableBookingOptions}\n                    error={formState.errors.bookingType?.message}\n                  />\n                )}\n              />\n\n              <FormField\n                control={control}\n                name=\"notes\"\n                render={({ field }) => (\n                  <NotesField\n                    value={field.value ?? ''}\n                    onChange={(next) => {\n                      field.onChange(next);\n                    }}\n                    onBlur={(next) => {\n                      field.onBlur();\n                      state.handlers.commitNotes(next);\n                    }}\n                    error={formState.errors.notes?.message}\n                  />\n                )}\n              />\n            </div>\n          </AccordionContent>\n        </AccordionItem>\n      </Accordion>\n    </form>\n  );\n}\n\nexport function PlanStepForm(props: PlanStepFormProps) {\n  const state = usePlanStepForm(props);\n\n  return (\n    <Form {...state.form}>\n      <PlanStepFormContent state={state} />\n    </Form>\n  );\n}\n\nexport type { PlanStepFormProps } from './types';\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/steps/plan-step/types.ts",
      "category": "booking-wizard",
      "content": "import type { State, StepAction } from '../../../model/reducer';\nimport type { PlanFormValues } from '../../../model/schemas';\nimport type { WizardActions } from '../../../model/store';\nimport type {\n  ReservationSchedule,\n  ServiceAvailability,\n  TimeSlotDescriptor,\n} from '@reserve/features/reservations/wizard/services';\nimport type { CalendarMask } from '@reserve/features/reservations/wizard/services/schedule';\nimport type { BookingOption } from '@reserve/shared/booking';\nimport type { OccasionDefinition } from '@reserve/shared/occasions';\nimport type { AnalyticsEvent } from '@shared/lib/analytics';\nimport type { UseFormReturn } from 'react-hook-form';\n\nexport interface PlanStepFormProps {\n  /**\n   * Legacy hooks/tests can provide explicit state/actions. Wizard context is used when omitted.\n   */\n  state?: State;\n  actions?: Pick<WizardActions, 'updateDetails' | 'goToStep'>;\n  onActionsChange: (actions: StepAction[]) => void;\n  onTrack?: (event: AnalyticsEvent, payload?: Record<string, unknown>) => void;\n  minDate: Date;\n  initialCalendarMask?: CalendarMask | null;\n}\n\nexport type PlanStepFormHandlers = {\n  selectDate: (value: Date | undefined | null) => void;\n  selectTime: (value: string, options?: { commit?: boolean }) => void;\n  changeParty: (direction: 'decrement' | 'increment') => void;\n  changeOccasion: (value: BookingOption) => void;\n  commitNotes: (value: string) => void;\n  prefetchMonth: (month: Date) => void;\n};\n\nexport type PlanStepUnavailableReason = 'closed' | 'no-slots' | 'unknown';\n\nexport type PlanStepFormState = {\n  form: UseFormReturn<PlanFormValues>;\n  slots: TimeSlotDescriptor[];\n  availability: ServiceAvailability;\n  availableBookingOptions: BookingOption[];\n  occasionCatalog: OccasionDefinition[];\n  handlers: PlanStepFormHandlers;\n  minDate: Date;\n  intervalMinutes: number | null;\n  unavailableDates: Map<string, PlanStepUnavailableReason>;\n  loadingDates: Set<string>;\n  hasAvailableSlots: boolean;\n  isScheduleLoading: boolean;\n  schedule: ReservationSchedule | null;\n  currentUnavailabilityReason: PlanStepUnavailableReason | null;\n  isSubmitting: boolean;\n  isValid: boolean;\n  submitForm: (values: PlanFormValues) => void;\n  handleError: (errors: Record<string, unknown>) => void;\n};\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/steps/PlanStep.tsx",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport { AlertTriangle } from 'lucide-react';\nimport React, { useMemo } from 'react';\n\nimport { Alert, AlertDescription, AlertIcon } from '@shared/ui/alert';\n\nimport { useWizardActions, useWizardState } from '../../context/WizardContext';\nimport { StepErrorBoundary } from '../ErrorBoundary';\nimport { WizardStep } from '../WizardStep';\nimport { PlanStepForm } from './plan-step/PlanStepForm';\n\nimport type { StepAction } from '../../model/reducer';\nimport type { CalendarMask } from '@reserve/features/reservations/wizard/services/schedule';\nimport type { AnalyticsEvent } from '@shared/lib/analytics';\n\nfunction getMinSelectableDate(timezone: string | null | undefined) {\n  const now = new Date();\n\n  if (!timezone) {\n    now.setHours(0, 0, 0, 0);\n    return now;\n  }\n\n  try {\n    const formatter = new Intl.DateTimeFormat('en-CA', {\n      timeZone: timezone,\n      year: 'numeric',\n      month: '2-digit',\n      day: '2-digit',\n    });\n    const parts = formatter.formatToParts(now);\n    const year = Number.parseInt(parts.find((part) => part.type === 'year')?.value ?? '', 10);\n    const month = Number.parseInt(parts.find((part) => part.type === 'month')?.value ?? '', 10);\n    const day = Number.parseInt(parts.find((part) => part.type === 'day')?.value ?? '', 10);\n\n    if (Number.isFinite(year) && Number.isFinite(month) && Number.isFinite(day)) {\n      return new Date(year, month - 1, day, 0, 0, 0, 0);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn('[plan-step] failed to derive timezone-adjusted min date', {\n        timezone,\n        error,\n      });\n    }\n  }\n\n  now.setHours(0, 0, 0, 0);\n  return now;\n}\n\nconst TITLE = 'Plan your visit';\nconst DESCRIPTION =\n  'Choose a date, time, party size, and any preferences. Well show the best options available.';\n\nexport interface PlanStepProps {\n  onActionsChange: (actions: StepAction[]) => void;\n  onTrack?: (event: AnalyticsEvent, payload?: Record<string, unknown>) => void;\n  planAlert?: string | null;\n  initialCalendarMask?: CalendarMask | null;\n}\n\nexport function PlanStep({\n  onActionsChange,\n  onTrack,\n  planAlert,\n  initialCalendarMask,\n}: PlanStepProps) {\n  const state = useWizardState();\n  const actions = useWizardActions();\n  const minSelectableDate = useMemo(() => {\n    return getMinSelectableDate(state.details.restaurantTimezone);\n  }, [state.details.restaurantTimezone]);\n\n  const alertMessage = planAlert ?? state.error;\n\n  return (\n    <StepErrorBoundary\n      stepName=\"Plan your visit\"\n      onReset={() => {\n        actions.goToStep(1);\n      }}\n    >\n      <WizardStep step={1} title={TITLE} description={DESCRIPTION}>\n        {alertMessage ? (\n          <Alert variant=\"destructive\" role=\"alert\" className=\"items-start\">\n            <AlertIcon>\n              <AlertTriangle className=\"h-4 w-4\" aria-hidden />\n            </AlertIcon>\n            <AlertDescription>{alertMessage}</AlertDescription>\n          </Alert>\n        ) : null}\n        <PlanStepForm\n          onActionsChange={onActionsChange}\n          onTrack={onTrack}\n          minDate={minSelectableDate}\n          initialCalendarMask={initialCalendarMask}\n        />\n      </WizardStep>\n    </StepErrorBoundary>\n  );\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/steps/review-step/types.ts",
      "category": "booking-wizard",
      "content": "import type { State, StepAction } from '../../../model/reducer';\nimport type { WizardActions } from '../../../model/store';\n\nexport interface ReviewStepProps {\n  state?: State;\n  actions?: Pick<WizardActions, 'goToStep'>;\n  onConfirm: () => void | Promise<void>;\n  onActionsChange: (actions: StepAction[]) => void;\n}\n\nexport type ReviewSummary = {\n  summaryValue: string;\n  summaryDate: string;\n  summaryTime: string;\n  partyText: string;\n};\n\nexport type ReviewStepController = {\n  details: State['details'];\n  summary: ReviewSummary;\n  isSubmitting: boolean;\n  error: State['error'];\n  handleEdit: () => void;\n  handleConfirm: () => void;\n};\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/steps/ReviewStep.tsx",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport { AlertTriangle } from 'lucide-react';\nimport React from 'react';\n\nimport { useReviewStep } from '@features/reservations/wizard/hooks/useReviewStep';\nimport { formatBookingLabel } from '@reserve/shared/formatting/booking';\nimport { Alert, AlertDescription, AlertIcon } from '@shared/ui/alert';\n\nimport { useWizardNavigation } from '../../context/WizardContext';\nimport { StepErrorBoundary } from '../ErrorBoundary';\nimport { WizardStep } from '../WizardStep';\n\nimport type { ReviewStepProps } from './review-step/types';\n\nexport function ReviewStep(props: ReviewStepProps) {\n  const { details, summary, error } = useReviewStep(props);\n  const { goToStep } = useWizardNavigation();\n\n  return (\n    <StepErrorBoundary\n      stepName=\"Review and confirm\"\n      onReset={() => {\n        goToStep(3);\n      }}\n    >\n      <WizardStep\n        step={3}\n        title=\"Review and confirm\"\n        description=\"Double-check the details below. You can edit any section before confirming.\"\n        contentClassName=\"space-y-4\"\n      >\n        <div className=\"space-y-4\">\n          <p className=\"sr-only\" aria-live=\"polite\">\n            {`Review details for ${summary.summaryValue}. Press confirm to finalise your reservation.`}\n          </p>\n          {error ? (\n            <Alert variant=\"destructive\" role=\"alert\" className=\"items-start\">\n              <AlertIcon>\n                <AlertTriangle className=\"h-4 w-4\" aria-hidden />\n              </AlertIcon>\n              <AlertDescription>{error}</AlertDescription>\n            </Alert>\n          ) : null}\n          <dl className=\"grid gap-4 rounded-2xl border border-border bg-card p-5 shadow-sm sm:grid-cols-2 lg:grid-cols-3\">\n            <div className=\"space-y-1\">\n              <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">Summary</dt>\n              <dd className=\"text-sm font-semibold text-foreground\">{summary.summaryValue}</dd>\n            </div>\n            <div className=\"space-y-1\">\n              <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">Venue</dt>\n              <dd className=\"text-sm font-medium text-foreground\">{details.restaurantName}</dd>\n            </div>\n            <div className=\"space-y-1\">\n              <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">\n                Party size\n              </dt>\n              <dd className=\"text-sm font-medium text-foreground\">\n                {details.party} {details.party === 1 ? 'guest' : 'guests'}\n              </dd>\n            </div>\n            <div className=\"space-y-1\">\n              <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">\n                Full name\n              </dt>\n              <dd className=\"text-sm font-medium text-foreground\">{details.name}</dd>\n            </div>\n            <div className=\"space-y-1\">\n              <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">Email</dt>\n              <dd className=\"text-sm font-medium text-foreground\">{details.email}</dd>\n            </div>\n            <div className=\"space-y-1\">\n              <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">Phone</dt>\n              <dd className=\"text-sm font-medium text-foreground\">{details.phone}</dd>\n            </div>\n            <div className=\"space-y-1\">\n              <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">\n                Booking type\n              </dt>\n              <dd className=\"text-sm font-medium text-foreground\">\n                {formatBookingLabel(details.bookingType)}\n              </dd>\n            </div>\n            <div className=\"space-y-1\">\n              <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">\n                Marketing updates\n              </dt>\n              <dd className=\"text-sm font-medium text-foreground\">\n                {details.marketingOptIn ? 'Subscribed' : 'Not subscribed'}\n              </dd>\n            </div>\n            {details.notes ? (\n              <div className=\"space-y-1 sm:col-span-2\">\n                <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">Notes</dt>\n                <dd className=\"text-sm text-muted-foreground\">{details.notes}</dd>\n              </div>\n            ) : null}\n          </dl>\n        </div>\n      </WizardStep>\n    </StepErrorBoundary>\n  );\n}\n\nexport type { ReviewStepProps } from './review-step/types';\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/StepSummary.tsx",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport * as React from 'react';\n\nimport { cn } from '@shared/lib/cn';\n\nimport type { WizardSummary } from './WizardProgress';\n\nexport interface StepSummaryProps {\n  summary: WizardSummary;\n  className?: string;\n  layout?: 'stacked' | 'inline';\n}\n\nexport function StepSummary({ summary, className, layout = 'stacked' }: StepSummaryProps) {\n  const details = summary.details ?? [];\n  const primary = summary.primary?.trim() || 'Select your date';\n  const detailText = details.filter(Boolean).join('  ');\n\n  return (\n    <div\n      className={cn(\n        'min-w-0 text-foreground',\n        layout === 'inline'\n          ? 'flex flex-col gap-0.5 sm:items-end sm:text-right'\n          : 'flex flex-col gap-0.5',\n        className,\n      )}\n      aria-live=\"polite\"\n    >\n      <p className=\"truncate text-base font-semibold sm:text-lg\" title={primary}>\n        {primary}\n      </p>\n      {detailText ? (\n        <p\n          className=\"text-sm text-muted-foreground sm:text-base\"\n          style={{\n            display: '-webkit-box',\n            WebkitLineClamp: 2,\n            WebkitBoxOrient: 'vertical',\n            overflow: 'hidden',\n          }}\n        >\n          {detailText}\n        </p>\n      ) : null}\n    </div>\n  );\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/WizardContainer.tsx",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport * as React from 'react';\n\nimport { WizardLayout, type WizardHeroRef } from './WizardLayout';\nimport { WizardNavigation } from './WizardNavigation';\n\nimport type { WizardStepMeta, WizardSummary } from './WizardProgress';\nimport type { StepAction } from '../model/reducer';\n\ntype WizardContextValue = {\n  steps: WizardStepMeta[];\n  currentStep: number;\n  totalSteps: number;\n};\n\nconst WizardContext = React.createContext<WizardContextValue | null>(null);\n\nexport interface WizardContainerProps {\n  steps: WizardStepMeta[];\n  currentStep: number;\n  actions: StepAction[];\n  summary: WizardSummary;\n  heroRef?: WizardHeroRef;\n  stickyHeight?: number;\n  stickyVisible?: boolean;\n  onStickyHeightChange?: (height: number) => void;\n  banner?: React.ReactNode;\n  children: React.ReactNode;\n  layoutElement?: 'main' | 'div';\n}\n\nexport function WizardContainer({\n  steps,\n  currentStep,\n  actions,\n  summary,\n  heroRef,\n  stickyHeight = 0,\n  stickyVisible = false,\n  onStickyHeightChange,\n  banner,\n  children,\n  layoutElement = 'main',\n}: WizardContainerProps) {\n  const totalSteps = steps.length || 1;\n  const clampedStep = Math.min(Math.max(currentStep, 1), totalSteps);\n\n  const providerValue = React.useMemo<WizardContextValue>(\n    () => ({ steps, currentStep: clampedStep, totalSteps }),\n    [steps, clampedStep, totalSteps],\n  );\n\n  const srAnnouncement = React.useMemo(() => {\n    const summaryText =\n      summary.srLabel ?? `${summary.primary}. ${summary.details?.join(', ') ?? ''}`;\n    return `Step ${clampedStep} of ${totalSteps}. ${summaryText}`;\n  }, [clampedStep, summary.details, summary.primary, summary.srLabel, totalSteps]);\n\n  return (\n    <WizardContext.Provider value={providerValue}>\n      <WizardLayout\n        heroRef={heroRef}\n        stickyHeight={stickyHeight}\n        stickyVisible={stickyVisible}\n        banner={banner}\n        elementType={layoutElement}\n        footer={\n          <WizardNavigation\n            steps={steps}\n            currentStep={clampedStep}\n            summary={summary}\n            actions={actions}\n            visible={stickyVisible}\n            onHeightChange={onStickyHeightChange}\n          />\n        }\n      >\n        <div className=\"sr-only\" aria-live=\"polite\">\n          {srAnnouncement}\n        </div>\n        {children}\n      </WizardLayout>\n    </WizardContext.Provider>\n  );\n}\n\nexport function useWizardContext() {\n  const context = React.useContext(WizardContext);\n  if (!context) {\n    return { steps: [], currentStep: 1, totalSteps: 1 } as WizardContextValue;\n  }\n  return context;\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/wizardIcons.ts",
      "category": "booking-wizard",
      "content": "import {\n  Calendar,\n  Check,\n  CheckCircle2,\n  ChevronDown,\n  ChevronLeft,\n  ChevronRight,\n  Clock3,\n  Edit3,\n  Info,\n  Loader2,\n  Plus,\n  UserRound,\n  Wallet,\n  X,\n} from 'lucide-react';\n\nimport { runtime } from '@shared/config/runtime';\n\nimport type { LucideIcon } from 'lucide-react';\n\nconst ICONS: Record<string, LucideIcon> = {\n  Calendar,\n  Check,\n  CheckCircle: CheckCircle2,\n  CheckCircle2,\n  ChevronDown,\n  ChevronLeft,\n  ChevronRight,\n  Clock: Clock3,\n  Info,\n  Loader2,\n  Pencil: Edit3,\n  Plus,\n  Spinner: Loader2,\n  User: UserRound,\n  Wallet,\n  X,\n};\n\nexport function resolveWizardIcon(name?: string | null): LucideIcon | null {\n  if (!name) return null;\n  const IconComponent = ICONS[name];\n  if (!IconComponent) {\n    if (runtime.isDev) {\n      console.warn(`[wizardIcons] Missing icon mapping for \"${name}\".`);\n    }\n    return null;\n  }\n  return IconComponent;\n}\n\nexport const defaultActionIcon = Loader2;\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/WizardLayout.tsx",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport * as React from 'react';\n\nimport { cn } from '@shared/lib/cn';\n\nexport type WizardHeroRef =\n  | React.RefObject<HTMLSpanElement | null>\n  | React.MutableRefObject<HTMLSpanElement | null>;\n\ninterface WizardLayoutProps {\n  heroRef?: WizardHeroRef;\n  stickyHeight?: number;\n  stickyVisible?: boolean;\n  banner?: React.ReactNode;\n  children: React.ReactNode;\n  footer?: React.ReactNode;\n  elementType?: 'main' | 'div';\n}\n\nexport function WizardLayout({\n  heroRef,\n  stickyHeight = 0,\n  stickyVisible = false,\n  banner,\n  children,\n  footer,\n  elementType = 'main',\n}: WizardLayoutProps) {\n  const mainStyle = stickyVisible\n    ? {\n        paddingBottom: `calc(${stickyHeight}px + env(safe-area-inset-bottom, 0px) + 1.5rem)`,\n      }\n    : undefined;\n\n  const Container = elementType === 'div' ? 'div' : 'main';\n\n  return (\n    <>\n      <Container\n        style={mainStyle}\n        className={cn(\n          'min-h-screen w-full bg-muted/[0.15] px-4 pb-20 pt-6 font-sans text-foreground transition-[padding-bottom] duration-200 sm:pt-12 md:px-6 lg:px-10',\n        )}\n      >\n        <div className=\"mx-auto flex w-full max-w-5xl flex-col gap-10 sm:gap-12\">\n          <span ref={heroRef} aria-hidden className=\"block h-px w-full\" />\n          {banner ? <div>{banner}</div> : null}\n          {children}\n        </div>\n      </Container>\n      {footer}\n    </>\n  );\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/WizardNavigation.tsx",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport { Loader2 } from 'lucide-react';\nimport * as React from 'react';\n\nimport { cn } from '@shared/lib/cn';\nimport { Button } from '@shared/ui/button';\nimport { Separator } from '@shared/ui/separator';\n\nimport { StepSummary } from './StepSummary';\nimport { resolveWizardIcon } from './wizardIcons';\nimport { WizardProgress, type WizardStepMeta, type WizardSummary } from './WizardProgress';\n\nimport type { StepAction } from '../model/reducer';\n\ntype ActionRole = 'primary' | 'secondary' | 'support';\n\nexport interface WizardNavigationProps {\n  steps: WizardStepMeta[];\n  currentStep: number;\n  summary: WizardSummary;\n  actions: StepAction[];\n  visible?: boolean;\n  onHeightChange?: (height: number) => void;\n  className?: string;\n}\n\nexport function WizardNavigation({\n  steps,\n  currentStep,\n  summary,\n  actions,\n  visible = true,\n  onHeightChange,\n  className,\n}: WizardNavigationProps) {\n  const containerRef = React.useRef<HTMLDivElement | null>(null);\n\n  React.useLayoutEffect(() => {\n    if (!onHeightChange) return;\n    const node = containerRef.current;\n    if (!node) {\n      onHeightChange(0);\n      return;\n    }\n\n    const updateHeight = () => {\n      onHeightChange(visible ? node.getBoundingClientRect().height : 0);\n    };\n\n    updateHeight();\n    const resizeObserver = new ResizeObserver(updateHeight);\n    resizeObserver.observe(node);\n\n    return () => {\n      resizeObserver.disconnect();\n      onHeightChange(0);\n    };\n  }, [onHeightChange, visible]);\n\n  React.useEffect(() => {\n    if (onHeightChange && !visible) {\n      onHeightChange(0);\n    }\n  }, [onHeightChange, visible]);\n\n  if (!visible) {\n    return null;\n  }\n\n  const { primary, secondary, support } = groupActions(actions);\n\n  return (\n    <div\n      className={cn(\n        'pointer-events-none fixed inset-x-0 bottom-0 z-50 px-3 pb-[calc(env(safe-area-inset-bottom,0px)+0.5rem)] sm:px-4 lg:px-10',\n        className,\n      )}\n      aria-hidden={false}\n    >\n      <nav\n        ref={containerRef}\n        className=\"pointer-events-auto mx-auto flex w-full max-w-5xl flex-col overflow-hidden rounded-3xl border border-[color:var(--color-border)] bg-[color:var(--color-surface,#ffffff)]/98 text-foreground shadow-card backdrop-blur supports-[backdrop-filter]:backdrop-blur-lg\"\n        aria-label=\"Wizard navigation\"\n      >\n        <div className=\"flex flex-col gap-3 px-3 py-3 sm:px-5 sm:py-4\">\n          <div className=\"flex flex-col gap-3 md:flex-row md:items-start md:justify-between\">\n            <WizardProgress\n              steps={steps}\n              currentStep={currentStep}\n              summary={summary}\n              className=\"md:flex-1\"\n            />\n            <StepSummary summary={summary} className=\"md:max-w-sm\" layout=\"inline\" />\n          </div>\n\n          <Separator className=\"my-1 bg-[color:var(--color-border)]\" decorative />\n\n          <div className=\"flex flex-col gap-3 sm:flex-row sm:items-center sm:justify-between\">\n            <div\n              className=\"flex flex-col gap-2 sm:flex-row sm:flex-wrap\"\n              aria-label=\"Secondary actions\"\n            >\n              {secondary.map((action) => renderActionButton(action, 'secondary'))}\n            </div>\n            {primary.length > 0 ? (\n              <div\n                className=\"flex flex-col gap-2 sm:flex-row sm:justify-end sm:gap-3\"\n                aria-label=\"Primary actions\"\n              >\n                {primary.map((action) => renderActionButton(action, 'primary'))}\n              </div>\n            ) : null}\n          </div>\n\n          {support.length > 0 ? (\n            <div\n              className=\"flex flex-wrap gap-2 border-t border-dashed border-[color:var(--color-border)] pt-3\"\n              aria-label=\"Additional actions\"\n            >\n              {support.map((action) => renderActionButton(action, 'support'))}\n            </div>\n          ) : null}\n        </div>\n      </nav>\n    </div>\n  );\n}\n\nfunction groupActions(actions: StepAction[]) {\n  const grouped = {\n    primary: [] as StepAction[],\n    secondary: [] as StepAction[],\n    support: [] as StepAction[],\n  } satisfies Record<ActionRole, StepAction[]>;\n\n  actions.forEach((action, index) => {\n    const fallbackRole: ActionRole = index === actions.length - 1 ? 'primary' : 'secondary';\n    const role = (action.role as ActionRole) ?? fallbackRole;\n    if (role === 'primary' || role === 'secondary' || role === 'support') {\n      grouped[role].push(action);\n      return;\n    }\n    grouped.support.push(action);\n  });\n\n  if (grouped.primary.length === 0 && grouped.secondary.length > 0) {\n    grouped.primary.push(grouped.secondary.pop() as StepAction);\n  }\n\n  return grouped;\n}\n\nfunction renderActionButton(action: StepAction, role: ActionRole) {\n  const IconComponent = action.icon ? resolveWizardIcon(action.icon) : null;\n  const isPrimary = role === 'primary';\n  const isSupport = role === 'support';\n\n  const variant =\n    action.variant ?? (isPrimary ? 'default' : role === 'secondary' ? 'outline' : 'ghost');\n  const sizingClass = cn(\n    'min-h-[44px] rounded-2xl text-base font-semibold transition-transform focus-visible:ring-2 focus-visible:ring-ring/60',\n    isPrimary ? 'w-full sm:w-auto px-6 shadow-sm' : 'w-full sm:w-auto px-4',\n    isSupport && 'text-sm font-medium',\n    action.fullWidth === false && 'w-auto',\n  );\n\n  const ariaLabel = action.ariaLabel ?? action.srLabel ?? action.label;\n\n  return (\n    <Button\n      key={action.id}\n      variant={variant}\n      size=\"lg\"\n      onClick={action.onClick}\n      disabled={action.disabled || action.loading}\n      aria-label={ariaLabel}\n      className={sizingClass}\n      data-testid={`wizard-action-${action.id}`}\n    >\n      {action.loading ? (\n        <Loader2 className=\"h-4 w-4 animate-spin\" aria-hidden />\n      ) : IconComponent ? (\n        <IconComponent className=\"h-4 w-4\" aria-hidden />\n      ) : null}\n      <span className=\"truncate\">{action.label}</span>\n    </Button>\n  );\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/WizardOfflineBanner.tsx",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport { WifiOff } from 'lucide-react';\nimport React, { forwardRef } from 'react';\n\nimport { Alert, AlertDescription, AlertIcon, AlertTitle } from '@shared/ui/alert';\n\nexport type WizardOfflineBannerProps = {\n  title?: string;\n  description?: string;\n};\n\nexport const WizardOfflineBanner = forwardRef<HTMLDivElement, WizardOfflineBannerProps>(\n  (\n    {\n      title = 'Youre offline',\n      description = 'Well keep your selections safe, but confirmation actions are disabled until you reconnect.',\n    },\n    ref,\n  ) => (\n    <Alert\n      ref={ref}\n      variant=\"warning\"\n      role=\"status\"\n      aria-live=\"polite\"\n      tabIndex={-1}\n      className=\"items-start\"\n    >\n      <AlertIcon>\n        <WifiOff className=\"h-5 w-5\" aria-hidden />\n      </AlertIcon>\n      <div className=\"flex flex-col gap-1\">\n        <AlertTitle>{title}</AlertTitle>\n        <AlertDescription>{description}</AlertDescription>\n      </div>\n    </Alert>\n  ),\n);\n\nWizardOfflineBanner.displayName = 'WizardOfflineBanner';\n\nexport default WizardOfflineBanner;\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/WizardProgress.tsx",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport * as React from 'react';\n\nimport { cn } from '@shared/lib/cn';\nimport { Progress } from '@shared/ui/progress';\n\nexport interface WizardStepMeta {\n  id: number;\n  label: string;\n  helper?: string;\n}\n\nexport interface WizardSummary {\n  primary: string;\n  details?: string[];\n  srLabel?: string;\n}\n\ninterface WizardProgressProps {\n  steps: WizardStepMeta[];\n  currentStep: number;\n  summary: WizardSummary;\n  className?: string;\n}\n\nexport function WizardProgress({ steps, currentStep, summary, className }: WizardProgressProps) {\n  const total = steps.length || 1;\n  const clampedCurrent = Math.min(Math.max(currentStep, 1), total);\n  const progressValue = total <= 1 ? 100 : ((clampedCurrent - 1) / (total - 1)) * 100;\n  const ariaSummary = summary.srLabel ?? `${summary.primary}. ${summary.details?.join(', ') ?? ''}`;\n  const headingId = React.useId();\n  const liveSummaryId = React.useId();\n\n  return (\n    <section\n      className={cn('flex flex-col gap-2', className)}\n      aria-labelledby={headingId}\n      aria-describedby={liveSummaryId}\n    >\n      <div\n        id={headingId}\n        className=\"flex items-center justify-between text-xs font-semibold uppercase tracking-[0.15em] text-muted-foreground sm:text-[13px]\"\n      >\n        <span>{`Step ${clampedCurrent} of ${total}`}</span>\n        <span aria-hidden>{`${Math.round(progressValue)}% complete`}</span>\n      </div>\n      <Progress\n        value={progressValue}\n        className=\"h-1.5 rounded-full bg-muted\"\n        aria-valuemin={0}\n        aria-valuemax={100}\n        aria-valuenow={Math.round(progressValue)}\n        aria-valuetext={`Step ${clampedCurrent} of ${total}`}\n      />\n      <div id={liveSummaryId} className=\"sr-only\" aria-live=\"polite\">\n        {`Step ${clampedCurrent} of ${total}. ${ariaSummary}`}\n      </div>\n      <ol className=\"hidden items-center justify-between gap-3 md:flex\" aria-label=\"Steps\">\n        {steps.map((step, index) => {\n          const stepNumber = index + 1;\n          const isCurrent = stepNumber === clampedCurrent;\n          const isComplete = stepNumber < clampedCurrent;\n          return (\n            <li\n              key={step.id ?? stepNumber}\n              className={cn(\n                'flex min-w-0 flex-1 items-center gap-3 text-sm',\n                !isCurrent && 'opacity-80',\n              )}\n            >\n              <div\n                className={cn(\n                  'flex h-9 w-9 items-center justify-center rounded-full border text-sm font-semibold transition-colors',\n                  isCurrent\n                    ? 'border-primary bg-primary text-primary-foreground'\n                    : isComplete\n                      ? 'border-primary bg-primary/20 text-primary'\n                      : 'border-border bg-background text-muted-foreground',\n                )}\n                aria-current={isCurrent ? 'step' : undefined}\n                aria-label={`${step.label} (${stepNumber} of ${total})`}\n              >\n                {stepNumber}\n              </div>\n              <div className=\"min-w-0\">\n                <p className=\"truncate text-xs font-semibold text-foreground\">{step.label}</p>\n                {step.helper ? (\n                  <p className=\"truncate text-[11px] text-muted-foreground\">{step.helper}</p>\n                ) : null}\n              </div>\n            </li>\n          );\n        })}\n      </ol>\n    </section>\n  );\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/WizardSkeletons.tsx",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport React from 'react';\n\nimport { Skeleton } from '@/components/ui/skeleton';\nimport { Card, CardContent, CardHeader } from '@shared/ui/card';\n\nexport function PlanStepSkeleton() {\n  return (\n    <Card className=\"mx-auto w-full max-w-4xl lg:max-w-5xl\">\n      <CardHeader className=\"space-y-4\">\n        <Skeleton className=\"h-8 w-48\" />\n        <Skeleton className=\"h-4 w-72\" />\n      </CardHeader>\n      <CardContent className=\"space-y-8\">\n        <div className=\"grid gap-6 md:grid-cols-2\">\n          <Skeleton className=\"h-64 w-full rounded-2xl\" />\n          <Skeleton className=\"h-64 w-full rounded-2xl\" />\n        </div>\n        <Skeleton className=\"h-48 w-full rounded-2xl\" />\n      </CardContent>\n    </Card>\n  );\n}\n\nexport function DetailsStepSkeleton() {\n  return (\n    <Card className=\"mx-auto w-full max-w-4xl lg:max-w-5xl\">\n      <CardHeader className=\"space-y-4\">\n        <Skeleton className=\"h-8 w-52\" />\n        <Skeleton className=\"h-4 w-80\" />\n      </CardHeader>\n      <CardContent className=\"space-y-6 md:space-y-8\">\n        <section className=\"space-y-4 rounded-2xl border border-border bg-card p-5 shadow-sm\">\n          <Skeleton className=\"h-5 w-36\" />\n          <div className=\"space-y-4\">\n            <Skeleton className=\"h-10 w-full\" />\n            <Skeleton className=\"h-10 w-full\" />\n            <Skeleton className=\"h-10 w-full\" />\n          </div>\n        </section>\n        <section className=\"space-y-4 rounded-2xl border border-border bg-card p-5 shadow-sm\">\n          <Skeleton className=\"h-5 w-32\" />\n          <Skeleton className=\"h-12 w-full\" />\n          <Skeleton className=\"h-28 w-full\" />\n        </section>\n      </CardContent>\n    </Card>\n  );\n}\n\nexport function ReviewStepSkeleton() {\n  return (\n    <Card className=\"mx-auto w-full max-w-4xl lg:max-w-5xl\">\n      <CardHeader className=\"space-y-4\">\n        <Skeleton className=\"h-8 w-48\" />\n        <Skeleton className=\"h-4 w-64\" />\n      </CardHeader>\n      <CardContent className=\"space-y-6\">\n        <Skeleton className=\"h-4 w-48\" />\n        <div className=\"grid gap-4 rounded-2xl border border-border bg-card p-5 shadow-sm sm:grid-cols-2 lg:grid-cols-3\">\n          {Array.from({ length: 6 }).map((_, index) => (\n            <div key={index} className=\"space-y-2\">\n              <Skeleton className=\"h-3 w-24\" />\n              <Skeleton className=\"h-4 w-40\" />\n            </div>\n          ))}\n        </div>\n      </CardContent>\n    </Card>\n  );\n}\n\nexport function ConfirmationStepSkeleton() {\n  return (\n    <Card className=\"mx-auto w-full max-w-4xl lg:max-w-5xl\">\n      <CardHeader className=\"space-y-4\">\n        <div className=\"flex items-center gap-3\">\n          <Skeleton className=\"h-6 w-6 rounded-full\" />\n          <Skeleton className=\"h-8 w-52\" />\n        </div>\n        <Skeleton className=\"h-4 w-72\" />\n      </CardHeader>\n      <CardContent className=\"space-y-6\">\n        <Skeleton className=\"h-4 w-80\" />\n        <div className=\"rounded-xl border border-border bg-card p-5 shadow-sm\">\n          <div className=\"grid gap-4 sm:grid-cols-2\">\n            {Array.from({ length: 4 }).map((_, index) => (\n              <div key={index} className=\"space-y-2\">\n                <Skeleton className=\"h-3 w-24\" />\n                <Skeleton className=\"h-4 w-36\" />\n              </div>\n            ))}\n          </div>\n        </div>\n      </CardContent>\n    </Card>\n  );\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/ui/WizardStep.tsx",
      "category": "booking-wizard",
      "content": "'use client';\n\nimport * as React from 'react';\n\nimport { cn } from '@shared/lib/cn';\nimport { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@shared/ui/card';\n\nimport { useWizardContext } from './WizardContainer';\n\nexport interface WizardStepProps {\n  step: number;\n  title: string;\n  description?: string;\n  children: React.ReactNode;\n  className?: string;\n  contentClassName?: string;\n  icon?: React.ReactNode;\n}\n\nexport function WizardStep({\n  step,\n  title,\n  description,\n  children,\n  className,\n  contentClassName,\n  icon,\n}: WizardStepProps) {\n  const { currentStep } = useWizardContext();\n  const isActive = currentStep === step;\n  const stepRef = React.useRef<HTMLDivElement | null>(null);\n  const titleId = React.useId();\n\n  React.useEffect(() => {\n    if (!isActive) {\n      return;\n    }\n    const node = stepRef.current;\n    if (!node) {\n      return;\n    }\n    node.focus();\n  }, [isActive]);\n\n  return (\n    <section\n      aria-labelledby={titleId}\n      data-step={step}\n      data-state={isActive ? 'active' : 'inactive'}\n      className=\"mx-auto w-full max-w-4xl lg:max-w-5xl\"\n    >\n      <Card\n        ref={stepRef}\n        tabIndex={-1}\n        className={cn(\n          'focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-offset-2 focus-visible:ring-ring/60',\n          className,\n        )}\n      >\n        <CardHeader className=\"space-y-3\">\n          <div className=\"flex items-center gap-3\">\n            {icon ? (\n              <span className=\"text-primary\" aria-hidden>\n                {icon}\n              </span>\n            ) : null}\n            <CardTitle\n              id={titleId}\n              role=\"heading\"\n              aria-level={2}\n              className=\"text-[clamp(1.65rem,1.35rem+0.6vw,2.1rem)] text-foreground\"\n            >\n              {title}\n            </CardTitle>\n          </div>\n          {description ? (\n            <CardDescription className=\"text-base text-muted-foreground\">\n              {description}\n            </CardDescription>\n          ) : null}\n        </CardHeader>\n        <CardContent className={cn('space-y-6 sm:space-y-8', contentClassName)}>\n          {children}\n        </CardContent>\n      </Card>\n    </section>\n  );\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/utils/debounce.ts",
      "category": "booking-wizard",
      "content": "import { useCallback, useEffect, useRef } from 'react';\n\n/**\n * Simple debounce helper for non-hook usage.\n */\nexport function debounce<T extends (...args: unknown[]) => unknown>(\n  func: T,\n  wait: number,\n): (...args: Parameters<T>) => void {\n  let timeout: NodeJS.Timeout | null = null;\n\n  return function debouncedFunction(...args: Parameters<T>) {\n    const later = () => {\n      timeout = null;\n      func(...args);\n    };\n\n    if (timeout) {\n      clearTimeout(timeout);\n    }\n\n    timeout = setTimeout(later, wait);\n  };\n}\n\n/**\n * React hook variant that keeps the latest callback reference.\n */\nexport function useDebounce<T extends (...args: unknown[]) => unknown>(\n  callback: T,\n  delay: number,\n): (...args: Parameters<T>) => void {\n  const callbackRef = useRef(callback);\n  const timeoutRef = useRef<NodeJS.Timeout | null>(null);\n\n  useEffect(() => {\n    callbackRef.current = callback;\n  }, [callback]);\n\n  useEffect(() => {\n    return () => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n    };\n  }, []);\n\n  return useCallback(\n    (...args: Parameters<T>) => {\n      if (timeoutRef.current) {\n        clearTimeout(timeoutRef.current);\n      }\n\n      timeoutRef.current = setTimeout(() => {\n        callbackRef.current(...args);\n      }, delay);\n    },\n    [delay],\n  );\n}\n\n/**\n * Lightweight throttle helper to avoid hammering handlers.\n */\nexport function useThrottle<T extends (...args: unknown[]) => unknown>(\n  callback: T,\n  delay: number,\n): (...args: Parameters<T>) => void {\n  const callbackRef = useRef(callback);\n  const lastRunRef = useRef(0);\n\n  useEffect(() => {\n    callbackRef.current = callback;\n  }, [callback]);\n\n  return useCallback(\n    (...args: Parameters<T>) => {\n      const now = Date.now();\n\n      if (now - lastRunRef.current >= delay) {\n        callbackRef.current(...args);\n        lastRunRef.current = now;\n      }\n    },\n    [delay],\n  );\n}\n"
    },
    {
      "path": "reserve/features/reservations/wizard/utils/timeoutRecovery.ts",
      "category": "booking-wizard",
      "content": "import { normalizeTime } from '@reserve/shared/time';\n\nimport type { FetchBookingsByContactParams } from '../api/fetchBookingsByContact';\nimport type { ReservationDraft } from '../model/reducer';\nimport type { Reservation } from '@entities/reservation/reservation.schema';\n\ntype FetchBookingsFn = (params: FetchBookingsByContactParams) => Promise<Reservation[]>;\n\nexport type TimeoutRecoveryResult = {\n  booking: Reservation;\n  bookings: Reservation[];\n};\n\nexport type TimeoutRecoveryParams = {\n  draft: ReservationDraft;\n  fetchBookings: FetchBookingsFn;\n  attempts?: number;\n  delayMs?: number;\n  logger?: (error: unknown) => void;\n};\n\nconst DEFAULT_ATTEMPTS = 3;\nconst DEFAULT_DELAY_MS = 2_000;\nconst RECENT_WINDOW_MS = 10 * 60 * 1_000;\n\nexport async function recoverBookingAfterTimeout(\n  params: TimeoutRecoveryParams,\n): Promise<TimeoutRecoveryResult | null> {\n  const { draft, fetchBookings, logger } = params;\n  const attempts = Math.max(1, params.attempts ?? DEFAULT_ATTEMPTS);\n  const delayMs = Math.max(0, params.delayMs ?? DEFAULT_DELAY_MS);\n\n  if (!draft?.restaurantId || !draft.email || !draft.phone) {\n    return null;\n  }\n\n  for (let attempt = 0; attempt < attempts; attempt += 1) {\n    let bookings: Reservation[];\n    try {\n      bookings = await fetchBookings({\n        restaurantId: draft.restaurantId,\n        email: draft.email,\n        phone: draft.phone,\n      });\n    } catch (error) {\n      logger?.(error);\n      break;\n    }\n\n    const match = findMatchingReservation(bookings, draft);\n    if (match) {\n      return { booking: match, bookings };\n    }\n\n    if (attempt < attempts - 1 && delayMs > 0) {\n      await delay(delayMs);\n    }\n  }\n\n  return null;\n}\n\nexport function findMatchingReservation(\n  bookings: Reservation[],\n  draft: ReservationDraft,\n): Reservation | null {\n  if (!draft?.restaurantId || !draft.email || !draft.phone) {\n    return null;\n  }\n\n  const normalizedTime = normalizeTime(draft.time);\n  const normalizedEmail = draft.email.trim().toLowerCase();\n  const normalizedPhone = normalizePhone(draft.phone);\n\n  return (\n    bookings.find((booking) => {\n      if (!booking) {\n        return false;\n      }\n\n      if (booking.restaurantId !== draft.restaurantId) {\n        return false;\n      }\n\n      if (booking.bookingDate !== draft.date) {\n        return false;\n      }\n\n      if (booking.partySize !== draft.party) {\n        return false;\n      }\n\n      if (booking.status?.toLowerCase() === 'cancelled') {\n        return false;\n      }\n\n      const bookingTime = normalizeTime(booking.startTime);\n      if (normalizedTime && bookingTime !== normalizedTime) {\n        return false;\n      }\n\n      if (booking.customerEmail.trim().toLowerCase() !== normalizedEmail) {\n        return false;\n      }\n\n      if (normalizePhone(booking.customerPhone) !== normalizedPhone) {\n        return false;\n      }\n\n      if (!isRecent(booking.createdAt)) {\n        return false;\n      }\n\n      return true;\n    }) ?? null\n  );\n}\n\nfunction normalizePhone(value: string): string {\n  return value.replace(/[^0-9]/g, '');\n}\n\nfunction isRecent(createdAt?: string | null): boolean {\n  if (!createdAt) {\n    return true;\n  }\n  const timestamp = Date.parse(createdAt);\n  if (Number.isNaN(timestamp)) {\n    return true;\n  }\n  return Date.now() - timestamp <= RECENT_WINDOW_MS;\n}\n\nfunction delay(ms: number) {\n  return new Promise((resolve) => {\n    setTimeout(resolve, ms);\n  });\n}\n"
    },
    {
      "path": "reserve/pages/NotFoundPage.tsx",
      "category": "reserve-router-pages",
      "content": "'use client';\n\nimport { Link } from 'react-router-dom';\n\nexport default function NotFoundPage() {\n  return (\n    <main className=\"flex min-h-screen flex-col items-center justify-center bg-slate-50 px-4 py-16 text-center text-slate-700\">\n      <h1 className=\"text-3xl font-semibold\">Page not found</h1>\n      <p className=\"mt-2 max-w-md text-base text-slate-600\">\n        We couldnt find the page you were looking for. Head back to the reservation flow to\n        continue.\n      </p>\n      <Link\n        to=\"/\"\n        className=\"mt-6 rounded-md bg-srx-ink-strong px-4 py-2 text-white hover:bg-srx-ink-strong/90\"\n      >\n        Return to reservations\n      </Link>\n    </main>\n  );\n}\n"
    },
    {
      "path": "reserve/pages/ReservationDetailsPage.tsx",
      "category": "reserve-router-pages",
      "content": "'use client';\n\nimport { useParams } from 'react-router-dom';\n\nexport default function ReservationDetailsPage() {\n  const { reservationId } = useParams();\n\n  return (\n    <main className=\"mx-auto flex min-h-screen w-full max-w-3xl flex-col gap-6 px-4 py-16 text-srx-ink-strong\">\n      <div>\n        <h1 className=\"text-3xl font-semibold\">Reservation {reservationId}</h1>\n        <p className=\"mt-2 text-slate-600\">\n          Details view coming soon. Use the back button in your browser to return to the booking\n          flow.\n        </p>\n      </div>\n    </main>\n  );\n}\n"
    },
    {
      "path": "reserve/pages/RootLayout.tsx",
      "category": "reserve-router-pages",
      "content": "'use client';\n\nimport { Outlet } from 'react-router-dom';\n\nimport { ReserveProviders } from '@app/providers';\n\nexport function ReserveRootLayout() {\n  return (\n    <ReserveProviders>\n      <a href=\"#reserve-content\" className=\"sr-only focus:not-sr-only\">\n        Skip to content\n      </a>\n      <div id=\"reserve-content\">\n        <Outlet />\n      </div>\n    </ReserveProviders>\n  );\n}\n"
    },
    {
      "path": "reserve/pages/RouteError.tsx",
      "category": "reserve-router-pages",
      "content": "'use client';\n\nimport { isRouteErrorResponse, useRouteError } from 'react-router-dom';\n\nimport { Icon } from '@reserve/shared/ui/icons';\nimport { env } from '@shared/config/env';\n\nexport function ReserveErrorBoundary() {\n  const error = useRouteError();\n\n  let title = 'Something went wrong';\n  let description = 'Please refresh the page or try again shortly.';\n\n  if (isRouteErrorResponse(error)) {\n    title = `${error.status} ${error.statusText}`;\n    description = error.data?.message ?? description;\n  }\n\n  return (\n    <main className=\"flex min-h-screen flex-col items-center justify-center bg-slate-50 px-4 py-16 text-center text-slate-700\">\n      <Icon.AlertCircle className=\"mb-4 h-10 w-10 text-red-500\" aria-hidden />\n      <h1 className=\"text-2xl font-semibold\">{title}</h1>\n      <p className=\"mt-2 max-w-md text-base text-slate-600\">{description}</p>\n      <button\n        type=\"button\"\n        onClick={() => window.location.assign(env.ROUTER_BASE_PATH)}\n        className=\"mt-6 rounded-md bg-srx-ink-strong px-4 py-2 text-white hover:bg-srx-ink-strong/90\"\n      >\n        Retry\n      </button>\n    </main>\n  );\n}\n"
    },
    {
      "path": "reserve/pages/WizardPage.tsx",
      "category": "reserve-router-pages",
      "content": "'use client';\n\nimport { useParams } from 'react-router-dom';\n\nimport { ReservationWizard } from '@features/reservations/wizard/ui/ReservationWizard';\n\ntype WizardRouteParams = {\n  slug?: string;\n};\n\nexport default function WizardPage() {\n  const { slug } = useParams<WizardRouteParams>();\n  const normalizedSlug = slug?.trim();\n  const initialDetails = normalizedSlug ? { restaurantSlug: normalizedSlug } : undefined;\n\n  return <ReservationWizard initialDetails={initialDetails} />;\n}\n"
    },
    {
      "path": "reserve/shared/api/client.ts",
      "category": "shared-api",
      "content": "import { CSRF_HEADER_NAME, getBrowserCsrfToken } from '@/lib/security/csrf';\nimport { env } from '@shared/config/env';\n\nexport type HttpMethod = 'GET' | 'POST' | 'PUT' | 'PATCH' | 'DELETE';\n\nexport type ApiError = {\n  code: string;\n  message: string;\n  details?: unknown;\n  status?: number;\n};\n\nconst defaultHeaders: HeadersInit = {\n  'Content-Type': 'application/json',\n};\n\nfunction composeHeaders(init?: HeadersInit): Headers {\n  const headers = new Headers(defaultHeaders);\n  if (init) {\n    const incoming = new Headers(init);\n    incoming.forEach((value, key) => {\n      headers.set(key, value);\n    });\n  }\n  return headers;\n}\n\ntype RequestOptions = RequestInit & { method?: HttpMethod; timeoutMs?: number };\n\nfunction mergeSignals(source: AbortController, external?: AbortSignal | null): () => void {\n  if (!external) {\n    return () => {};\n  }\n\n  if (external.aborted) {\n    source.abort(external.reason ?? new DOMException('Request aborted', 'AbortError'));\n    return () => {};\n  }\n\n  const forwardAbort = () => {\n    source.abort(external.reason ?? new DOMException('Request aborted', 'AbortError'));\n  };\n\n  external.addEventListener('abort', forwardAbort, { once: true });\n\n  return () => external.removeEventListener('abort', forwardAbort);\n}\n\nfunction inferTimeoutMs(timeoutMs: number | undefined): number | null {\n  if (typeof timeoutMs === 'number') {\n    if (!Number.isFinite(timeoutMs) || timeoutMs <= 0) {\n      return null;\n    }\n    return timeoutMs;\n  }\n  if (!Number.isFinite(env.API_TIMEOUT_MS) || env.API_TIMEOUT_MS <= 0) {\n    return null;\n  }\n  return env.API_TIMEOUT_MS;\n}\n\nasync function request<TResponse>(\n  path: string,\n  { method = 'GET', headers, body, signal, timeoutMs, ...init }: RequestOptions = {},\n): Promise<TResponse> {\n  const controller = new AbortController();\n  const removeExternalListener = mergeSignals(controller, signal);\n  const requestHeaders = composeHeaders(headers);\n  const csrfToken = getBrowserCsrfToken();\n  if (csrfToken && !requestHeaders.has(CSRF_HEADER_NAME)) {\n    requestHeaders.set(CSRF_HEADER_NAME, csrfToken);\n  }\n\n  const resolvedTimeout = inferTimeoutMs(timeoutMs);\n  const timeoutHandle =\n    resolvedTimeout !== null\n      ? setTimeout(() => {\n          controller.abort(new DOMException('Request timed out', 'TimeoutError'));\n        }, resolvedTimeout)\n      : null;\n\n  try {\n    const response = await fetch(`${env.API_BASE_URL}${path}`, {\n      method,\n      headers: requestHeaders,\n      body,\n      signal: controller.signal,\n      credentials: 'include',\n      ...init,\n    });\n\n    const text = await response.text();\n    const parsed = text ? JSON.parse(text) : undefined;\n\n    if (!response.ok) {\n      const normalized: ApiError = {\n        code: parsed?.code ?? `${response.status}`,\n        message: parsed?.message ?? response.statusText ?? 'Request failed',\n        details: parsed?.details,\n        status: response.status,\n      };\n      throw normalized;\n    }\n\n    return parsed as TResponse;\n  } catch (error) {\n    if (error instanceof DOMException) {\n      if (error.name === 'TimeoutError') {\n        const timeoutError: ApiError = {\n          code: 'TIMEOUT',\n          message: 'Request timed out. Please try again.',\n          status: 408,\n        };\n        throw timeoutError;\n      }\n      if (error.name === 'AbortError') {\n        const reason = controller.signal.reason ?? null;\n        let reasonMessage: string | null = null;\n        if (typeof reason === 'string') {\n          reasonMessage = reason;\n        } else if (\n          reason &&\n          typeof reason === 'object' &&\n          typeof (reason as { message?: unknown }).message === 'string'\n        ) {\n          reasonMessage = (reason as { message: string }).message;\n        }\n        const derivedMessage =\n          reasonMessage && reasonMessage.trim().length > 0\n            ? reasonMessage.trim()\n            : 'Request was cancelled.';\n        const abortError: ApiError = {\n          code: 'REQUEST_ABORTED',\n          message: derivedMessage,\n          status: 499,\n        };\n        throw abortError;\n      }\n    }\n    throw error;\n  } finally {\n    if (timeoutHandle !== null) {\n      clearTimeout(timeoutHandle);\n    }\n    removeExternalListener();\n  }\n}\n\nexport const apiClient = {\n  get: <TResponse>(path: string, init?: RequestOptions) =>\n    request<TResponse>(path, { ...init, method: 'GET' }),\n  post: <TResponse>(path: string, body: unknown, init?: RequestOptions) =>\n    request<TResponse>(path, { ...init, method: 'POST', body: JSON.stringify(body) }),\n  put: <TResponse>(path: string, body: unknown, init?: RequestOptions) =>\n    request<TResponse>(path, { ...init, method: 'PUT', body: JSON.stringify(body) }),\n  patch: <TResponse>(path: string, body: unknown, init?: RequestOptions) =>\n    request<TResponse>(path, { ...init, method: 'PATCH', body: JSON.stringify(body) }),\n  delete: <TResponse>(path: string, init?: RequestOptions) =>\n    request<TResponse>(path, { ...init, method: 'DELETE' }),\n};\n"
    },
    {
      "path": "reserve/shared/api/queryKeys.ts",
      "category": "shared-api",
      "content": "import type { QueryKey } from '@tanstack/react-query';\n\nconst RESERVATIONS_ROOT = 'reservations' as const;\nconst RESERVATIONS_KEY = [RESERVATIONS_ROOT] as const;\nconst RESERVATION_DETAIL = 'reservation' as const;\n\ntype ReservationIdentifier = string | null | undefined;\n\nexport const reservationKeys = {\n  all(): QueryKey {\n    return RESERVATIONS_KEY;\n  },\n  detail(reservationId: ReservationIdentifier): QueryKey {\n    return [RESERVATION_DETAIL, reservationId ?? null] as const;\n  },\n};\n\nexport type ReservationQueryKey = ReturnType<typeof reservationKeys.detail>;\n"
    },
    {
      "path": "reserve/shared/config/booking.ts",
      "category": "shared-config",
      "content": "import type { OccasionKey } from '@reserve/shared/occasions';\n\nexport const BOOKING_TYPES = ['breakfast', 'lunch', 'dinner', 'drinks'] as const;\nexport type BookingType = OccasionKey;\n\nexport const BOOKING_TYPES_UI = [\n  'lunch',\n  'dinner',\n  'drinks',\n] as const satisfies readonly OccasionKey[];\n\nexport const BOOKING_STATUSES = [\n  'pending',\n  'pending_allocation',\n  'confirmed',\n  'cancelled',\n] as const;\nexport type BookingStatus = (typeof BOOKING_STATUSES)[number];\n\nexport const BOOKING_BLOCKING_STATUSES = [\n  'pending',\n  'pending_allocation',\n  'confirmed',\n] as const satisfies readonly BookingStatus[];\n\nexport const SEATING_PREFERENCES = ['any', 'indoor', 'outdoor', 'window', 'booth', 'bar'] as const;\nexport type SeatingPreference = (typeof SEATING_PREFERENCES)[number];\n\nexport const SEATING_PREFERENCES_UI = [\n  'any',\n  'indoor',\n  'outdoor',\n] as const satisfies readonly SeatingPreference[];\n\nfunction createEnumPredicate<const T extends readonly string[]>(values: T) {\n  const set = new Set(values as readonly string[]);\n  return (value: string): value is T[number] => set.has(value);\n}\n\nexport const isBookingType = createEnumPredicate(BOOKING_TYPES);\nexport const isBookingStatus = createEnumPredicate(BOOKING_STATUSES);\nexport const isSeatingPreference = createEnumPredicate(SEATING_PREFERENCES);\n\nfunction formatValidList(values: readonly string[]) {\n  return values.map((entry) => `\"${entry}\"`).join(', ');\n}\n\nexport function ensureBookingType(value: string, fieldName = 'booking type'): BookingType {\n  if (!isBookingType(value)) {\n    throw new Error(\n      `Invalid ${fieldName}: ${value}. Valid values: ${formatValidList(BOOKING_TYPES)}.`,\n    );\n  }\n  return value;\n}\n\nexport function ensureBookingStatus(value: string, fieldName = 'booking status'): BookingStatus {\n  if (!isBookingStatus(value)) {\n    throw new Error(\n      `Invalid ${fieldName}: ${value}. Valid values: ${formatValidList(BOOKING_STATUSES)}.`,\n    );\n  }\n  return value;\n}\n\nexport function ensureSeatingPreference(\n  value: string,\n  fieldName = 'seating preference',\n): SeatingPreference {\n  if (!isSeatingPreference(value)) {\n    throw new Error(\n      `Invalid ${fieldName}: ${value}. Valid values: ${formatValidList(SEATING_PREFERENCES)}.`,\n    );\n  }\n  return value;\n}\n"
    },
    {
      "path": "reserve/shared/config/env.ts",
      "category": "shared-config",
      "content": "import { z } from 'zod';\n\nimport { runtime } from '@shared/config/runtime';\n\nconst envSchema = z.object({\n  API_BASE_URL: z.string().min(1),\n  API_TIMEOUT_MS: z.number().int().positive(),\n  RESERVE_V2_ENABLED: z.boolean(),\n  ROUTER_BASE_PATH: z.string().min(1),\n});\n\nconst sanitizeBasePath = (value: string | null | undefined): string => {\n  const trimmed = value?.trim();\n  if (!trimmed) {\n    return '/reserve';\n  }\n\n  if (trimmed === '/') {\n    return '/';\n  }\n\n  const withoutSlashes = trimmed.replace(/^\\/+/, '').replace(/\\/+$/, '');\n  return `/${withoutSlashes}`;\n};\n\nconst apiBaseUrlRaw = runtime.readString('RESERVE_API_BASE_URL', {\n  alternatives: ['NEXT_PUBLIC_RESERVE_API_BASE_URL', 'API_BASE_URL'],\n});\n\nconst apiTimeoutRaw = runtime.readNumber('RESERVE_API_TIMEOUT_MS', {\n  alternatives: ['NEXT_PUBLIC_RESERVE_API_TIMEOUT_MS', 'RESERVE_API_TIMEOUT'],\n  fallback: 15_000,\n});\n\nconst reserveV2Raw = runtime.readBoolean('RESERVE_V2_ENABLED', {\n  alternatives: ['NEXT_PUBLIC_RESERVE_V2', 'RESERVE_V2_FLAG'],\n  fallback: false,\n});\n\nconst routerBasePathRaw = runtime.readString('RESERVE_ROUTER_BASE_PATH', {\n  alternatives: ['NEXT_PUBLIC_RESERVE_ROUTER_BASE_PATH', 'ROUTER_BASE_PATH'],\n});\n\nconst routerBasePath = sanitizeBasePath(routerBasePathRaw);\n\nconst API_FALLBACK = '/api';\n\nconst raw = {\n  API_BASE_URL: apiBaseUrlRaw ?? API_FALLBACK,\n  API_TIMEOUT_MS: apiTimeoutRaw ?? 15_000,\n  RESERVE_V2_ENABLED: reserveV2Raw ?? false,\n  ROUTER_BASE_PATH: routerBasePath,\n};\n\nconst parsed = envSchema.safeParse(raw);\n\nif (!parsed.success) {\n  throw new Error(`reserve env validation failed: ${parsed.error.message}`);\n}\n\n// Only throw error if we're in production AND no API base URL is available at all\nif (!apiBaseUrlRaw && !raw.API_BASE_URL && !(runtime.isDev || runtime.isTest)) {\n  throw new Error(\n    '[reserve env] Missing RESERVE_API_BASE_URL (or NEXT_PUBLIC_RESERVE_API_BASE_URL) for production build',\n  );\n}\n\nif (!apiBaseUrlRaw && runtime.isDev) {\n  console.warn('[reserve env] Using fallback API base URL \"/api\" because no env var was found.');\n}\n\nif (routerBasePathRaw && routerBasePathRaw !== routerBasePath && runtime.isDev) {\n  console.warn(\n    `[reserve env] Normalized RESERVE_ROUTER_BASE_PATH from \"${routerBasePathRaw}\" to \"${routerBasePath}\".`,\n  );\n}\n\nexport const env = parsed.data;\n"
    },
    {
      "path": "reserve/shared/config/reservations.ts",
      "category": "shared-config",
      "content": "import { isReservationTime, normalizeTime as normalizeReservationTime } from '@reserve/shared/time';\nimport { runtime } from '@shared/config/runtime';\n\nimport type { ReservationTime } from '@reserve/shared/time';\n\nexport type ReservationConfig = {\n  timezone: string;\n  opening: {\n    open: ReservationTime;\n    close: ReservationTime;\n    intervalMinutes: number;\n  };\n  windows: {\n    weekdayLunchEnd: ReservationTime;\n    weekendLunchEnd: ReservationTime;\n    dinnerStart: ReservationTime;\n    happyHour?: {\n      start: ReservationTime;\n      end: ReservationTime;\n    };\n  };\n  defaultDurationMinutes: number;\n  copy: {\n    unavailableTooltip: string;\n  };\n};\n\nexport type ReservationConfigIssue = {\n  key: string;\n  value: string;\n  reason: string;\n};\n\ntype MutableReservationConfig = {\n  config: ReservationConfig;\n  issues: ReservationConfigIssue[];\n};\n\nconst DEFAULT_RESERVATION_CONFIG: ReservationConfig = {\n  timezone: 'Europe/London',\n  opening: {\n    open: '12:00' as ReservationTime,\n    close: '23:00' as ReservationTime,\n    intervalMinutes: 15,\n  },\n  windows: {\n    weekdayLunchEnd: '15:00' as ReservationTime,\n    weekendLunchEnd: '17:00' as ReservationTime,\n    dinnerStart: '17:00' as ReservationTime,\n    happyHour: {\n      start: '15:00' as ReservationTime,\n      end: '17:00' as ReservationTime,\n    },\n  },\n  defaultDurationMinutes: 90,\n  copy: {\n    unavailableTooltip: 'Not available for the selected time.',\n  },\n};\n\nconst timeOverrideKeys = {\n  open: 'RESERVE_RESERVATION_OPEN',\n  close: 'RESERVE_RESERVATION_CLOSE',\n  interval: 'RESERVE_RESERVATION_INTERVAL_MINUTES',\n  weekdayLunchEnd: 'RESERVE_RESERVATION_WEEKDAY_LUNCH_END',\n  weekendLunchEnd: 'RESERVE_RESERVATION_WEEKEND_LUNCH_END',\n  dinnerStart: 'RESERVE_RESERVATION_DINNER_START',\n  happyHourStart: 'RESERVE_RESERVATION_HAPPY_HOUR_START',\n  happyHourEnd: 'RESERVE_RESERVATION_HAPPY_HOUR_END',\n  duration: 'RESERVE_RESERVATION_DEFAULT_DURATION_MINUTES',\n  timezone: 'RESERVE_RESERVATION_TIMEZONE',\n  tooltip: 'RESERVE_RESERVATION_UNAVAILABLE_TOOLTIP',\n} as const;\n\nconst normalizeTimeOverride = (\n  key: string,\n  fallback: ReservationTime,\n  issues: ReservationConfigIssue[],\n): ReservationTime => {\n  const raw = runtime.readString(key);\n  if (!raw) return fallback;\n  const candidate = normalizeReservationTime(raw);\n  if (!candidate || !isReservationTime(candidate)) {\n    issues.push({\n      key,\n      value: raw,\n      reason: 'Expected HH:MM 24-hour format',\n    });\n    return fallback;\n  }\n  return candidate;\n};\n\nconst readIntervalOverride = (\n  key: string,\n  fallback: number,\n  issues: ReservationConfigIssue[],\n): number => {\n  const raw = runtime.readNumber(key);\n  if (raw === undefined) return fallback;\n  if (!Number.isFinite(raw) || raw <= 0 || raw > 180) {\n    issues.push({\n      key,\n      value: String(raw),\n      reason: 'Interval must be between 1 and 180 minutes',\n    });\n    return fallback;\n  }\n  return raw;\n};\n\nconst readDurationOverride = (\n  key: string,\n  fallback: number,\n  issues: ReservationConfigIssue[],\n): number => {\n  const raw = runtime.readNumber(key);\n  if (raw === undefined) return fallback;\n  if (!Number.isFinite(raw) || raw < 15 || raw > 300) {\n    issues.push({\n      key,\n      value: String(raw),\n      reason: 'Duration must be between 15 and 300 minutes',\n    });\n    return fallback;\n  }\n  return raw;\n};\n\nconst applyOverrides = (): MutableReservationConfig => {\n  const issues: ReservationConfigIssue[] = [];\n  const base = structuredClone(DEFAULT_RESERVATION_CONFIG);\n\n  base.opening.open = normalizeTimeOverride(timeOverrideKeys.open, base.opening.open, issues);\n  base.opening.close = normalizeTimeOverride(timeOverrideKeys.close, base.opening.close, issues);\n  base.opening.intervalMinutes = readIntervalOverride(\n    timeOverrideKeys.interval,\n    base.opening.intervalMinutes,\n    issues,\n  );\n\n  base.windows.weekdayLunchEnd = normalizeTimeOverride(\n    timeOverrideKeys.weekdayLunchEnd,\n    base.windows.weekdayLunchEnd,\n    issues,\n  );\n  base.windows.weekendLunchEnd = normalizeTimeOverride(\n    timeOverrideKeys.weekendLunchEnd,\n    base.windows.weekendLunchEnd,\n    issues,\n  );\n  base.windows.dinnerStart = normalizeTimeOverride(\n    timeOverrideKeys.dinnerStart,\n    base.windows.dinnerStart,\n    issues,\n  );\n\n  const happyHourStart = normalizeTimeOverride(\n    timeOverrideKeys.happyHourStart,\n    base.windows.happyHour?.start ?? base.windows.dinnerStart,\n    issues,\n  );\n  const happyHourEnd = normalizeTimeOverride(\n    timeOverrideKeys.happyHourEnd,\n    base.windows.happyHour?.end ?? base.windows.dinnerStart,\n    issues,\n  );\n\n  if (base.windows.happyHour) {\n    base.windows.happyHour = { start: happyHourStart, end: happyHourEnd };\n  }\n\n  const duration = readDurationOverride(\n    timeOverrideKeys.duration,\n    base.defaultDurationMinutes,\n    issues,\n  );\n  base.defaultDurationMinutes = duration;\n\n  const timezoneOverride = runtime.readString(timeOverrideKeys.timezone);\n  if (timezoneOverride) {\n    base.timezone = timezoneOverride.trim();\n  }\n\n  const tooltipOverride = runtime.readString(timeOverrideKeys.tooltip);\n  if (tooltipOverride) {\n    base.copy.unavailableTooltip = tooltipOverride.trim();\n  }\n\n  const openMinutes =\n    parseInt(base.opening.open.slice(0, 2), 10) * 60 + parseInt(base.opening.open.slice(3), 10);\n  const closeMinutes =\n    parseInt(base.opening.close.slice(0, 2), 10) * 60 + parseInt(base.opening.close.slice(3), 10);\n\n  if (closeMinutes <= openMinutes) {\n    issues.push({\n      key: `${timeOverrideKeys.open}/${timeOverrideKeys.close}`,\n      value: `${base.opening.open}-${base.opening.close}`,\n      reason: 'Close time must be after open time',\n    });\n  }\n\n  return { config: base, issues };\n};\n\nexport type ReservationConfigResult = MutableReservationConfig;\n\nexport const reservationConfigResult: ReservationConfigResult = applyOverrides();\n\nif (reservationConfigResult.issues.length > 0 && runtime.isDev) {\n  console.warn(\n    '[reserve config] Using default reservation config due to issues:',\n    reservationConfigResult.issues,\n  );\n}\n\nexport const defaultReservationConfig = reservationConfigResult.config;\n"
    },
    {
      "path": "reserve/shared/config/runtime.ts",
      "category": "shared-config",
      "content": "const metaEnv = (import.meta as unknown as { env?: Record<string, string | boolean | undefined> })\n  .env;\nconst processEnv =\n  typeof process !== 'undefined' ? (process.env as Record<string, string | undefined>) : undefined;\n\ntype ReadOptions = {\n  fallback?: string;\n  alternatives?: string[];\n};\n\ntype BooleanOptions = Omit<ReadOptions, 'fallback'> & {\n  fallback?: boolean;\n};\n\ntype NumberOptions = Omit<ReadOptions, 'fallback'> & {\n  fallback?: number;\n};\n\nconst toBooleanString = (value: string | boolean | undefined): string | undefined => {\n  if (typeof value === 'string') return value;\n  if (typeof value === 'boolean') return value ? 'true' : 'false';\n  return undefined;\n};\n\nconst expandCandidate = (candidate: string): string[] => {\n  const normalized = candidate.trim();\n  if (normalized.length === 0) return [];\n  if (normalized.startsWith('VITE_') || normalized.startsWith('NEXT_PUBLIC_')) {\n    const bare = normalized.replace(/^(VITE_|NEXT_PUBLIC_)/, '');\n    return [normalized, bare];\n  }\n  return [normalized, `VITE_${normalized}`, `NEXT_PUBLIC_${normalized}`];\n};\n\nconst collectCandidates = (key: string, alternatives?: string[]): string[] => {\n  const set = new Set<string>();\n  [key, ...(alternatives ?? [])].forEach((candidate) => {\n    expandCandidate(candidate).forEach((entry) => {\n      if (entry) set.add(entry);\n    });\n  });\n  return Array.from(set);\n};\n\nconst readRaw = (key: string, options?: ReadOptions): string | undefined => {\n  const candidates = collectCandidates(key, options?.alternatives);\n\n  for (const candidate of candidates) {\n    const fromMeta = toBooleanString(metaEnv?.[candidate]);\n    if (typeof fromMeta === 'string') {\n      return fromMeta;\n    }\n    const fromProcess = processEnv?.[candidate];\n    if (typeof fromProcess === 'string' && fromProcess.length > 0) {\n      return fromProcess;\n    }\n  }\n\n  return options?.fallback;\n};\n\nconst parseBoolean = (value: string | undefined): boolean | undefined => {\n  if (typeof value !== 'string') return undefined;\n  if (/^(true|1|yes)$/i.test(value.trim())) return true;\n  if (/^(false|0|no)$/i.test(value.trim())) return false;\n  return undefined;\n};\n\nconst parseNumber = (value: string | undefined): number | undefined => {\n  if (typeof value !== 'string') return undefined;\n  const parsed = Number(value);\n  return Number.isFinite(parsed) ? parsed : undefined;\n};\n\nconst resolvedMode = readRaw('MODE', { alternatives: ['NODE_ENV'] }) ?? 'production';\n\nexport const runtime = {\n  mode: resolvedMode,\n  isDev: resolvedMode === 'development',\n  isTest: resolvedMode === 'test',\n  readString: (key: string, options?: ReadOptions): string | undefined => readRaw(key, options),\n  readBoolean: (key: string, options?: BooleanOptions): boolean | undefined => {\n    const value = readRaw(key, options ? { alternatives: options.alternatives } : undefined);\n    const parsed = parseBoolean(value);\n    return parsed ?? options?.fallback;\n  },\n  readNumber: (key: string, options?: NumberOptions): number | undefined => {\n    const value = readRaw(key, options ? { alternatives: options.alternatives } : undefined);\n    const parsed = parseNumber(value);\n    return parsed ?? options?.fallback;\n  },\n};\n\nexport type Runtime = typeof runtime;\n"
    },
    {
      "path": "reserve/shared/config/venue.ts",
      "category": "shared-config",
      "content": "import { runtime } from '@shared/config/runtime';\n\nexport type VenueDetails = {\n  id: string;\n  slug: string;\n  name: string;\n  address: string;\n  phone: string;\n  email: string;\n  policy: string;\n  timezone: string;\n  logoUrl: string | null;\n};\n\nconst defaultRestaurantId =\n  runtime.readString('RESERVE_DEFAULT_RESTAURANT_ID', {\n    alternatives: ['DEFAULT_RESTAURANT_ID'],\n    fallback: 'b70decfe-8ad3-487e-bdbb-43aa7bd016ca',\n  }) ?? 'b70decfe-8ad3-487e-bdbb-43aa7bd016ca';\n\nconst defaultRestaurantSlug =\n  runtime.readString('RESERVE_DEFAULT_RESTAURANT_SLUG', {\n    alternatives: ['DEFAULT_RESTAURANT_SLUG'],\n    fallback: 'white-horse-pub-waterbeach',\n  }) ?? 'white-horse-pub-waterbeach';\n\nconst defaultPolicy =\n  runtime.readString('RESERVE_DEFAULT_VENUE_POLICY', {\n    fallback:\n      'You can cancel or amend up to 24 hours before your reservation. After that window please call the venue and well do our best to help.',\n  }) ??\n  'You can cancel or amend up to 24 hours before your reservation. After that window please call the venue and well do our best to help.';\n\nexport const DEFAULT_RESTAURANT_ID = defaultRestaurantId;\nexport const DEFAULT_RESTAURANT_SLUG = defaultRestaurantSlug;\n\nexport const DEFAULT_VENUE: VenueDetails = {\n  id: defaultRestaurantId,\n  slug: defaultRestaurantSlug,\n  name:\n    runtime.readString('RESERVE_DEFAULT_VENUE_NAME', {\n      fallback: 'White Horse Pub (Waterbeach)',\n    }) ?? 'White Horse Pub (Waterbeach)',\n  address:\n    runtime.readString('RESERVE_DEFAULT_VENUE_ADDRESS', {\n      fallback: '12 Green Side, Waterbeach, Cambridge, CB25 9HP',\n    }) ?? '12 Green Side, Waterbeach, Cambridge, CB25 9HP',\n  phone:\n    runtime.readString('RESERVE_DEFAULT_VENUE_PHONE', {\n      fallback: '01223 375578',\n    }) ?? '01223 375578',\n  email:\n    runtime.readString('RESERVE_DEFAULT_VENUE_EMAIL', {\n      fallback: 'whitehorse@lapeninns.com',\n    }) ?? 'whitehorse@lapeninns.com',\n  policy: defaultPolicy,\n  timezone:\n    runtime.readString('RESERVE_DEFAULT_VENUE_TIMEZONE', {\n      fallback: 'Europe/London',\n    }) ?? 'Europe/London',\n  logoUrl: runtime.readString('RESERVE_DEFAULT_VENUE_LOGO_URL') ?? null,\n};\n\nexport const resolveVenueDetails = (overrides?: Partial<VenueDetails>): VenueDetails => ({\n  ...DEFAULT_VENUE,\n  ...overrides,\n  slug:\n    overrides?.slug ??\n    overrides?.name?.toLowerCase().replace(/[^a-z0-9]+/g, '-') ??\n    DEFAULT_VENUE.slug,\n});\n"
    },
    {
      "path": "reserve/shared/error/errorReporter.ts",
      "category": "shared-error",
      "content": "export interface ErrorReporter {\n  capture: (error: unknown, context?: Record<string, unknown>) => void;\n}\n\nconst formatContext = (context?: Record<string, unknown>) => {\n  if (!context || Object.keys(context).length === 0) return undefined;\n  return context;\n};\n\nexport const defaultErrorReporter: ErrorReporter = {\n  capture: (error, context) => {\n    if (process.env.NODE_ENV !== 'production') {\n      if (context) {\n        console.error('[error]', formatContext(context), error);\n      } else {\n        console.error('[error]', error);\n      }\n    }\n  },\n};\n"
    },
    {
      "path": "reserve/shared/error/index.ts",
      "category": "shared-error",
      "content": "export type { ErrorReporter } from './errorReporter';\nexport { defaultErrorReporter } from './errorReporter';\nexport { mapErrorToMessage } from './mapErrorToMessage';\n"
    },
    {
      "path": "reserve/shared/error/mapErrorToMessage.ts",
      "category": "shared-error",
      "content": "const ERROR_CODE_MESSAGES: Record<string, string> = {\n  CAPACITY_EXCEEDED: 'No tables are available at that time. Please choose another slot.',\n  RATE_LIMITED: 'Too many booking attempts right now. Please wait a moment and try again.',\n  SERVICE_PERIOD: 'That time is no longer available for bookings.',\n  OUTSIDE_WINDOW: 'That time is outside the restaurant operating hours.',\n};\n\nexport function mapErrorToMessage(error: unknown, fallback = 'Something went wrong'): string {\n  if (!error) return fallback;\n\n  if (typeof error === 'string') {\n    return error.trim() || fallback;\n  }\n\n  if (error instanceof Error) {\n    return error.message?.trim() || fallback;\n  }\n\n  if (typeof error === 'object' && error !== null) {\n    const record = error as Record<string, unknown>;\n    const maybeMessage = record.message;\n    if (typeof maybeMessage === 'string' && maybeMessage.trim().length > 0) {\n      return maybeMessage.trim();\n    }\n\n    const maybeErrorMessage = record.error;\n    if (typeof maybeErrorMessage === 'string' && maybeErrorMessage.trim().length > 0) {\n      return maybeErrorMessage.trim();\n    }\n\n    const issues = record.issues;\n    if (Array.isArray(issues)) {\n      for (const issue of issues) {\n        if (issue && typeof issue === 'object' && 'message' in issue) {\n          const issueMessage = (issue as { message?: unknown }).message;\n          if (typeof issueMessage === 'string' && issueMessage.trim().length > 0) {\n            return issueMessage.trim();\n          }\n        }\n      }\n    }\n\n    const codeValue = record.code ?? record.errorCode;\n    if (typeof codeValue === 'string') {\n      const normalizedCode = codeValue.trim().toUpperCase();\n      const mapped = ERROR_CODE_MESSAGES[normalizedCode];\n      if (mapped) {\n        return mapped;\n      }\n    }\n  }\n\n  return fallback;\n}\n"
    },
    {
      "path": "reserve/shared/formatting/booking.ts",
      "category": "shared-formatting",
      "content": "import { reservationConfigResult } from '@reserve/shared/config/reservations';\nimport { normalizeTime } from '@reserve/shared/time';\nimport { BOOKING_TYPES_UI } from '@shared/config/booking';\n\nimport type { BookingOption } from '@reserve/shared/booking';\nimport type { ReservationDate, ReservationTime } from '@reserve/shared/time';\n\nconst formatterCache = new Map<string, Intl.DateTimeFormat>();\n\nconst BASE_LABELS: Record<BookingOption, string> = {\n  lunch: 'Lunch',\n  dinner: 'Dinner',\n  drinks: 'Drinks & cocktails',\n};\n\ntype FormattingOptions = {\n  timezone?: string;\n};\n\nfunction resolveTimezone(override?: string): string {\n  const candidate = override?.trim();\n  if (candidate) {\n    return candidate;\n  }\n  return reservationConfigResult.config.timezone ?? 'Europe/London';\n}\n\nfunction getFormatter(\n  cacheKey: string,\n  options: Intl.DateTimeFormatOptions,\n  timezoneOverride?: string,\n): Intl.DateTimeFormat {\n  const timezone = resolveTimezone(timezoneOverride);\n  const key = `${cacheKey}:${timezone}`;\n  const existing = formatterCache.get(key);\n  if (existing) return existing;\n  const formatter = new Intl.DateTimeFormat('en-GB', {\n    timeZone: timezone,\n    ...options,\n  });\n  formatterCache.set(key, formatter);\n  return formatter;\n}\n\nconst toDateString = (value: string | ReservationDate | null | undefined): string | null => {\n  if (!value) return null;\n  return typeof value === 'string' ? value : String(value);\n};\n\nexport function formatBookingLabel(option: BookingOption): string {\n  if (BASE_LABELS[option]) {\n    return BASE_LABELS[option];\n  }\n  if ((BOOKING_TYPES_UI as readonly string[]).includes(option)) {\n    return option.replace(/_/g, ' ').replace(/\\b\\w/g, (char) => char.toUpperCase());\n  }\n  return option;\n}\n\nexport function formatReservationDate(\n  value: string | ReservationDate | null | undefined,\n  options?: FormattingOptions,\n): string {\n  const date = toDateString(value);\n  if (!date) return '';\n  try {\n    const formatter = getFormatter(\n      'reservation-date',\n      {\n        weekday: 'long',\n        year: 'numeric',\n        month: 'long',\n        day: 'numeric',\n      },\n      options?.timezone,\n    );\n    const parts = formatter.formatToParts(new Date(`${date}T00:00:00Z`));\n    const weekday = parts.find((part) => part.type === 'weekday')?.value ?? '';\n    const day = parts.find((part) => part.type === 'day')?.value ?? '';\n    const month = parts.find((part) => part.type === 'month')?.value ?? '';\n    const year = parts.find((part) => part.type === 'year')?.value ?? '';\n    const body = [day, month, year].filter(Boolean).join(' ');\n    return [weekday, body].filter(Boolean).join(', ');\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn('[formatReservationDate] failed to format date', { value, error });\n    }\n    return '';\n  }\n}\n\nexport function formatReservationDateShort(\n  value: string | ReservationDate | null | undefined,\n  options?: FormattingOptions,\n): string {\n  const date = toDateString(value);\n  if (!date) return '';\n  try {\n    const formatter = getFormatter(\n      'reservation-date-short',\n      {\n        weekday: 'short',\n        month: 'short',\n        day: '2-digit',\n        year: 'numeric',\n      },\n      options?.timezone,\n    );\n    return formatter.format(new Date(`${date}T00:00:00Z`));\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn('[formatReservationDateShort] failed to format date', { value, error });\n    }\n    return '';\n  }\n}\n\nexport function formatReservationTime(\n  value: string | ReservationTime | null | undefined,\n  _options?: FormattingOptions,\n): string {\n  const normalized = normalizeTime(value);\n  if (!normalized) return '';\n  const [hours = '00', minutes = '00'] = normalized.split(':');\n  return `${hours.padStart(2, '0')}:${minutes.padStart(2, '0')}`;\n}\n\nexport function formatReservationTimeFromDate(date: Date, options?: FormattingOptions): string {\n  try {\n    const formatter = getFormatter(\n      'reservation-time-date',\n      {\n        hour: '2-digit',\n        minute: '2-digit',\n        hour12: false,\n      },\n      options?.timezone,\n    );\n    return formatter.format(date);\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn('[formatReservationTimeFromDate] failed to format date instance', {\n        date,\n        error,\n      });\n    }\n    return '';\n  }\n}\n\nexport function formatReservationSummaryDate(\n  value: string | ReservationDate | null | undefined,\n  options?: FormattingOptions,\n): string {\n  const date = toDateString(value);\n  if (!date) return '';\n  try {\n    const formatter = getFormatter(\n      'reservation-summary-date',\n      {\n        month: 'short',\n        day: '2-digit',\n        year: 'numeric',\n      },\n      options?.timezone,\n    );\n    const parts = formatter.formatToParts(new Date(`${date}T00:00:00Z`));\n    const month = parts.find((part) => part.type === 'month')?.value ?? '';\n    const day = parts.find((part) => part.type === 'day')?.value ?? '';\n    const year = parts.find((part) => part.type === 'year')?.value ?? '';\n    return [month, day, year].filter(Boolean).join(' ').trim();\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn('[formatReservationSummaryDate] failed to format date', { value, error });\n    }\n    return '';\n  }\n}\n\nexport function formatDateForInput(value: Date): string {\n  const year = value.getFullYear();\n  const month = String(value.getMonth() + 1).padStart(2, '0');\n  const day = String(value.getDate()).padStart(2, '0');\n  return `${year}-${month}-${day}`;\n}\n"
    },
    {
      "path": "reserve/shared/hooks/useStickyProgress.ts",
      "category": "shared-hooks",
      "content": "'use client';\n\nimport { useEffect, useState, type MutableRefObject, type RefObject } from 'react';\n\ntype RefLike<TElement extends HTMLElement> =\n  | RefObject<TElement | null>\n  | MutableRefObject<TElement | null>;\n\nexport function useStickyProgress<TElement extends HTMLElement>(anchorRef: RefLike<TElement>) {\n  const [anchorVisible, setAnchorVisible] = useState(true);\n\n  useEffect(() => {\n    const anchor = anchorRef.current;\n    if (!anchor || typeof IntersectionObserver === 'undefined') return;\n\n    const observer = new IntersectionObserver(\n      ([entry]) => {\n        if (entry) {\n          setAnchorVisible(entry.isIntersecting);\n        }\n      },\n      {\n        threshold: 0.75,\n      },\n    );\n\n    observer.observe(anchor);\n    return () => observer.disconnect();\n  }, [anchorRef]);\n\n  return {\n    isAnchorVisible: anchorVisible,\n    shouldShow: true,\n  } as const;\n}\n"
    },
    {
      "path": "reserve/shared/lib/analytics.ts",
      "category": "shared-lib",
      "content": "import { runtime } from '@shared/config/runtime';\n\ntype AnalyticsProps = Record<string, unknown>;\n\ntype PlausibleWindow = Window & {\n  plausible?: (event: string, options?: { props?: AnalyticsProps }) => void;\n};\n\nexport const ANALYTICS_EVENTS = [\n  'select_date',\n  'select_party',\n  'select_time',\n  'confirm_open',\n  'details_submit',\n  'booking_created',\n  'wizard_offline_detected',\n  'wizard_submit_failed',\n  'booking_timeout_unrecovered',\n] as const;\n\nexport type AnalyticsEvent = (typeof ANALYTICS_EVENTS)[number];\n\nconst debugOverride = runtime.readBoolean('RESERVE_ANALYTICS_DEBUG');\nconst debugEnabled =\n  typeof debugOverride === 'boolean' ? debugOverride : runtime.isDev || runtime.isTest;\n\nconst sanitizeProps = (props?: AnalyticsProps): AnalyticsProps | undefined => {\n  if (!props) return undefined;\n  return Object.fromEntries(\n    Object.entries(props).filter(([, value]) => value !== undefined && value !== null),\n  );\n};\n\nexport const track = (event: AnalyticsEvent, props?: AnalyticsProps) => {\n  if (typeof window === 'undefined') return;\n\n  if (!ANALYTICS_EVENTS.includes(event)) {\n    if (debugEnabled) {\n      console.warn('[analytics] refused to send unknown event', event);\n    }\n    return;\n  }\n\n  const payload = sanitizeProps(props);\n  const plausible = (window as PlausibleWindow).plausible;\n\n  try {\n    if (typeof plausible === 'function') {\n      plausible(event, payload ? { props: payload } : undefined);\n    }\n  } catch (error) {\n    if (debugEnabled) {\n      console.warn('[analytics] failed to send event', event, error);\n    }\n  }\n\n  if (debugEnabled) {\n    console.debug('[analytics]', event, payload ?? {});\n  }\n};\n"
    },
    {
      "path": "reserve/shared/lib/cn.ts",
      "category": "shared-lib",
      "content": "export { cn } from '@/lib/utils';\nexport { cn as default } from '@/lib/utils';\n"
    },
    {
      "path": "reserve/shared/lib/haptics.ts",
      "category": "shared-lib",
      "content": "export function triggerSubtleHaptic(pattern: number | number[] = 8) {\n  if (typeof window === 'undefined') return;\n  const vibrate = typeof navigator !== 'undefined' ? navigator.vibrate?.bind(navigator) : undefined;\n  if (vibrate) {\n    try {\n      vibrate(pattern);\n      return;\n    } catch {\n      // fall back to CSS animation\n    }\n  }\n\n  if (typeof document === 'undefined') return;\n  try {\n    document.body?.animate(\n      [\n        { transform: 'scale(1)', opacity: 1 },\n        { transform: 'scale(0.995)', opacity: 0.98 },\n        { transform: 'scale(1)', opacity: 1 },\n      ],\n      { duration: 140, easing: 'ease-out' },\n    );\n  } catch {\n    // ignore when Web Animations API is unavailable\n  }\n}\n"
    },
    {
      "path": "reserve/shared/ui/accordion.tsx",
      "category": "shared-ui",
      "content": "'use client';\n\nexport * from '@/components/ui/accordion';\n"
    },
    {
      "path": "reserve/shared/ui/alert.tsx",
      "category": "shared-ui",
      "content": "'use client';\n\nexport * from '@/components/ui/alert';\n"
    },
    {
      "path": "reserve/shared/ui/badge.tsx",
      "category": "shared-ui",
      "content": "'use client';\n\nexport * from '@/components/ui/badge';\n"
    },
    {
      "path": "reserve/shared/ui/button.tsx",
      "category": "shared-ui",
      "content": "'use client';\n\nexport * from '@/components/ui/button';\n"
    },
    {
      "path": "reserve/shared/ui/calendar.tsx",
      "category": "shared-ui",
      "content": "'use client';\n\nexport * from '@/components/ui/calendar';\n"
    },
    {
      "path": "reserve/shared/ui/card.tsx",
      "category": "shared-ui",
      "content": "'use client';\n\nexport * from '@/components/ui/card';\n"
    },
    {
      "path": "reserve/shared/ui/checkbox.tsx",
      "category": "shared-ui",
      "content": "'use client';\n\nexport * from '@/components/ui/checkbox';\n"
    },
    {
      "path": "reserve/shared/ui/Field.tsx",
      "category": "shared-ui",
      "content": "'use client';\n\nimport { Icon } from '@reserve/shared/ui/icons';\nimport { cn } from '@shared/lib/cn';\nimport { Label } from '@shared/ui/label';\n\nimport type { PropsWithChildren, ReactNode } from 'react';\n\nexport type FieldProps = PropsWithChildren<{\n  id: string;\n  label: string | ReactNode;\n  required?: boolean;\n  error?: string;\n  className?: string;\n}>;\n\nexport function Field({ id, label, required, error, className, children }: FieldProps) {\n  return (\n    <div className={cn('grid w-full items-center gap-1.5', className)}>\n      <Label htmlFor={id} className=\"flex items-center\">\n        {label}\n        {required ? <span className=\"ml-1 text-red-500\">*</span> : null}\n      </Label>\n      {children}\n      {error ? (\n        <p className=\"flex items-center gap-1 text-sm text-red-600\" role=\"alert\">\n          <Icon.AlertCircle className=\"h-4 w-4\" />\n          {error}\n        </p>\n      ) : null}\n    </div>\n  );\n}\n"
    },
    {
      "path": "reserve/shared/ui/form.tsx",
      "category": "shared-ui",
      "content": "'use client';\n\nexport * from '@/components/ui/form';\n"
    },
    {
      "path": "reserve/shared/ui/icons.tsx",
      "category": "shared-ui",
      "content": "import { Icon } from '@/components/reserve/icons';\n\nexport { Icon };\n\nexport type IconKey = keyof typeof Icon;\n"
    },
    {
      "path": "reserve/shared/ui/input.tsx",
      "category": "shared-ui",
      "content": "'use client';\n\nexport * from '@/components/ui/input';\n"
    },
    {
      "path": "reserve/shared/ui/label.tsx",
      "category": "shared-ui",
      "content": "'use client';\n\nexport * from '@/components/ui/label';\n"
    },
    {
      "path": "reserve/shared/ui/popover.tsx",
      "category": "shared-ui",
      "content": "'use client';\n\nexport * from '@/components/ui/popover';\n"
    },
    {
      "path": "reserve/shared/ui/progress.tsx",
      "category": "shared-ui",
      "content": "'use client';\n\nexport * from '@/components/ui/progress';\n"
    },
    {
      "path": "reserve/shared/ui/separator.tsx",
      "category": "shared-ui",
      "content": "'use client';\n\nexport * from '@/components/ui/separator';\n"
    },
    {
      "path": "reserve/shared/ui/textarea.tsx",
      "category": "shared-ui",
      "content": "'use client';\n\nexport * from '@/components/ui/textarea';\n"
    },
    {
      "path": "reserve/shared/ui/toggle-group.tsx",
      "category": "shared-ui",
      "content": "'use client';\n\nexport * from '@/components/ui/toggle-group';\n"
    },
    {
      "path": "reserve/shared/ui/toggle.tsx",
      "category": "shared-ui",
      "content": "'use client';\n\nexport * from '@/components/ui/toggle';\n"
    },
    {
      "path": "src/app/(guest-public)/(guest-experience)/reserve/_components/ReserveApp.tsx",
      "category": "next-reserve-entry",
      "content": "'use client';\n\nimport { useEffect, useMemo } from \"react\";\n\nimport { ReserveRouter } from \"@reserve/app/router\";\n\ntype ReserveAppProps = {\n  initialPath?: string;\n};\n\nconst normalizePath = (value: string | undefined): string => {\n  if (!value) return \"/\";\n  if (value.startsWith(\"/\")) return value;\n  return `/${value}`;\n};\n\nexport default function ReserveApp({ initialPath = \"/\" }: ReserveAppProps) {\n  const normalizedPath = useMemo(() => normalizePath(initialPath), [initialPath]);\n\n  useEffect(() => {\n    if (typeof window === \"undefined\") return;\n    const expected = normalizedPath === \"/\" ? \"/reserve\" : `/reserve${normalizedPath}`;\n    if (window.location.pathname !== expected) {\n      window.history.replaceState(window.history.state, \"\", expected + window.location.search + window.location.hash);\n    }\n  }, [normalizedPath]);\n\n  return <ReserveRouter key={normalizedPath} />;\n}\n"
    },
    {
      "path": "src/app/(guest-public)/(guest-experience)/reserve/[reservationId]/page.tsx",
      "category": "next-reserve-entry",
      "content": "import { HydrationBoundary, QueryClient, dehydrate } from \"@tanstack/react-query\";\nimport { cookies, headers } from \"next/headers\";\nimport { redirect } from \"next/navigation\";\n\nimport { getCanonicalSiteUrl } from \"@/lib/site-url\";\nimport { withRedirectedFrom } from \"@/lib/url/withRedirectedFrom\";\nimport { getServerComponentSupabaseClient } from \"@/server/supabase\";\nimport { reservationAdapter } from \"@entities/reservation/adapter\";\nimport { reservationKeys } from \"@shared/api/queryKeys\";\n\nimport ReservationDetailClient from \"./ReservationDetailClient\";\n\nimport type { Metadata } from \"next\";\n\nexport const dynamic = \"force-dynamic\";\n\ntype RouteParams = Promise<{ reservationId: string }>;\n\nconst shortenId = (value: string): string => (value.length > 8 ? value.slice(0, 8) : value);\n\nconst cookieHeaderFromStore = (cookieStore: Awaited<ReturnType<typeof cookies>>): string => {\n  return cookieStore\n    .getAll()\n    .map(({ name, value }) => `${name}=${value}`)\n    .join(\"; \");\n};\n\nconst resolveOrigin = (requestHeaders: Headers): string => {\n  const forwardedHost = requestHeaders.get(\"x-forwarded-host\") ?? requestHeaders.get(\"host\");\n  const forwardedProto = requestHeaders.get(\"x-forwarded-proto\");\n  if (forwardedHost) {\n    return `${forwardedProto ?? \"https\"}://${forwardedHost}`;\n  }\n  return process.env.NEXT_PUBLIC_SITE_URL ?? getCanonicalSiteUrl();\n};\n\nasync function prefetchReservation(queryClient: QueryClient, reservationId: string) {\n  const requestHeaders = await headers();\n  const cookieStore = await cookies();\n  const cookieHeader = cookieHeaderFromStore(cookieStore);\n  const origin = resolveOrigin(requestHeaders);\n\n  try {\n    const response = await fetch(`${origin}/api/bookings/${reservationId}`, {\n      headers: {\n        accept: \"application/json\",\n        ...(cookieHeader ? { cookie: cookieHeader } : {}),\n      },\n      cache: \"no-store\",\n    });\n\n    if (!response.ok) {\n      return;\n    }\n\n    const payload = await response.json();\n    if (!payload?.booking) {\n      return;\n    }\n\n    const normalizedReservation = reservationAdapter(payload.booking);\n    queryClient.setQueryData(reservationKeys.detail(reservationId), normalizedReservation);\n  } catch (error) {\n    console.error(\"[reservation-detail][prefetch]\", error);\n  }\n}\n\nexport async function generateMetadata({ params }: { params: RouteParams }): Promise<Metadata> {\n  const { reservationId } = await params;\n  const safeId = reservationId?.trim() || \"reservation\";\n  return {\n    title: `Reservation ${shortenId(safeId)}  SajiloReserveX`,\n    description: \"Review the latest status, timing, and actions for your SajiloReserveX booking.\",\n  };\n}\n\nexport default async function ReservationDetailPage({ params }: { params: RouteParams }) {\n  const { reservationId } = await params;\n  const normalized = reservationId?.trim();\n\n  if (!normalized) {\n    redirect(\"/reserve\");\n  }\n\n  const supabase = await getServerComponentSupabaseClient();\n  const {\n    data: { user },\n  } = await supabase.auth.getUser();\n\n  if (!user) {\n    redirect(withRedirectedFrom(\"/signin\", `/reserve/${normalized}`));\n  }\n\n  const queryClient = new QueryClient();\n  await prefetchReservation(queryClient, normalized);\n  const dehydratedState = dehydrate(queryClient);\n\n  return (\n    <HydrationBoundary state={dehydratedState}>\n      <ReservationDetailClient reservationId={normalized} restaurantName={null} />\n    </HydrationBoundary>\n  );\n}\n"
    },
    {
      "path": "src/app/(guest-public)/(guest-experience)/reserve/[reservationId]/ReservationDetailClient.tsx",
      "category": "next-reserve-entry",
      "content": "'use client';\n\nimport Link from 'next/link';\nimport { useRouter, useSearchParams } from 'next/navigation';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\n\nimport { CancelBookingDialog } from '@/components/dashboard/CancelBookingDialog';\nimport { EditBookingDialog } from '@/components/dashboard/EditBookingDialog';\nimport { StatusChip } from '@/components/dashboard/StatusChip';\nimport { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';\nimport { Button, buttonVariants } from '@/components/ui/button';\nimport { Skeleton } from '@/components/ui/skeleton';\nimport config from '@/config';\nimport { useOnlineStatus } from '@/hooks/useOnlineStatus';\nimport { track } from '@/lib/analytics';\nimport { emit } from '@/lib/analytics/emit';\nimport { getPendingSelfServeGraceMinutes, isPendingSelfServeLocked } from '@/lib/bookings/pendingLock';\nimport { downloadCalendarEvent, shareReservationDetails, type ShareResult } from '@/lib/reservations/share';\nimport { useReservation } from '@features/reservations/wizard/api/useReservation';\nimport { DEFAULT_VENUE } from '@shared/config/venue';\n\nimport { ReservationHistory } from './ReservationHistory';\n\nimport type { BookingDTO } from '@/hooks/useBookings';\nimport type { Reservation } from '@entities/reservation/reservation.schema';\n\nexport type ReservationVenue = {\n  name: string;\n  address: string;\n  timezone: string;\n  slug?: string | null;\n};\n\nconst sanitizeJsonLd = (value: string | null | undefined) => {\n  if (!value) {\n    return null;\n  }\n  return value.replace(/</g, '\\\\u003c');\n};\n\nconst formatDate = (iso: string | null | undefined) => {\n  if (!iso) return '';\n  const parsed = new Date(iso);\n  if (Number.isNaN(parsed.getTime())) return '';\n  return new Intl.DateTimeFormat(undefined, {\n    dateStyle: 'full',\n  }).format(parsed);\n};\n\nconst formatTimeRange = (startIso: string | null | undefined, endIso: string | null | undefined) => {\n  if (!startIso) return '';\n  const start = new Date(startIso);\n  if (Number.isNaN(start.getTime())) return '';\n  const timeFormatter = new Intl.DateTimeFormat(undefined, {\n    hour: 'numeric',\n    minute: 'numeric',\n  });\n  const startLabel = timeFormatter.format(start);\n  if (!endIso) {\n    return startLabel;\n  }\n  const end = new Date(endIso);\n  if (Number.isNaN(end.getTime())) {\n    return startLabel;\n  }\n  return `${startLabel}  ${timeFormatter.format(end)}`;\n};\n\nconst buildBookingDto = (\n  reservation: Reservation | undefined,\n  restaurantName: string | null,\n  venue: ReservationVenue,\n): BookingDTO | null => {\n  if (!reservation) return null;\n  return {\n    id: reservation.id,\n    restaurantId: reservation.restaurantId,\n    restaurantName: restaurantName ?? 'Reservation',\n    restaurantSlug: venue.slug ?? DEFAULT_VENUE.slug,\n    restaurantTimezone: venue.timezone,\n    partySize: reservation.partySize,\n    startIso: reservation.startAt,\n    endIso: reservation.endAt ?? reservation.startAt,\n    status: reservation.status as BookingDTO['status'],\n    notes: reservation.notes ?? null,\n  };\n};\n\nconst buildReservationJsonLd = (reservation: Reservation, venue: ReservationVenue) => ({\n  '@context': 'https://schema.org',\n  '@type': 'Reservation',\n  reservationNumber: reservation.reference ?? reservation.id,\n  reservationStatus: reservation.status,\n  reservationFor: {\n    '@type': 'FoodEstablishment',\n    name: venue.name,\n    address: venue.address,\n  },\n  partySize: reservation.partySize,\n  startTime: reservation.startAt ? new Date(reservation.startAt).toISOString() : undefined,\n});\n\nexport type ReservationDetailClientProps = {\n  reservationId: string;\n  restaurantName: string | null;\n  structuredData?: string | null;\n  venue?: ReservationVenue | null;\n};\n\nexport function ReservationDetailClient({\n  reservationId,\n  restaurantName,\n  structuredData,\n  venue: providedVenue,\n}: ReservationDetailClientProps) {\n  const router = useRouter();\n  const searchParams = useSearchParams();\n  const [isEditOpen, setIsEditOpen] = useState(false);\n  const [isCancelOpen, setIsCancelOpen] = useState(false);\n  const viewTrackedRef = useRef(false);\n  const isOnline = useOnlineStatus();\n  const lastOnlineAtRef = useRef<number>(Date.now());\n  const offlineTrackedRef = useRef(false);\n  const [shareFeedback, setShareFeedback] = useState<ShareResult | null>(null);\n  const feedbackTimerRef = useRef<ReturnType<typeof setTimeout> | null>(null);\n  const [calendarLoading, setCalendarLoading] = useState(false);\n  const [shareLoading, setShareLoading] = useState(false);\n  const [downloadLoading, setDownloadLoading] = useState(false);\n  const calendarButtonRef = useRef<HTMLButtonElement | null>(null);\n  const shareButtonRef = useRef<HTMLButtonElement | null>(null);\n  const shareAlertVariant = shareFeedback\n    ? shareFeedback.variant === 'error'\n      ? 'destructive'\n      : shareFeedback.variant === 'warning'\n        ? 'warning'\n        : shareFeedback.variant === 'info'\n          ? 'info'\n          : 'success'\n    : 'info';\n  const pendingGraceMinutes = useMemo(() => getPendingSelfServeGraceMinutes(), []);\n  const supportEmail = config.email?.supportEmail ?? 'support@example.com';\n  const [clockNow, setClockNow] = useState(() => Date.now());\n\n  const { data: reservation, error, isError, isLoading, refetch, isFetching } = useReservation(reservationId);\n\n  // Calculate venue info before any early returns\n  const venue = useMemo<ReservationVenue>(() => {\n    if (providedVenue) {\n      return {\n        name: providedVenue.name ?? DEFAULT_VENUE.name,\n        address: providedVenue.address ?? DEFAULT_VENUE.address,\n        timezone: providedVenue.timezone ?? DEFAULT_VENUE.timezone,\n        slug: providedVenue.slug ?? DEFAULT_VENUE.slug,\n      };\n    }\n    return {\n      name: restaurantName ?? reservation?.restaurantName ?? DEFAULT_VENUE.name,\n      address: DEFAULT_VENUE.address,\n      timezone: DEFAULT_VENUE.timezone,\n      slug: DEFAULT_VENUE.slug,\n    };\n  }, [providedVenue, reservation?.restaurantName, restaurantName]);\n\n  const bookingDto = useMemo(\n    () => buildBookingDto(reservation, restaurantName, venue),\n    [reservation, restaurantName, venue],\n  );\n\n  // Calculate share payload before any early returns\n  const sharePayload = useMemo(() => {\n    if (!reservation) return null;\n    return {\n      reservationId,\n      reference: reservation.reference ?? null,\n      guestName: reservation.customerName,\n      partySize: reservation.partySize,\n      startAt: reservation.startAt,\n      endAt: reservation.endAt ?? undefined,\n      venueName: venue.name,\n      venueAddress: venue.address,\n      venueTimezone: venue.timezone,\n    };\n  }, [reservation, reservationId, venue.address, venue.name, venue.timezone]);\n\n  const handleDownloadConfirmation = useCallback(() => {\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    if (!reservation) {\n      setShareFeedback({ variant: 'warning', message: 'Reservation details not ready yet.' });\n      return;\n    }\n\n    const targetId = reservation.id ?? reservationId;\n    setDownloadLoading(true);\n    try {\n      const link = document.createElement('a');\n      link.href = `/api/reservations/${targetId}/confirmation`;\n      link.download = `reservation-${reservation.reference ?? targetId}.pdf`;\n      link.rel = 'noopener noreferrer';\n      document.body.appendChild(link);\n      link.click();\n      document.body.removeChild(link);\n    } catch (error) {\n      console.error('[reservation-detail] download failed', error);\n      setShareFeedback({\n        variant: 'error',\n        message: \"We couldn't download the confirmation. Please try again.\",\n      });\n    } finally {\n      setDownloadLoading(false);\n    }\n  }, [reservation, reservationId]);\n\n  const pendingLock = useMemo(() => {\n    if (!reservation || reservation.status !== 'pending') {\n      return { locked: false, lockTimestamp: null as number | null };\n    }\n    const locked = isPendingSelfServeLocked(reservation.status, reservation.createdAt, clockNow);\n    const createdMs = reservation.createdAt ? Date.parse(reservation.createdAt) : Number.NaN;\n    const lockTimestamp = Number.isFinite(createdMs)\n      ? createdMs + pendingGraceMinutes * 60_000\n      : null;\n    return { locked, lockTimestamp };\n  }, [reservation, pendingGraceMinutes, clockNow]);\n\n  const pendingSupportHref = useMemo(() => {\n    const target = supportEmail;\n    if (!reservation) {\n      return `mailto:${target}`;\n    }\n    const subject = `Reservation change request (${reservation.reference ?? reservation.id})`;\n    const details = [\n      'Hi team,',\n      '',\n      'I need help updating or cancelling this pending reservation while it is under review.',\n      `Reservation ID: ${reservation.id}`,\n      reservation.reference ? `Reference: ${reservation.reference}` : null,\n      `Name: ${reservation.customerName}`,\n      reservation.startAt ? `Start: ${formatDate(reservation.startAt)} at ${formatTimeRange(reservation.startAt, reservation.endAt ?? reservation.startAt)}` : null,\n    ].filter(Boolean);\n    return `mailto:${target}?subject=${encodeURIComponent(subject)}&body=${encodeURIComponent(details.join('\\n'))}`;\n  }, [reservation, supportEmail]);\n\n  // Calculate JSON-LD before any early returns\n  const reservationJsonLdString = useMemo(() => {\n    const provided = typeof structuredData === 'string' && structuredData.length > 0 ? structuredData : null;\n    const sanitizedProvided = sanitizeJsonLd(provided);\n    if (sanitizedProvided) {\n      return sanitizedProvided;\n    }\n\n    if (!reservation) {\n      return null;\n    }\n\n    return sanitizeJsonLd(JSON.stringify(buildReservationJsonLd(reservation, venue)));\n  }, [reservation, structuredData, venue]);\n\n  useEffect(() => {\n    if (typeof window === 'undefined') {\n      return;\n    }\n\n    if (isOnline) {\n      lastOnlineAtRef.current = Date.now();\n      offlineTrackedRef.current = false;\n      return;\n    }\n\n    if (offlineTrackedRef.current) {\n      return;\n    }\n\n    const wasOnlineForMs = Date.now() - lastOnlineAtRef.current;\n    const payload = {\n      path: window.location?.pathname ?? '/reserve',\n      wasOnlineForMs: Number.isFinite(wasOnlineForMs) ? wasOnlineForMs : undefined,\n    };\n    track('network_offline', payload);\n    void emit('network_offline', payload);\n    offlineTrackedRef.current = true;\n  }, [isOnline]);\n\n  useEffect(() => {\n    if (!shareFeedback) {\n      if (feedbackTimerRef.current) {\n        clearTimeout(feedbackTimerRef.current);\n        feedbackTimerRef.current = null;\n      }\n      return;\n    }\n\n    feedbackTimerRef.current = setTimeout(() => {\n      setShareFeedback(null);\n      feedbackTimerRef.current = null;\n    }, 6000);\n\n    return () => {\n      if (feedbackTimerRef.current) {\n        clearTimeout(feedbackTimerRef.current);\n        feedbackTimerRef.current = null;\n      }\n    };\n  }, [shareFeedback]);\n\n  useEffect(() => {\n    if (!reservation || viewTrackedRef.current) return;\n    viewTrackedRef.current = true;\n    void emit('reservation_detail_viewed', {\n      reservationId,\n      status: reservation.status,\n    });\n  }, [reservation, reservationId]);\n\n  useEffect(() => {\n    if (!reservation || reservation.status !== 'pending' || pendingLock.locked) {\n      return;\n    }\n\n    const interval = window.setInterval(() => {\n      setClockNow(Date.now());\n    }, 15_000);\n\n    return () => {\n      window.clearInterval(interval);\n    };\n  }, [reservation, pendingLock.locked]);\n\n  useEffect(() => {\n    const actionParam = searchParams?.get('action');\n    if (!actionParam) {\n      return;\n    }\n\n    if (actionParam === 'calendar' && calendarButtonRef.current) {\n      calendarButtonRef.current.focus();\n      calendarButtonRef.current.scrollIntoView({ behavior: 'smooth', block: 'center' });\n      setShareFeedback({ variant: 'info', message: 'Tap the button below to download your calendar event.' });\n    } else if (actionParam === 'wallet' && shareButtonRef.current) {\n      shareButtonRef.current.focus();\n      shareButtonRef.current.scrollIntoView({ behavior: 'smooth', block: 'center' });\n      setShareFeedback({ variant: 'info', message: 'Tap the button below to share your reservation details.' });\n    }\n  }, [searchParams]);\n\n  const handleEdit = useCallback(() => {\n    if (!reservation || pendingLock.locked) return;\n    void emit('reservation_detail_edit_clicked', { reservationId });\n    setIsEditOpen(true);\n  }, [pendingLock.locked, reservation, reservationId]);\n\n  const handleCancel = useCallback(() => {\n    if (!reservation || pendingLock.locked) return;\n    void emit('reservation_detail_cancel_clicked', { reservationId });\n    setIsCancelOpen(true);\n  }, [pendingLock.locked, reservation, reservationId]);\n\n  const handleRebook = useCallback(() => {\n    if (!reservation) return;\n    void emit('reservation_detail_rebook_clicked', {\n      reservationId,\n      party: reservation.partySize,\n    });\n    router.push(`/?source=rebook&reservationId=${reservation.id}`);\n  }, [reservation, reservationId, router]);\n\n  const closeEditDialog = useCallback((open: boolean) => {\n    setIsEditOpen(open);\n  }, []);\n\n  const closeCancelDialog = useCallback((open: boolean) => {\n    setIsCancelOpen(open);\n  }, []);\n\n  const actionDisabled = reservation ? reservation.status === 'cancelled' || pendingLock.locked : true;\n\n  if (isLoading && !reservation) {\n    return (\n      <section className=\"mx-auto flex w-full max-w-3xl flex-col gap-6 px-4 py-12\" aria-busy>\n        <Skeleton className=\"h-5 w-24\" />\n        <Skeleton className=\"h-10 w-2/3\" />\n        <Skeleton className=\"h-32 w-full\" />\n        <Skeleton className=\"h-16 w-full\" />\n      </section>\n    );\n  }\n\n  if (isError && !reservation) {\n    return (\n      <section className=\"mx-auto w-full max-w-3xl space-y-6 px-4 py-12\">\n        <Alert variant=\"destructive\">\n          <div className=\"space-y-2\">\n            <AlertTitle>Unable to load reservation</AlertTitle>\n            <AlertDescription>\n              {error?.message ?? 'Something went wrong while fetching the reservation details.'}\n            </AlertDescription>\n          </div>\n          <div className=\"ml-auto flex flex-wrap gap-3\">\n            <Button variant=\"outline\" onClick={() => refetch()} disabled={isFetching}>\n              Retry\n            </Button>\n            <Link href=\"/\" className={buttonVariants({ variant: 'default' })}>\n              Back to booking\n            </Link>\n          </div>\n        </Alert>\n      </section>\n    );\n  }\n\n  if (!reservation) {\n    return null;\n  }\n\n  const reservationDate = formatDate(reservation.startAt);\n  const reservationTime = formatTimeRange(reservation.startAt, reservation.endAt);\n\n  const warnings: Array<{ id: string; title: string; description: string; variant: 'warning' | 'info' }> = [];\n\n  if (reservation.status === 'pending_allocation') {\n    warnings.push({\n      id: 'allocation',\n      title: 'We are finding you a table',\n      description:\n        'Thanks for your patienceour team is confirming a table for your party. We will email you as soon as the booking is allocated.',\n      variant: 'warning',\n    });\n  } else if (reservation.status === 'pending') {\n    warnings.push({\n      id: 'pending',\n      title: 'Reservation awaiting confirmation',\n      description:\n        'This reservation is awaiting confirmation. Our team will update you shortly; feel free to reach out if your plans change.',\n      variant: 'info',\n    });\n  }\n\n  const metadataConflict = reservation.metadata?.conflict?.reason;\n  if (metadataConflict) {\n    warnings.push({\n      id: 'conflict',\n      title: 'Schedule conflict detected',\n      description:\n        reservation.metadata?.conflict?.reason ?? 'A conflict was detected for this reservation. Please review the details and adjust.',\n      variant: 'warning',\n    });\n  }\n\n  const metadataRescheduled = reservation.metadata?.rescheduledFrom;\n  if (metadataRescheduled) {\n    const previousDate = formatDate(metadataRescheduled);\n    warnings.push({\n      id: 'rescheduled',\n      title: 'Reservation rescheduled',\n      description: `This reservation was moved from ${previousDate}. Double-check the new time before you arrive.`,\n      variant: 'info',\n    });\n  }\n\n  return (\n    <>\n      {reservationJsonLdString ? (\n        <script\n          type=\"application/ld+json\"\n          suppressHydrationWarning\n          dangerouslySetInnerHTML={{ __html: reservationJsonLdString }}\n        />\n      ) : null}\n      <section className=\"mx-auto w-full max-w-4xl space-y-8 px-4 py-12\">\n        {!isOnline ? (\n          <Alert variant=\"warning\" role=\"status\" aria-live=\"polite\">\n            <div>\n              <AlertTitle>No internet connection</AlertTitle>\n              <AlertDescription>\n                You&apos;re offline. Sharing actions are disabled until you reconnect.\n              </AlertDescription>\n            </div>\n          </Alert>\n        ) : null}\n\n        {shareFeedback ? (\n          <Alert variant={shareAlertVariant} role=\"status\" aria-live=\"polite\">\n            <AlertDescription>{shareFeedback.message}</AlertDescription>\n          </Alert>\n        ) : null}\n\n        <div className=\"flex flex-wrap items-center justify-between gap-3\">\n          <div className=\"space-y-2\">\n            <Link href=\"/my-bookings\" className=\"text-sm text-primary underline-offset-4 hover:underline\">\n               Back to dashboard\n            </Link>\n            <h1 className=\"text-3xl font-semibold text-foreground\">Reservation details</h1>\n            <p className=\"text-muted-foreground\">\n              {reservation.reference ? `Reference ${reservation.reference}` : 'Manage your upcoming visit.'}\n            </p>\n          </div>\n          <StatusChip status={reservation.status as BookingDTO['status']} />\n        </div>\n\n      {warnings.map((warning) => (\n        <Alert key={warning.id} variant={warning.variant}>\n          <div>\n            <AlertTitle>{warning.title}</AlertTitle>\n            <AlertDescription>{warning.description}</AlertDescription>\n          </div>\n        </Alert>\n      ))}\n\n      {pendingLock.locked ? (\n        <Alert variant=\"info\" role=\"status\" aria-live=\"polite\">\n          <div className=\"space-y-2\">\n            <div>\n              <AlertTitle>Your request is pending review</AlertTitle>\n              <AlertDescription>\n                We temporarily pause self-serve edits while the restaurant reviews pending bookings.\n                You can request a change below or wait until the booking is confirmed (typically within about {pendingGraceMinutes} minutes).\n              </AlertDescription>\n            </div>\n            <Button asChild variant=\"outline\">\n              <a href={pendingSupportHref} target=\"_blank\" rel=\"noopener noreferrer\">\n                Request a change\n              </a>\n            </Button>\n          </div>\n        </Alert>\n      ) : null}\n\n      <div className=\"rounded-[var(--radius-lg)] border border-border bg-card shadow-sm\">\n        <div className=\"flex flex-col gap-4 border-b border-border/80 p-6 sm:flex-row sm:items-center sm:justify-between\">\n          <div className=\"space-y-1\">\n            <h2 className=\"text-xl font-semibold text-foreground\">\n              {restaurantName ?? 'Your reservation'}\n            </h2>\n            <p className=\"text-sm text-muted-foreground\">{reservationDate}</p>\n            <p className=\"text-sm text-muted-foreground\">\n              {reservationTime}  party of {reservation.partySize}\n            </p>\n          </div>\n          <div className=\"flex flex-wrap items-center gap-3\">\n            <Button variant=\"default\" onClick={handleRebook} disabled={isFetching}>\n              Rebook\n            </Button>\n            <Button variant=\"outline\" onClick={handleEdit} disabled={actionDisabled}>\n              Edit\n            </Button>\n            <Button variant=\"destructive\" onClick={handleCancel} disabled={actionDisabled}>\n              Cancel\n            </Button>\n            <Button\n              variant=\"outline\"\n              onClick={() => {\n                if (!sharePayload) {\n                  setShareFeedback({ variant: 'warning', message: 'Reservation details not ready yet.' });\n                  return;\n                }\n                void emit('reservation_detail_calendar_clicked', { reservationId });\n                setCalendarLoading(true);\n                const result = downloadCalendarEvent(sharePayload);\n                setCalendarLoading(false);\n                setShareFeedback(result);\n              }}\n              disabled={!sharePayload || calendarLoading}\n              ref={calendarButtonRef}\n            >\n              {calendarLoading ? 'Preparing' : 'Add to calendar'}\n            </Button>\n            <Button\n              variant=\"outline\"\n              onClick={async () => {\n                if (!sharePayload) {\n                  setShareFeedback({ variant: 'warning', message: 'Reservation details not ready yet.' });\n                  return;\n                }\n                void emit('reservation_detail_share_clicked', { reservationId });\n                setShareLoading(true);\n                const result = await shareReservationDetails(sharePayload);\n                setShareLoading(false);\n                setShareFeedback(result);\n              }}\n              disabled={!isOnline || !sharePayload || shareLoading}\n              ref={shareButtonRef}\n            >\n              {shareLoading ? 'Sharing' : 'Share details'}\n            </Button>\n            <Button\n              variant=\"outline\"\n              onClick={handleDownloadConfirmation}\n              disabled={downloadLoading || !reservation}\n            >\n              {downloadLoading ? 'Preparing' : 'Download confirmation'}\n            </Button>\n          </div>\n        </div>\n\n        <div className=\"grid gap-6 p-6 md:grid-cols-2\">\n          <div className=\"space-y-1\">\n            <h3 className=\"text-sm font-semibold text-muted-foreground\">Guest name</h3>\n            <p className=\"text-base text-foreground\">{reservation.customerName}</p>\n          </div>\n          <div className=\"space-y-1\">\n            <h3 className=\"text-sm font-semibold text-muted-foreground\">Contact</h3>\n            <p className=\"text-base text-foreground\">{reservation.customerEmail}</p>\n            <p className=\"text-base text-muted-foreground\">{reservation.customerPhone}</p>\n          </div>\n          <div className=\"space-y-1\">\n            <h3 className=\"text-sm font-semibold text-muted-foreground\">Seating preference</h3>\n            <p className=\"text-base text-foreground\">{reservation.seatingPreference}</p>\n          </div>\n          <div className=\"space-y-1\">\n            <h3 className=\"text-sm font-semibold text-muted-foreground\">Booking type</h3>\n            <p className=\"text-base text-foreground\">{reservation.bookingType}</p>\n          </div>\n          <div className=\"space-y-1 md:col-span-2\">\n            <h3 className=\"text-sm font-semibold text-muted-foreground\">Notes</h3>\n            <p className=\"text-base text-foreground\">\n              {reservation.notes?.trim() ? reservation.notes : 'No special notes added.'}\n            </p>\n          </div>\n        </div>\n      </div>\n\n      <ReservationHistory reservationId={reservationId} />\n\n      {bookingDto ? (\n        <>\n          <EditBookingDialog\n            booking={bookingDto}\n            open={isEditOpen}\n            onOpenChange={closeEditDialog}\n            restaurantSlug={venue.slug ?? bookingDto.restaurantSlug ?? null}\n            restaurantTimezone={venue.timezone ?? bookingDto.restaurantTimezone ?? null}\n          />\n          <CancelBookingDialog booking={bookingDto} open={isCancelOpen} onOpenChange={closeCancelDialog} />\n        </>\n      ) : null}\n      </section>\n    </>\n  );\n}\n\nexport default ReservationDetailClient;\n"
    },
    {
      "path": "src/app/(guest-public)/(guest-experience)/reserve/[reservationId]/ReservationHistory.tsx",
      "category": "next-reserve-entry",
      "content": "'use client';\n\nimport { useMemo } from 'react';\n\nimport { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';\nimport { Badge } from '@/components/ui/badge';\nimport { Skeleton } from '@/components/ui/skeleton';\nimport { useBookingHistory } from '@/hooks/useBookingHistory';\nimport { cn } from '@/lib/utils';\nimport { formatBookingLabel, formatReservationDate, formatReservationTime } from '@reserve/shared/formatting/booking';\nimport { normalizeTime } from '@reserve/shared/time';\n\nimport type { BookingHistoryChange } from '@/types/bookingHistory';\n\nconst STATUS_LABELS: Record<string, string> = {\n  confirmed: 'Confirmed',\n  cancelled: 'Cancelled',\n  pending: 'Pending',\n  pending_allocation: 'Pending allocation',\n};\n\nconst SEATING_LABELS: Record<string, string> = {\n  any: 'No preference',\n  indoor: 'Indoor',\n  outdoor: 'Outdoor',\n  window: 'Window',\n  booth: 'Booth',\n  bar: 'Bar',\n};\n\nfunction formatChangeValue(change: BookingHistoryChange): string {\n  const { field, after } = change;\n\n  if (after === null || after === undefined) {\n    return '';\n  }\n\n  if (field === 'booking_date' && typeof after === 'string') {\n    return formatReservationDate(after);\n  }\n\n  if ((field === 'start_time' || field === 'end_time') && typeof after === 'string') {\n    return formatReservationTime(normalizeTime(after) ?? after);\n  }\n\n  if (field === 'party_size') {\n    return String(after);\n  }\n\n  if (field === 'booking_type' && typeof after === 'string') {\n    return formatBookingLabel(after as Parameters<typeof formatBookingLabel>[0]);\n  }\n\n  if (field === 'seating_preference' && typeof after === 'string') {\n    return SEATING_LABELS[after] ?? after;\n  }\n\n  if (field === 'status' && typeof after === 'string') {\n    return STATUS_LABELS[after] ?? after;\n  }\n\n  if (typeof after === 'boolean') {\n    return after ? 'Yes' : 'No';\n  }\n\n  if (typeof after === 'string') {\n    return after;\n  }\n\n  return String(after);\n}\n\nfunction formatBeforeValue(change: BookingHistoryChange): string {\n  const { field, before } = change;\n\n  if (before === null || before === undefined) {\n    return '';\n  }\n\n  if (field === 'booking_date' && typeof before === 'string') {\n    return formatReservationDate(before);\n  }\n\n  if ((field === 'start_time' || field === 'end_time') && typeof before === 'string') {\n    return formatReservationTime(normalizeTime(before) ?? before);\n  }\n\n  if (field === 'party_size') {\n    return String(before);\n  }\n\n  if (field === 'booking_type' && typeof before === 'string') {\n    return formatBookingLabel(before as Parameters<typeof formatBookingLabel>[0]);\n  }\n\n  if (field === 'seating_preference' && typeof before === 'string') {\n    return SEATING_LABELS[before] ?? before;\n  }\n\n  if (field === 'status' && typeof before === 'string') {\n    return STATUS_LABELS[before] ?? before;\n  }\n\n  if (typeof before === 'boolean') {\n    return before ? 'Yes' : 'No';\n  }\n\n  if (typeof before === 'string') {\n    return before;\n  }\n\n  return String(before);\n}\n\nexport function ReservationHistory({ reservationId }: { reservationId: string }) {\n  const historyQuery = useBookingHistory(reservationId);\n\n  const formatter = useMemo(\n    () =>\n      new Intl.DateTimeFormat(undefined, {\n        dateStyle: 'medium',\n        timeStyle: 'short',\n      }),\n    [],\n  );\n\n  if (historyQuery.isLoading) {\n    return (\n      <section className=\"rounded-[var(--radius-lg)] border border-border bg-card p-6 shadow-sm\">\n        <header className=\"mb-4\">\n          <h2 className=\"text-lg font-semibold text-foreground\">History</h2>\n          <p className=\"text-sm text-muted-foreground\">Loading recent changes</p>\n        </header>\n        <div className=\"space-y-3\">\n          {Array.from({ length: 3 }).map((_, idx) => (\n            <Skeleton key={idx} className=\"h-20 w-full\" />\n          ))}\n        </div>\n      </section>\n    );\n  }\n\n  if (historyQuery.isError) {\n    return (\n      <section className=\"rounded-[var(--radius-lg)] border border-border bg-card p-6 shadow-sm\">\n        <header className=\"mb-4\">\n          <h2 className=\"text-lg font-semibold text-foreground\">History</h2>\n          <p className=\"text-sm text-muted-foreground\">Review how this reservation changed over time.</p>\n        </header>\n        <Alert variant=\"destructive\">\n          <AlertTitle>Unable to load history</AlertTitle>\n          <AlertDescription>{historyQuery.error?.message ?? 'Please try again later.'}</AlertDescription>\n        </Alert>\n      </section>\n    );\n  }\n\n  const events = historyQuery.data?.events ?? [];\n\n  return (\n    <section className=\"rounded-[var(--radius-lg)] border border-border bg-card p-6 shadow-sm\">\n      <header className=\"mb-4\">\n        <h2 className=\"text-lg font-semibold text-foreground\">History</h2>\n        <p className=\"text-sm text-muted-foreground\">Track edits and cancellations for this reservation.</p>\n      </header>\n\n      {events.length === 0 ? (\n        <p className=\"text-sm text-muted-foreground\">No changes recorded yet.</p>\n      ) : (\n        <ul className=\"space-y-4\">\n          {events.map((event) => {\n            const actorLabel = event.actor && event.actor.trim().length > 0 ? event.actor.trim() : 'system';\n            const actorDisplay = actorLabel.toLowerCase() === 'system' ? 'System' : actorLabel;\n\n            return (\n              <li key={event.versionId} className=\"space-y-3 rounded-lg border border-border/60 p-4\">\n                <div className=\"flex flex-wrap items-center justify-between gap-3\">\n                  <div>\n                    <p className=\"text-sm font-semibold text-foreground\">{event.summary}</p>\n                    <p className=\"text-xs text-muted-foreground\">\n                      {formatter.format(new Date(event.changedAt))}\n                    </p>\n                  </div>\n                  <Badge variant=\"outline\" className=\"text-xs font-medium\">\n                    {actorDisplay}\n                  </Badge>\n                </div>\n\n                {event.changes.length > 0 ? (\n                  <dl className=\"space-y-2\">\n                    {event.changes.map((change) => (\n                      <div key={`${event.versionId}-${change.field}`} className=\"grid gap-3 sm:grid-cols-[180px,1fr]\">\n                        <dt className=\"text-xs font-semibold uppercase tracking-[0.18em] text-muted-foreground\">\n                          {change.label}\n                        </dt>\n                        <dd className=\"text-sm text-foreground\">\n                          <span\n                            className={cn(\n                              'inline-flex flex-wrap items-center gap-1',\n                              'rounded-full bg-muted px-2 py-1 text-xs font-medium text-muted-foreground',\n                            )}\n                          >\n                            <span>{formatBeforeValue(change)}</span>\n                            <span aria-hidden></span>\n                            <span className=\"text-foreground\">{formatChangeValue(change)}</span>\n                          </span>\n                        </dd>\n                      </div>\n                    ))}\n                  </dl>\n                ) : (\n                  <p className=\"text-sm text-muted-foreground\">No notable field changes recorded.</p>\n                )}\n              </li>\n            );\n          })}\n        </ul>\n      )}\n    </section>\n  );\n}\n"
    },
    {
      "path": "src/app/(guest-public)/(guest-experience)/reserve/page.tsx",
      "category": "next-reserve-entry",
      "content": "import ReserveApp from \"./_components/ReserveApp\";\n\nimport type { Metadata } from \"next\";\n\n\nexport const dynamic = \"force-dynamic\";\n\nexport const metadata: Metadata = {\n  title: \"Reserve a table  SajiloReserveX\",\n  description: \"Pick a SajiloReserveX partner restaurant and book your next visit in seconds.\",\n  robots: {\n    index: false,\n    follow: false,\n  },\n};\n\nexport default function ReserveEntryPage() {\n  return <ReserveApp initialPath=\"/\" />;\n}\n"
    },
    {
      "path": "src/app/(guest-public)/(guest-experience)/reserve/r/[slug]/page.tsx",
      "category": "next-reserve-entry",
      "content": "import ReserveApp from \"../../_components/ReserveApp\";\n\nimport type { Metadata } from \"next\";\n\n\nexport const dynamic = \"force-dynamic\";\n\ntype RouteParams = Promise<{ slug: string }>;\n\nexport async function generateMetadata({ params }: { params: RouteParams }): Promise<Metadata> {\n  const { slug } = await params;\n  const safeSlug = slug?.replace(/-/g, \" \").replace(/\\s+/g, \" \").trim() || \"restaurant\";\n  return {\n    title: `Book ${safeSlug}  SajiloReserveX`,\n    description: \"Reserve your table instantly with live availability and instant confirmation.\",\n  };\n}\n\nexport default async function ReserveRestaurantPage({ params }: { params: RouteParams }) {\n  const { slug } = await params;\n  const normalized = slug?.trim() ?? \"\";\n  const initialPath = normalized ? `/r/${normalized}` : \"/\";\n  return <ReserveApp initialPath={initialPath} />;\n}\n"
    }
  ]
}
