{
  "server/capacity/tables.ts": "import { randomUUID } from \"node:crypto\";\n\nimport { DateTime } from \"luxon\";\n\nimport {\n  bandDuration,\n  getBufferConfig,\n  getSelectorScoringConfig,\n  getVenuePolicy,\n  serviceEnd,\n  whichService,\n  type ServiceKey,\n  type VenuePolicy,\n  ServiceNotFoundError,\n  ServiceOverrunError,\n} from \"./policy\";\nimport { buildScoredTablePlans, type RankedTablePlan } from \"./selector\";\nimport {\n  emitHoldConfirmed,\n  emitRpcConflict,\n  emitSelectorDecision,\n  emitSelectorQuote,\n  summarizeCandidate,\n  type CandidateSummary,\n} from \"./telemetry\";\nimport {\n  AssignTablesRpcError,\n  HoldConflictError,\n  HoldNotFoundError,\n  createTableHold,\n  findHoldConflicts,\n  listActiveHoldsForBooking,\n  releaseTableHold,\n  type CreateTableHoldInput,\n  type HoldConflictInfo,\n  type TableHold,\n} from \"./holds\";\nimport { createAvailabilityBitset, markWindow, isWindowFree } from \"./planner/bitset\";\n\nimport {\n  getAllocatorKMax,\n  getAllocatorKMax as getAllocatorCombinationLimit,\n  isAllocatorAdjacencyRequired,\n  isAllocatorMergesEnabled,\n  isAllocatorV2Enabled,\n  isCombinationPlannerEnabled,\n  isHoldsEnabled,\n  isOpsMetricsEnabled,\n  isSelectorScoringEnabled,\n} from \"@/server/feature-flags\";\nimport { getServiceSupabaseClient } from \"@/server/supabase\";\nimport {\n  AssignmentConflictError,\n  AssignmentOrchestrator,\n  AssignmentRepositoryError,\n  AssignmentValidationError,\n  SupabaseAssignmentRepository,\n  createPlanSignature,\n  normalizeTableIds,\n} from \"./v2\";\n\nimport type { Database, Json, Tables } from \"@/types/supabase\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\n\ntype DbClient = SupabaseClient<Database, \"public\", any>;\n\nconst DEFAULT_HOLD_TTL_SECONDS = 180;\nconst TABLE_RESOURCE_TYPE = \"table\";\n\nexport type Table = {\n  id: string;\n  tableNumber: string;\n  capacity: number;\n  minPartySize?: number | null;\n  maxPartySize?: number | null;\n  section?: string | null;\n  category?: Tables<\"table_inventory\">[\"category\"] | string | null;\n  seatingType?: Tables<\"table_inventory\">[\"seating_type\"] | string | null;\n  mobility?: Tables<\"table_inventory\">[\"mobility\"] | string | null;\n  zoneId: string;\n  status?: Tables<\"table_inventory\">[\"status\"] | string | null;\n  active?: boolean | null;\n  position?: Tables<\"table_inventory\">[\"position\"] | null;\n};\n\nexport type TableMatchParams = {\n  partySize: number;\n  requireAdjacency?: boolean;\n  avoidTableIds?: string[];\n  zoneId?: string | null;\n};\n\nexport type TableAssignmentMember = {\n  tableId: string;\n  assignmentId: string;\n  startAt: string;\n  endAt: string;\n  mergeGroupId?: string | null;\n};\n\nexport type TableAssignmentGroup = {\n  bookingId: string;\n  tableIds: string[];\n  assignments: TableAssignmentMember[];\n};\n\nexport type ManualSelectionCheck = {\n  id: \"capacity\" | \"zone\" | \"movable\" | \"adjacency\" | \"conflict\" | \"holds\";\n  status: \"ok\" | \"warning\" | \"error\";\n  message: string;\n  details?: Record<string, unknown>;\n};\n\nexport type ManualSelectionSummary = {\n  tableCount: number;\n  totalCapacity: number;\n  slack: number;\n  zoneId: string | null;\n  tableNumbers: string[];\n  partySize: number;\n};\n\nexport type ManualValidationResult = {\n  ok: boolean;\n  summary: ManualSelectionSummary;\n  checks: ManualSelectionCheck[];\n};\n\nexport type ManualSelectionOptions = {\n  bookingId: string;\n  tableIds: string[];\n  requireAdjacency?: boolean;\n  excludeHoldId?: string | null;\n  client?: DbClient;\n};\n\nexport type ManualHoldOptions = ManualSelectionOptions & {\n  createdBy: string;\n  holdTtlSeconds?: number;\n  holdExpiresAt?: string;\n};\n\nexport type ManualHoldResult = {\n  hold: TableHold | null;\n  validation: ManualValidationResult;\n};\n\nexport type AutoAssignResult = {\n  assigned: Array<{ bookingId: string; tableIds: string[] }>;\n  skipped: Array<{ bookingId: string; reason: string }>;\n};\n\nexport type QuoteTablesOptions = {\n  bookingId: string;\n  zoneId?: string | null;\n  maxTables?: number;\n  requireAdjacency?: boolean;\n  avoidTables?: string[];\n  holdTtlSeconds?: number;\n  createdBy: string;\n  client?: DbClient;\n};\n\nexport type QuoteTablesResult = {\n  hold: TableHold | null;\n  candidate: CandidateSummary | null;\n  alternates: CandidateSummary[];\n  nextTimes: string[];\n  reason?: string;\n};\n\nexport type ManualAssignmentConflict = {\n  tableId: string;\n  bookingId: string | null;\n  startAt: string;\n  endAt: string;\n  source: \"booking\" | \"hold\";\n};\n\nexport type ManualAssignmentContextHold = TableHold & {\n  createdByName?: string | null;\n  createdByEmail?: string | null;\n  summary?: ManualSelectionSummary;\n};\n\nexport type ManualAssignmentContext = {\n  booking: Tables<\"bookings\">;\n  tables: Table[];\n  bookingAssignments: string[];\n  holds: ManualAssignmentContextHold[];\n  activeHold: ManualAssignmentContextHold | null;\n  conflicts: ManualAssignmentConflict[];\n  window: {\n    startAt: string | null;\n    endAt: string | null;\n  };\n};\n\ntype BookingRow = Tables<\"bookings\"> & {\n  restaurants?: { timezone: string | null } | { timezone: string | null }[];\n};\n\ntype ContextBookingRow = {\n  id: string;\n  party_size: number;\n  status: string;\n  start_time: string | null;\n  end_time: string | null;\n  start_at: string | null;\n  end_at: string | null;\n  booking_date: string | null;\n  seating_preference?: string | null;\n  booking_table_assignments: Array<{ table_id: string | null }> | null;\n};\n\ntype BusyWindow = {\n  tableId: string;\n  startAt: string;\n  endAt: string;\n  bookingId: string | null;\n  source: \"booking\" | \"hold\";\n};\n\ntype AvailabilityMap = Map<\n  string,\n  {\n    bitset: ReturnType<typeof createAvailabilityBitset>;\n    windows: BusyWindow[];\n  }\n>;\n\nexport class ManualSelectionInputError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string = \"MANUAL_SELECTION_INPUT_INVALID\",\n    public readonly status = 400,\n  ) {\n    super(message);\n    this.name = \"ManualSelectionInputError\";\n  }\n}\n\nfunction ensureClient(client?: DbClient): DbClient {\n  return client ?? getServiceSupabaseClient();\n}\n\nfunction toDateTime(iso: string | null | undefined, fallbackZone: string): DateTime | null {\n  if (!iso) {\n    return null;\n  }\n  const parsed = DateTime.fromISO(iso, { zone: fallbackZone });\n  if (parsed.isValid) {\n    return parsed;\n  }\n  return DateTime.fromISO(iso);\n}\n\nfunction normalizeBookingRow(row: BookingRow): BookingRow {\n  if (Array.isArray(row.restaurants) && row.restaurants.length > 0) {\n    return { ...row, restaurants: row.restaurants[0] ?? null };\n  }\n  return row;\n}\n\nexport type BookingWindow = ReturnType<typeof computeBookingWindow>;\n\nexport function computeBookingWindow(args: {\n  startISO?: string | null;\n  bookingDate?: string | null;\n  startTime?: string | null;\n  partySize: number;\n  policy?: VenuePolicy;\n  serviceHint?: ServiceKey | null;\n}): {\n  service: ServiceKey;\n  durationMinutes: number;\n  dining: {\n    start: DateTime;\n    end: DateTime;\n  };\n  block: {\n    start: DateTime;\n    end: DateTime;\n  };\n} {\n  const policy = args.policy ?? getVenuePolicy();\n  const baseStart = resolveStartDateTime(args, policy);\n  const service = resolveService(baseStart, args.serviceHint ?? null, policy);\n\n  const diningMinutes = bandDuration(service, args.partySize, policy);\n  const buffer = getBufferConfig(service, policy);\n  const diningStart = baseStart;\n  const diningEnd = diningStart.plus({ minutes: diningMinutes });\n  const blockStart = diningStart.minus({ minutes: buffer.pre ?? 0 });\n  const blockEnd = diningEnd.plus({ minutes: buffer.post ?? 0 });\n\n  const serviceEndBoundary = serviceEnd(service, diningStart, policy);\n  if (blockEnd > serviceEndBoundary) {\n    throw new ServiceOverrunError(service, blockEnd, serviceEndBoundary);\n  }\n\n  return {\n    service,\n    durationMinutes: diningMinutes,\n    dining: {\n      start: diningStart,\n      end: diningEnd,\n    },\n    block: {\n      start: blockStart,\n      end: blockEnd,\n    },\n  };\n}\n\ntype ComputeWindowArgs = {\n  startISO?: string | null;\n  bookingDate?: string | null;\n  startTime?: string | null;\n  partySize: number;\n  policy?: VenuePolicy;\n  serviceHint?: ServiceKey | null;\n};\n\nfunction computeBookingWindowWithFallback(args: ComputeWindowArgs): BookingWindow {\n  const policy = args.policy ?? getVenuePolicy();\n  try {\n    return computeBookingWindow({ ...args, policy });\n  } catch (error) {\n    if (error instanceof ServiceNotFoundError) {\n      const serviceOrderCandidates = policy.serviceOrder.filter((key) => Boolean(policy.services[key]));\n      const servicesFallback = (Object.keys(policy.services) as ServiceKey[]).filter((key) =>\n        Boolean(policy.services[key]),\n      );\n      const fallbackService =\n        args.serviceHint && policy.services[args.serviceHint]\n          ? args.serviceHint\n          : serviceOrderCandidates[0] ?? servicesFallback[0];\n\n      if (!fallbackService || !policy.services[fallbackService]) {\n        throw error;\n      }\n\n      const baseStart = resolveStartDateTime(args, policy);\n      const durationMinutes = bandDuration(fallbackService, args.partySize, policy);\n      const buffer = getBufferConfig(fallbackService, policy);\n      const diningStart = baseStart;\n      const diningEnd = diningStart.plus({ minutes: durationMinutes });\n      const blockStart = diningStart.minus({ minutes: buffer.pre ?? 0 });\n      const blockEnd = diningEnd.plus({ minutes: buffer.post ?? 0 });\n\n      console.warn(\"[capacity][window][fallback] service not found, using fallback service\", {\n        start: baseStart.toISO(),\n        fallbackService,\n      });\n\n      return {\n        service: fallbackService,\n        durationMinutes,\n        dining: {\n          start: diningStart,\n          end: diningEnd,\n        },\n        block: {\n          start: blockStart,\n          end: blockEnd,\n        },\n      };\n    }\n\n    throw error;\n  }\n}\n\nfunction resolveStartDateTime(\n  args: {\n    startISO?: string | null;\n    bookingDate?: string | null;\n    startTime?: string | null;\n  },\n  policy: VenuePolicy,\n): DateTime {\n  if (args.startISO) {\n    const parsed = DateTime.fromISO(args.startISO);\n    if (!parsed.isValid) {\n      throw new ManualSelectionInputError(\"Invalid start ISO timestamp provided\", \"INVALID_START\");\n    }\n    return parsed.setZone(policy.timezone, { keepLocalTime: false });\n  }\n\n  const { bookingDate, startTime } = args;\n  if (!bookingDate || !startTime) {\n    throw new ManualSelectionInputError(\"Booking date and start time are required\", \"START_TIME_REQUIRED\");\n  }\n\n  const composed = DateTime.fromISO(`${bookingDate}T${startTime}`, { zone: policy.timezone });\n  if (!composed.isValid) {\n    throw new ManualSelectionInputError(\"Invalid booking date/time\", \"INVALID_START\");\n  }\n  return composed;\n}\n\nfunction resolveService(start: DateTime, hint: ServiceKey | null, policy: VenuePolicy): ServiceKey {\n  if (hint) {\n    return hint;\n  }\n  const found = whichService(start, policy);\n  if (!found) {\n    throw new ServiceNotFoundError(start);\n  }\n  return found;\n}\n\nexport function windowsOverlap(\n  a: { start: number; end: number },\n  b: { start: number; end: number },\n): boolean {\n  return a.start < b.end && b.start < a.end;\n}\n\nfunction toIsoUtc(dateTime: DateTime): string {\n  return (\n    dateTime.toUTC().toISO({ suppressMilliseconds: true }) ??\n    dateTime.toUTC().toISO() ??\n    dateTime.toUTC().toString()\n  );\n}\n\nfunction normalizeIsoString(value: string | null | undefined): string | null {\n  if (!value) {\n    return null;\n  }\n  const parsed = DateTime.fromISO(value);\n  if (!parsed.isValid) {\n    return null;\n  }\n  return toIsoUtc(parsed);\n}\n\nexport function filterAvailableTables(\n  tables: Table[],\n  partySize: number,\n  window: ReturnType<typeof computeBookingWindow>,\n  adjacency: Map<string, Set<string>>,\n  avoidTables?: Set<string>,\n  zoneId?: string | null,\n  options?: { allowInsufficientCapacity?: boolean },\n): Table[] {\n  const allowPartial = options?.allowInsufficientCapacity ?? false;\n  const avoid = avoidTables ?? new Set<string>();\n\n  const filtered = tables.filter((table) => {\n    if (!table) return false;\n    if (avoid.has(table.id)) return false;\n    if (zoneId && table.zoneId !== zoneId) return false;\n    if (table.active === false) return false;\n    if (typeof table.status === \"string\" && table.status.toLowerCase() === \"out_of_service\") return false;\n    const capacity = table.capacity ?? 0;\n    if (!Number.isFinite(capacity) || capacity <= 0) return false;\n    if (!allowPartial && capacity < partySize) return false;\n    if (typeof table.maxPartySize === \"number\" && table.maxPartySize > 0 && partySize > table.maxPartySize) {\n      return false;\n    }\n    if (typeof table.minPartySize === \"number\" && table.minPartySize > 0 && partySize < table.minPartySize) {\n      return false;\n    }\n    // If adjacency map is supplied and requires zone-level adjacency, ensure entry exists.\n    if (partiesRequireAdjacency(partySize) && adjacency.size > 0 && !adjacency.has(table.id)) {\n      adjacency.set(table.id, new Set());\n    }\n    return true;\n  });\n\n  return filtered.sort((a, b) => {\n    const capacityDiff = (a.capacity ?? 0) - (b.capacity ?? 0);\n    if (capacityDiff !== 0) return capacityDiff;\n    return a.tableNumber.localeCompare(b.tableNumber);\n  });\n}\n\nfunction partiesRequireAdjacency(_partySize: number): boolean {\n  return false;\n}\n\nasync function loadBooking(bookingId: string, client: DbClient): Promise<BookingRow> {\n  const { data, error } = await client\n    .from(\"bookings\")\n    .select(\n      [\n        \"id\",\n        \"restaurant_id\",\n        \"booking_date\",\n        \"start_time\",\n        \"end_time\",\n        \"start_at\",\n        \"end_at\",\n        \"party_size\",\n        \"status\",\n        \"seating_preference\",\n        \"restaurants(timezone)\",\n      ].join(\",\"),\n    )\n    .eq(\"id\", bookingId)\n    .maybeSingle();\n\n  if (error) {\n    throw new ManualSelectionInputError(error.message ?? \"Failed to load booking\", \"BOOKING_LOOKUP_FAILED\", 500);\n  }\n\n  if (!data) {\n    throw new ManualSelectionInputError(\"Booking not found\", \"BOOKING_NOT_FOUND\", 404);\n  }\n\n  return normalizeBookingRow(data as unknown as BookingRow);\n}\n\nasync function loadRestaurantTimezone(restaurantId: string, client: DbClient): Promise<string | null> {\n  const { data, error } = await client\n    .from(\"restaurants\")\n    .select(\"timezone\")\n    .eq(\"id\", restaurantId)\n    .maybeSingle();\n\n  if (error) {\n    throw new ManualSelectionInputError(error.message ?? \"Failed to load restaurant timezone\", \"RESTAURANT_LOOKUP_FAILED\", 500);\n  }\n\n  return data?.timezone ?? null;\n}\n\nasync function loadTablesForRestaurant(restaurantId: string, client: DbClient): Promise<Table[]> {\n  const { data, error } = await client\n    .from(\"table_inventory\")\n    .select(\n      [\n        \"id\",\n        \"table_number\",\n        \"capacity\",\n        \"min_party_size\",\n        \"max_party_size\",\n        \"section\",\n        \"category\",\n        \"seating_type\",\n        \"mobility\",\n        \"zone_id\",\n        \"status\",\n        \"active\",\n        \"position\",\n      ].join(\",\"),\n    )\n    .eq(\"restaurant_id\", restaurantId)\n    .order(\"table_number\", { ascending: true });\n\n  if (error || !data) {\n    return [];\n  }\n\n  const rows = data as unknown as Tables<\"table_inventory\">[];\n\n  return rows.map((row) => ({\n    id: row.id,\n    tableNumber: row.table_number,\n    capacity: row.capacity ?? 0,\n    minPartySize: row.min_party_size ?? null,\n    maxPartySize: row.max_party_size ?? null,\n    section: row.section,\n    category: row.category,\n    seatingType: row.seating_type,\n    mobility: row.mobility,\n    zoneId: row.zone_id,\n    status: row.status,\n    active: row.active,\n    position: row.position,\n  }));\n}\n\nasync function loadTablesByIds(\n  restaurantId: string,\n  tableIds: string[],\n  client: DbClient,\n): Promise<Table[]> {\n  if (tableIds.length === 0) {\n    return [];\n  }\n\n  const allTables = await loadTablesForRestaurant(restaurantId, client);\n  const lookup = new Map(allTables.map((table) => [table.id, table]));\n\n  return tableIds\n    .map((id) => lookup.get(id))\n    .filter((table): table is Table => Boolean(table));\n}\n\nasync function loadAdjacency(tableIds: string[], client: DbClient): Promise<Map<string, Set<string>>> {\n  if (tableIds.length === 0) {\n    return new Map();\n  }\n\n  const { data, error } = await client\n    .from(\"table_adjacencies\")\n    .select(\"table_a, table_b\")\n    .in(\"table_a\", tableIds);\n\n  if (error || !data) {\n    return new Map();\n  }\n\n  const map = new Map<string, Set<string>>();\n  for (const row of data) {\n    if (!map.has(row.table_a)) {\n      map.set(row.table_a, new Set());\n    }\n    map.get(row.table_a)!.add(row.table_b);\n    if (!map.has(row.table_b)) {\n      map.set(row.table_b, new Set());\n    }\n    map.get(row.table_b)!.add(row.table_a);\n  }\n  return map;\n}\n\nasync function loadContextBookings(\n  restaurantId: string,\n  bookingDate: string | null,\n  client: DbClient,\n): Promise<ContextBookingRow[]> {\n  if (!bookingDate) {\n    return [];\n  }\n\n  const { data, error } = await client\n    .from(\"bookings\")\n    .select(\n      [\n        \"id\",\n        \"party_size\",\n        \"status\",\n        \"start_time\",\n        \"end_time\",\n        \"start_at\",\n        \"end_at\",\n        \"booking_date\",\n        \"booking_table_assignments(table_id)\",\n      ].join(\",\"),\n    )\n    .eq(\"restaurant_id\", restaurantId)\n    .eq(\"booking_date\", bookingDate)\n    .order(\"start_at\", { ascending: true });\n\n  if (error || !data) {\n    return [];\n  }\n\n  return data as unknown as ContextBookingRow[];\n}\n\nasync function loadBookingAssignments(bookingId: string, client: DbClient): Promise<TableAssignmentMember[]> {\n  const { data, error } = await client\n    .from(\"booking_table_assignments\")\n    .select(\"table_id, id, assigned_at\")\n    .eq(\"booking_id\", bookingId);\n\n  if (error || !data) {\n    return [];\n  }\n\n  return data.map((row) => ({\n    tableId: row.table_id,\n    assignmentId: row.id,\n    startAt: row.assigned_at ?? \"\",\n    endAt: row.assigned_at ?? \"\",\n    mergeGroupId: null,\n  }));\n}\n\ntype BookingAssignmentRow = {\n  table_id: string;\n  id: string;\n  start_at: string | null;\n  end_at: string | null;\n  merge_group_id: string | null;\n};\n\nasync function loadTableAssignmentsForTables(\n  bookingId: string,\n  tableIds: string[],\n  client: DbClient,\n): Promise<BookingAssignmentRow[]> {\n  const baseBuilder = client\n    .from(\"booking_table_assignments\")\n    .select(\"table_id, id, start_at, end_at, merge_group_id\")\n    .eq(\"booking_id\", bookingId);\n\n  let data: any;\n  let error: any;\n\n  const builder: any = baseBuilder;\n  if (builder && typeof builder.in === \"function\") {\n    const response = await builder.in(\n      \"table_id\",\n      tableIds,\n    );\n    data = response?.data ?? null;\n    error = response?.error ?? null;\n  } else {\n    const response = await builder;\n    data = response?.data ?? null;\n    error = response?.error ?? null;\n  }\n\n  if (error || !data) {\n    return [];\n  }\n\n  return (data as BookingAssignmentRow[]).filter((row) => tableIds.includes(row.table_id));\n}\n\nfunction registerBusyWindow(\n  map: AvailabilityMap,\n  tableId: string,\n  window: { startAt: string; endAt: string; bookingId: string | null; source: \"booking\" | \"hold\" },\n): void {\n  if (!map.has(tableId)) {\n    map.set(tableId, {\n      bitset: createAvailabilityBitset(),\n      windows: [],\n    });\n  }\n  const entry = map.get(tableId)!;\n  markWindow(entry.bitset, window.startAt, window.endAt);\n  entry.windows.push({\n    tableId,\n    ...window,\n  });\n}\n\nfunction buildBusyMaps(params: {\n  targetBookingId: string;\n  bookings: ContextBookingRow[];\n  holds: TableHold[];\n  excludeHoldId?: string | null;\n  policy: VenuePolicy;\n}): AvailabilityMap {\n  const { targetBookingId, bookings, holds, excludeHoldId, policy } = params;\n  const map: AvailabilityMap = new Map();\n\n  for (const booking of bookings) {\n    if (booking.id === targetBookingId) continue;\n    const assignments = booking.booking_table_assignments ?? [];\n    if (assignments.length === 0) continue;\n\n    const window = computeBookingWindowWithFallback({\n      startISO: booking.start_at,\n      bookingDate: booking.booking_date,\n      startTime: booking.start_time,\n      partySize: booking.party_size,\n      policy,\n    });\n\n    for (const assignment of assignments) {\n      if (!assignment?.table_id) continue;\n      registerBusyWindow(map, assignment.table_id, {\n        startAt: toIsoUtc(window.block.start),\n        endAt: toIsoUtc(window.block.end),\n        bookingId: booking.id,\n        source: \"booking\",\n      });\n    }\n  }\n\n  for (const hold of holds) {\n    if (excludeHoldId && hold.id === excludeHoldId) continue;\n    for (const tableId of hold.tableIds) {\n      registerBusyWindow(map, tableId, {\n        startAt: hold.startAt,\n        endAt: hold.endAt,\n        bookingId: hold.bookingId,\n        source: \"hold\",\n      });\n    }\n  }\n\n  return map;\n}\n\nfunction extractConflictsForTables(\n  busy: AvailabilityMap,\n  tableIds: string[],\n  window: ReturnType<typeof computeBookingWindow>,\n): ManualAssignmentConflict[] {\n  const conflicts: ManualAssignmentConflict[] = [];\n  const targetStart = toIsoUtc(window.block.start);\n  const targetEnd = toIsoUtc(window.block.end);\n\n  for (const tableId of tableIds) {\n    const entry = busy.get(tableId);\n    if (!entry) continue;\n    for (const other of entry.windows) {\n      if (windowsOverlapMs(targetStart, targetEnd, other.startAt, other.endAt)) {\n        conflicts.push({\n          tableId,\n          bookingId: other.bookingId,\n          startAt: other.startAt,\n          endAt: other.endAt,\n          source: other.source,\n        });\n      }\n    }\n  }\n\n  return conflicts;\n}\n\nfunction formatConflictSummary(conflicts: ManualAssignmentConflict[]): string {\n  if (conflicts.length === 0) {\n    return \"conflicts\";\n  }\n\n  const sources = new Set(conflicts.map((conflict) => conflict.source));\n  const tableIds = Array.from(new Set(conflicts.map((conflict) => conflict.tableId))).join(\", \");\n  if (sources.size === 0) {\n    return tableIds ? `conflicts on tables ${tableIds}` : \"conflicts\";\n  }\n\n  if (sources.size > 1) {\n    return tableIds ? `holds and bookings on tables ${tableIds}` : \"holds and bookings\";\n  }\n\n  const [source] = sources;\n  const label = source === \"hold\" ? \"holds\" : \"bookings\";\n  return tableIds ? `${label} on tables ${tableIds}` : label;\n}\n\nfunction windowsOverlapMs(aStart: string, aEnd: string, bStart: string, bEnd: string): boolean {\n  const a = { start: Date.parse(aStart), end: Date.parse(aEnd) };\n  const b = { start: Date.parse(bStart), end: Date.parse(bEnd) };\n  if (!Number.isFinite(a.start) || !Number.isFinite(a.end) || !Number.isFinite(b.start) || !Number.isFinite(b.end)) {\n    return false;\n  }\n  return a.start < b.end && b.start < a.end;\n}\n\nfunction evaluateAdjacency(\n  tableIds: string[],\n  adjacency: Map<string, Set<string>>,\n): { connected: boolean } {\n  if (tableIds.length <= 1) {\n    return { connected: true };\n  }\n  const queue = [tableIds[0]!];\n  const visited = new Set<string>([tableIds[0]!]);\n  while (queue.length > 0) {\n    const current = queue.shift();\n    if (!current) continue;\n    const neighbors = adjacency.get(current);\n    if (!neighbors) continue;\n    for (const neighbor of neighbors) {\n      if (!tableIds.includes(neighbor)) continue;\n      if (visited.has(neighbor)) continue;\n      visited.add(neighbor);\n      queue.push(neighbor);\n    }\n  }\n  return { connected: visited.size === tableIds.length };\n}\n\nfunction summarizeSelection(tables: Table[], partySize: number): ManualSelectionSummary {\n  const totalCapacity = tables.reduce((sum, table) => sum + (table.capacity ?? 0), 0);\n  const zoneIds = new Set(tables.map((table) => table.zoneId));\n  return {\n    tableCount: tables.length,\n    totalCapacity,\n    slack: Math.max(0, totalCapacity - partySize),\n    zoneId: zoneIds.size === 1 ? tables[0]?.zoneId ?? null : null,\n    tableNumbers: tables.map((table) => table.tableNumber),\n    partySize,\n  };\n}\n\nfunction buildManualChecks(params: {\n  summary: ManualSelectionSummary;\n  tables: Table[];\n  requireAdjacency: boolean;\n  adjacency: Map<string, Set<string>>;\n  conflicts: ManualAssignmentConflict[];\n  holdConflicts: HoldConflictInfo[];\n}): ManualSelectionCheck[] {\n  const checks: ManualSelectionCheck[] = [];\n  const { summary, tables, requireAdjacency, adjacency, conflicts, holdConflicts } = params;\n\n  checks.push({\n    id: \"capacity\",\n    status: summary.totalCapacity >= summary.partySize ? \"ok\" : \"error\",\n    message:\n      summary.totalCapacity >= summary.partySize\n        ? \"Capacity satisfied\"\n        : \"Selected tables do not meet requested party size\",\n    details: {\n      totalCapacity: summary.totalCapacity,\n      partySize: summary.partySize,\n      slack: summary.slack,\n    },\n  });\n\n  if (summary.zoneId === null) {\n    checks.push({\n      id: \"zone\",\n      status: \"error\",\n      message: \"Tables must belong to the same zone for manual assignment\",\n    });\n  } else {\n    checks.push({\n      id: \"zone\",\n      status: \"ok\",\n      message: `Zone ${summary.zoneId} validated`,\n    });\n  }\n\n  if (tables.length > 1) {\n    const allMovable = tables.every((table) => table.mobility === \"movable\");\n    checks.push({\n      id: \"movable\",\n      status: allMovable ? \"ok\" : \"error\",\n      message: allMovable\n        ? \"All tables are movable\"\n        : \"Merged assignments require movable tables\",\n    });\n  } else {\n    checks.push({\n      id: \"movable\",\n      status: \"ok\",\n      message: \"Single table selection\",\n    });\n  }\n\n  if (requireAdjacency && tables.length > 1) {\n    const evaluation = evaluateAdjacency(\n      tables.map((table) => table.id),\n      adjacency,\n    );\n    checks.push({\n      id: \"adjacency\",\n      status: evaluation.connected ? \"ok\" : \"error\",\n      message: evaluation.connected\n        ? \"Tables are connected\"\n        : \"Tables must be adjacent when adjacency enforcement is enabled\",\n    });\n  } else {\n    checks.push({\n      id: \"adjacency\",\n      status: \"ok\",\n      message: \"Adjacency not required\",\n    });\n  }\n\n  checks.push({\n    id: \"conflict\",\n    status: conflicts.length === 0 && holdConflicts.length === 0 ? \"ok\" : \"error\",\n    message:\n      conflicts.length === 0 && holdConflicts.length === 0\n        ? \"No conflicting assignments\"\n        : \"Existing assignments or holds conflict with selection\",\n    details: {\n      conflicts,\n      holdConflicts,\n    },\n  });\n\n  checks.push({\n    id: \"holds\",\n    status: holdConflicts.length === 0 ? \"ok\" : \"error\",\n    message: holdConflicts.length === 0 ? \"No holds blocking selection\" : \"Tables currently on hold\",\n    details: {\n      holds: holdConflicts,\n    },\n  });\n\n  return checks;\n}\n\nexport async function evaluateManualSelection(options: ManualSelectionOptions): Promise<ManualValidationResult> {\n  const { bookingId, tableIds, requireAdjacency = isAllocatorAdjacencyRequired(), excludeHoldId = null, client } = options;\n\n  if (!Array.isArray(tableIds) || tableIds.length === 0) {\n    throw new ManualSelectionInputError(\"At least one table must be selected\", \"TABLES_REQUIRED\");\n  }\n\n  const supabase = ensureClient(client);\n  const booking = await loadBooking(bookingId, supabase);\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n\n  const window = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n\n  const selectionTables = await loadTablesByIds(booking.restaurant_id, tableIds, supabase);\n  if (selectionTables.length !== tableIds.length) {\n    throw new ManualSelectionInputError(\"One or more selected tables were not found\", \"TABLE_LOOKUP_FAILED\");\n  }\n\n  const adjacency = await loadAdjacency(tableIds, supabase);\n\n  const contextBookings = await loadContextBookings(booking.restaurant_id, booking.booking_date ?? null, supabase);\n  let holds: TableHold[] = [];\n  if (isHoldsEnabled()) {\n    try {\n      holds = await listActiveHoldsForBooking({ bookingId, client: supabase });\n    } catch (error) {\n      holds = [];\n    }\n  }\n\n  const busy = buildBusyMaps({\n    targetBookingId: bookingId,\n    bookings: contextBookings,\n    holds,\n    excludeHoldId,\n    policy,\n  });\n\n  const conflicts = extractConflictsForTables(busy, tableIds, window);\n  let holdConflicts: HoldConflictInfo[] = [];\n  try {\n    holdConflicts = await findHoldConflicts({\n      restaurantId: booking.restaurant_id,\n      tableIds,\n      startAt: toIsoUtc(window.block.start),\n      endAt: toIsoUtc(window.block.end),\n      excludeHoldId,\n      client: supabase,\n    });\n  } catch (error) {\n    holdConflicts = [];\n  }\n\n  const summary = summarizeSelection(selectionTables, booking.party_size);\n  const checks = buildManualChecks({\n    summary,\n    tables: selectionTables,\n    requireAdjacency,\n    adjacency,\n    conflicts,\n    holdConflicts,\n  });\n\n  const ok = checks.every((check) => check.status !== \"error\");\n\n  return {\n    ok,\n    summary,\n    checks,\n  };\n}\n\nexport async function createManualHold(options: ManualHoldOptions): Promise<ManualHoldResult> {\n  const { bookingId, tableIds, createdBy, holdTtlSeconds = DEFAULT_HOLD_TTL_SECONDS, requireAdjacency, excludeHoldId, client } = options;\n  const supabase = ensureClient(client);\n\n  const validation = await evaluateManualSelection({\n    bookingId,\n    tableIds,\n    requireAdjacency,\n    excludeHoldId,\n    client: supabase,\n  });\n\n  if (!validation.ok || !validation.summary) {\n    return {\n      hold: null,\n      validation,\n    };\n  }\n\n  const booking = await loadBooking(bookingId, supabase);\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n\n  const window = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n\n  const selectionTables = await loadTablesByIds(booking.restaurant_id, tableIds, supabase);\n  if (selectionTables.length !== tableIds.length) {\n    throw new ManualSelectionInputError(\"Selected tables could not be loaded\", \"TABLE_LOOKUP_FAILED\");\n  }\n\n  const startAtIso = toIsoUtc(window.block.start);\n  const endAtIso = toIsoUtc(window.block.end);\n\n  if (excludeHoldId) {\n    await releaseTableHold({ holdId: excludeHoldId, client: supabase });\n  }\n\n  const expiresAt =\n    options.holdExpiresAt ??\n    toIsoUtc(DateTime.now().plus({ seconds: holdTtlSeconds })) ??\n    toIsoUtc(window.block.start.plus({ minutes: 2 }));\n\n  const zoneIdValue = validation.summary.zoneId ?? selectionTables[0]?.zoneId;\n  if (!zoneIdValue) {\n    throw new ManualSelectionInputError(\"Unable to determine zone for selected tables\", \"ZONE_REQUIRED\");\n  }\n\n  const holdPayload: CreateTableHoldInput = {\n    bookingId,\n    restaurantId: booking.restaurant_id,\n    zoneId: zoneIdValue,\n    tableIds,\n    startAt: startAtIso,\n    endAt: endAtIso,\n    expiresAt,\n    createdBy,\n    metadata: {\n      selection: {\n        tableIds,\n        summary: validation.summary,\n      },\n    },\n    client: supabase,\n  };\n\n  const hold = await createTableHold(holdPayload);\n\n  return {\n    hold,\n    validation,\n  };\n}\n\nexport async function getManualAssignmentContext(options: {\n  bookingId: string;\n  client?: DbClient;\n}): Promise<ManualAssignmentContext> {\n  const { bookingId, client } = options;\n  const supabase = ensureClient(client);\n  const booking = await loadBooking(bookingId, supabase);\n\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n\n  const window = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n\n  const tables = await loadTablesForRestaurant(booking.restaurant_id, supabase);\n  const contextBookings = await loadContextBookings(booking.restaurant_id, booking.booking_date ?? null, supabase);\n\n  let holds: ManualAssignmentContextHold[] = [];\n  if (isHoldsEnabled()) {\n    try {\n      const rawHolds = await fetchHoldsForWindow(booking.restaurant_id, window, supabase);\n      holds = await hydrateHoldMetadata(rawHolds, supabase);\n    } catch (error: any) {\n      if (error?.code === \"42P01\") {\n        console.warn(\"[capacity][manual][context] holds table unavailable; skipping hold hydration\", {\n          bookingId,\n        });\n      } else {\n        console.warn(\"[capacity][manual][context] failed to list holds\", { bookingId, error });\n      }\n      holds = [];\n    }\n  }\n\n  const busy = buildBusyMaps({\n    targetBookingId: bookingId,\n    bookings: contextBookings,\n    holds,\n    policy,\n  });\n\n  const bookingAssignments = await loadTableAssignmentsForTables(\n    bookingId,\n    tables.map((table) => table.id),\n    supabase,\n  );\n\n  const conflicts = extractConflictsForTables(\n    busy,\n    tables.map((table) => table.id),\n    window,\n  );\n\n  const activeHold = holds.find((hold) => hold.bookingId === bookingId) ?? null;\n\n  return {\n    booking,\n    tables,\n    bookingAssignments: bookingAssignments.map((row) => row.table_id),\n    holds,\n    activeHold,\n    conflicts,\n    window: {\n      startAt: toIsoUtc(window.block.start),\n      endAt: toIsoUtc(window.block.end),\n    },\n  };\n}\n\nasync function hydrateHoldMetadata(holds: TableHold[], client: DbClient): Promise<ManualAssignmentContextHold[]> {\n  if (holds.length === 0) {\n    return [];\n  }\n  const creatorIds = Array.from(\n    new Set(\n      holds\n        .map((hold) => hold.createdBy)\n        .filter((value): value is string => Boolean(value)),\n    ),\n  );\n\n  let creators: Array<{ id: string; name: string | null; email: string | null }> = [];\n  if (creatorIds.length > 0) {\n    const { data, error } = await client\n      .from(\"profiles\")\n      .select(\"id, name, email\")\n      .in(\"id\", creatorIds);\n\n    if (!error && data) {\n      creators = data as Array<{ id: string; name: string | null; email: string | null }>;\n    }\n  }\n\n  return holds.map((hold) => {\n    const creator = creators.find((profile) => profile.id === hold.createdBy);\n    return {\n      ...hold,\n      createdByName: creator?.name ?? null,\n      createdByEmail: creator?.email ?? null,\n    };\n  });\n}\n\nasync function fetchHoldsForWindow(\n  restaurantId: string,\n  window: ReturnType<typeof computeBookingWindow>,\n  client: DbClient,\n): Promise<TableHold[]> {\n  const { data, error } = await client\n    .from(\"table_holds\")\n    .select(\"*, table_hold_members(table_id)\")\n    .eq(\"restaurant_id\", restaurantId)\n    .gt(\"expires_at\", new Date().toISOString())\n    .lt(\"start_at\", toIsoUtc(window.block.end))\n    .gt(\"end_at\", toIsoUtc(window.block.start));\n\n  if (error || !data) {\n    throw error ?? new Error(\"Failed to load holds\");\n  }\n\n  return data.map((row: any) => {\n    const members = (row.table_hold_members ?? []) as Array<{ table_id: string }>;\n    const tableIds = members.map((member) => member.table_id);\n    return {\n      id: row.id,\n      bookingId: row.booking_id,\n      restaurantId: row.restaurant_id,\n      zoneId: row.zone_id,\n      startAt: row.start_at,\n      endAt: row.end_at,\n      expiresAt: row.expires_at,\n      tableIds,\n      createdBy: row.created_by ?? null,\n      metadata: row.metadata ?? null,\n    } satisfies TableHold;\n  });\n}\n\nasync function loadActiveHoldsForDate(\n  restaurantId: string,\n  bookingDate: string | null,\n  policy: VenuePolicy,\n  client: DbClient,\n): Promise<TableHold[]> {\n  if (!bookingDate) {\n    return [];\n  }\n\n  const day = DateTime.fromISO(bookingDate, { zone: policy.timezone ?? \"UTC\" });\n  if (!day.isValid) {\n    return [];\n  }\n\n  const dayStart = toIsoUtc(day.startOf(\"day\"));\n  const dayEnd = toIsoUtc(day.plus({ days: 1 }).startOf(\"day\"));\n  const now = toIsoUtc(DateTime.now());\n\n  const { data, error } = await client\n    .from(\"table_holds\")\n    .select(\"*, table_hold_members(table_id)\")\n    .eq(\"restaurant_id\", restaurantId)\n    .gt(\"expires_at\", now)\n    .lt(\"start_at\", dayEnd)\n    .gt(\"end_at\", dayStart);\n\n  if (error || !data) {\n    throw error ?? new Error(\"Failed to load holds\");\n  }\n\n  return data.map((row: any) => {\n    const members = (row.table_hold_members ?? []) as Array<{ table_id: string }>;\n    const tableIds = members.map((member) => member.table_id);\n    return {\n      id: row.id,\n      bookingId: row.booking_id,\n      restaurantId: row.restaurant_id,\n      zoneId: row.zone_id,\n      startAt: row.start_at,\n      endAt: row.end_at,\n      expiresAt: row.expires_at,\n      tableIds,\n      createdBy: row.created_by ?? null,\n      metadata: row.metadata ?? null,\n    } satisfies TableHold;\n  });\n}\n\ntype RawAssignmentRecord = {\n  tableId: string;\n  startAt?: string | null;\n  endAt?: string | null;\n  mergeGroupId?: string | null;\n};\n\ntype AssignmentSyncParams = {\n  supabase: DbClient;\n  booking: BookingRow;\n  tableIds: string[];\n  idempotencyKey: string | null;\n  assignments: RawAssignmentRecord[];\n  startIso: string;\n  endIso: string;\n  actorId?: string | null;\n  mergeGroupId?: string | null;\n  holdContext?: {\n    holdId: string;\n    zoneId?: string | null;\n  };\n};\n\nfunction serializeDetails(value: unknown): string | null {\n  if (value === null || value === undefined) {\n    return null;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  try {\n    return JSON.stringify(value);\n  } catch {\n    return null;\n  }\n}\n\nasync function synchronizeAssignments(params: AssignmentSyncParams): Promise<TableAssignmentMember[]> {\n  const { supabase, booking, tableIds, idempotencyKey, assignments, startIso, endIso, actorId, mergeGroupId, holdContext } = params;\n  const uniqueTableIds = Array.from(new Set(tableIds));\n  const assignmentRows = await loadTableAssignmentsForTables(booking.id, uniqueTableIds, supabase);\n  const windowRange = `[${startIso},${endIso})`;\n\n  const needsUpdate = assignments.some((assignment) => {\n    const normalizedStart = normalizeIsoString(assignment.startAt ?? null);\n    const normalizedEnd = normalizeIsoString(assignment.endAt ?? null);\n    return normalizedStart !== startIso || normalizedEnd !== endIso;\n  });\n\n  if (needsUpdate) {\n    try {\n      await supabase\n        .from(\"booking_table_assignments\")\n        .update({ start_at: startIso, end_at: endIso })\n        .eq(\"booking_id\", booking.id)\n        .in(\"table_id\", uniqueTableIds);\n    } catch {\n      // Ignore in mocked environments.\n    }\n\n    try {\n      await supabase\n        .from(\"allocations\")\n        .update({ window: windowRange })\n        .eq(\"booking_id\", booking.id)\n        .eq(\"resource_type\", TABLE_RESOURCE_TYPE)\n        .in(\"resource_id\", uniqueTableIds);\n    } catch {\n      // Ignore missing allocation support in mocked environments.\n    }\n\n    if (idempotencyKey) {\n      try {\n        await supabase\n          .from(\"booking_assignment_idempotency\")\n          .update({\n            assignment_window: windowRange,\n            merge_group_allocation_id: mergeGroupId ?? null,\n          })\n          .eq(\"booking_id\", booking.id)\n          .eq(\"idempotency_key\", idempotencyKey);\n      } catch {\n        // Ignore ledger updates in mocked environments.\n      }\n    }\n  }\n\n  const assignmentLookup = new Map<string, RawAssignmentRecord>();\n  for (const assignment of assignments) {\n    assignmentLookup.set(assignment.tableId, assignment);\n  }\n\n  const tableRowLookup = new Map(assignmentRows.map((row) => [row.table_id, row]));\n\n  const result: TableAssignmentMember[] = uniqueTableIds.map((tableId) => {\n    const row = tableRowLookup.get(tableId);\n    const assignment = assignmentLookup.get(tableId);\n    return {\n      tableId,\n      assignmentId: row?.id ?? randomUUID(),\n      startAt: startIso,\n      endAt: endIso,\n      mergeGroupId: assignment?.mergeGroupId ?? mergeGroupId ?? null,\n    };\n  });\n\n  if (holdContext) {\n    await emitHoldConfirmed({\n      holdId: holdContext.holdId,\n      bookingId: booking.id,\n      restaurantId: booking.restaurant_id,\n      zoneId: holdContext.zoneId ?? result[0]?.tableId ?? \"\",\n      tableIds: result.map((assignment) => assignment.tableId),\n      startAt: startIso,\n      endAt: endIso,\n      expiresAt: endIso,\n      actorId: actorId ?? null,\n    });\n  }\n\n  return result;\n}\n\nexport async function confirmHoldAssignment(options: {\n  holdId: string;\n  bookingId: string;\n  idempotencyKey: string;\n  requireAdjacency?: boolean;\n  assignedBy?: string | null;\n  client?: DbClient;\n}): Promise<TableAssignmentMember[]> {\n  if (!isAllocatorV2Enabled()) {\n    throw new AssignTablesRpcError({\n      message: \"Allocator v2 must be enabled to confirm holds\",\n      code: \"ALLOCATOR_V2_DISABLED\",\n      details: null,\n      hint: \"Enable allocator.v2.enabled to use confirmHoldAssignment\",\n    });\n  }\n\n  const { holdId, bookingId, idempotencyKey, requireAdjacency = isAllocatorAdjacencyRequired(), assignedBy = null, client } = options;\n  const supabase = ensureClient(client);\n\n  const {\n    data: holdRow,\n    error: holdError,\n  } = await supabase\n    .from(\"table_holds\")\n    .select(\"restaurant_id, zone_id, table_hold_members(table_id)\")\n    .eq(\"id\", holdId)\n    .maybeSingle();\n\n  if (holdError) {\n    throw new HoldNotFoundError(holdError.message ?? \"Failed to load table hold\");\n  }\n\n  if (!holdRow) {\n    throw new HoldNotFoundError();\n  }\n\n  const tableIds = Array.isArray(holdRow.table_hold_members)\n    ? (holdRow.table_hold_members as Array<{ table_id: string }>).map((member) => member.table_id)\n    : [];\n\n  if (tableIds.length === 0) {\n    throw new AssignTablesRpcError({\n      message: \"Hold has no tables\",\n      code: \"HOLD_EMPTY\",\n      details: null,\n      hint: null,\n    });\n  }\n\n  const booking = await loadBooking(bookingId, supabase);\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const window = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n\n  const startIso = toIsoUtc(window.block.start);\n  const endIso = toIsoUtc(window.block.end);\n  const normalizedTableIds = normalizeTableIds(tableIds);\n  const planSignature = createPlanSignature({\n    bookingId,\n    tableIds: normalizedTableIds,\n    startAt: startIso,\n    endAt: endIso,\n  });\n\n  const orchestrator = new AssignmentOrchestrator(new SupabaseAssignmentRepository(supabase));\n  let response;\n  try {\n    response = await orchestrator.commitPlan(\n      {\n        bookingId,\n        restaurantId: booking.restaurant_id,\n        partySize: booking.party_size,\n        zoneId: holdRow.zone_id,\n        serviceDate: booking.booking_date ?? null,\n        window: {\n          startAt: startIso,\n          endAt: endIso,\n        },\n        holdId,\n      },\n      {\n        signature: planSignature,\n        tableIds: normalizedTableIds,\n        startAt: startIso,\n        endAt: endIso,\n        metadata: {\n          holdId,\n        },\n      },\n      {\n        source: \"manual\",\n        idempotencyKey,\n        actorId: assignedBy,\n        metadata: {\n          requireAdjacency,\n          holdId,\n        },\n        requireAdjacency,\n      },\n    );\n  } catch (error) {\n    if (error instanceof AssignmentConflictError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_CONFLICT\",\n        details: serializeDetails(error.details),\n        hint: error.details?.hint ?? null,\n      });\n    }\n\n    if (error instanceof AssignmentValidationError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_VALIDATION\",\n        details: serializeDetails(error.details),\n        hint: null,\n      });\n    }\n\n    if (error instanceof AssignmentRepositoryError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_REPOSITORY_ERROR\",\n        details: serializeDetails(error.cause ?? null),\n        hint: null,\n      });\n    }\n\n    throw error;\n  }\n\n  try {\n    await supabase.from(\"table_holds\").delete().eq(\"id\", holdId);\n  } catch {\n    // Best-effort cleanup.\n  }\n\n  return synchronizeAssignments({\n    supabase,\n    booking,\n    tableIds: normalizedTableIds,\n    idempotencyKey,\n    assignments: response.assignments.map((assignment) => ({\n      tableId: assignment.tableId,\n      startAt: assignment.startAt,\n      endAt: assignment.endAt,\n      mergeGroupId: assignment.mergeGroupId ?? response.mergeGroupId ?? null,\n    })),\n    startIso,\n    endIso,\n    actorId: assignedBy,\n    mergeGroupId: response.mergeGroupId ?? null,\n    holdContext: {\n      holdId,\n      zoneId: holdRow.zone_id ?? null,\n    },\n  });\n}\n\nexport async function assignTableToBooking(\n  bookingId: string,\n  tableIdOrIds: string | string[],\n  assignedBy: string | null,\n  client?: DbClient,\n  options?: { idempotencyKey?: string | null; requireAdjacency?: boolean; booking?: BookingRow },\n): Promise<string> {\n  if (!isAllocatorV2Enabled()) {\n    throw new AssignTablesRpcError({\n      message: \"Allocator v2 must be enabled to assign tables\",\n      code: \"ALLOCATOR_V2_DISABLED\",\n      details: null,\n      hint: \"Enable allocator.v2.enabled to call assignTableToBooking\",\n    });\n  }\n\n  const supabase = ensureClient(client);\n  const tableIds = Array.isArray(tableIdOrIds) ? tableIdOrIds : [tableIdOrIds];\n  if (tableIds.length === 0) {\n    throw new ManualSelectionInputError(\"Must provide at least one table id\", \"TABLES_REQUIRED\");\n  }\n\n  const booking = options?.booking ?? (await loadBooking(bookingId, supabase));\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const window = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n  const startIso = toIsoUtc(window.block.start);\n  const endIso = toIsoUtc(window.block.end);\n  const normalizedTableIds = normalizeTableIds(tableIds);\n  const planSignature = createPlanSignature({\n    bookingId,\n    tableIds: normalizedTableIds,\n    startAt: startIso,\n    endAt: endIso,\n    salt: options?.idempotencyKey ?? undefined,\n  });\n  const idempotencyKey = options?.idempotencyKey ?? planSignature;\n  const requireAdjacency = options?.requireAdjacency ?? false;\n\n  const orchestrator = new AssignmentOrchestrator(new SupabaseAssignmentRepository(supabase));\n  let response;\n  try {\n    response = await orchestrator.commitPlan(\n      {\n        bookingId,\n        restaurantId: booking.restaurant_id,\n        partySize: booking.party_size,\n        serviceDate: booking.booking_date ?? null,\n        window: {\n          startAt: startIso,\n          endAt: endIso,\n        },\n      },\n      {\n        signature: planSignature,\n        tableIds: normalizedTableIds,\n        startAt: startIso,\n        endAt: endIso,\n        metadata: {\n          requestSource: \"assignTableToBooking\",\n        },\n      },\n      {\n        source: \"manual\",\n        idempotencyKey,\n        actorId: assignedBy,\n        metadata: {\n          requireAdjacency,\n        },\n        requireAdjacency,\n      },\n    );\n  } catch (error) {\n    if (error instanceof AssignmentConflictError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_CONFLICT\",\n        details: serializeDetails(error.details),\n        hint: error.details?.hint ?? null,\n      });\n    }\n\n    if (error instanceof AssignmentValidationError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_VALIDATION\",\n        details: serializeDetails(error.details),\n        hint: null,\n      });\n    }\n\n    if (error instanceof AssignmentRepositoryError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_REPOSITORY_ERROR\",\n        details: serializeDetails(error.cause ?? null),\n        hint: null,\n      });\n    }\n\n    throw error;\n  }\n\n  const synchronized = await synchronizeAssignments({\n    supabase,\n    booking,\n    tableIds: normalizedTableIds,\n    idempotencyKey,\n    assignments: response.assignments.map((assignment) => ({\n      tableId: assignment.tableId,\n      startAt: assignment.startAt,\n      endAt: assignment.endAt,\n      mergeGroupId: assignment.mergeGroupId ?? response.mergeGroupId ?? null,\n    })),\n    startIso,\n    endIso,\n    actorId: assignedBy,\n    mergeGroupId: response.mergeGroupId ?? null,\n  });\n\n  const firstAssignment = synchronized[0];\n  if (!firstAssignment) {\n    throw new AssignTablesRpcError({\n      message: \"Assignment failed with no records returned\",\n      code: \"ASSIGNMENT_EMPTY\",\n      details: null,\n      hint: null,\n    });\n  }\n\n  return firstAssignment.assignmentId;\n}\n\nexport async function unassignTableFromBooking(\n  bookingId: string,\n  tableId: string,\n  client?: DbClient,\n): Promise<boolean> {\n  const supabase = ensureClient(client);\n  const { data, error } = await supabase.rpc(\"unassign_tables_atomic\", {\n    p_booking_id: bookingId,\n    p_table_ids: [tableId],\n  });\n  if (error) {\n    return false;\n  }\n  return Array.isArray(data) && data.length > 0;\n}\n\nexport async function getBookingTableAssignments(\n  bookingId: string,\n  client?: DbClient,\n): Promise<TableAssignmentMember[]> {\n  const supabase = ensureClient(client);\n  const { data, error } = await supabase\n    .from(\"booking_table_assignments\")\n    .select(\"table_id, id, assigned_at\")\n    .eq(\"booking_id\", bookingId);\n\n  if (error || !data) {\n    return [];\n  }\n\n  return data.map((row) => ({\n    tableId: row.table_id,\n    assignmentId: row.id,\n    startAt: row.assigned_at ?? \"\",\n    endAt: row.assigned_at ?? \"\",\n    mergeGroupId: null,\n  }));\n}\n\nexport async function quoteTablesForBooking(options: QuoteTablesOptions): Promise<QuoteTablesResult> {\n  const {\n    bookingId,\n    zoneId,\n    maxTables,\n    requireAdjacency = isAllocatorAdjacencyRequired(),\n    avoidTables = [],\n    holdTtlSeconds = DEFAULT_HOLD_TTL_SECONDS,\n    createdBy,\n    client,\n  } = options;\n\n  const supabase = ensureClient(client);\n  const booking = await loadBooking(bookingId, supabase);\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const window = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n\n  const tables = await loadTablesForRestaurant(booking.restaurant_id, supabase);\n  const adjacency = await loadAdjacency(\n    tables.map((table) => table.id),\n    supabase,\n  );\n\n  const filtered = filterAvailableTables(\n    tables,\n    booking.party_size,\n    window,\n    adjacency,\n    new Set(avoidTables),\n    zoneId ?? null,\n    { allowInsufficientCapacity: true },\n  );\n\n  const scoringConfig = getSelectorScoringConfig();\n  const plans = buildScoredTablePlans({\n    tables: filtered,\n    partySize: booking.party_size,\n    adjacency,\n    config: scoringConfig,\n    enableCombinations: isCombinationPlannerEnabled(),\n    kMax: maxTables ?? getAllocatorCombinationLimit(),\n    requireAdjacency,\n  });\n\n  const alternates: CandidateSummary[] = [];\n\n  for (let index = 0; index < plans.plans.length; index += 1) {\n    const plan = plans.plans[index]!;\n    const candidateSummary = summarizeCandidate({\n      tableIds: plan.tables.map((table) => table.id),\n      tableNumbers: plan.tables.map((table) => table.tableNumber),\n      totalCapacity: plan.totalCapacity,\n      tableCount: plan.tables.length,\n      slack: plan.slack,\n      score: plan.score,\n      adjacencyStatus: plan.adjacencyStatus,\n    });\n\n    if (index > 0) {\n      alternates.push(candidateSummary);\n    }\n\n    try {\n      const summary = summarizeSelection(plan.tables, booking.party_size);\n      const zoneForHold = summary.zoneId ?? plan.tables[0]?.zoneId;\n      if (!zoneForHold) {\n        continue;\n      }\n\n      const hold = await createTableHold({\n        bookingId,\n        restaurantId: booking.restaurant_id,\n        zoneId: zoneForHold,\n        tableIds: plan.tables.map((table) => table.id),\n        startAt: toIsoUtc(window.block.start),\n        endAt: toIsoUtc(window.block.end),\n        expiresAt: toIsoUtc(DateTime.now().plus({ seconds: holdTtlSeconds })),\n        createdBy,\n        metadata: {\n          selection: {\n            tableIds: plan.tables.map((table) => table.id),\n            summary,\n          },\n        },\n        client: supabase,\n      });\n\n      await emitSelectorQuote({\n        restaurantId: booking.restaurant_id,\n        bookingId,\n        partySize: booking.party_size,\n        window: {\n          start: toIsoUtc(window.block.start),\n          end: toIsoUtc(window.block.end),\n        },\n        candidates: [candidateSummary, ...alternates],\n        selected: candidateSummary,\n        durationMs: 0,\n        featureFlags: {\n          selectorScoring: isSelectorScoringEnabled(),\n          opsMetrics: isOpsMetricsEnabled(),\n        },\n        diagnostics: plans.diagnostics,\n        holdId: hold.id,\n        expiresAt: hold.expiresAt,\n      });\n\n      return {\n        hold,\n        candidate: candidateSummary,\n        alternates,\n        nextTimes: [],\n      };\n    } catch (error) {\n      if (error instanceof HoldConflictError) {\n        const conflicts = await findHoldConflicts({\n          restaurantId: booking.restaurant_id,\n          tableIds: plan.tables.map((table) => table.id),\n          startAt: toIsoUtc(window.block.start),\n          endAt: toIsoUtc(window.block.end),\n          client: supabase,\n        });\n\n        await emitRpcConflict({\n          source: \"create_hold_conflict\",\n          bookingId,\n          restaurantId: booking.restaurant_id,\n          tableIds: plan.tables.map((table) => table.id),\n          holdId: error.holdId ?? null,\n          error: {\n            code: null,\n            message: error.message,\n            details: JSON.stringify(conflicts),\n            hint: null,\n          },\n        });\n\n        continue;\n      }\n      throw error;\n    }\n  }\n\n  return {\n    hold: null,\n    candidate: null,\n    alternates,\n    nextTimes: [],\n    reason: plans.fallbackReason ?? \"No suitable tables available\",\n  };\n}\n\nexport async function autoAssignTablesForDate(options: {\n  restaurantId: string;\n  date: string;\n  client?: DbClient;\n  assignedBy?: string | null;\n}): Promise<AutoAssignResult> {\n  const { restaurantId, date, client, assignedBy = null } = options;\n  const supabase = ensureClient(client);\n  const [bookings, tables, restaurantTimezone] = await Promise.all([\n    loadContextBookings(restaurantId, date, supabase),\n    loadTablesForRestaurant(restaurantId, supabase),\n    loadRestaurantTimezone(restaurantId, supabase),\n  ]);\n  const adjacency = await loadAdjacency(\n    tables.map((table) => table.id),\n    supabase,\n  );\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const adjacencyEdgeCount = Array.from(adjacency.values()).reduce((sum, neighbors) => sum + neighbors.size, 0);\n  const requireAdjacencyForMerge = adjacencyEdgeCount > 0 && isAllocatorAdjacencyRequired();\n  const combinationPlannerEnabled = isCombinationPlannerEnabled();\n  const mergesEnabled = isAllocatorMergesEnabled();\n  let activeHolds: TableHold[] = [];\n  if (isHoldsEnabled()) {\n    try {\n      activeHolds = await loadActiveHoldsForDate(restaurantId, date, policy, supabase);\n    } catch (error: any) {\n      if (error?.code === \"42P01\") {\n        console.warn(\"[ops][auto-assign] holds table unavailable; skipping hold hydration\", {\n          restaurantId,\n        });\n      } else {\n        console.warn(\"[ops][auto-assign] failed to load active holds\", {\n          restaurantId,\n          error,\n        });\n      }\n      activeHolds = [];\n    }\n  }\n\n  const result: AutoAssignResult = {\n    assigned: [],\n    skipped: [],\n  };\n\n  for (const booking of bookings) {\n    const alreadyAssigned = (booking.booking_table_assignments ?? []).some((row) => Boolean(row.table_id));\n    if (alreadyAssigned) {\n      continue;\n    }\n\n    const featureFlags = {\n      selectorScoring: isSelectorScoringEnabled(),\n      opsMetrics: isOpsMetricsEnabled(),\n    };\n\n    let window: BookingWindow | null = null;\n    let overrunReason: string | null = null;\n    try {\n      window = computeBookingWindowWithFallback({\n        startISO: booking.start_at,\n        bookingDate: booking.booking_date,\n        startTime: booking.start_time,\n        partySize: booking.party_size,\n        policy,\n      });\n    } catch (error) {\n      if (error instanceof ServiceOverrunError) {\n        overrunReason = error.message ?? \"Reservation window exceeds service boundary\";\n      } else {\n        throw error;\n      }\n    }\n    if (!window) {\n      const reason = overrunReason ?? \"Reservation window exceeds service boundary\";\n      result.skipped.push({ bookingId: booking.id, reason });\n      await emitSelectorDecision({\n        restaurantId,\n        bookingId: booking.id,\n        partySize: booking.party_size,\n        window: undefined,\n        candidates: [],\n        selected: null,\n        skipReason: reason,\n        durationMs: 0,\n        featureFlags,\n        diagnostics: undefined,\n      });\n      continue;\n    }\n\n    const availableTables = filterAvailableTables(\n      tables,\n      booking.party_size,\n      window,\n      adjacency,\n      undefined,\n      undefined,\n      { allowInsufficientCapacity: true },\n    );\n    const scoringConfig = getSelectorScoringConfig();\n    const runPlanner = (enableCombinations: boolean) =>\n      buildScoredTablePlans({\n        tables: availableTables,\n        partySize: booking.party_size,\n        adjacency,\n        config: scoringConfig,\n        enableCombinations,\n        kMax: getAllocatorCombinationLimit(),\n        requireAdjacency: requireAdjacencyForMerge,\n      });\n    let plans = runPlanner(combinationPlannerEnabled);\n\n    if (plans.plans.length === 0 && !combinationPlannerEnabled) {\n      if (mergesEnabled) {\n        const mergeFallback = runPlanner(true);\n        if (mergeFallback.plans.length > 0) {\n          plans = mergeFallback;\n        } else {\n          plans = {\n            ...mergeFallback,\n            fallbackReason: mergeFallback.fallbackReason ?? \"Combination planner disabled (requires merges)\",\n          };\n        }\n      } else if (!plans.fallbackReason) {\n        plans = {\n          ...plans,\n          fallbackReason: \"Combination planner disabled (requires merges)\",\n        };\n      }\n    }\n\n    if (plans.plans.length === 0) {\n      const fallback = plans.fallbackReason ?? \"No suitable tables available\";\n      const skipReason = `No suitable tables available (${fallback})`;\n      result.skipped.push({ bookingId: booking.id, reason: skipReason });\n      await emitSelectorDecision({\n        restaurantId,\n        bookingId: booking.id,\n        partySize: booking.party_size,\n        window: {\n          start: toIsoUtc(window.block.start),\n          end: toIsoUtc(window.block.end),\n        },\n        candidates: [],\n        selected: null,\n        skipReason,\n        durationMs: 0,\n        featureFlags,\n        diagnostics: plans.diagnostics,\n      });\n      continue;\n    }\n\n    const busy = buildBusyMaps({\n      targetBookingId: booking.id,\n      bookings,\n      holds: activeHolds,\n      policy,\n    });\n\n    const planEvaluations = plans.plans.map((plan) => ({\n      plan,\n      conflicts: extractConflictsForTables(\n        busy,\n        plan.tables.map((table) => table.id),\n        window,\n      ),\n    }));\n\n    const candidateSummariesAll: CandidateSummary[] = planEvaluations.map(({ plan }) =>\n      summarizeCandidate({\n        tableIds: plan.tables.map((table) => table.id),\n        tableNumbers: plan.tables.map((table) => table.tableNumber),\n        totalCapacity: plan.totalCapacity,\n        tableCount: plan.tables.length,\n        slack: plan.slack,\n        score: plan.score,\n        adjacencyStatus: plan.adjacencyStatus,\n      }),\n    );\n\n    const conflictFreeEntries = planEvaluations.filter(({ conflicts }) => conflicts.length === 0);\n    if (conflictFreeEntries.length === 0) {\n      const conflictEntry = planEvaluations.find(({ conflicts }) => conflicts.length > 0);\n      const conflictSummary = conflictEntry ? formatConflictSummary(conflictEntry.conflicts) : \"conflicts\";\n      const skipReason = `Conflicts with existing ${conflictSummary}`;\n\n      if (conflictEntry) {\n        await emitRpcConflict({\n          source: \"auto_assign_conflict\",\n          bookingId: booking.id,\n          restaurantId,\n          tableIds: conflictEntry.plan.tables.map((table) => table.id),\n          error: {\n            code: null,\n            message: skipReason,\n            details: JSON.stringify(conflictEntry.conflicts),\n            hint: null,\n          },\n        });\n      }\n\n      result.skipped.push({ bookingId: booking.id, reason: skipReason });\n      await emitSelectorDecision({\n        restaurantId,\n        bookingId: booking.id,\n        partySize: booking.party_size,\n        window: {\n          start: toIsoUtc(window.block.start),\n          end: toIsoUtc(window.block.end),\n        },\n        candidates: candidateSummariesAll,\n        selected: null,\n        skipReason,\n        durationMs: 0,\n        featureFlags,\n        diagnostics: plans.diagnostics,\n      });\n      continue;\n    }\n\n    const topEntry = conflictFreeEntries[0]!;\n    const topPlan = topEntry.plan;\n    const candidateSummaries: CandidateSummary[] = conflictFreeEntries.map(({ plan }) =>\n      summarizeCandidate({\n        tableIds: plan.tables.map((table) => table.id),\n        tableNumbers: plan.tables.map((table) => table.tableNumber),\n        totalCapacity: plan.totalCapacity,\n        tableCount: plan.tables.length,\n        slack: plan.slack,\n        score: plan.score,\n        adjacencyStatus: plan.adjacencyStatus,\n      }),\n    );\n    const candidate = candidateSummaries[0]!;\n\n    try {\n      await assignTableToBooking(\n        booking.id,\n        topPlan.tables.map((table) => table.id),\n        assignedBy,\n        supabase,\n        {\n          idempotencyKey: randomUUID(),\n          requireAdjacency: requireAdjacencyForMerge,\n          booking: {\n            ...(booking as any),\n            id: booking.id,\n            restaurant_id: restaurantId,\n            booking_date: booking.booking_date,\n            start_time: booking.start_time,\n            end_time: booking.end_time,\n            start_at: booking.start_at,\n            end_at: booking.end_at,\n            party_size: booking.party_size,\n            status: booking.status,\n            seating_preference: booking.seating_preference ?? null,\n            restaurants: { timezone: policy.timezone },\n          } as BookingRow,\n        },\n      );\n    } catch (error: any) {\n      const message = error?.message ? String(error.message) : String(error);\n      const normalized = message.toLowerCase();\n      const overlap =\n        normalized.includes(\"assignment overlap\") || normalized.includes(\"allocations_no_overlap\");\n\n      if (!overlap) {\n        throw error;\n      }\n\n      await emitRpcConflict({\n        source: \"auto_assign_overlap\",\n        bookingId: booking.id,\n        restaurantId,\n        tableIds: topPlan.tables.map((table) => table.id),\n        error: {\n          code: null,\n          message,\n          details: null,\n          hint: null,\n        },\n      });\n\n      const skipReason = \"Auto assign skipped: Supabase reported an overlapping assignment\";\n      result.skipped.push({ bookingId: booking.id, reason: skipReason });\n      await emitSelectorDecision({\n        restaurantId,\n        bookingId: booking.id,\n        partySize: booking.party_size,\n        window: {\n          start: toIsoUtc(window.block.start),\n          end: toIsoUtc(window.block.end),\n        },\n        candidates: candidateSummariesAll,\n        selected: null,\n        skipReason,\n        durationMs: 0,\n        featureFlags,\n        diagnostics: plans.diagnostics,\n      });\n      continue;\n    }\n\n    if (!booking.booking_table_assignments) {\n      booking.booking_table_assignments = [];\n    }\n    for (const table of topPlan.tables) {\n      if (!booking.booking_table_assignments.some((assignment) => assignment?.table_id === table.id)) {\n        booking.booking_table_assignments.push({ table_id: table.id });\n      }\n    }\n\n    result.assigned.push({\n      bookingId: booking.id,\n      tableIds: topPlan.tables.map((table) => table.id),\n    });\n\n    await emitSelectorDecision({\n      restaurantId,\n      bookingId: booking.id,\n      partySize: booking.party_size,\n      window: {\n        start: toIsoUtc(window.block.start),\n        end: toIsoUtc(window.block.end),\n      },\n      candidates: candidateSummaries,\n      selected: candidate,\n      skipReason: null,\n      durationMs: 0,\n      featureFlags,\n      diagnostics: plans.diagnostics,\n    });\n  }\n\n  return result;\n}\n\nexport async function autoAssignTables(options: {\n  restaurantId: string;\n  date: string;\n  client?: DbClient;\n  assignedBy?: string | null;\n}): Promise<AutoAssignResult> {\n  return autoAssignTablesForDate(options);\n}\n\nexport async function findSuitableTables(options: {\n  bookingId: string;\n  client?: DbClient;\n}): Promise<RankedTablePlan[]> {\n  const { bookingId, client } = options;\n  const supabase = ensureClient(client);\n  const booking = await loadBooking(bookingId, supabase);\n  const tables = await loadTablesForRestaurant(booking.restaurant_id, supabase);\n  const adjacency = await loadAdjacency(\n    tables.map((table) => table.id),\n    supabase,\n  );\n  const policy = getVenuePolicy();\n  const window = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n\n  const filtered = filterAvailableTables(\n    tables,\n    booking.party_size,\n    window,\n    adjacency,\n    undefined,\n    undefined,\n    { allowInsufficientCapacity: true },\n  );\n  const scoringConfig = getSelectorScoringConfig();\n  const plans = buildScoredTablePlans({\n    tables: filtered,\n    partySize: booking.party_size,\n    adjacency,\n    config: scoringConfig,\n    enableCombinations: isCombinationPlannerEnabled(),\n    kMax: getAllocatorCombinationLimit(),\n    requireAdjacency: isAllocatorAdjacencyRequired(),\n  });\n\n  return plans.plans;\n}\n\nexport async function isTableAvailableV2(\n  tableId: string,\n  startISO: string,\n  partySize: number,\n  options?: {\n    excludeBookingId?: string;\n    policy?: VenuePolicy;\n    client?: DbClient;\n  },\n): Promise<boolean> {\n  const supabase = ensureClient(options?.client);\n  const policy = options?.policy ?? getVenuePolicy();\n  const window = computeBookingWindowWithFallback({\n    startISO,\n    partySize,\n    policy,\n  });\n\n  const { data, error } = await supabase\n    .from(\"booking_table_assignments\")\n    .select(\"table_id, start_at, end_at, bookings(id, status, start_at, end_at)\")\n    .eq(\"table_id\", tableId);\n\n  if (error || !data) {\n    return true;\n  }\n\n  for (const row of data) {\n    const booking = (row as any).bookings;\n    if (options?.excludeBookingId && booking?.id === options.excludeBookingId) {\n      continue;\n    }\n\n    const otherStart = row.start_at ?? booking?.start_at;\n    const otherEnd = row.end_at ?? booking?.end_at;\n    if (!otherStart || !otherEnd) {\n      continue;\n    }\n\n    if (\n      windowsOverlapMs(\n        toIsoUtc(window.block.start),\n        toIsoUtc(window.block.end),\n        otherStart,\n        otherEnd,\n      )\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport async function isTableAvailable(\n  tableId: string,\n  startISO: string,\n  partySize: number,\n  options?: {\n    excludeBookingId?: string;\n    policy?: VenuePolicy;\n    client?: DbClient;\n  },\n): Promise<boolean> {\n  return isTableAvailableV2(tableId, startISO, partySize, options);\n}\n\nexport const __internal = {\n  computeBookingWindow,\n  windowsOverlap,\n  filterAvailableTables,\n};\n",
  "server/capacity/selector.ts": "import type { SelectorScoringConfig, SelectorScoringWeights } from \"./policy\";\nimport type { Table } from \"./tables\";\n\nexport type CandidateMetrics = {\n  overage: number;\n  tableCount: number;\n  fragmentation: number;\n  zoneBalance: number;\n  adjacencyCost: number;\n};\n\nexport type RankedTablePlan = {\n  tables: Table[];\n  totalCapacity: number;\n  slack: number;\n  metrics: CandidateMetrics;\n  score: number;\n  tableKey: string;\n  adjacencyStatus: \"single\" | \"connected\" | \"disconnected\";\n};\n\nexport type CandidateDiagnostics = {\n  singlesConsidered: number;\n  combinationsEnumerated: number;\n  combinationsAccepted: number;\n  skipped: Record<string, number>;\n};\n\nexport type BuildCandidatesOptions = {\n  tables: Table[];\n  partySize: number;\n  adjacency: Map<string, Set<string>>;\n  config: SelectorScoringConfig;\n  enableCombinations?: boolean;\n  kMax?: number;\n  maxPlansPerSlack?: number;\n  maxCombinationEvaluations?: number;\n  requireAdjacency?: boolean;\n};\n\nexport type BuildCandidatesResult = {\n  plans: RankedTablePlan[];\n  fallbackReason?: string;\n  diagnostics: CandidateDiagnostics;\n};\n\nconst FALLBACK_NO_TABLES = \"No tables meet the capacity requirements for this party size.\";\nconst DEFAULT_MAX_PLANS_PER_SLACK = 50;\nconst DEFAULT_MAX_COMBINATION_EVALUATIONS = 500;\n\nfunction incrementCounter(target: Record<string, number>, key: string, amount = 1): void {\n  const current = target[key] ?? 0;\n  target[key] = current + amount;\n}\n\nexport function buildScoredTablePlans(options: BuildCandidatesOptions): BuildCandidatesResult {\n  const {\n    tables,\n    partySize,\n    adjacency,\n    config,\n    enableCombinations = false,\n    kMax,\n    maxPlansPerSlack,\n    maxCombinationEvaluations,\n    requireAdjacency = true,\n  } = options;\n  const { maxOverage, weights } = config;\n\n  const diagnostics: CandidateDiagnostics = {\n    singlesConsidered: 0,\n    combinationsEnumerated: 0,\n    combinationsAccepted: 0,\n    skipped: Object.create(null) as Record<string, number>,\n  };\n\n  const maxAllowedCapacity = partySize + Math.max(maxOverage, 0);\n  const combinationCap = Math.max(1, Math.min(kMax ?? config.maxTables ?? 1, tables.length || 1));\n  const perSlackLimit = Math.max(1, maxPlansPerSlack ?? DEFAULT_MAX_PLANS_PER_SLACK);\n  const combinationEvaluationLimit = Math.max(1, maxCombinationEvaluations ?? DEFAULT_MAX_COMBINATION_EVALUATIONS);\n\n  const validTables: Table[] = [];\n  const singleTableCandidates: Table[] = [];\n\n  for (const table of tables) {\n    const capacity = table.capacity ?? 0;\n    if (!Number.isFinite(capacity) || capacity <= 0) {\n      incrementCounter(diagnostics.skipped, \"capacity\");\n      continue;\n    }\n\n    if (typeof table.minPartySize === \"number\" && table.minPartySize > 0 && partySize < table.minPartySize) {\n      incrementCounter(diagnostics.skipped, \"capacity\");\n      continue;\n    }\n\n    if (typeof table.maxPartySize === \"number\" && table.maxPartySize > 0 && partySize > table.maxPartySize) {\n      incrementCounter(diagnostics.skipped, \"capacity\");\n      continue;\n    }\n\n    if (capacity > maxAllowedCapacity) {\n      incrementCounter(diagnostics.skipped, \"overage\");\n      continue;\n    }\n\n    validTables.push(table);\n\n    if (capacity >= partySize) {\n      singleTableCandidates.push(table);\n    }\n  }\n\n  diagnostics.singlesConsidered = singleTableCandidates.length;\n\n  const plans: RankedTablePlan[] = [];\n\n  for (const table of singleTableCandidates) {\n    const adjacencyDepths = new Map<string, number>([[table.id, 0]]);\n    const metrics = computeMetrics([table], partySize, adjacencyDepths);\n    const score = computeScore(metrics, weights);\n    const totalCapacity = metrics.overage + partySize;\n    const tableKey = buildTableKey([table]);\n\n    plans.push({\n      tables: [table],\n      totalCapacity,\n      slack: metrics.overage,\n      metrics,\n      score,\n      tableKey,\n      adjacencyStatus: \"single\",\n    });\n  }\n\n  if (enableCombinations && combinationCap > 1 && validTables.length > 1) {\n    const combinationPlans = enumerateCombinationPlans({\n      candidates: validTables,\n      partySize,\n      weights,\n      adjacency,\n      maxAllowedCapacity,\n      kMax: combinationCap,\n      bucketLimit: perSlackLimit,\n      evaluationLimit: combinationEvaluationLimit,\n      diagnostics,\n      requireAdjacency,\n    });\n\n    plans.push(...combinationPlans);\n  }\n\n  plans.sort((a, b) => comparePlans(a, b, weights));\n\n  const fallbackReason = plans.length > 0 ? undefined : FALLBACK_NO_TABLES;\n\n  for (const key of [\"capacity\", \"overage\", \"adjacency\", \"kmax\", \"bucket\", \"limit\", \"zone\"]) {\n    if (diagnostics.skipped[key] === undefined) {\n      diagnostics.skipped[key] = 0;\n    }\n  }\n\n  return { plans, fallbackReason, diagnostics };\n}\n\nfunction computeMetrics(tables: Table[], partySize: number, adjacencyDepths: Map<string, number>): CandidateMetrics {\n  const capacities = tables.map((table) => table.capacity ?? 0);\n  const totalCapacity = capacities.reduce((sum, capacity) => sum + capacity, 0);\n  const maxCapacity = capacities.length > 0 ? Math.max(...capacities) : 0;\n  const overage = Math.max(totalCapacity - partySize, 0);\n  const fragmentation = Math.max(totalCapacity - maxCapacity, 0);\n  const zoneIds = new Set(tables.map((table) => table.zoneId ?? null));\n  const zoneBalance = Math.max(zoneIds.size - 1, 0);\n  const depthValues = adjacencyDepths.size > 0 ? [...adjacencyDepths.values()] : [0];\n  let adjacencyCost = Math.max(...depthValues);\n  if (adjacencyDepths.size < tables.length) {\n    adjacencyCost = Math.max(adjacencyCost, tables.length);\n  }\n\n  return {\n    overage,\n    tableCount: tables.length,\n    fragmentation,\n    zoneBalance,\n    adjacencyCost,\n  };\n}\n\nfunction computeScore(metrics: CandidateMetrics, weights: SelectorScoringWeights): number {\n  return (\n    metrics.overage * weights.overage +\n    (metrics.tableCount - 1) * weights.tableCount +\n    metrics.fragmentation * weights.fragmentation +\n    metrics.zoneBalance * weights.zoneBalance +\n    metrics.adjacencyCost * weights.adjacencyCost\n  );\n}\n\nfunction comparePlans(a: RankedTablePlan, b: RankedTablePlan, weights: SelectorScoringWeights): number {\n  if (a.score !== b.score) {\n    return a.score - b.score;\n  }\n\n  if (a.metrics.overage !== b.metrics.overage) {\n    return a.metrics.overage - b.metrics.overage;\n  }\n\n  if (a.metrics.tableCount !== b.metrics.tableCount) {\n    return a.metrics.tableCount - b.metrics.tableCount;\n  }\n\n  if (a.totalCapacity !== b.totalCapacity) {\n    return a.totalCapacity - b.totalCapacity;\n  }\n\n  if (a.metrics.fragmentation !== b.metrics.fragmentation) {\n    return a.metrics.fragmentation - b.metrics.fragmentation;\n  }\n\n  if (a.metrics.adjacencyCost !== b.metrics.adjacencyCost) {\n    return a.metrics.adjacencyCost - b.metrics.adjacencyCost;\n  }\n\n  return a.tableKey.localeCompare(b.tableKey, \"en\");\n}\n\nfunction buildTableKey(tables: Table[]): string {\n  return tables\n    .map((table) => table.tableNumber ?? table.id)\n    .sort((a, b) => a.localeCompare(b))\n    .join(\"+\");\n}\n\ntype CombinationPlannerArgs = {\n  candidates: Table[];\n  partySize: number;\n  weights: SelectorScoringWeights;\n  adjacency: Map<string, Set<string>>;\n  maxAllowedCapacity: number;\n  kMax: number;\n  bucketLimit: number;\n  evaluationLimit: number;\n  diagnostics: CandidateDiagnostics;\n  requireAdjacency: boolean;\n};\n\nfunction enumerateCombinationPlans(args: CombinationPlannerArgs): RankedTablePlan[] {\n  const {\n    candidates,\n    partySize,\n    weights,\n    adjacency,\n    maxAllowedCapacity,\n    kMax,\n    bucketLimit,\n    evaluationLimit,\n    diagnostics,\n    requireAdjacency,\n  } = args;\n\n  if (kMax <= 1) {\n    return [];\n  }\n\n  const seenKeys = new Set<string>();\n  const buckets = new Map<number, RankedTablePlan[]>();\n  const sortedCandidates = [...candidates].sort((a, b) => {\n    const capacityDiff = (a.capacity ?? 0) - (b.capacity ?? 0);\n    if (capacityDiff !== 0) {\n      return capacityDiff;\n    }\n    const nameA = a.tableNumber ?? a.id;\n    const nameB = b.tableNumber ?? b.id;\n    return nameA.localeCompare(nameB);\n  });\n\n  let evaluations = 0;\n  let enumerated = diagnostics.combinationsEnumerated ?? 0;\n  let accepted = diagnostics.combinationsAccepted ?? 0;\n  let limitRecorded = false;\n  let stopSearch = false;\n\n  const registerPlan = (plan: RankedTablePlan) => {\n    const bucket = buckets.get(plan.slack) ?? [];\n    bucket.push(plan);\n    bucket.sort((a, b) => comparePlans(a, b, weights));\n    if (bucket.length > bucketLimit) {\n      bucket.length = bucketLimit;\n      incrementCounter(diagnostics.skipped, \"bucket\");\n    }\n    buckets.set(plan.slack, bucket);\n    accepted += 1;\n    diagnostics.combinationsAccepted = accepted;\n  };\n\n  const dfs = (startIndex: number, selection: Table[], runningCapacity: number, baseZoneId: string | null) => {\n    if (stopSearch) {\n      return;\n    }\n\n    if (selection.length >= 2 && runningCapacity >= partySize) {\n      enumerated += 1;\n      diagnostics.combinationsEnumerated = enumerated;\n\n      const key = buildTableKey(selection);\n      if (!seenKeys.has(key)) {\n        seenKeys.add(key);\n        const adjacencyEvaluation = evaluateAdjacency(selection, adjacency);\n        if (!adjacencyEvaluation.connected && requireAdjacency) {\n          incrementCounter(diagnostics.skipped, \"adjacency\");\n        } else {\n          const metrics = computeMetrics(selection, partySize, adjacencyEvaluation.depths);\n          const score = computeScore(metrics, weights);\n          const totalCapacity = metrics.overage + partySize;\n          const adjacencyStatus: RankedTablePlan[\"adjacencyStatus\"] =\n            selection.length <= 1\n              ? \"single\"\n              : adjacencyEvaluation.connected\n                ? \"connected\"\n                : \"disconnected\";\n          const plan: RankedTablePlan = {\n            tables: [...selection],\n            totalCapacity,\n            slack: metrics.overage,\n            metrics,\n            score,\n            tableKey: key,\n            adjacencyStatus,\n          };\n          registerPlan(plan);\n        }\n      }\n\n      evaluations += 1;\n      if (evaluations >= evaluationLimit) {\n        stopSearch = true;\n        if (!limitRecorded) {\n          incrementCounter(diagnostics.skipped, \"limit\");\n          limitRecorded = true;\n        }\n        return;\n      }\n    }\n\n    if (selection.length >= kMax) {\n      if (runningCapacity < partySize) {\n        incrementCounter(diagnostics.skipped, \"capacity\");\n      }\n      incrementCounter(diagnostics.skipped, \"kmax\");\n      return;\n    }\n\n    for (let index = startIndex; index < sortedCandidates.length; index += 1) {\n      if (stopSearch) {\n        break;\n      }\n\n      const candidate = sortedCandidates[index];\n\n      if (selection.some((existing) => existing.id === candidate.id)) {\n        continue;\n      }\n\n      if (selection.length > 0 && baseZoneId && candidate.zoneId && candidate.zoneId !== baseZoneId) {\n        incrementCounter(diagnostics.skipped, \"zone\");\n        continue;\n      }\n\n      if (selection.length + 1 > kMax) {\n        incrementCounter(diagnostics.skipped, \"kmax\");\n        continue;\n      }\n\n      const nextCapacity = runningCapacity + (candidate.capacity ?? 0);\n\n      if (nextCapacity > maxAllowedCapacity) {\n        incrementCounter(diagnostics.skipped, \"overage\");\n        // Capacities sorted ascending; further entries will exceed as well for this path.\n        break;\n      }\n\n      if (requireAdjacency && selection.length > 0 && !isAdjacentToSelection(candidate, selection, adjacency)) {\n        incrementCounter(diagnostics.skipped, \"adjacency\");\n        continue;\n      }\n\n      const nextZoneId = baseZoneId ?? candidate.zoneId ?? null;\n\n      dfs(index + 1, [...selection, candidate], nextCapacity, nextZoneId);\n    }\n  };\n\n  for (let i = 0; i < sortedCandidates.length && !stopSearch; i += 1) {\n    const base = sortedCandidates[i];\n    dfs(i + 1, [base], base.capacity ?? 0, base.zoneId ?? null);\n  }\n\n  return Array.from(buckets.values())\n    .flat()\n    .sort((a, b) => comparePlans(a, b, weights));\n}\n\nfunction isAdjacentToSelection(candidate: Table, selection: Table[], adjacency: Map<string, Set<string>>): boolean {\n  for (const table of selection) {\n    const forward = adjacency.get(table.id);\n    if (forward && forward.has(candidate.id)) {\n      return true;\n    }\n    const backward = adjacency.get(candidate.id);\n    if (backward && backward.has(table.id)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction evaluateAdjacency(\n  tables: Table[],\n  adjacency: Map<string, Set<string>>,\n): { connected: boolean; depths: Map<string, number> } {\n  if (tables.length === 0) {\n    return { connected: true, depths: new Map() };\n  }\n\n  if (tables.length === 1) {\n    return { connected: true, depths: new Map([[tables[0].id, 0]]) };\n  }\n\n  const tableIds = tables.map((table) => table.id);\n  const selection = new Set(tableIds);\n  const depths = new Map<string, number>();\n  const queue: string[] = [];\n\n  const [firstId] = tableIds;\n  queue.push(firstId);\n  depths.set(firstId, 0);\n\n  while (queue.length > 0) {\n    const current = queue.shift();\n    if (!current) {\n      continue;\n    }\n    const neighbors = adjacency.get(current);\n    if (!neighbors) {\n      continue;\n    }\n    for (const neighbor of neighbors) {\n      if (!selection.has(neighbor) || depths.has(neighbor)) {\n        continue;\n      }\n      const depth = (depths.get(current) ?? 0) + 1;\n      depths.set(neighbor, depth);\n      queue.push(neighbor);\n    }\n  }\n\n  const connected = depths.size === selection.size;\n  return { connected, depths };\n}\n",
  "server/capacity/policy.ts": "import { DateTime } from \"luxon\";\n\nconst DEFAULT_TIMEZONE = \"Europe/London\";\n\nexport const SERVICE_KEYS = [\"lunch\", \"dinner\", \"drinks\"] as const;\nexport type ServiceKey = (typeof SERVICE_KEYS)[number];\n\nexport type TimeOfDay = {\n  hour: number;\n  minute: number;\n};\n\nexport type BufferConfig = {\n  pre: number;\n  post: number;\n};\n\nexport type TurnBand = {\n  maxPartySize: number;\n  durationMinutes: number;\n};\n\nexport type ServiceDefinition = {\n  key: ServiceKey;\n  label: string;\n  start: TimeOfDay;\n  end: TimeOfDay;\n  buffer: BufferConfig;\n  turnBands: TurnBand[];\n};\n\nexport type VenuePolicy = {\n  timezone: string;\n  services: Partial<Record<ServiceKey, ServiceDefinition>>;\n  serviceOrder: ServiceKey[];\n};\n\nexport type SelectorScoringWeights = {\n  overage: number;\n  tableCount: number;\n  fragmentation: number;\n  zoneBalance: number;\n  adjacencyCost: number;\n};\n\nexport type SelectorScoringConfig = {\n  weights: SelectorScoringWeights;\n  maxOverage: number;\n  maxTables: number;\n};\n\nexport type ServiceWindow = {\n  start: DateTime;\n  end: DateTime;\n};\n\nfunction cloneTurnBands(bands: TurnBand[]): TurnBand[] {\n  return bands.map((band) => ({ ...band }));\n}\n\nfunction cloneService(service: ServiceDefinition): ServiceDefinition {\n  return {\n    ...service,\n    start: { ...service.start },\n    end: { ...service.end },\n    buffer: { ...service.buffer },\n    turnBands: cloneTurnBands(service.turnBands),\n  };\n}\n\nexport const defaultVenuePolicy: VenuePolicy = {\n  timezone: DEFAULT_TIMEZONE,\n  serviceOrder: [\"lunch\", \"dinner\"],\n  services: {\n    lunch: {\n      key: \"lunch\",\n      label: \"Lunch\",\n      start: { hour: 12, minute: 0 },\n      end: { hour: 15, minute: 0 },\n      buffer: { pre: 0, post: 5 },\n      turnBands: [\n        { maxPartySize: 2, durationMinutes: 60 },\n        { maxPartySize: 4, durationMinutes: 75 },\n        { maxPartySize: 6, durationMinutes: 85 },\n        { maxPartySize: 8, durationMinutes: 85 },\n      ],\n    },\n    dinner: {\n      key: \"dinner\",\n      label: \"Dinner\",\n      start: { hour: 17, minute: 0 },\n      end: { hour: 22, minute: 0 },\n      buffer: { pre: 0, post: 5 },\n      turnBands: [\n        { maxPartySize: 2, durationMinutes: 60 },\n        { maxPartySize: 4, durationMinutes: 75 },\n        { maxPartySize: 6, durationMinutes: 85 },\n        { maxPartySize: 8, durationMinutes: 90 },\n      ],\n    },\n  },\n};\n\nconst defaultSelectorScoringConfig: SelectorScoringConfig = {\n  weights: {\n    overage: 5,\n    tableCount: 3,\n    fragmentation: 2,\n    zoneBalance: 4,\n    adjacencyCost: 1,\n  },\n  maxOverage: 2,\n  maxTables: 3,\n};\n\nexport function getSelectorScoringConfig(): SelectorScoringConfig {\n  return {\n    weights: { ...defaultSelectorScoringConfig.weights },\n    maxOverage: defaultSelectorScoringConfig.maxOverage,\n    maxTables: defaultSelectorScoringConfig.maxTables,\n  };\n}\n\nexport class PolicyError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"PolicyError\";\n  }\n}\n\nexport class ServiceNotFoundError extends PolicyError {\n  constructor(public readonly attempted: DateTime, message?: string) {\n    super(message ?? `No service window matches ${attempted.toISO() ?? \"provided time\"}.`);\n    this.name = \"ServiceNotFoundError\";\n  }\n}\n\nexport class ServiceOverrunError extends PolicyError {\n  constructor(\n    public readonly service: ServiceKey,\n    public readonly attemptedEnd: DateTime,\n    public readonly serviceEnd: DateTime,\n    message?: string,\n  ) {\n    super(\n      message ??\n        `Reservation would overrun ${service} service (end ${serviceEnd.toFormat(\"HH:mm\")}).`,\n    );\n    this.name = \"ServiceOverrunError\";\n  }\n}\n\ntype PolicyOptions = {\n  timezone?: string | null;\n};\n\nexport function getVenuePolicy(options?: PolicyOptions): VenuePolicy {\n  if (!options?.timezone || options.timezone === defaultVenuePolicy.timezone) {\n    return {\n      timezone: defaultVenuePolicy.timezone,\n      serviceOrder: [...defaultVenuePolicy.serviceOrder],\n      services: Object.fromEntries(\n        Object.entries(defaultVenuePolicy.services).map(([key, service]) => [\n          key,\n          service ? cloneService(service) : service,\n        ]),\n      ),\n    };\n  }\n\n  return {\n    timezone: options.timezone,\n    serviceOrder: [...defaultVenuePolicy.serviceOrder],\n    services: Object.fromEntries(\n      Object.entries(defaultVenuePolicy.services).map(([key, service]) => [\n        key,\n        service ? cloneService(service) : service,\n      ]),\n    ),\n  };\n}\n\nfunction toZonedBase(dateTime: DateTime, timezone: string): DateTime {\n  const candidate = dateTime.isValid ? dateTime : DateTime.invalid(\"Invalid start time\");\n  const zoned = candidate.setZone(timezone, { keepLocalTime: false });\n  if (!zoned.isValid) {\n    throw new PolicyError(`Invalid DateTime for policy computation: ${candidate.invalidReason ?? \"unknown reason\"}`);\n  }\n  return zoned;\n}\n\nfunction toDateTime(base: DateTime, time: TimeOfDay): DateTime {\n  return base.set({\n    hour: time.hour,\n    minute: time.minute,\n    second: 0,\n    millisecond: 0,\n  });\n}\n\nfunction resolveServiceWindow(base: DateTime, service: ServiceDefinition): ServiceWindow {\n  const start = toDateTime(base, service.start);\n  let end = toDateTime(base, service.end);\n  if (end <= start) {\n    end = end.plus({ days: 1 });\n  }\n  return { start, end };\n}\n\nfunction activeServices(policy: VenuePolicy): ServiceDefinition[] {\n  return policy.serviceOrder\n    .map((key) => policy.services[key])\n    .filter((service): service is ServiceDefinition => Boolean(service));\n}\n\nexport function whichService(dateTime: DateTime, policy: VenuePolicy = defaultVenuePolicy): ServiceKey | null {\n  const zoned = toZonedBase(dateTime, policy.timezone);\n\n  for (const service of activeServices(policy)) {\n    const window = resolveServiceWindow(zoned, service);\n    if (zoned >= window.start && zoned < window.end) {\n      return service.key;\n    }\n  }\n\n  return null;\n}\n\nexport function serviceWindowFor(\n  serviceKey: ServiceKey,\n  dateTime: DateTime,\n  policy: VenuePolicy = defaultVenuePolicy,\n): ServiceWindow {\n  const service = policy.services[serviceKey];\n  if (!service) {\n    throw new PolicyError(`Unknown service \"${serviceKey}\".`);\n  }\n\n  const zoned = toZonedBase(dateTime, policy.timezone);\n  return resolveServiceWindow(zoned, service);\n}\n\nexport function serviceEnd(\n  serviceKey: ServiceKey,\n  dateTime: DateTime,\n  policy: VenuePolicy = defaultVenuePolicy,\n): DateTime {\n  return serviceWindowFor(serviceKey, dateTime, policy).end;\n}\n\nexport function getTurnBand(\n  serviceKey: ServiceKey,\n  partySize: number,\n  policy: VenuePolicy = defaultVenuePolicy,\n): TurnBand {\n  const service = policy.services[serviceKey];\n  if (!service) {\n    throw new PolicyError(`Unknown service \"${serviceKey}\".`);\n  }\n\n  const bands = service.turnBands;\n  if (!bands || bands.length === 0) {\n    throw new PolicyError(`No turn bands configured for service \"${serviceKey}\".`);\n  }\n\n  if (!Number.isFinite(partySize) || partySize <= 0) {\n    return bands[0]!;\n  }\n\n  for (const band of bands) {\n    if (partySize <= band.maxPartySize) {\n      return band;\n    }\n  }\n\n  return bands[bands.length - 1]!;\n}\n\nexport function bandDuration(\n  serviceKey: ServiceKey,\n  partySize: number,\n  policy: VenuePolicy = defaultVenuePolicy,\n): number {\n  return getTurnBand(serviceKey, partySize, policy).durationMinutes;\n}\n\nexport function getBufferConfig(\n  serviceKey: ServiceKey,\n  policy: VenuePolicy = defaultVenuePolicy,\n): BufferConfig {\n  const service = policy.services[serviceKey];\n  if (!service) {\n    throw new PolicyError(`Unknown service \"${serviceKey}\".`);\n  }\n  return { ...service.buffer };\n}\n",
  "server/feature-flags.ts": "import { env } from \"@/lib/env\";\n\nconst loyaltyPilotIds = new Set(\n  (env.featureFlags.loyaltyPilotRestaurantIds ?? \"\")\n    .split(\",\")\n    .map((value) => value.trim())\n    .filter((value) => value.length > 0),\n);\n\nfunction isProductionEnv(): boolean {\n  return env.node.env === \"production\";\n}\n\nexport function isLoyaltyPilotRestaurant(restaurantId: string): boolean {\n  if (!restaurantId) return false;\n  return loyaltyPilotIds.has(restaurantId);\n}\n\nexport function isAllocationsDualWriteEnabled(): boolean {\n  return env.featureFlags.allocationsDualWrite ?? false;\n}\n\nexport function isSelectorScoringEnabled(): boolean {\n  return env.featureFlags.selectorScoring ?? false;\n}\n\nexport function isCombinationPlannerEnabled(): boolean {\n  return env.featureFlags.combinationPlanner ?? false;\n}\n\nexport function isAdjacencyValidationEnabled(): boolean {\n  return env.featureFlags.adjacencyValidation ?? false;\n}\n\nexport function isOpsMetricsEnabled(): boolean {\n  return env.featureFlags.opsMetrics ?? false;\n}\n\nexport function isHoldsEnabled(): boolean {\n  return env.featureFlags.holds.enabled ?? true;\n}\n\nexport function isAllocatorMergesEnabled(): boolean {\n  return env.featureFlags.allocator.mergesEnabled ?? !isProductionEnv();\n}\n\nexport function isAllocatorV2ForceLegacy(): boolean {\n  return env.featureFlags.allocatorV2?.forceLegacy ?? false;\n}\n\nexport function isAllocatorV2Enabled(): boolean {\n  if (isAllocatorV2ForceLegacy()) {\n    return false;\n  }\n  return env.featureFlags.allocatorV2?.enabled ?? false;\n}\n\nexport function isAllocatorV2ShadowMode(): boolean {\n  if (isAllocatorV2ForceLegacy()) {\n    return false;\n  }\n  return env.featureFlags.allocatorV2?.shadow ?? false;\n}\n\nexport function isAllocatorAdjacencyRequired(): boolean {\n  return env.featureFlags.allocator.requireAdjacency ?? true;\n}\n\nexport function getAllocatorKMax(): number {\n  const configured = env.featureFlags.allocator.kMax ?? 3;\n  return Math.max(1, Math.min(configured, 5));\n}\n",
  "server/capacity/telemetry.ts": "import { recordObservabilityEvent } from \"@/server/observability\";\n\nimport type { CandidateDiagnostics } from \"./selector\";\n\nimport type { Json } from \"@/types/supabase\";\n\nexport type CandidateSummary = {\n  tableIds: string[];\n  tableNumbers: string[];\n  totalCapacity: number;\n  tableCount: number;\n  slack?: number;\n  score?: number;\n  adjacencyStatus?: \"single\" | \"connected\" | \"disconnected\";\n};\n\nexport type SelectorDecisionEvent = {\n  restaurantId: string;\n  bookingId: string;\n  partySize: number;\n  window?: { start: string | null; end: string | null };\n  candidates: CandidateSummary[];\n  selected?: CandidateSummary | null;\n  skipReason?: string | null;\n  durationMs: number;\n  featureFlags: {\n    selectorScoring: boolean;\n    opsMetrics: boolean;\n  };\n  diagnostics?: CandidateDiagnostics;\n};\n\nexport async function emitSelectorDecision(event: SelectorDecisionEvent): Promise<void> {\n  const logPayload = {\n    type: \"capacity.selector\",\n    timestamp: new Date().toISOString(),\n    restaurantId: event.restaurantId,\n    bookingId: event.bookingId,\n    partySize: event.partySize,\n    window: event.window ?? null,\n    selected: event.selected ?? null,\n    topCandidates: event.candidates,\n    candidates: event.candidates,\n    skipReason: event.skipReason ?? null,\n    durationMs: event.durationMs,\n    featureFlags: event.featureFlags,\n    diagnostics: event.diagnostics ?? null,\n  };\n\n  try {\n    console.log(JSON.stringify(logPayload));\n  } catch (error) {\n    console.error(\"[capacity.selector] failed to serialize log payload\", {\n      error,\n      bookingId: event.bookingId,\n      restaurantId: event.restaurantId,\n    });\n  }\n\n  try {\n    await recordObservabilityEvent({\n      source: \"capacity.selector\",\n      eventType: event.selected ? \"capacity.selector.assignment\" : \"capacity.selector.skipped\",\n      severity: event.skipReason ? \"warning\" : \"info\",\n      context: logPayload,\n      restaurantId: event.restaurantId,\n      bookingId: event.bookingId,\n    });\n  } catch (error) {\n    console.error(\"[capacity.selector] failed to persist observability event\", {\n      error,\n      bookingId: event.bookingId,\n      restaurantId: event.restaurantId,\n    });\n  }\n}\n\nexport type SelectorQuoteEvent = SelectorDecisionEvent & {\n  holdId?: string;\n  expiresAt?: string;\n};\n\nexport async function emitSelectorQuote(event: SelectorQuoteEvent): Promise<void> {\n  const payload = {\n    ...event,\n    type: \"capacity.selector.quote\",\n  };\n\n  try {\n    await recordObservabilityEvent({\n      source: \"capacity.selector\",\n      eventType: \"capacity.selector.quote\",\n      severity: event.skipReason ? \"warning\" : \"info\",\n      context: payload,\n      restaurantId: event.restaurantId,\n      bookingId: event.bookingId,\n    });\n  } catch (error) {\n    console.error(\"[capacity.selector.quote] failed to record telemetry\", {\n      error,\n      bookingId: event.bookingId,\n      restaurantId: event.restaurantId,\n    });\n  }\n}\n\nexport type HoldTelemetryEvent = {\n  holdId: string;\n  bookingId: string | null;\n  restaurantId: string;\n  zoneId: string;\n  tableIds: string[];\n  startAt: string;\n  endAt: string;\n  expiresAt?: string;\n  actorId?: string | null;\n  reason?: string | null;\n  metadata?: Json | null;\n};\n\nasync function emitHoldEvent(eventType: string, payload: HoldTelemetryEvent): Promise<void> {\n  try {\n    await recordObservabilityEvent({\n      source: \"capacity.hold\",\n      eventType,\n      severity: eventType.endsWith(\"expired\") ? \"warning\" : \"info\",\n      context: payload,\n      restaurantId: payload.restaurantId,\n      bookingId: payload.bookingId ?? undefined,\n    });\n  } catch (error) {\n    console.error(`[capacity.hold] failed to emit ${eventType}`, {\n      error,\n      holdId: payload.holdId,\n      bookingId: payload.bookingId,\n    });\n  }\n}\n\nexport async function emitHoldCreated(event: HoldTelemetryEvent): Promise<void> {\n  await emitHoldEvent(\"capacity.hold.created\", event);\n}\n\nexport async function emitHoldConfirmed(event: HoldTelemetryEvent): Promise<void> {\n  await emitHoldEvent(\"capacity.hold.confirmed\", event);\n}\n\nexport async function emitHoldExpired(event: HoldTelemetryEvent): Promise<void> {\n  await emitHoldEvent(\"capacity.hold.expired\", event);\n}\n\nexport type RpcConflictEvent = {\n  source: string;\n  bookingId: string;\n  restaurantId: string;\n  tableIds: string[];\n  idempotencyKey?: string | null;\n  holdId?: string | null;\n  error: {\n    code?: string | null;\n    message: string;\n    details?: string | null;\n    hint?: string | null;\n  };\n};\n\nexport async function emitRpcConflict(event: RpcConflictEvent): Promise<void> {\n  try {\n    await recordObservabilityEvent({\n      source: \"capacity.rpc\",\n      eventType: \"capacity.rpc.conflict\",\n      severity: \"warning\",\n      context: event,\n      restaurantId: event.restaurantId,\n      bookingId: event.bookingId,\n    });\n  } catch (error) {\n    console.error(\"[capacity.rpc] failed to record conflict telemetry\", {\n      error,\n      bookingId: event.bookingId,\n      restaurantId: event.restaurantId,\n    });\n  }\n}\n\nexport function summarizeCandidate(input: {\n  tableIds: string[];\n  tableNumbers: (string | null | undefined)[];\n  totalCapacity: number;\n  tableCount: number;\n  slack?: number;\n  score?: number;\n  adjacencyStatus?: \"single\" | \"connected\" | \"disconnected\";\n}): CandidateSummary {\n  return {\n    tableIds: input.tableIds,\n    tableNumbers: input.tableNumbers.map((value) => value ?? \"\"),\n    totalCapacity: input.totalCapacity,\n    tableCount: input.tableCount,\n    slack: input.slack,\n    score: input.score,\n    adjacencyStatus: input.adjacencyStatus,\n  };\n}\n"
}
