# Research: Comprehensive API Testing

## Existing Patterns & Reuse

- All API handlers live under `src/app/api` using Next.js App Router route handlers. Methods are defined via `export async function METHOD` or re-exported for versioned paths (e.g., `/api/v1/*`).
- Request validation consistently relies on Zod schemas defined inline or imported from domain packages (`@/server/booking`, `./schema`, etc.). Responses are produced with `NextResponse.json`.
- Authentication and Supabase access use helpers from `server/supabase.ts` with cookie-based sessions. Authorization helpers exist in `server/team/access`, `server/security`, and domain-specific guards.
- Rate limiting and observability utilities (`consumeRateLimit`, `recordObservabilityEvent`) appear across guest-facing endpoints (bookings, availability, lead capture) and ops tooling.
- Versioned endpoints (`/api/v1/*`) re-export unversioned implementations for backward compatibility; test endpoints live under `/api/test/*` for QA tooling.

## External Resources

- Supabase client docs inform the auth flow via `@supabase/ssr` (implicit dependency).
- Luxon is used for date handling in ops booking routes (`DateTime`).
- Domain logic references shared server modules in `/server` (bookings, capacity, restaurants, loyalty, etc.) rather than duplicating logic in handlers.

## Constraints & Risks

- No explicit OpenAPI/Swagger spec exists; documentation must be inferred from code. Risk of misinterpreting implicit defaults (e.g., optional query params, derived defaults from helpers like `getDefaultRestaurantId`).
- Authentication path depends on cookies/session; without production base URL or credentials we cannot exercise live endpoints. Automated testing must simulate Supabase auth or stub clients.
- High surface area (~60 handlers) increases chance of omission; dynamic segments (e.g., `[id]`, `[tableId]`) require contextual understanding for path resolution.
- Rate limiting and background job side effects (queues, emails) complicate replayable tests; need isolation strategies or mocks.

## Open Questions (and answers if resolved)

- Q: What base URL/environment should tests run against?
  A: Not provided. Assume local Next.js dev server (e.g., `http://localhost:3000`) for planning; highlight as dependency.
- Q: What auth tokens/credentials are available for exercising protected routes?
  A: None supplied. Identify necessary Supabase roles and document as prerequisite for execution.
- Q: Are QA `/api/test/*` endpoints intended for production?
  A: Appear limited to test tooling; include in inventory but flag as non-production.

## Recommended Direction (with rationale)

- Build an autogenerated endpoint inventory from `src/app/api/**/route.ts` (already captured in `endpoints.json`) to ensure no handler is missed.
- For each route, extract Zod schemas, auth guards, and response patterns directly from source to populate documentation tables. Group by domain (guest bookings, ops/owner, config) for clarity while still enumerating every endpoint.
- Derive test matrices per endpoint category using shared templates (functional, edge, security, performance) but tailor parameter boundaries to each schema to avoid generic placeholders.
- Note dependencies (Supabase session, rate limits, background jobs) in the testing plan and propose mocking/seed strategies; highlight gaps where live execution is currently blocked.
