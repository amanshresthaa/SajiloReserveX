{
  "metadata": {
    "generatedAt": "2025-11-12T19:09:00Z",
    "description": "Consolidated overview of the booking auto-assignment algorithms and helpers.",
    "sourceFiles": [
      "server/jobs/auto-assign.ts",
      "scripts/ops-auto-assign-ultra-fast.ts",
      "scripts/ops-auto-assign-ultra-fast-loop.ts",
      "server/booking/auto-assign/cancellable-auto-assign.ts",
      "src/app/api/bookings/route.ts"
    ]
  },
  "autoAssignAlgorithms": [
    {
      "id": "server-auto-assign-job",
      "name": "Booking auto-assign job",
      "entryPoint": "server/jobs/auto-assign.ts",
      "purpose": "Background job that tries to confirm a newly created or modified booking by quoting tables, creating a hold, and transitioning the booking to confirmed status.",
      "trigger": "Invoked from the bookings API and modification flow when FEATURE_AUTO_ASSIGN_ON_BOOKING is true; also scheduled as a fallback if inline auto-assign fails.",
      "configuration": {
        "featureFlag": "FEATURE_AUTO_ASSIGN_ON_BOOKING (checked via isAutoAssignOnBookingEnabled())",
        "maxRetries": "getAutoAssignMaxRetries() (cap applied through maxAttempts = min(maxRetries + 1, 11))",
        "retryDelaysMs": "getAutoAssignRetryDelaysMs() (uses per-attempt delays, defaults to 5s slots)",
        "startCutoffMinutes": "getAutoAssignStartCutoffMinutes() (skips retries if the booking is within the cutoff window)",
        "holdTtlSeconds": 180,
        "idempotencyKey": "booking.auto_assign_idempotency_key or fallback to auto-<bookingId>"
      },
      "coreSteps": [
        "Fetch the booking row, exit early for cancelled/completed/no-show statuses, or simply resend the email if already confirmed.",
        "Loop up to the configured maxAttempts: call quoteTablesForBooking and inspect the returned hold/candidate information.",
        "When a hold exists, call atomicConfirmAndTransition with the idempotency key and history metadata, then fetch the refreshed booking row and send confirmation/modification emails unless suppressed.",
        "On quote failures, wait for the configured delay, refresh the booking status, and stop retrying if the booking is already confirmed or within the start cutoff period.",
        "Log detailed observability events (started, attempt, success, failure, cutoff) and console markers for operators."
      ],
      "observability": [
        "recordObservabilityEvent is called at start, success, failure, attempt errors, and cutoff skips to feed telemetry.",
        "Console logs emit stages such as scheduled, attempt.start, attempt.success, and exhausted so cron jobs can monitor job progress."
      ],
      "dependencies": [
        "quoteTablesForBooking",
        "atomicConfirmAndTransition",
        "sendBookingConfirmationEmail / sendBookingModificationConfirmedEmail",
        "recordObservabilityEvent"
      ],
      "notes": [
        "SUPPRESS_EMAILS or LOAD_TEST_DISABLE_EMAILS silences mail when load testing",
        "Keeps track of an inline idempotency key so multiple auto-assign executions can safely run concurrently."
      ],
      "sourceCode": {
        "file": "server/jobs/auto-assign.ts",
        "content": "import { quoteTablesForBooking, atomicConfirmAndTransition } from \"@/server/capacity/tables\";\nimport { sendBookingConfirmationEmail, sendBookingModificationConfirmedEmail } from \"@/server/emails/bookings\";\nimport {\n  isAutoAssignOnBookingEnabled,\n  getAutoAssignMaxRetries,\n  getAutoAssignRetryDelaysMs,\n  getAutoAssignStartCutoffMinutes,\n} from \"@/server/feature-flags\";\nimport { recordObservabilityEvent } from \"@/server/observability\";\nimport { getServiceSupabaseClient } from \"@/server/supabase\";\n\nimport type { Tables } from \"@/types/supabase\";\n\ntype AutoAssignReason = \"creation\" | \"modification\";\ntype AutoAssignEmailVariant = \"standard\" | \"modified\";\n\ntype AutoAssignOptions = {\n  bypassFeatureFlag?: boolean;\n  reason?: AutoAssignReason;\n  emailVariant?: AutoAssignEmailVariant;\n};\n\n/**\n * Attempts to automatically assign tables for a booking and flips status to confirmed.\n * Sends the configured confirmation email variant on success.\n *\n * Best-effort: swallows errors and logs; safe to fire-and-forget.\n */\nexport async function autoAssignAndConfirmIfPossible(\n  bookingId: string,\n  options?: AutoAssignOptions,\n): Promise<void> {\n  const SUPPRESS_EMAILS = process.env.LOAD_TEST_DISABLE_EMAILS === 'true' || process.env.SUPPRESS_EMAILS === 'true';\n  const logJob = (stage: string, payload: Record<string, unknown> = {}) => {\n    console.info(\"[auto-assign][job]\", stage, { bookingId, ...payload });\n  };\n\n  const shouldRun = options?.bypassFeatureFlag || isAutoAssignOnBookingEnabled();\n  if (!shouldRun) {\n    logJob(\"skipped.feature-flag\", { bypass: Boolean(options?.bypassFeatureFlag) });\n    return;\n  }\n\n  const emailVariant: AutoAssignEmailVariant = options?.emailVariant ?? \"standard\";\n  const reason: AutoAssignReason = options?.reason ?? \"creation\";\n  logJob(\"scheduled\", { reason, emailVariant, bypass: Boolean(options?.bypassFeatureFlag) });\n\n  const supabase = getServiceSupabaseClient();\n\n  try {\n    const { data: booking, error } = await supabase\n      .from(\"bookings\")\n      .select(\n        \"id, restaurant_id, status, booking_date, start_time, end_time, start_at, end_at, party_size, customer_email, customer_name, reference, seating_preference, booking_type, notes, source, loyalty_points_awarded, created_at, updated_at, auto_assign_idempotency_key\",\n      )\n      .eq(\"id\", bookingId)\n      .maybeSingle();\n\n    if (error || !booking) {\n      console.error(\"[auto-assign] booking lookup failed\", { bookingId, error: error?.message ?? error });\n      logJob(\"failed.lookup\", { error: error?.message ?? error });\n      return;\n    }\n\n    // Skip non-actionable states\n    if ([\"cancelled\", \"no_show\", \"completed\"].includes(String(booking.status))) {\n      logJob(\"skipped.status\", { status: booking.status });\n      return;\n    }\n\n    // If already confirmed (e.g., manual/other flow), ensure guest receives the ticket.\n    if (booking.status === \"confirmed\") {\n      try {\n        // Cast is safe for email template expectations\n        if (!SUPPRESS_EMAILS) {\n          if (emailVariant === \"modified\") {\n            await sendBookingModificationConfirmedEmail(booking as unknown as Tables<\"bookings\">);\n          } else {\n            await sendBookingConfirmationEmail(booking as unknown as Tables<\"bookings\">);\n          }\n        }\n      } catch (e) {\n        console.error(\"[auto-assign] failed sending confirmation for already-confirmed\", { bookingId, error: e });\n        logJob(\"failed.email_already_confirmed\", { error: e instanceof Error ? e.message : String(e) });\n      }\n      return;\n    }\n\n    await recordObservabilityEvent({\n      source: \"auto_assign\",\n      eventType: \"auto_assign.started\",\n      restaurantId: booking.restaurant_id,\n      bookingId: booking.id,\n      context: { status: booking.status, trigger: reason },\n    });\n\n    const maxRetries = getAutoAssignMaxRetries();\n    const delays = getAutoAssignRetryDelaysMs();\n    const cutoffMinutes = getAutoAssignStartCutoffMinutes();\n\n    const startAt = typeof booking.start_at === 'string' ? new Date(booking.start_at) : null;\n    const withinCutoff = () => {\n      if (!startAt || Number.isNaN(startAt.getTime())) return false;\n      const msUntilStart = startAt.getTime() - Date.now();\n      return msUntilStart <= cutoffMinutes * 60_000;\n    };\n\n    const sleep = (ms: number) => new Promise((res) => setTimeout(res, ms));\n\n    // Attempt loop\n    let attempt = 0;\n    const startedAt = Date.now();\n    // include initial attempt + retry count\n    const maxAttempts = Math.max(1, Math.min(maxRetries + 1, 11));\n\n    while (attempt < maxAttempts) {\n      logJob(\"attempt.start\", { attempt, maxAttempts });\n      // If near service start, avoid further attempts (let ops handle)\n      if (attempt > 0 && withinCutoff()) {\n        await recordObservabilityEvent({\n          source: \"auto_assign\",\n          eventType: \"auto_assign.cutoff_skipped\",\n          restaurantId: booking.restaurant_id,\n          bookingId: booking.id,\n          context: { attempt, cutoffMinutes },\n        });\n        logJob(\"attempt.cutoff_skipped\", { attempt, cutoffMinutes });\n        break;\n      }\n\n      const attemptStart = Date.now();\n      try {\n        const quote = await quoteTablesForBooking({\n          bookingId,\n          // createdBy is optional down the stack; pass undefined to store NULL\n          // eslint-disable-next-line @typescript-eslint/no-explicit-any\n          createdBy: (undefined as any) as string,\n          holdTtlSeconds: 180,\n        });\n\n        if (!quote.hold) {\n          await recordObservabilityEvent({\n            source: \"auto_assign\",\n            eventType: \"auto_assign.attempt\",\n            restaurantId: booking.restaurant_id,\n            bookingId: booking.id,\n            context: {\n              attempt,\n              success: false,\n              reason: quote.reason ?? 'NO_HOLD',\n              alternates: (quote.alternates ?? []).length,\n              trigger: reason,\n            },\n          });\n          logJob(\"attempt.no_hold\", {\n            attempt,\n            reason: quote.reason ?? \"NO_HOLD\",\n            alternates: (quote.alternates ?? []).length,\n          });\n        } else {\n          const idempotencyKey = booking.auto_assign_idempotency_key ?? `auto-${bookingId}`;\n\n          await atomicConfirmAndTransition({\n            bookingId,\n            holdId: quote.hold.id,\n            idempotencyKey,\n            assignedBy: null,\n            historyReason: \"auto_assign\",\n            historyMetadata: { source: \"auto-assign\", holdId: quote.hold.id },\n          });\n\n          // Reload booking and send confirmed email\n          const { data: updated } = await supabase\n            .from(\"bookings\")\n            .select(\"*\")\n            .eq(\"id\", bookingId)\n            .maybeSingle();\n          if (updated && !SUPPRESS_EMAILS) {\n            if (emailVariant === \"modified\") {\n              await sendBookingModificationConfirmedEmail(updated as unknown as Tables<\"bookings\">);\n            } else {\n              await sendBookingConfirmationEmail(updated as unknown as Tables<\"bookings\">);\n            }\n          }\n\n          const durationMs = Date.now() - startedAt;\n          await recordObservabilityEvent({\n            source: \"auto_assign\",\n            eventType: \"auto_assign.succeeded\",\n            restaurantId: booking.restaurant_id,\n            bookingId: booking.id,\n            context: { attempt, durationMs, trigger: reason },\n          });\n          logJob(\"attempt.success\", { attempt, holdId: quote.hold.id, durationMs });\n          return; // done\n        }\n      } catch (e) {\n        await recordObservabilityEvent({\n          source: \"auto_assign\",\n          eventType: \"auto_assign.attempt_error\",\n          severity: \"warning\",\n          restaurantId: booking.restaurant_id,\n          bookingId: booking.id,\n          context: { attempt, error: e instanceof Error ? e.message : String(e), trigger: reason },\n        });\n        logJob(\"attempt.error\", { attempt, error: e instanceof Error ? e.message : String(e) });\n      }\n\n      attempt += 1;\n      if (attempt >= maxAttempts) break;\n      const delay = delays[Math.min(attempt - 1, delays.length - 1)] ?? 5000;\n      const elapsed = Date.now() - attemptStart;\n      // Sleep remaining delay budget for this attempt slot\n      const toSleep = Math.max(0, delay - elapsed);\n      if (toSleep > 0) {\n        await sleep(toSleep);\n      }\n      // Refresh latest booking state; if someone confirmed in between, stop\n      const { data: latest } = await supabase.from('bookings').select('status').eq('id', bookingId).maybeSingle();\n      if (latest?.status === 'confirmed') {\n        await recordObservabilityEvent({\n          source: 'auto_assign',\n          eventType: 'auto_assign.exited_already_confirmed',\n          restaurantId: booking.restaurant_id,\n          bookingId: booking.id,\n          context: { attempt, trigger: reason },\n        });\n        logJob(\"attempt.success_race\", { attempt });\n        return;\n      }\n    }\n\n    await recordObservabilityEvent({\n      source: \"auto_assign\",\n      eventType: \"auto_assign.failed\",\n      severity: \"warning\",\n      restaurantId: booking.restaurant_id,\n      bookingId: booking.id,\n      context: { attempts: attempt, trigger: reason },\n    });\n    logJob(\"exhausted\", { attempts: attempt, maxAttempts });\n  } catch (e) {\n    console.error(\"[auto-assign] unexpected error\", { bookingId, error: e });\n    logJob(\"failed.unexpected\", { error: e instanceof Error ? e.message : String(e) });\n  }\n}\n"
      }
    },
    {
      "id": "ultra-fast-script",
      "name": "Ultra-fast auto-assign script",
      "entryPoint": "scripts/ops-auto-assign-ultra-fast.ts",
      "purpose": "Ops-focused stress test runner that mass-assigns a restaurant\u2019s bookings on a given date while recording JSON reports.",
      "configuration": {
        "TARGET_RESTAURANT_SLUG": "env-driven slug (default white-horse-pub-waterbeach)",
        "TARGET_DATE": "env-driven target date (default today)",
        "MAX_CONCURRENT_BOOKINGS": "Number of parallel booking tasks (default 15)",
        "SINGLE_ATTEMPT_ONLY": "true by default (fast fail, no retries)",
        "HOLD_TTL_SECONDS": 180,
        "MINIMAL_CONSOLE_OUTPUT": "false by default",
        "FORCE_REASSIGN_ALL": "false unless overridden"
      },
      "coreSteps": [
        "Load dotenv files, force FEATURE_AUTO_ASSIGN_ON_BOOKING on, and suppress emails unless re-enabled.",
        "Dynamically import Supabase + capacity helpers, then process bookings in chunks of MAX_CONCURRENT_BOOKINGS retrieved for the target restaurant/date.",
        "For each booking chunk, call fastAssign which quotes tables, confirms the hold, transitions the booking via RPC, and queries assigned tables.",
        "Collect QuickResult objects, compute summary metrics (success/failure counts, avg duration), and optionally write the FastReport JSON into reports/auto-assign-ultra-fast-<date>-<timestamp>.json.",
        "Log a failure breakdown, success roster, and persisted booking statuses; the script exits with printed stats for operators."
      ],
      "reporting": [
        "Writes per-run JSON reports (config/results) under reports/auto-assign-ultra-fast-<date>-<timestamp>.json when ULTRA_WRITE_REPORTS is not false.",
        "Prints summary stats plus failure breakdown/resolution info to the console for fast triage."
      ],
      "dependencies": [
        "quoteTablesForBooking",
        "confirmHoldAssignment",
        "releaseTableHold",
        "apply_booking_state_transition RPC",
        "Supabase booking and booking_table_assignments tables",
        "reports directory"
      ],
      "notes": [
        "fastAssign classifies failure types (adjacency, zone lock, capacity, etc.) to make logs actionable.",
        "SINGLE_ATTEMPT_ONLY=true and MAX_CONCURRENT_BOOKINGS=15 make the script optimized for throughput, not resilience.",
        "FORCE_REASSIGN_ALL=true bypasses the pending filter so already-confirmed bookings are reprocessed if needed."
      ],
      "sourceCode": {
        "file": "scripts/ops-auto-assign-ultra-fast.ts",
        "content": "/**\n * ULTRA-FAST Auto-Assignment Script\n * \n * Performance Optimizations:\n * - Aggressive parallel processing (10+ concurrent operations)\n * - No retry delays (fail fast)\n * - Minimal logging overhead\n * - Batched database operations\n * - Connection pooling optimizations\n * \n * Uses repository algorithms:\n * - quoteTablesForBooking() - intelligent table assignment\n * - confirmHoldAssignment() - hold confirmation\n * - apply_booking_state_transition RPC - atomic status updates\n * \n * Usage:\n *   pnpm tsx -r tsconfig-paths/register scripts/ops-auto-assign-ultra-fast.ts\n */\n\nimport { config as loadEnv } from 'dotenv';\nimport { resolve as resolvePath } from 'path';\nimport { pathToFileURL } from 'node:url';\n\n// Load env BEFORE any imports that depend on it\nloadEnv({ path: resolvePath(process.cwd(), '.env.local') });\nloadEnv({ path: resolvePath(process.cwd(), '.env.development') });\nloadEnv({ path: resolvePath(process.cwd(), '.env') });\n\n// Enable features\nif (!process.env.FEATURE_AUTO_ASSIGN_ON_BOOKING) {\n  process.env.FEATURE_AUTO_ASSIGN_ON_BOOKING = 'true';\n}\nprocess.env.SUPPRESS_EMAILS = process.env.SUPPRESS_EMAILS ?? 'true';\n\nimport { DateTime } from 'luxon';\nimport fs from 'node:fs/promises';\nimport path from 'node:path';\n\n// ============================================================\n// ULTRA-FAST CONFIGURATION\n// ============================================================\n\nexport type UltraFastConfig = {\n  TARGET_RESTAURANT_SLUG: string;\n  TARGET_DATE: string;\n  MAX_CONCURRENT_BOOKINGS: number;\n  SINGLE_ATTEMPT_ONLY: boolean;\n  HOLD_TTL_SECONDS: number;\n  MINIMAL_CONSOLE_OUTPUT: boolean;\n  FORCE_REASSIGN_ALL: boolean;\n};\n\nconst DEFAULT_CONFIG: UltraFastConfig = {\n  TARGET_RESTAURANT_SLUG: process.env.TARGET_RESTAURANT_SLUG || 'white-horse-pub-waterbeach',\n  TARGET_DATE: process.env.TARGET_DATE || new Date().toISOString().split('T')[0],  // Today's date (YYYY-MM-DD)\n\n  // PERFORMANCE SETTINGS\n  MAX_CONCURRENT_BOOKINGS: parseInt(process.env.MAX_CONCURRENT_BOOKINGS || '15', 10),  // Process bookings simultaneously\n  SINGLE_ATTEMPT_ONLY: true,    // No retries - fail fast\n  HOLD_TTL_SECONDS: 180,\n\n  // REPORTING\n  MINIMAL_CONSOLE_OUTPUT: false,\n\n  // FORCE REASSIGNMENT (ignore current status)\n  FORCE_REASSIGN_ALL: false,  // Only process pending bookings\n};\n\n// ============================================================\n// TYPES\n// ============================================================\n\ninterface QuickResult {\n  id: string;\n  bookingId: string;\n  time: string;\n  party: number;\n  statusBefore: string | null;\n  statusAfter: string | null;\n  success: boolean;\n  reason: string | null;\n  failureType: string | null;\n  errorCode: string | null;\n  rawError: string | null;\n  transitionError: string | null;\n  quoteReason: string | null;\n  holdId: string | null;\n  holdExpiresAt: string | null;\n  tablesAssigned: string[];\n  assignmentsPersisted: number | null;\n  alternatesSuggested: number;\n  skippedCandidates: number;\n  durationMs: number;\n}\n\ninterface FastReport {\n  executedAt: string;\n  restaurant: string;\n  date: string;\n  config: UltraFastConfig;\n  totalBookings: number;\n  pendingProcessed: number;\n  successful: number;\n  failed: number;\n  successRate: number;\n  totalDurationSeconds: number;\n  avgProcessingMs: number;\n  results: QuickResult[];\n  persistedStatuses: Record<string, string | null>;\n}\n\n// ============================================================\n// MAIN\n// ============================================================\n\nexport async function runUltraFastAssignment(\n  overrides: Partial<UltraFastConfig> = {},\n): Promise<FastReport> {\n  const config: UltraFastConfig = {\n    ...DEFAULT_CONFIG,\n    ...overrides,\n  };\n  const scriptStart = Date.now();\n  \n  // Dynamic import after env is loaded\n  const supabaseModule = await import('@/server/supabase');\n  const tablesModule = await import('@/server/capacity/tables');\n  const holdsModule = await import('@/server/capacity/holds');\n  const getServiceSupabaseClient = supabaseModule.getServiceSupabaseClient;\n  const quoteTablesForBooking = tablesModule.quoteTablesForBooking;\n  const confirmHoldAssignment = tablesModule.confirmHoldAssignment;\n  const releaseTableHold = holdsModule.releaseTableHold;\n  const AssignTablesRpcError = holdsModule.AssignTablesRpcError;\n  \n  // Ultra-fast assignment function (defined inside main to access imports)\n  async function fastAssign(\n    supabase: any,\n    bookingId: string,\n    bookingTime: string,\n    partySize: number\n  ): Promise<QuickResult> {\n    const start = Date.now();\n    const shortId = bookingId.slice(0, 8);\n    const sanitizeError = (\n      error: unknown,\n    ): { code: string | null; message: string; details?: unknown } => {\n      if (!error) {\n        return { code: null, message: \"Unknown error\" };\n      }\n      if (error instanceof AssignTablesRpcError) {\n        return {\n          code: error.code ?? null,\n          message: error.message,\n          details: error.details ?? null,\n        };\n      }\n      if (typeof error === \"object\" && error !== null) {\n        const code = \"code\" in error && typeof (error as { code?: unknown }).code === \"string\"\n          ? (error as { code?: string }).code!\n          : null;\n        const message = \"message\" in error && typeof (error as { message?: unknown }).message === \"string\"\n          ? (error as { message?: string }).message!\n          : String(error);\n        return { code, message };\n      }\n      return { code: null, message: String(error) };\n    };\n\n    const classifyFailure = (message: string | null, code?: string | null): string | null => {\n      if (code === \"ASSIGNMENT_CONFLICT\") return \"assignment_conflict\";\n      if (!message) return null;\n      const normalized = message.toLowerCase();\n      if (normalized.includes(\"locked to zone\")) return \"zone_lock\";\n      if (normalized.includes(\"hold conflict\")) return \"hold_conflict\";\n      if (normalized.includes(\"capacity\")) return \"capacity\";\n      if (normalized.includes(\"adjacency\")) return \"adjacency\";\n      if (normalized.includes(\"timeout\")) return \"timeout\";\n      if (normalized.includes(\"duplicate\")) return \"idempotency\";\n      return \"unknown\";\n    };\n\n    let holdId: string | null = null;\n    let holdExpiresAt: string | null = null;\n    let holdConfirmed = false;\n\n    try {\n      const { data: before } = await supabase\n        .from('bookings')\n        .select('status')\n        .eq('id', bookingId)\n        .maybeSingle();\n\n      // Single attempt - no retries\n      const requireAdjacencyOverride = process.env.ULTRA_REQUIRE_ADJACENCY\n        ? String(process.env.ULTRA_REQUIRE_ADJACENCY).toLowerCase() === 'true'\n        : undefined;\n      const maxTablesOverride = process.env.ULTRA_MAX_TABLES\n        ? Math.max(1, Math.min(Number(process.env.ULTRA_MAX_TABLES) || 1, 5))\n        : undefined;\n\n      const quote = await quoteTablesForBooking({\n        bookingId,\n        createdBy: 'ultra-fast-script',\n        holdTtlSeconds: config.HOLD_TTL_SECONDS,\n        requireAdjacency: requireAdjacencyOverride,\n        maxTables: maxTablesOverride,\n      });\n\n      if (!quote.hold) {\n        return {\n          id: shortId,\n          bookingId,\n          time: bookingTime,\n          party: partySize,\n          statusBefore: before?.status ?? null,\n          statusAfter: before?.status ?? null,\n          success: false,\n          reason: quote.reason || 'No hold',\n          failureType: classifyFailure(quote.reason || null),\n          errorCode: null,\n          rawError: null,\n          transitionError: null,\n          quoteReason: quote.reason || null,\n          holdId: null,\n          holdExpiresAt: null,\n          tablesAssigned: [],\n          assignmentsPersisted: null,\n          alternatesSuggested: quote.alternates.length,\n          skippedCandidates: quote.skipped?.length ?? 0,\n          durationMs: Date.now() - start,\n        };\n      }\n\n      holdId = quote.hold.id;\n      holdExpiresAt = quote.hold.expiresAt;\n\n      // Confirm hold\n      await confirmHoldAssignment({\n        holdId: quote.hold.id,\n        bookingId,\n        idempotencyKey: `ultra-fast-${bookingId}`,\n        assignedBy: null,\n      });\n      holdConfirmed = true;\n\n      // Transition to confirmed\n      const { data: current } = await supabase\n        .from('bookings')\n        .select('status, assigned_zone_id')\n        .eq('id', bookingId)\n        .maybeSingle();\n\n      const nowIso = new Date().toISOString();\n      const { error: transitionError } = await supabase.rpc('apply_booking_state_transition', {\n        p_booking_id: bookingId,\n        p_status: 'confirmed',\n        p_checked_in_at: null,\n        p_checked_out_at: null,\n        p_updated_at: nowIso,\n        p_history_from: current?.status || before?.status || 'pending',\n        p_history_to: 'confirmed',\n        p_history_changed_by: null,\n        p_history_changed_at: nowIso,\n        p_history_reason: 'ultra_fast_script',\n        p_history_metadata: { holdId: quote.hold.id },\n      });\n\n      if (transitionError) {\n        const { code, message } = sanitizeError(transitionError);\n        return {\n          id: shortId,\n          bookingId,\n          time: bookingTime,\n          party: partySize,\n          statusBefore: before?.status ?? null,\n          statusAfter: current?.status ?? null,\n          success: false,\n          reason: message,\n          failureType: classifyFailure(message, code),\n          errorCode: code,\n          rawError: message,\n          transitionError: message,\n          quoteReason: quote.reason || null,\n          holdId: quote.hold.id,\n          holdExpiresAt: quote.hold.expiresAt,\n          tablesAssigned: [],\n          assignmentsPersisted: null,\n          alternatesSuggested: quote.alternates.length,\n          skippedCandidates: quote.skipped?.length ?? 0,\n          durationMs: Date.now() - start,\n        };\n      }\n\n      // Get assigned tables\n      const { data: assignments, error: assignmentsError } = await supabase\n        .from('booking_table_assignments')\n        .select('table_id, table:table_inventory(table_number)')\n        .eq('booking_id', bookingId);\n\n      if (assignmentsError) {\n        const { code, message } = sanitizeError(assignmentsError);\n        return {\n          id: shortId,\n          bookingId,\n          time: bookingTime,\n          party: partySize,\n          statusBefore: before?.status ?? null,\n          statusAfter: 'confirmed',\n          success: false,\n          reason: message,\n          failureType: classifyFailure(message, code),\n          errorCode: code,\n          rawError: message,\n          transitionError: null,\n          quoteReason: quote.reason || null,\n          holdId: quote.hold.id,\n          holdExpiresAt: quote.hold.expiresAt,\n          tablesAssigned: [],\n          assignmentsPersisted: null,\n          alternatesSuggested: quote.alternates.length,\n          skippedCandidates: quote.skipped?.length ?? 0,\n          durationMs: Date.now() - start,\n        };\n      }\n\n      const tables = (assignments || []).map((a: any) => a.table?.table_number || '?');\n      const assignmentsPersisted = assignments ? assignments.length : 0;\n\n      const { data: after } = await supabase\n        .from('bookings')\n        .select('status')\n        .eq('id', bookingId)\n        .maybeSingle();\n\n      const statusAfter = after?.status ?? 'unknown';\n      const success = statusAfter === 'confirmed' && assignmentsPersisted > 0;\n      const successReason = success ? 'Assigned' : 'Confirmed without persistence';\n\n      return {\n        id: shortId,\n        bookingId,\n        time: bookingTime,\n        party: partySize,\n        statusBefore: before?.status ?? null,\n        statusAfter,\n        success,\n        reason: successReason,\n        failureType: success ? null : 'persistence',\n        errorCode: null,\n        rawError: null,\n        transitionError: null,\n        quoteReason: quote.reason || null,\n        holdId: quote.hold.id,\n        holdExpiresAt: quote.hold.expiresAt,\n        tablesAssigned: tables,\n        assignmentsPersisted,\n        alternatesSuggested: quote.alternates.length,\n        skippedCandidates: quote.skipped?.length ?? 0,\n        durationMs: Date.now() - start,\n      };\n\n    } catch (error: any) {\n      if (holdId && !holdConfirmed) {\n        try {\n          await releaseTableHold({ holdId });\n        } catch (releaseError) {\n          if (!config.MINIMAL_CONSOLE_OUTPUT) {\n            console.warn('[ultra-fast] failed to release hold after error', {\n              bookingId,\n              holdId,\n              error: releaseError instanceof Error ? releaseError.message : String(releaseError),\n            });\n          }\n        }\n      }\n\n      const { code, message } = sanitizeError(error);\n      return {\n        id: shortId,\n        bookingId,\n        time: bookingTime,\n        party: partySize,\n        statusBefore: null,\n        statusAfter: null,\n        success: false,\n        reason: message || 'Error',\n        failureType: classifyFailure(message || null, code ?? undefined),\n        errorCode: code,\n        rawError: message,\n        transitionError: null,\n        quoteReason: null,\n        holdId,\n        holdExpiresAt,\n        tablesAssigned: [],\n        assignmentsPersisted: null,\n        alternatesSuggested: 0,\n        skippedCandidates: 0,\n        durationMs: Date.now() - start,\n      };\n    }\n  }\n  \n  if (!config.MINIMAL_CONSOLE_OUTPUT) {\n    console.log('\\n\u26a1 ULTRA-FAST AUTO-ASSIGNMENT SCRIPT');\n    console.log(`\ud83d\udccd ${config.TARGET_RESTAURANT_SLUG} | ${config.TARGET_DATE}`);\n    console.log(`\ud83d\ude80 Concurrent: ${config.MAX_CONCURRENT_BOOKINGS} | Single attempt only\\n`);\n  }\n\n  const supabase = getServiceSupabaseClient();\n\n  // Get restaurant\n  const { data: restaurant } = await supabase\n    .from('restaurants')\n    .select('id, name')\n    .eq('slug', config.TARGET_RESTAURANT_SLUG)\n    .single();\n\n  if (!restaurant) throw new Error('Restaurant not found');\n\n  // Get bookings - query by booking_date column\n  const { data: allBookings } = await supabase\n    .from('bookings')\n    .select('id, booking_date, start_time, party_size, status')\n    .eq('restaurant_id', restaurant.id)\n    .eq('booking_date', config.TARGET_DATE)\n    .order('start_time', { ascending: true });\n\n  // Choose which bookings to process\n  const pending = (allBookings || []).filter((b: any) => b.status === 'pending');\n  const toProcess = config.FORCE_REASSIGN_ALL ? (allBookings || []) : pending;\n\n  if (!config.MINIMAL_CONSOLE_OUTPUT) {\n    console.log(`\ud83d\udcca Found ${allBookings?.length || 0} bookings (${pending.length} pending)`);\n    if (config.FORCE_REASSIGN_ALL) {\n      console.log(`\u26a0\ufe0f  FORCE MODE: Processing ALL ${toProcess.length} bookings (including confirmed)\\n`);\n    } else {\n      console.log();\n    }\n  }\n\n  if (toProcess.length === 0) {\n    console.log('\u2705 No bookings to process\\n');\n    const emptyReport: FastReport = {\n      executedAt: new Date().toISOString(),\n      restaurant: restaurant.name,\n      date: config.TARGET_DATE,\n      config,\n      totalBookings: allBookings?.length || 0,\n      pendingProcessed: 0,\n      successful: 0,\n      failed: 0,\n      successRate: 0,\n      totalDurationSeconds: Math.round(((Date.now() - scriptStart) / 1000) * 100) / 100,\n      avgProcessingMs: 0,\n      results: [],\n      persistedStatuses: {},\n    };\n    return emptyReport;\n  }\n\n  // Process with aggressive parallelization\n  if (!config.MINIMAL_CONSOLE_OUTPUT) {\n    console.log(`\u26a1 Processing ${toProcess.length} bookings...`);\n    console.log(`   ${config.MAX_CONCURRENT_BOOKINGS} at a time, no retries\\n`);\n  }\n\n  const results: QuickResult[] = [];\n  \n  // Split into chunks for parallel processing\n  for (let i = 0; i < toProcess.length; i += config.MAX_CONCURRENT_BOOKINGS) {\n    const chunk = toProcess.slice(i, i + config.MAX_CONCURRENT_BOOKINGS);\n    \n    const chunkResults = await Promise.allSettled(\n      chunk.map((b: any) => \n        fastAssign(\n          supabase,\n          b.id,\n          b.start_time, // Time in HH:mm:ss format\n          b.party_size\n        )\n      )\n    );\n\n    for (const result of chunkResults) {\n      if (result.status === 'fulfilled') {\n        results.push(result.value);\n        \n        if (!config.MINIMAL_CONSOLE_OUTPUT) {\n          const icon = result.value.success ? '\u2705' : '\u274c';\n          const tables = result.value.success \n            ? ` \u2192 tables=${result.value.tablesAssigned.join(',')}` \n            : ` \u2192 reason=${result.value.reason}`;\n          const meta = result.value.success\n            ? `status=${result.value.statusAfter}`\n            : `failure=${result.value.failureType || 'unknown'} code=${result.value.errorCode ?? 'n/a'}`;\n          console.log(`${icon} ${result.value.id} | ${result.value.time} | party=${result.value.party} | ${meta}${tables} (${result.value.durationMs}ms)`);\n        }\n      }\n    }\n  }\n\n  const totalDuration = (Date.now() - scriptStart) / 1000;\n  const successful = results.filter(r => r.success).length;\n  const failed = results.filter(r => !r.success).length;\n  const avgMs = results.reduce((sum, r) => sum + r.durationMs, 0) / results.length;\n\n  // Generate report\n  // Verify persisted state for processed bookings\n  const processedIds = results.map((r) => r.bookingId);\n  const persistedStatuses: Record<string, string | null> = {};\n  if (processedIds.length > 0) {\n    const { data: persisted } = await supabase\n      .from('bookings')\n      .select('id, status')\n      .in('id', processedIds);\n    if (persisted) {\n      for (const row of persisted) {\n        persistedStatuses[row.id] = row.status;\n      }\n    }\n  }\n\n  const persistedConfirmed = Object.values(persistedStatuses).filter((status) => status === 'confirmed').length;\n\n  const report: FastReport = {\n    executedAt: new Date().toISOString(),\n    restaurant: restaurant.name,\n    date: config.TARGET_DATE,\n    config,\n    totalBookings: allBookings?.length || 0,\n    pendingProcessed: toProcess.length,\n    successful,\n    failed,\n    successRate: results.length > 0 ? Math.round(successful / results.length * 100) : 0,\n    totalDurationSeconds: Math.round(totalDuration * 100) / 100,\n    avgProcessingMs: Math.round(avgMs),\n    results,\n    persistedStatuses,\n  };\n\n  // Save report (optional). To disable writing, set ULTRA_WRITE_REPORTS=false\n  const WRITE_REPORTS = String(process.env.ULTRA_WRITE_REPORTS ?? 'true').toLowerCase() !== 'false';\n  let reportPath: string | null = null;\n  if (WRITE_REPORTS) {\n    const timestamp = new Date().toISOString().replace(/:/g, '-');\n    const reportsDir = path.join(process.cwd(), 'reports');\n    await fs.mkdir(reportsDir, { recursive: true });\n    reportPath = path.join(\n      reportsDir,\n      `auto-assign-ultra-fast-${config.TARGET_DATE}-${timestamp}.json`\n    );\n    await fs.writeFile(reportPath, JSON.stringify(report, null, 2));\n  }\n\n  // Summary\n  console.log('\\n\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550');\n  console.log('  \u26a1 ULTRA-FAST EXECUTION COMPLETE');\n  console.log('\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550');\n  console.log(`  Restaurant: ${restaurant.name}`);\n  console.log(`  Date: ${config.TARGET_DATE}`);\n  console.log(`  Total bookings: ${report.totalBookings}`);\n  console.log(`  Pending processed: ${results.length}`);\n  console.log(`  \u2705 Success (script reported): ${successful}`);\n  console.log(`  \u2705 Success (persisted confirmed): ${persistedConfirmed}`);\n  console.log(`  \u274c Failed: ${failed}`);\n  console.log(`  Success rate (script): ${report.successRate}%`);\n  const persistedRate = results.length > 0 ? Math.round((persistedConfirmed / results.length) * 100) : 0;\n  console.log(`  Success rate (persisted): ${persistedRate}%`);\n  console.log(`  \u23f1\ufe0f  Total time: ${totalDuration.toFixed(2)}s`);\n  console.log(`  \u26a1 Avg per booking: ${report.avgProcessingMs}ms`);\n  if (reportPath) {\n    console.log(`  \ud83d\udcc1 Report: ${reportPath}`);\n  } else {\n    console.log(`  \ud83d\udcc1 Report writing disabled (ULTRA_WRITE_REPORTS=false)`);\n  }\n  console.log('\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\\n');\n\n  // Failure breakdown\n  if (failed > 0) {\n    console.log('\ud83d\udcca FAILURE BREAKDOWN:\\n');\n    const failureReasons = results\n      .filter(r => !r.success)\n      .reduce((acc, r) => {\n        const key = `${r.failureType || 'unknown'}::${r.reason || 'Unknown'}`;\n        acc[key] = (acc[key] || 0) + 1;\n        return acc;\n      }, {} as Record<string, number>);\n\n    Object.entries(failureReasons)\n      .sort((a, b) => b[1] - a[1])\n      .forEach(([reason, count]) => {\n        const [failureType, message] = reason.split('::');\n        console.log(`  ${count}x - type=${failureType} message=${message}`);\n      });\n    console.log('');\n  }\n\n  // Success details\n  if (successful > 0) {\n    console.log(`\u2705 SUCCESSFUL ASSIGNMENTS (${successful}):\\n`);\n    results\n      .filter(r => r.success)\n      .forEach(r => {\n        console.log(`  ${r.id} | ${r.time} | party=${r.party} | tables: ${r.tablesAssigned.join(', ')}`);\n      });\n    console.log('');\n  }\n\n  return report;\n}\n\nconst invokedPath = process.argv[1] ? pathToFileURL(process.argv[1]).href : null;\nif (invokedPath && invokedPath === import.meta.url) {\n  runUltraFastAssignment().catch(error => {\n    console.error('\\n\u274c FATAL ERROR:', error.message);\n    process.exit(1);\n  });\n}\n"
      }
    },
    {
      "id": "ultra-fast-loop",
      "name": "Assignment/reserve-loop runner",
      "entryPoint": "scripts/ops-auto-assign-ultra-fast-loop.ts",
      "purpose": "Drives repeated runs of the ultra-fast script using configurable strategies or clones bookings from a source date and assigns them sequentially.",
      "configuration": {
        "mode": "assign (default) / reserve (via --mode=reserve), determines whether to call runAssignLoopJob or runReserveFlowJob.",
        "ASSIGN_LOOP_MAX_ITERATIONS": "default 6 iterations to reduce remaining pending bookings",
        "ASSIGN_LOOP_SLEEP_MS": "default 5000ms pause between passes",
        "ASSIGN_LOOP_MAX_TABLES": "maxTables used to build adjacency/relaxed strategies",
        "ASSIGN_LOOP_HOLD_TTL": "default 180 seconds for additional hold attempts",
        "ASSIGN_LOOP_CLONE_LIMIT": "max clones for reserve-flow mode",
        "ASSIGN_LOOP_AVOID_USED_TABLES": "optional flag to prevent reusing tables during cloning"
      },
      "coreSteps": [
        "buildStrategies(maxTables) produces adjacency-first then relaxed variants to test table combinations.",
        "fetchBookingStats queries pending/assigned counts for a slug/date and early-exits if trivial.",
        "runAssignLoopJob iterates over strategies, temporarily overriding ULTRA_REQUIRE_ADJACENCY and ULTRA_MAX_TABLES before invoking runUltraFastAssignment and re-checking stats, sleeping between iterations until either all bookings are assigned or max iterations is reached.",
        "runReserveFlowJob clones bookings from a source date and attempts sequential assignment per clone using assignBookingSequentially, logging candidate details and releasing holds on failure.",
        "assignBookingSequentially quotes tables with avoidTables, confirms holds, transitions statuses, and optionally tracks used table IDs to avoid repeated collisions."
      ],
      "notes": [
        "Works directly against Supabase using a PG pool to gather stats and passes env overrides into the ultra-fast script for each strategy.",
        "Reserve-flow clones draw from real bookings (sourceDate) and use createBookingWithCapacityCheck to ensure capacity before auto-assign attempts.",
        "Used in stress tests (see scripts/run-allocation-stress-test.sh) and manual experimentation to tune combination planner behavior."
      ],
      "sourceCode": {
        "file": "scripts/ops-auto-assign-ultra-fast-loop.ts",
        "content": "import { config as loadEnv } from \"dotenv\";\nimport { resolve as resolvePath } from \"node:path\";\nimport { randomUUID } from \"node:crypto\";\nimport { DateTime } from \"luxon\";\nimport { Pool } from \"pg\";\n\nimport { runUltraFastAssignment } from \"./ops-auto-assign-ultra-fast\";\n\nimport { getServiceSupabaseClient } from \"@/server/supabase\";\nimport { createBookingWithCapacityCheck, type BookingRecord } from \"@/server/capacity\";\nimport { quoteTablesForBooking, confirmHoldAssignment } from \"@/server/capacity/tables\";\nimport { releaseTableHold } from \"@/server/capacity/holds\";\nimport type { CandidateSummary } from \"@/server/capacity/telemetry\";\nimport { Constants, type Database, type Tables } from \"@/types/supabase\";\nimport { ensureBookingType } from \"@/lib/enums\";\n\nloadEnv({ path: resolvePath(process.cwd(), \".env.local\") });\nloadEnv({ path: resolvePath(process.cwd(), \".env.development\") });\nloadEnv({ path: resolvePath(process.cwd(), \".env\") });\n\nconst DEFAULT_SLUG = process.env.TARGET_RESTAURANT_SLUG || \"white-horse-pub-waterbeach\";\nconst DEFAULT_DATE = process.env.TARGET_DATE || DateTime.now().toISODate() || new Date().toISOString().split(\"T\")[0];\nconst DEFAULT_MAX_ITERATIONS = Number(process.env.ASSIGN_LOOP_MAX_ITERATIONS ?? \"6\");\nconst DEFAULT_SLEEP_MS = Number(process.env.ASSIGN_LOOP_SLEEP_MS ?? \"5000\");\nconst DEFAULT_MAX_TABLES = clampTables(Number(process.env.ASSIGN_LOOP_MAX_TABLES ?? \"4\"));\nconst DEFAULT_MODE: LoopMode = process.env.ASSIGN_LOOP_MODE === \"reserve\" ? \"reserve\" : \"assign\";\nconst DEFAULT_HOLD_TTL = Math.max(30, Number(process.env.ASSIGN_LOOP_HOLD_TTL ?? \"180\") || 180);\nconst DEFAULT_CLONE_LIMIT = Math.max(1, Number(process.env.ASSIGN_LOOP_CLONE_LIMIT ?? \"5\") || 5);\nconst DEFAULT_SOURCE_DATE = process.env.ASSIGN_LOOP_SOURCE_DATE;\nconst DEFAULT_AVOID_USED_TABLES =\n  String(process.env.ASSIGN_LOOP_AVOID_USED_TABLES ?? \"\").toLowerCase() === \"true\";\n\nif (!process.env.SUPABASE_DB_URL) {\n  throw new Error(\"SUPABASE_DB_URL is required to run the assignment loop\");\n}\n\nconst VALID_STATUS_FOR_PENDING = [\"pending\", \"pending_allocation\", \"confirmed\"] as const;\ntype BookingStatus = Tables<\"bookings\">[\"status\"];\n\n// Mirror the Supabase enum to keep RPC transitions type-safe.\nconst SUPABASE_BOOKING_STATUS_VALUES = new Set<string>(Constants.public.Enums.booking_status);\n\nfunction normalizeBookingStatus(value: string | null | undefined): BookingStatus {\n  if (value && SUPABASE_BOOKING_STATUS_VALUES.has(value)) {\n    return value as BookingStatus;\n  }\n  return \"pending\";\n}\n\ntype LoopMode = \"assign\" | \"reserve\";\n\ntype LoopJob = {\n  slug: string;\n  date: string;\n  maxIterations: number;\n  sleepMs: number;\n  once: boolean;\n  maxTables: number;\n  verbose: boolean;\n  forceAll: boolean;\n  mode: LoopMode;\n  holdTtlSeconds: number;\n  sourceDate?: string;\n  cloneLimit: number;\n  sourceAfter?: string;\n  avoidUsedTables: boolean;\n};\n\ntype BookingStats = {\n  total: number;\n  assigned: number;\n  unassigned: number;\n  pendingState: number;\n};\n\ntype Strategy = {\n  label: string;\n  requireAdjacency: boolean;\n  maxTables: number;\n};\n\ntype RestaurantRow = Pick<Tables<\"restaurants\">, \"id\" | \"name\" | \"timezone\">;\n\ntype CustomerSummary = Pick<Tables<\"customers\">, \"id\" | \"full_name\" | \"email\" | \"phone\">;\n\ntype CloneSource = Pick<\n  Tables<\"bookings\">,\n  | \"id\"\n  | \"booking_date\"\n  | \"start_time\"\n  | \"end_time\"\n  | \"party_size\"\n  | \"customer_id\"\n  | \"customer_name\"\n  | \"customer_email\"\n  | \"customer_phone\"\n  | \"seating_preference\"\n  | \"booking_type\"\n  | \"notes\"\n  | \"marketing_opt_in\"\n  | \"details\"\n>;\n\nfunction clampTables(value: number): number {\n  if (!Number.isFinite(value) || value <= 0) return 1;\n  return Math.max(1, Math.min(5, Math.floor(value)));\n}\n\nfunction splitIntoJobs(argv: string[]): string[][] {\n  const jobs: string[][] = [];\n  let current: string[] = [];\n  for (const token of argv) {\n    if (token === \"--\") {\n      if (current.length > 0) {\n        jobs.push(current);\n        current = [];\n      }\n      continue;\n    }\n    current.push(token);\n  }\n  if (current.length > 0) {\n    jobs.push(current);\n  }\n  if (jobs.length === 0) {\n    jobs.push([]);\n  }\n  return jobs;\n}\n\nfunction parseJobArgs(tokens: string[]): LoopJob {\n  const job: LoopJob = {\n    slug: DEFAULT_SLUG,\n    date: DEFAULT_DATE,\n    maxIterations: DEFAULT_MAX_ITERATIONS,\n    sleepMs: DEFAULT_SLEEP_MS,\n    once: false,\n    maxTables: DEFAULT_MAX_TABLES,\n    verbose: false,\n    forceAll: false,\n    mode: DEFAULT_MODE,\n    holdTtlSeconds: DEFAULT_HOLD_TTL,\n  sourceDate: DEFAULT_SOURCE_DATE,\n  cloneLimit: DEFAULT_CLONE_LIMIT,\n  sourceAfter: undefined,\n  avoidUsedTables: DEFAULT_AVOID_USED_TABLES,\n};\n\n  for (let i = 0; i < tokens.length; i += 1) {\n    const arg = tokens[i];\n    switch (arg) {\n      case \"--slug\":\n        job.slug = tokens[i + 1] ?? job.slug;\n        i += 1;\n        break;\n      case \"--date\":\n        job.date = tokens[i + 1] ?? job.date;\n        i += 1;\n        break;\n      case \"--max-iterations\":\n        job.maxIterations = Number(tokens[i + 1] ?? job.maxIterations) || job.maxIterations;\n        i += 1;\n        break;\n      case \"--sleep-ms\":\n        job.sleepMs = Number(tokens[i + 1] ?? job.sleepMs) || job.sleepMs;\n        i += 1;\n        break;\n      case \"--max-tables\":\n        job.maxTables = clampTables(Number(tokens[i + 1] ?? job.maxTables));\n        i += 1;\n        break;\n      case \"--once\":\n        job.once = true;\n        job.maxIterations = 1;\n        job.cloneLimit = 1;\n        break;\n      case \"--verbose\":\n        job.verbose = true;\n        break;\n      case \"--force-all\":\n        job.forceAll = true;\n        break;\n      case \"--mode\":\n        job.mode = (tokens[i + 1] === \"reserve\" ? \"reserve\" : \"assign\");\n        i += 1;\n        break;\n      case \"--source-date\":\n        job.sourceDate = tokens[i + 1] ?? job.sourceDate;\n        i += 1;\n        break;\n      case \"--source-after\":\n        job.sourceAfter = tokens[i + 1] ?? job.sourceAfter;\n        i += 1;\n        break;\n      case \"--clone-limit\":\n        job.cloneLimit = Math.max(1, Number(tokens[i + 1] ?? job.cloneLimit) || job.cloneLimit);\n        i += 1;\n        break;\n      case \"--hold-ttl\":\n        job.holdTtlSeconds = Math.max(30, Number(tokens[i + 1] ?? job.holdTtlSeconds) || job.holdTtlSeconds);\n        i += 1;\n        break;\n      case \"--avoid-used\":\n        job.avoidUsedTables = true;\n        break;\n      case \"--allow-reuse\":\n        job.avoidUsedTables = false;\n        break;\n      default:\n        throw new Error(`Unknown argument: ${arg}`);\n    }\n  }\n\n  return job;\n}\n\nfunction buildStrategies(maxTables: number): Strategy[] {\n  const strategies: Strategy[] = [];\n  for (let tables = 1; tables <= maxTables; tables += 1) {\n    strategies.push({ label: `adjacent-x${tables}`, requireAdjacency: true, maxTables: tables });\n  }\n  for (let tables = 1; tables <= maxTables; tables += 1) {\n    strategies.push({ label: `relaxed-x${tables}`, requireAdjacency: false, maxTables: tables });\n  }\n  return strategies;\n}\n\nasync function fetchBookingStats(pool: Pool, slug: string, date: string): Promise<BookingStats> {\n  const query = `\n    WITH scoped AS (\n      SELECT b.id, b.status,\n             EXISTS (\n               SELECT 1 FROM booking_table_assignments bta\n               WHERE bta.booking_id = b.id\n             ) AS has_assignment\n      FROM bookings b\n      JOIN restaurants r ON r.id = b.restaurant_id\n      WHERE r.slug = $1\n        AND b.booking_date = $2::date\n    )\n    SELECT\n      COUNT(*)::int AS total,\n      COUNT(*) FILTER (WHERE has_assignment)::int AS assigned,\n      COUNT(*) FILTER (WHERE NOT has_assignment)::int AS unassigned,\n      COUNT(*) FILTER (WHERE status = ANY($3))::int AS pending_state\n    FROM scoped;\n  `;\n\n  const result = await pool.query(query, [slug, date, VALID_STATUS_FOR_PENDING]);\n  if (result.rows.length === 0) {\n    return { total: 0, assigned: 0, unassigned: 0, pendingState: 0 };\n  }\n  const row = result.rows[0];\n  return {\n    total: Number(row.total ?? 0),\n    assigned: Number(row.assigned ?? 0),\n    unassigned: Number(row.unassigned ?? 0),\n    pendingState: Number(row.pending_state ?? 0),\n  };\n}\n\nfunction applyStrategyEnv(strategy: Strategy): () => void {\n  const overrides: Record<string, string> = {\n    ULTRA_REQUIRE_ADJACENCY: strategy.requireAdjacency ? \"true\" : \"false\",\n    ULTRA_MAX_TABLES: String(strategy.maxTables),\n  };\n\n  const previousEntries = Object.entries(overrides).map(([key]) => [key, process.env[key]] as const);\n  Object.entries(overrides).forEach(([key, value]) => {\n    process.env[key] = value;\n  });\n\n  return () => {\n    for (const [key, prev] of previousEntries) {\n      if (prev === undefined) {\n        delete process.env[key];\n      } else {\n        process.env[key] = prev;\n      }\n    }\n  };\n}\n\nasync function delay(ms: number): Promise<void> {\n  await new Promise((resolve) => setTimeout(resolve, ms));\n}\n\nasync function runAssignLoopJob(job: LoopJob, pool: Pool): Promise<void> {\n  console.log(`\\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557`);\n  console.log(`\u2551  AUTO-ASSIGN MODE \u00b7 ${job.slug} \u00b7 ${job.date}                 \u2551`);\n  console.log(`\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d`);\n\n  let stats = await fetchBookingStats(pool, job.slug, job.date);\n  if (stats.total === 0) {\n    console.log(`No bookings found for ${job.slug} on ${job.date}. Skipping.`);\n    return;\n  }\n  if (stats.unassigned === 0) {\n    console.log(`All ${stats.total} bookings already have assignments. Nothing to do.`);\n    return;\n  }\n\n  console.log(`Found ${stats.unassigned}/${stats.total} bookings without tables (pending states: ${stats.pendingState}).`);\n  const strategies = buildStrategies(job.maxTables);\n\n  let iteration = 0;\n  while (stats.unassigned > 0 && iteration < job.maxIterations) {\n    iteration += 1;\n    console.log(`\\n\u25b6\ufe0e Iteration ${iteration} \u2014 ${stats.unassigned} bookings remain unassigned`);\n\n    for (const strategy of strategies) {\n      console.log(`  \u2022 Strategy ${strategy.label} (adjacency=${strategy.requireAdjacency}, maxTables=${strategy.maxTables})`);\n      const restoreEnv = applyStrategyEnv(strategy);\n      let reportSummary = \"\";\n\n      try {\n        const report = await runUltraFastAssignment({\n          TARGET_RESTAURANT_SLUG: job.slug,\n          TARGET_DATE: job.date,\n          MINIMAL_CONSOLE_OUTPUT: !job.verbose,\n          FORCE_REASSIGN_ALL: job.forceAll,\n        });\n        reportSummary = `successRate=${report.successRate}% failed=${report.failed}`;\n      } catch (error) {\n        reportSummary = `error=${error instanceof Error ? error.message : String(error)}`;\n      } finally {\n        restoreEnv();\n      }\n\n      stats = await fetchBookingStats(pool, job.slug, job.date);\n      console.log(`    \u2192 ${reportSummary} | remaining ${stats.unassigned}/${stats.total}`);\n\n      if (stats.unassigned === 0 || job.once) {\n        break;\n      }\n    }\n\n    if (stats.unassigned === 0 || job.once) {\n      break;\n    }\n\n    if (iteration < job.maxIterations) {\n      console.log(`  Sleeping ${job.sleepMs}ms before next pass...`);\n      await delay(job.sleepMs);\n      stats = await fetchBookingStats(pool, job.slug, job.date);\n    }\n  }\n\n  if (stats.unassigned === 0) {\n    console.log(`\\n\u2705 Completed in ${iteration} iteration(s). All bookings have tables.`);\n  } else {\n    console.log(`\\n\u26a0\ufe0f  ${stats.unassigned} bookings remain after ${iteration} iteration(s).`);\n  }\n}\n\nasync function runReserveFlowJob(job: LoopJob, pool: Pool): Promise<void> {\n  const supabase = getServiceSupabaseClient();\n  const restaurant = await loadRestaurant(supabase, job.slug);\n  const sourceDate = job.sourceDate ?? job.date;\n  const targetDate = job.date;\n  const strategies = buildStrategies(job.maxTables);\n  const usedTableIds = new Set<string>();\n\n  console.log(`\\n\u2554\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2557`);\n  console.log(`\u2551  RESERVE-FLOW MODE \u00b7 ${restaurant.name} (${job.slug})           \u2551`);\n  const filterLabel = job.sourceAfter ? ` start>=${job.sourceAfter}` : \"\";\n  console.log(`\u2551  source=${sourceDate}${filterLabel} \u2192 target=${targetDate} | limit=${job.cloneLimit} \u2551`);\n  console.log(`\u255a\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u2550\u255d`);\n\n  const baseBookings = await loadCloneSources({\n    supabase,\n    restaurantId: restaurant.id,\n    sourceDate,\n    limit: job.cloneLimit,\n    sourceAfter: job.sourceAfter,\n  });\n  if (baseBookings.length === 0) {\n    console.log(`No base bookings found on ${sourceDate} to clone. Aborting.`);\n    return;\n  }\n\n  const fallbackCustomer = await loadFallbackCustomer(supabase, restaurant.id);\n  let processed = 0;\n\n  for (const source of baseBookings) {\n    if (job.once && processed > 0) {\n      break;\n    }\n\n    processed += 1;\n    console.log(`\\n[create] Source ${source.id.slice(0, 8)} \u00b7 party=${source.party_size} @ ${source.start_time ?? \"??\"}`);\n\n    try {\n      const created = await cloneBooking({\n        source,\n        restaurant,\n        fallbackCustomer,\n        supabase,\n        targetDate,\n      });\n\n      console.log(`  \u21b3 Booking ${created.id.slice(0, 8)} created (status=${created.status})`);\n      const success = await assignBookingSequentially({\n        booking: created,\n        supabase,\n        strategies,\n        job,\n        usedTableIds,\n      });\n\n      const stats = await fetchBookingStats(pool, job.slug, targetDate);\n      console.log(\n        `  \u21b3 Post-attempt stats: assigned=${stats.assigned} pending=${stats.unassigned} (total=${stats.total})`,\n      );\n\n      if (!success) {\n        console.warn(`  \u26a0\ufe0f Booking ${created.id.slice(0, 8)} remained pending after all combinations.`);\n      }\n    } catch (error) {\n      console.error(\n        `  \u274c Failed to replicate booking ${source.id.slice(0, 8)}:`,\n        error instanceof Error ? error.message : error,\n      );\n    }\n  }\n\n  console.log(`\\n\u2705 Reserve-flow mode complete. Processed ${processed} booking(s).`);\n}\n\nasync function cloneBooking(params: {\n  source: CloneSource;\n  restaurant: RestaurantRow;\n  fallbackCustomer: CustomerSummary;\n  supabase: ReturnType<typeof getServiceSupabaseClient>;\n  targetDate: string;\n}): Promise<BookingRecord> {\n  const { source, restaurant, fallbackCustomer, supabase, targetDate } = params;\n  const customerPersona = buildCustomerPersona(source, fallbackCustomer);\n  const bookingType = safeBookingType(source.booking_type);\n  const startTime = normalizeTime(source.start_time);\n  const endTime = resolveEndTime({\n    startTime,\n    explicitEnd: source.end_time,\n    timezone: restaurant.timezone,\n    bookingDate: targetDate,\n  });\n\n  const result = await createBookingWithCapacityCheck({\n    restaurantId: restaurant.id,\n    customerId: customerPersona.id,\n    bookingDate: targetDate,\n    startTime,\n    endTime,\n    partySize: source.party_size,\n    bookingType,\n    customerName: customerPersona.name,\n    customerEmail: customerPersona.email,\n    customerPhone: customerPersona.phone,\n    seatingPreference: (source.seating_preference ?? \"any\") as Database[\"public\"][\"Enums\"][\"seating_preference_type\"],\n    notes: source.notes ?? null,\n    marketingOptIn: source.marketing_opt_in ?? false,\n    idempotencyKey: `reserve-flow-${source.id}-${Date.now()}-${randomUUID()}`,\n    source: \"reserve-flow-stress\",\n    clientRequestId: randomUUID(),\n    details: source.details ?? {},\n  });\n\n  if (!result.success || !result.booking) {\n    const reasonParts = [\n      result.message,\n      result.error,\n      result.details && typeof result.details === \"object\" ? JSON.stringify(result.details) : null,\n    ]\n      .filter(Boolean)\n      .join(\" | \");\n    throw new Error(reasonParts || \"createBookingWithCapacityCheck failed\");\n  }\n\n  return result.booking;\n}\n\nasync function assignBookingSequentially(params: {\n  booking: BookingRecord;\n  supabase: ReturnType<typeof getServiceSupabaseClient>;\n  strategies: Strategy[];\n  job: LoopJob;\n  usedTableIds: Set<string>;\n}): Promise<boolean> {\n  const { booking, supabase, strategies, job, usedTableIds } = params;\n  let attempt = 0;\n  const globalAvoid = job.avoidUsedTables ? new Set(usedTableIds) : null;\n  const localAvoid = new Set<string>();\n  if (globalAvoid) {\n    for (const tableId of globalAvoid) {\n      localAvoid.add(tableId);\n    }\n  }\n\n  for (const strategy of strategies) {\n    attempt += 1;\n    console.log(\n      `  [assign] Attempt ${attempt}/${strategies.length} \u00b7 ${strategy.label} (booking ${booking.id.slice(0, 8)})`,\n    );\n\n    try {\n      const avoidTables = job.avoidUsedTables ? Array.from(localAvoid) : undefined;\n      const quote = await quoteTablesForBooking({\n        bookingId: booking.id,\n        createdBy: \"reserve-flow-loop\",\n        holdTtlSeconds: job.holdTtlSeconds,\n        requireAdjacency: strategy.requireAdjacency,\n        maxTables: strategy.maxTables,\n        avoidTables,\n      });\n\n      logCandidate(\"selected\", quote.candidate);\n      if (quote.alternates.length > 0) {\n        quote.alternates.forEach((alt, idx) => logCandidate(`alternate#${idx + 1}`, alt));\n      }\n      if (quote.skipped && quote.skipped.length > 0) {\n        console.log(\n          `    \u2937 Skipped candidates: ${quote.skipped.length} (ex: ${quote.skipped[0]?.reason ?? \"n/a\"})`,\n        );\n      }\n      if (quote.reason) {\n        console.log(`    \u2937 Reason: ${quote.reason}`);\n      }\n\n      const attemptedTables = quote.hold?.tableIds ?? quote.candidate?.tableIds ?? [];\n      if (job.avoidUsedTables) {\n        for (const tableId of attemptedTables) {\n          localAvoid.add(tableId);\n        }\n      }\n\n      if (!quote.hold) {\n        console.log(\"    \u274c No hold created \u2013 continuing to next configuration.\");\n        continue;\n      }\n\n      console.log(\n        `    \ud83d\udd12 Hold ${quote.hold.id} tables=${quote.candidate?.tableNumbers?.join(\", \") ?? quote.hold.tableIds.join(\",\")}`,\n      );\n\n      try {\n        await confirmHoldAssignment({\n          holdId: quote.hold.id,\n          bookingId: booking.id,\n          idempotencyKey: `reserve-flow-confirm-${booking.id}-${attempt}`,\n          assignedBy: null,\n        });\n\n        await markBookingConfirmed({\n          supabase,\n          bookingId: booking.id,\n          previousStatus: booking.status ?? \"pending\",\n        });\n\n        if (job.avoidUsedTables) {\n          for (const tableId of attemptedTables) {\n            usedTableIds.add(tableId);\n          }\n        }\n\n        const updated = await reloadBooking(supabase, booking.id);\n        console.log(\n          `    \u2705 Confirmed \u2192 status=${updated?.status ?? \"unknown\"} tables=${quote.candidate?.tableNumbers?.join(\", \") ?? \"n/a\"}`,\n        );\n        return true;\n      } catch (error) {\n        console.error(\n          \"    \u26a0\ufe0f Confirm/transition failed:\",\n          error instanceof Error ? error.message : String(error),\n        );\n        await safeReleaseHold({ supabase, holdId: quote.hold.id });\n      }\n    } catch (error) {\n      console.error(\n        \"    \u26a0\ufe0f quoteTablesForBooking errored:\",\n        error instanceof Error ? error.message : String(error),\n      );\n    }\n  }\n\n  return false;\n}\n\nasync function markBookingConfirmed(params: {\n  supabase: ReturnType<typeof getServiceSupabaseClient>;\n  bookingId: string;\n  previousStatus: string | null;\n}): Promise<void> {\n  const { supabase, bookingId, previousStatus } = params;\n  const nowIso = new Date().toISOString();\n  const historyFrom = normalizeBookingStatus(previousStatus);\n  const { error } = await supabase.rpc(\"apply_booking_state_transition\", {\n    p_booking_id: bookingId,\n    p_status: \"confirmed\",\n    p_checked_in_at: null,\n    p_checked_out_at: null,\n    p_updated_at: nowIso,\n    p_history_from: historyFrom,\n    p_history_to: \"confirmed\",\n    p_history_changed_by: null,\n    p_history_changed_at: nowIso,\n    p_history_reason: \"reserve_flow_auto_assign\",\n    p_history_metadata: { script: \"reserve-flow-loop\" },\n  });\n\n  if (error) {\n    throw new Error(error.message ?? \"apply_booking_state_transition failed\");\n  }\n}\n\nasync function reloadBooking(supabase: ReturnType<typeof getServiceSupabaseClient>, bookingId: string) {\n  const { data } = await supabase\n    .from(\"bookings\")\n    .select(\"id, status\")\n    .eq(\"id\", bookingId)\n    .maybeSingle();\n  return data as Pick<BookingRecord, \"id\" | \"status\"> | null;\n}\n\nasync function safeReleaseHold(params: { supabase: ReturnType<typeof getServiceSupabaseClient>; holdId: string }) {\n  try {\n    await releaseTableHold({ holdId: params.holdId, client: params.supabase });\n    console.log(`    \u21ba Hold ${params.holdId} released.`);\n  } catch (error) {\n    console.error(\"    \u26a0\ufe0f Failed to release hold:\", error instanceof Error ? error.message : error);\n  }\n}\n\nfunction logCandidate(label: string, candidate: CandidateSummary | null | undefined) {\n  if (!candidate) {\n    console.log(`    \u2937 ${label}: none`);\n    return;\n  }\n  console.log(\n    `    \u2937 ${label}: tables=${candidate.tableNumbers.join(\", \")} capacity=${candidate.totalCapacity} slack=${candidate.slack ?? 0} score=${candidate.score ?? \"n/a\"}`,\n  );\n}\n\nfunction buildCustomerPersona(source: CloneSource, fallback: CustomerSummary) {\n  return {\n    id: source.customer_id ?? fallback.id,\n    name: source.customer_name ?? fallback.full_name,\n    email: source.customer_email ?? fallback.email,\n    phone: source.customer_phone ?? fallback.phone,\n  };\n}\n\nfunction safeBookingType(value: string | null | undefined) {\n  try {\n    return ensureBookingType((value ?? \"dinner\") as string);\n  } catch {\n    return \"dinner\";\n  }\n}\n\nfunction normalizeTime(value: string | null | undefined): string {\n  if (!value) return \"19:00\";\n  const parts = value.split(\":\");\n  if (parts.length >= 2) {\n    return `${parts[0]?.padStart(2, \"0\")}:${parts[1]?.padStart(2, \"0\")}`;\n  }\n  return value.slice(0, 5);\n}\n\nfunction resolveEndTime(params: {\n  startTime: string;\n  explicitEnd: string | null | undefined;\n  timezone: string | null;\n  bookingDate: string;\n}): string {\n  const { startTime, explicitEnd, timezone, bookingDate } = params;\n  if (explicitEnd) {\n    return normalizeTime(explicitEnd);\n  }\n  const zone = timezone || \"UTC\";\n  const start = DateTime.fromISO(`${bookingDate}T${startTime}`, { zone });\n  return start.plus({ minutes: 90 }).toFormat(\"HH:mm\");\n}\n\nasync function loadRestaurant(supabase: ReturnType<typeof getServiceSupabaseClient>, slug: string): Promise<RestaurantRow> {\n  const { data, error } = await supabase\n    .from(\"restaurants\")\n    .select(\"id, name, timezone\")\n    .eq(\"slug\", slug)\n    .maybeSingle();\n\n  if (error || !data) {\n    throw new Error(`Failed to load restaurant for slug ${slug}: ${error?.message ?? \"not found\"}`);\n  }\n\n  return data as RestaurantRow;\n}\n\nasync function loadCloneSources(params: {\n  supabase: ReturnType<typeof getServiceSupabaseClient>;\n  restaurantId: string;\n  sourceDate: string;\n  limit: number;\n  sourceAfter?: string;\n}): Promise<CloneSource[]> {\n  const { supabase, restaurantId, sourceDate, limit, sourceAfter } = params;\n  let query = supabase\n    .from(\"bookings\")\n    .select(\n      \"id, booking_date, start_time, end_time, party_size, customer_id, customer_name, customer_email, customer_phone, seating_preference, booking_type, notes, marketing_opt_in, details\",\n    )\n    .eq(\"restaurant_id\", restaurantId)\n    .eq(\"booking_date\", sourceDate);\n  if (sourceAfter) {\n    query = query.gte(\"start_time\", sourceAfter);\n  }\n  const { data, error } = await query.order(\"start_time\", { ascending: true }).limit(limit);\n\n  if (error) {\n    throw new Error(`Failed to load source bookings: ${error.message}`);\n  }\n\n  return (data ?? []) as CloneSource[];\n}\n\nasync function loadFallbackCustomer(\n  supabase: ReturnType<typeof getServiceSupabaseClient>,\n  restaurantId: string,\n): Promise<CustomerSummary> {\n  const { data, error } = await supabase\n    .from(\"customers\")\n    .select(\"id, full_name, email, phone\")\n    .eq(\"restaurant_id\", restaurantId)\n    .order(\"created_at\", { ascending: true })\n    .limit(1)\n    .maybeSingle();\n\n  if (error || !data) {\n    throw new Error(`Restaurant ${restaurantId} is missing customers for stress testing.`);\n  }\n\n  return data as CustomerSummary;\n}\n\nasync function runJob(job: LoopJob, pool: Pool): Promise<void> {\n  if (job.mode === \"reserve\") {\n    await runReserveFlowJob(job, pool);\n  } else {\n    await runAssignLoopJob(job, pool);\n  }\n}\n\nasync function main(): Promise<void> {\n  const jobs = splitIntoJobs(process.argv.slice(2)).map(parseJobArgs);\n  const pool = new Pool({ connectionString: process.env.SUPABASE_DB_URL });\n\n  try {\n    for (const job of jobs) {\n      await runJob(job, pool);\n    }\n  } finally {\n    await pool.end();\n  }\n}\n\nmain().catch((error) => {\n  console.error(\"\\n\u274c Loop runner failed:\", error);\n  process.exit(1);\n});\n"
      }
    },
    {
      "id": "cancellable-auto-assign",
      "name": "Cancellable auto-assign helper",
      "entryPoint": "server/booking/auto-assign/cancellable-auto-assign.ts",
      "purpose": "Bounds an auto-assign operation with a timeout and abort semantics (used during inline API booking creation).",
      "configuration": {
        "timeoutMs": "Provided by the caller (inline auto-assign defaults to env.featureFlags.inlineAutoAssignTimeoutMs or 4000ms)."
      },
      "coreSteps": [
        "Instantiate AbortController and set a timer to abort after timeoutMs.",
        "Run the provided operation with the signal, executing the optional onAbort callback when the controller fires.",
        "If the controller aborts, wrap the error as AbortError so callers can differentiate timeouts."
      ],
      "usage": [
        "Inline auto-assign path in src/app/api/bookings/route.ts uses CancellableAutoAssign to guard quoteTablesForBooking + atomicConfirmAndTransition so guests receive a request-received email even if auto-assignment takes too long.",
        "Inline flow logs quote/confirm durations, emits observability events, and schedules the background auto-assign job when the inline attempt times out or fails."
      ],
      "notes": [
        "Keeps API responses fast by aborting slow attempts and ensures the fallback background job still runs after inline failures."
      ],
      "sourceCode": {
        "file": "server/booking/auto-assign/cancellable-auto-assign.ts",
        "content": "export class CancellableAutoAssign {\n  constructor(private readonly timeoutMs: number) {}\n\n  async runWithTimeout<T>(\n    operation: (signal: AbortSignal) => Promise<T>,\n    onAbort?: () => Promise<void> | void,\n  ): Promise<T> {\n    const controller = new AbortController();\n    const timer = setTimeout(() => controller.abort(), this.timeoutMs);\n\n    try {\n      return await operation(controller.signal);\n    } catch (error) {\n      if (controller.signal.aborted) {\n        if (onAbort) {\n          await onAbort();\n        }\n        const abortError = error instanceof Error ? error : new Error(String(error));\n        abortError.name = \"AbortError\";\n        throw abortError;\n      }\n      throw error;\n    } finally {\n      clearTimeout(timer);\n    }\n  }\n}\n"
      }
    }
  ]
}
