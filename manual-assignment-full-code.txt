// Consolidated manual assignment code bundle
// Generated: 2025-11-17T23:24:32Z
// Purpose: single-file reference of manual assignment backend/frontend code. Not intended for build.
\n// ===== src/app/api/staff/manual/context/route.ts =====
import { NextResponse } from "next/server";
import { z } from "zod";

import { ManualSelectionInputError, getManualContext } from "@/server/capacity/engine";
import { getRouteHandlerSupabaseClient, getTenantServiceSupabaseClient } from "@/server/supabase";

import type { NextRequest } from "next/server";

const querySchema = z.object({
  bookingId: z.string().uuid(),
});

export async function GET(request: NextRequest) {
  const supabase = await getRouteHandlerSupabaseClient();

  const {
    data: { user },
    error: authError,
  } = await supabase.auth.getUser();

  if (authError || !user) {
    return NextResponse.json({ error: "Unauthorized", code: "UNAUTHORIZED" }, { status: 401 });
  }

  const parsed = querySchema.safeParse(Object.fromEntries(request.nextUrl.searchParams.entries()));
  if (!parsed.success) {
    return NextResponse.json(
      { error: "Invalid query parameters", code: "INVALID_QUERY", details: parsed.error.flatten() },
      { status: 400 },
    );
  }

  const { bookingId } = parsed.data;

  const bookingLookup = await supabase
    .from("bookings")
    .select("restaurant_id")
    .eq("id", bookingId)
    .maybeSingle();

  if (bookingLookup.error) {
    console.error("[staff/manual/context] booking lookup failed", { bookingId, error: bookingLookup.error });
    return NextResponse.json({ error: "Failed to load booking", code: "BOOKING_LOOKUP_FAILED" }, { status: 500 });
  }

  const bookingRow = bookingLookup.data;
  if (!bookingRow?.restaurant_id) {
    return NextResponse.json({ error: "Booking not found", code: "BOOKING_NOT_FOUND" }, { status: 404 });
  }

  const membership = await supabase
    .from("restaurant_memberships")
    .select("role")
    .eq("restaurant_id", bookingRow.restaurant_id)
    .eq("user_id", user.id)
    .maybeSingle();

  if (membership.error) {
    console.error("[staff/manual/context] membership lookup failed", { bookingId, error: membership.error });
    return NextResponse.json({ error: "Failed to verify access", code: "ACCESS_LOOKUP_FAILED" }, { status: 500 });
  }

  if (!membership.data) {
    return NextResponse.json({ error: "Access denied", code: "ACCESS_DENIED" }, { status: 403 });
  }

  try {
    const context = await getManualContext({
      bookingId,
      client: getTenantServiceSupabaseClient(bookingRow.restaurant_id),
    });

    return NextResponse.json(context);
  } catch (error) {
    if (error instanceof ManualSelectionInputError) {
      return NextResponse.json(
        { error: error.message, code: error.code },
        { status: error.status },
      );
    }

    console.error("[staff/manual/context] unexpected error", { bookingId, error });
    const message = error instanceof Error ? error.message : "Unexpected error";
    return NextResponse.json({ error: message, code: "INTERNAL_ERROR" }, { status: 500 });
  }
}
\n// ===== src/app/api/staff/manual/validate/route.ts =====
import { NextResponse } from "next/server";
import { z } from "zod";

import { ManualSelectionInputError } from "@/server/capacity/engine";
import { getOrCreateManualSession, proposeOrHoldSelection, StaleContextError, SessionConflictError } from "@/server/capacity/manual-session";
import { emitManualValidate } from "@/server/capacity/telemetry";
import { getRouteHandlerSupabaseClient, getTenantServiceSupabaseClient } from "@/server/supabase";

import type { NextRequest } from "next/server";

const validatePayloadSchema = z.object({
  bookingId: z.string().uuid(),
  tableIds: z.array(z.string().uuid()).min(1),
  requireAdjacency: z.boolean().optional(),
  excludeHoldId: z.string().uuid().optional(),
  contextVersion: z.string(),
});

export async function POST(req: NextRequest) {
  const supabase = await getRouteHandlerSupabaseClient();

  const {
    data: { user },
    error: authError,
  } = await supabase.auth.getUser();

  if (authError || !user) {
    return NextResponse.json({ error: "Unauthorized", code: "UNAUTHORIZED" }, { status: 401 });
  }

  const body = await req.json().catch(() => null);
  const parsed = validatePayloadSchema.safeParse(body);

  if (!parsed.success) {
    return NextResponse.json(
      { error: "Invalid request payload", code: "INVALID_PAYLOAD", details: parsed.error.flatten() },
      { status: 400 },
    );
  }

  const { bookingId, tableIds, requireAdjacency, excludeHoldId, contextVersion } = parsed.data;

  const bookingLookup = await supabase
    .from("bookings")
    .select("restaurant_id")
    .eq("id", bookingId)
    .maybeSingle();

  if (bookingLookup.error) {
    console.error("[staff/manual/validate] booking lookup failed", { bookingId, error: bookingLookup.error });
    return NextResponse.json({ error: "Failed to load booking", code: "BOOKING_LOOKUP_FAILED" }, { status: 500 });
  }

  const bookingRow = bookingLookup.data;
  if (!bookingRow?.restaurant_id) {
    return NextResponse.json({ error: "Booking not found", code: "BOOKING_NOT_FOUND" }, { status: 404 });
  }

  const membership = await supabase
    .from("restaurant_memberships")
    .select("role")
    .eq("restaurant_id", bookingRow.restaurant_id)
    .eq("user_id", user.id)
    .maybeSingle();

  if (membership.error) {
    console.error("[staff/manual/validate] membership lookup failed", { bookingId, error: membership.error });
    return NextResponse.json({ error: "Failed to verify access", code: "ACCESS_LOOKUP_FAILED" }, { status: 500 });
  }

  if (!membership.data) {
    return NextResponse.json({ error: "Access denied", code: "ACCESS_DENIED" }, { status: 403 });
  }

  const serviceClient = getTenantServiceSupabaseClient(bookingRow.restaurant_id);

  const session = await getOrCreateManualSession({
    bookingId,
    restaurantId: bookingRow.restaurant_id,
    createdBy: user.id,
    client: serviceClient,
  });

  let contextAdjacencyRequired: boolean | null = null;
  let expectedContextVersion: string | null = null;

  try {
    const result = await proposeOrHoldSelection({
      sessionId: session.id,
      bookingId,
      restaurantId: bookingRow.restaurant_id,
      tableIds,
      mode: "propose",
      requireAdjacency,
      excludeHoldId,
      contextVersion,
      selectionVersion: session.selectionVersion,
      createdBy: user.id,
      client: serviceClient,
    });
    const validation = result.validation;
    const contextVersionUsed = result.context.contextVersion ?? null;
    contextAdjacencyRequired = Boolean(result.context.flags?.adjacencyRequired ?? null);

    // Emit manual.validate outcome
    await emitManualValidate({
      ok: true,
      bookingId,
      restaurantId: bookingRow.restaurant_id,
      policyVersion: (validation as { policyVersion?: string }).policyVersion ?? result.context.policyVersion ?? null,
      adjacencyRequired: contextAdjacencyRequired ?? (typeof requireAdjacency === 'boolean' ? requireAdjacency : null),
    });

    return NextResponse.json({
      ok: validation.ok,
      checks: validation.checks,
      summary: validation.summary,
      contextVersion: contextVersionUsed,
    });
  } catch (error) {
    if (error instanceof StaleContextError) {
      expectedContextVersion = error.expected ?? null;
      return NextResponse.json(
        {
          error: error.message,
          code: "STALE_CONTEXT",
          details: { expected: error.expected, provided: error.provided },
        },
        { status: 409 },
      );
    }
    if (error instanceof SessionConflictError) {
      return NextResponse.json(
        { error: error.message, code: error.code, details: error.details },
        { status: 409 },
      );
    }
    if (error instanceof ManualSelectionInputError) {
      await emitManualValidate({
        ok: false,
        bookingId,
        restaurantId: bookingRow.restaurant_id,
        policyVersion: null,
        adjacencyRequired: contextAdjacencyRequired ?? (typeof requireAdjacency === 'boolean' ? requireAdjacency : null),
        code: error.code,
      });
      return NextResponse.json(
        { error: error.message, code: error.code },
        { status: error.status },
      );
    }

    console.error("[staff/manual/validate] unexpected error", { error, bookingId, userId: user.id });
    await emitManualValidate({
      ok: false,
      bookingId,
      restaurantId: bookingRow.restaurant_id,
      policyVersion: null,
      adjacencyRequired: contextAdjacencyRequired ?? (typeof requireAdjacency === 'boolean' ? requireAdjacency : null),
      code: "INTERNAL_ERROR",
    });
    const message = error instanceof Error ? error.message : "Unexpected error";
    return NextResponse.json({ error: message, code: "INTERNAL_ERROR" }, { status: 500 });
  }
}
\n// ===== src/app/api/staff/manual/hold/route.ts =====
import { NextResponse } from "next/server";
import { z } from "zod";

import { ManualSelectionInputError } from "@/server/capacity/engine";
import { HoldConflictError, releaseTableHold } from "@/server/capacity/holds";
import { getOrCreateManualSession, proposeOrHoldSelection, StaleContextError, SessionConflictError } from "@/server/capacity/manual-session";
import { emitManualHold } from "@/server/capacity/telemetry";
import { getRouteHandlerSupabaseClient, getTenantServiceSupabaseClient } from "@/server/supabase";

import type { NextRequest } from "next/server";

const holdPayloadSchema = z.object({
  bookingId: z.string().uuid(),
  tableIds: z.array(z.string().uuid()).min(1),
  holdTtlSeconds: z.number().int().min(30).max(600).optional(),
  requireAdjacency: z.boolean().optional(),
  excludeHoldId: z.string().uuid().optional(),
  contextVersion: z.string(),
});

const holdReleaseSchema = z.object({
  holdId: z.string().uuid(),
  bookingId: z.string().uuid(),
});

const VALIDATION_CODE_MAP: Record<string, string> = {
  capacity: "CAPACITY_INSUFFICIENT",
  slack: "SLACK_BUDGET_EXCEEDED",
  zone: "ZONE_MISMATCH",
  movable: "TABLE_IMMUTABLE",
  adjacency: "ADJACENCY_INVALID",
  conflict: "ASSIGNMENT_CONFLICT",
  holds: "HOLD_CONFLICT",
};

function deriveValidationCode(validation: { checks: Array<{ id: string; status: string }> }): string {
  const failing = validation.checks.find((check) => check.status === "error");
  return failing ? VALIDATION_CODE_MAP[failing.id] ?? "VALIDATION_FAILED" : "VALIDATION_FAILED";
}

export async function POST(req: NextRequest) {
  const supabase = await getRouteHandlerSupabaseClient();

  const {
    data: { user },
    error: authError,
  } = await supabase.auth.getUser();

  if (authError || !user) {
    return NextResponse.json({ error: "Unauthorized", code: "UNAUTHORIZED" }, { status: 401 });
  }

  const body = await req.json().catch(() => null);
  const parsed = holdPayloadSchema.safeParse(body);

  if (!parsed.success) {
    return NextResponse.json(
      { error: "Invalid request payload", code: "INVALID_PAYLOAD", details: parsed.error.flatten() },
      { status: 400 },
    );
  }

  const { bookingId, tableIds, holdTtlSeconds, requireAdjacency, excludeHoldId, contextVersion } = parsed.data;

  const bookingLookup = await supabase
    .from("bookings")
    .select("restaurant_id")
    .eq("id", bookingId)
    .maybeSingle();

  if (bookingLookup.error) {
    console.error("[staff/manual/hold] booking lookup failed", { bookingId, error: bookingLookup.error });
    return NextResponse.json({ error: "Failed to load booking", code: "BOOKING_LOOKUP_FAILED" }, { status: 500 });
  }

  const bookingRow = bookingLookup.data;
  if (!bookingRow?.restaurant_id) {
    return NextResponse.json({ error: "Booking not found", code: "BOOKING_NOT_FOUND" }, { status: 404 });
  }

  const membership = await supabase
    .from("restaurant_memberships")
    .select("role")
    .eq("restaurant_id", bookingRow.restaurant_id)
    .eq("user_id", user.id)
    .maybeSingle();

  if (membership.error) {
    console.error("[staff/manual/hold] membership lookup failed", { bookingId, error: membership.error });
    return NextResponse.json({ error: "Failed to verify access", code: "ACCESS_LOOKUP_FAILED" }, { status: 500 });
  }

  if (!membership.data) {
    return NextResponse.json({ error: "Access denied", code: "ACCESS_DENIED" }, { status: 403 });
  }

  const serviceClient = getTenantServiceSupabaseClient(bookingRow.restaurant_id);

  const session = await getOrCreateManualSession({
    bookingId,
    restaurantId: bookingRow.restaurant_id,
    createdBy: user.id,
    client: serviceClient,
  });

  let contextAdjacencyRequired: boolean | null = null;

  try {
    const result = await proposeOrHoldSelection({
      sessionId: session.id,
      bookingId,
      restaurantId: bookingRow.restaurant_id,
      tableIds,
      mode: "hold",
      requireAdjacency,
      excludeHoldId,
      contextVersion,
      selectionVersion: session.selectionVersion,
      createdBy: user.id,
      holdTtlSeconds,
      client: serviceClient,
    });
    contextAdjacencyRequired = Boolean(result.context.flags?.adjacencyRequired ?? null);

    if (!result.hold) {
      const summary = result.validation.summary;
      const code = deriveValidationCode(result.validation);
      const status = code === "HOLD_CONFLICT" ? 409 : 422;

      await emitManualHold({
        ok: false,
        bookingId,
        restaurantId: bookingRow.restaurant_id,
        policyVersion: result.validation.policyVersion ?? null,
        adjacencyRequired: contextAdjacencyRequired ?? (typeof requireAdjacency === 'boolean' ? requireAdjacency : null),
        code,
      });

      return NextResponse.json(
        {
          error: "Validation failed",
          code,
          validation: result.validation,
          summary,
          details: {
            validation: result.validation,
            summary,
          },
        },
        { status },
      );
    }

    await emitManualHold({
      ok: true,
      bookingId,
      restaurantId: bookingRow.restaurant_id,
      policyVersion: result.validation.policyVersion ?? result.context.policyVersion ?? null,
      adjacencyRequired: contextAdjacencyRequired ?? (typeof requireAdjacency === 'boolean' ? requireAdjacency : null),
    });

    return NextResponse.json({
      hold: {
        id: result.hold.id,
        expiresAt: result.hold.expiresAt,
        startAt: result.hold.startAt,
        endAt: result.hold.endAt,
        zoneId: result.hold.zoneId,
        tableIds: result.hold.tableIds,
      },
      serverNow: new Date().toISOString(),
      summary: result.validation.summary,
      validation: result.validation,
      session: result.session,
      contextVersion: result.context.contextVersion ?? null,
    });
  } catch (error) {
    if (error instanceof StaleContextError) {
      return NextResponse.json(
        {
          error: error.message,
          code: "STALE_CONTEXT",
          details: { expected: error.expected, provided: error.provided },
        },
        { status: 409 },
      );
    }
    if (error instanceof SessionConflictError) {
      return NextResponse.json(
        { error: error.message, code: error.code, details: error.details },
        { status: 409 },
      );
    }
    if (error instanceof ManualSelectionInputError) {
      await emitManualHold({
        ok: false,
        bookingId,
        restaurantId: bookingRow.restaurant_id,
        policyVersion: null,
        adjacencyRequired: contextAdjacencyRequired ?? (typeof requireAdjacency === 'boolean' ? requireAdjacency : null),
        code: error.code,
      });
      return NextResponse.json(
        { error: error.message, code: error.code },
        { status: error.status },
      );
    }

    if (error instanceof HoldConflictError) {
      await emitManualHold({
        ok: false,
        bookingId,
        restaurantId: bookingRow.restaurant_id,
        policyVersion: null,
        adjacencyRequired: contextAdjacencyRequired ?? (typeof requireAdjacency === 'boolean' ? requireAdjacency : null),
        code: "HOLD_CONFLICT",
      });
      return NextResponse.json(
        {
          error: error.message,
          code: "HOLD_CONFLICT",
          holdId: error.holdId ?? null,
        },
        { status: 409 },
      );
    }

    console.error("[staff/manual/hold] unexpected error", { error, bookingId, userId: user.id });
    await emitManualHold({
      ok: false,
      bookingId,
      restaurantId: bookingRow.restaurant_id,
      policyVersion: null,
      adjacencyRequired: contextAdjacencyRequired ?? (typeof requireAdjacency === 'boolean' ? requireAdjacency : null),
      code: "INTERNAL_ERROR",
    });
    const message = error instanceof Error ? error.message : "Unexpected error";
    return NextResponse.json({ error: message, code: "INTERNAL_ERROR" }, { status: 500 });
  }
}

export async function DELETE(req: NextRequest) {
  const supabase = await getRouteHandlerSupabaseClient();

  const {
    data: { user },
    error: authError,
  } = await supabase.auth.getUser();

  if (authError || !user) {
    return NextResponse.json({ error: "Unauthorized", code: "UNAUTHORIZED" }, { status: 401 });
  }

  const body = await req.json().catch(() => null);
  const parsed = holdReleaseSchema.safeParse(body);

  if (!parsed.success) {
    return NextResponse.json(
      { error: "Invalid request payload", code: "INVALID_PAYLOAD", details: parsed.error.flatten() },
      { status: 400 },
    );
  }

  const { holdId, bookingId } = parsed.data;

  const holdLookup = await supabase
    .from("table_holds")
    .select("restaurant_id, booking_id")
    .eq("id", holdId)
    .maybeSingle();

  if (holdLookup.error) {
    console.error("[staff/manual/hold][delete] hold lookup failed", { holdId, error: holdLookup.error });
    return NextResponse.json({ error: "Failed to load hold", code: "HOLD_LOOKUP_FAILED" }, { status: 500 });
  }

  const holdRow = holdLookup.data;
  if (!holdRow?.restaurant_id) {
    return NextResponse.json({ error: "Hold not found", code: "HOLD_NOT_FOUND" }, { status: 404 });
  }

  if (holdRow.booking_id && holdRow.booking_id !== bookingId) {
    return NextResponse.json(
      { error: "Hold belongs to a different booking", code: "HOLD_BOOKING_MISMATCH" },
      { status: 409 },
    );
  }

  const membership = await supabase
    .from("restaurant_memberships")
    .select("role")
    .eq("restaurant_id", holdRow.restaurant_id)
    .eq("user_id", user.id)
    .maybeSingle();

  if (membership.error) {
    console.error("[staff/manual/hold][delete] membership lookup failed", { holdId, error: membership.error });
    return NextResponse.json({ error: "Failed to verify access", code: "ACCESS_LOOKUP_FAILED" }, { status: 500 });
  }

  if (!membership.data) {
    return NextResponse.json({ error: "Access denied", code: "ACCESS_DENIED" }, { status: 403 });
  }

  const serviceClient = getTenantServiceSupabaseClient(holdRow.restaurant_id);

  try {
    await releaseTableHold({ holdId, client: serviceClient });
    return NextResponse.json({ holdId, released: true });
  } catch (error) {
    console.error("[staff/manual/hold][delete] failed to release hold", { holdId, error });
    const message = error instanceof Error ? error.message : "Unexpected error";
    return NextResponse.json({ error: message, code: "RELEASE_FAILED" }, { status: 500 });
  }
}
\n// ===== src/app/api/staff/manual/confirm/route.ts =====
import { NextResponse } from "next/server";
import { z } from "zod";

import { mapAssignTablesErrorToHttp } from "@/app/api/staff/_utils/assign-tables-error";
import { AssignTablesRpcError, HoldNotFoundError } from "@/server/capacity/holds";
import { confirmSessionHold, getOrCreateManualSession, SessionConflictError, StaleContextError } from "@/server/capacity/manual-session";
import { emitManualConfirm } from "@/server/capacity/telemetry";
import { sendBookingConfirmationEmail } from "@/server/emails/bookings";
import { getRouteHandlerSupabaseClient, getTenantServiceSupabaseClient } from "@/server/supabase";

import type { BookingRecord } from "@/server/bookings";
import type { NextRequest } from "next/server";

const confirmPayloadSchema = z.object({
  bookingId: z.string().uuid(),
  holdId: z.string().uuid(),
  idempotencyKey: z.string().min(1),
  requireAdjacency: z.boolean().optional(),
  contextVersion: z.string(),
});

const isEmailSuppressed = () =>
  process.env.LOAD_TEST_DISABLE_EMAILS === "true" || process.env.SUPPRESS_EMAILS === "true";

export async function POST(req: NextRequest) {
  const supabase = await getRouteHandlerSupabaseClient();

  const {
    data: { user },
    error: authError,
  } = await supabase.auth.getUser();

  if (authError || !user) {
    return NextResponse.json({ message: "Unauthorized", error: "Unauthorized", code: "UNAUTHORIZED" }, { status: 401 });
  }

  const body = await req.json().catch(() => null);
  const parsed = confirmPayloadSchema.safeParse(body);

  if (!parsed.success) {
    return NextResponse.json(
      {
        message: "Invalid request payload",
        error: "Invalid request payload",
        code: "INVALID_PAYLOAD",
        details: parsed.error.flatten(),
      },
      { status: 400 },
    );
  }

  const { bookingId, holdId, idempotencyKey, requireAdjacency, contextVersion } = parsed.data;

  const holdLookup = await supabase
    .from("table_holds")
    .select("restaurant_id, booking_id")
    .eq("id", holdId)
    .maybeSingle();

  if (holdLookup.error) {
    console.error("[staff/manual/confirm] hold lookup failed", { holdId, error: holdLookup.error });
    return NextResponse.json(
      { message: "Failed to load hold", error: "Failed to load hold", code: "HOLD_LOOKUP_FAILED" },
      { status: 500 },
    );
  }

  const holdRow = holdLookup.data;
  if (!holdRow?.restaurant_id) {
    return NextResponse.json(
      { message: "Hold not found", error: "Hold not found", code: "HOLD_NOT_FOUND" },
      { status: 404 },
    );
  }

  if (holdRow.booking_id && holdRow.booking_id !== bookingId) {
    return NextResponse.json(
      {
        message: "Hold belongs to a different booking",
        error: "Hold belongs to a different booking",
        code: "HOLD_BOOKING_MISMATCH",
      },
      { status: 409 },
    );
  }

  const membership = await supabase
    .from("restaurant_memberships")
    .select("role")
    .eq("restaurant_id", holdRow.restaurant_id)
    .eq("user_id", user.id)
    .maybeSingle();

  if (membership.error) {
    console.error("[staff/manual/confirm] membership lookup failed", { holdId, error: membership.error });
    return NextResponse.json(
      { message: "Failed to verify access", error: "Failed to verify access", code: "ACCESS_LOOKUP_FAILED" },
      { status: 500 },
    );
  }

  if (!membership.data) {
    return NextResponse.json(
      { message: "Access denied", error: "Access denied", code: "ACCESS_DENIED" },
      { status: 403 },
    );
  }

  const serviceClient = getTenantServiceSupabaseClient(holdRow.restaurant_id);

  const bookingLookup = await serviceClient
    .from("bookings")
    .select("*")
    .eq("id", bookingId)
    .maybeSingle();

  if (bookingLookup.error) {
    console.error("[staff/manual/confirm] booking lookup failed", { bookingId, error: bookingLookup.error });
    return NextResponse.json(
      { message: "Failed to load booking", error: "Failed to load booking", code: "BOOKING_LOOKUP_FAILED" },
      { status: 500 },
    );
  }

  const bookingRow = (bookingLookup.data ?? null) as BookingRecord | null;
  if (!bookingRow) {
    return NextResponse.json(
      { message: "Booking not found", error: "Booking not found", code: "BOOKING_NOT_FOUND" },
      { status: 404 },
    );
  }
  const alreadyConfirmed = bookingRow.status === "confirmed";

  const session = await getOrCreateManualSession({
    bookingId,
    restaurantId: holdRow.restaurant_id,
    createdBy: user.id,
    client: serviceClient,
  });

  try {
    const result = await confirmSessionHold({
      sessionId: session.id,
      bookingId,
      restaurantId: holdRow.restaurant_id,
      holdId,
      idempotencyKey,
      requireAdjacency,
      contextVersion,
      selectionVersion: session.selectionVersion,
      assignedBy: user.id,
      client: serviceClient,
    });

    const contextAdjacencyRequired = Boolean(result.context.flags?.adjacencyRequired ?? null);

    await emitManualConfirm({
      ok: true,
      bookingId,
      restaurantId: holdRow.restaurant_id,
      policyVersion: result.context.policyVersion ?? null,
      adjacencyRequired: contextAdjacencyRequired ?? (typeof requireAdjacency === "boolean" ? requireAdjacency : null),
    });

    if (!isEmailSuppressed() && !alreadyConfirmed) {
      try {
        const refreshed = await serviceClient
          .from("bookings")
          .select("*")
          .eq("id", bookingId)
          .maybeSingle();

        if (refreshed.error) {
          console.error("[staff/manual/confirm] failed to reload booking for email", {
            bookingId,
            error: refreshed.error,
          });
        } else {
          const updatedBooking = (refreshed.data ?? null) as BookingRecord | null;
          if (!updatedBooking) {
            console.warn("[staff/manual/confirm] booking disappeared before email send", { bookingId });
          } else if (updatedBooking.status === "confirmed" && updatedBooking.customer_email) {
            await sendBookingConfirmationEmail(updatedBooking);
          }
        }
      } catch (error) {
        console.error("[staff/manual/confirm] failed to send confirmation email", { bookingId, error });
      }
    }

    return NextResponse.json({ assignments: result.assignments, session: result.session, context: result.context });
  } catch (error) {
    if (error instanceof HoldNotFoundError) {
      return NextResponse.json({ message: error.message, error: error.message, code: "HOLD_NOT_FOUND" }, { status: 404 });
    }
    if (error instanceof StaleContextError) {
      return NextResponse.json(
        {
          message: error.message,
          error: error.message,
          code: "STALE_CONTEXT",
          details: { expected: error.expected, provided: error.provided },
        },
        { status: 409 },
      );
    }
    if (error instanceof SessionConflictError) {
      return NextResponse.json(
        { message: error.message, error: error.message, code: error.code, details: error.details },
        { status: 409 },
      );
    }
    if (error instanceof AssignTablesRpcError) {
      const { status, payload } = mapAssignTablesErrorToHttp(error);
      return NextResponse.json(payload, { status });
    }
    console.error("[staff/manual/confirm] unexpected error", { error, bookingId, userId: user.id });
    const message = error instanceof Error ? error.message : "Unexpected error";
    return NextResponse.json({ message, error: message, code: "INTERNAL_ERROR" }, { status: 500 });
  }
}
\n// ===== src/app/api/staff/manual/session/route.ts =====
import { NextResponse } from "next/server";
import { z } from "zod";

import { computeManualContext, getOrCreateManualSession, ManualSessionDisabledError } from "@/server/capacity/manual-session";
import { ManualSelectionInputError } from "@/server/capacity/table-assignment";
import { getRouteHandlerSupabaseClient, getTenantServiceSupabaseClient } from "@/server/supabase";

import type { NextRequest } from "next/server";

const createSessionSchema = z.object({
  bookingId: z.string().uuid(),
});

export async function POST(req: NextRequest) {
  const supabase = await getRouteHandlerSupabaseClient();
  const {
    data: { user },
    error: authError,
  } = await supabase.auth.getUser();

  if (authError || !user) {
    return NextResponse.json({ error: "Unauthorized", code: "UNAUTHORIZED" }, { status: 401 });
  }

  const body = await req.json().catch(() => null);
  const parsed = createSessionSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json(
      { error: "Invalid request payload", code: "INVALID_PAYLOAD", details: parsed.error.flatten() },
      { status: 400 },
    );
  }

  const { bookingId } = parsed.data;

  const bookingLookup = await supabase
    .from("bookings")
    .select("restaurant_id")
    .eq("id", bookingId)
    .maybeSingle();

  if (bookingLookup.error) {
    return NextResponse.json({ error: "Failed to load booking", code: "BOOKING_LOOKUP_FAILED" }, { status: 500 });
  }
  const bookingRow = bookingLookup.data;
  if (!bookingRow?.restaurant_id) {
    return NextResponse.json({ error: "Booking not found", code: "BOOKING_NOT_FOUND" }, { status: 404 });
  }

  const membership = await supabase
    .from("restaurant_memberships")
    .select("role")
    .eq("restaurant_id", bookingRow.restaurant_id)
    .eq("user_id", user.id)
    .maybeSingle();

  if (membership.error) {
    return NextResponse.json({ error: "Failed to verify access", code: "ACCESS_LOOKUP_FAILED" }, { status: 500 });
  }
  if (!membership.data) {
    return NextResponse.json({ error: "Access denied", code: "ACCESS_DENIED" }, { status: 403 });
  }

  const serviceClient = getTenantServiceSupabaseClient(bookingRow.restaurant_id);

  try {
    const session = await getOrCreateManualSession({
      bookingId,
      restaurantId: bookingRow.restaurant_id,
      createdBy: user.id,
      client: serviceClient,
    });
    const context = await computeManualContext({ bookingId, client: serviceClient });
    return NextResponse.json({
      session,
      context,
    });
  } catch (error) {
    if (error instanceof ManualSessionDisabledError) {
      return NextResponse.json({ error: error.message, code: "SESSION_DISABLED" }, { status: 404 });
    }
    if (error instanceof ManualSelectionInputError) {
      return NextResponse.json({ error: error.message, code: error.code }, { status: error.status });
    }
    console.error("[staff/manual/session] unexpected error", { error, bookingId, userId: user.id });
    const message = error instanceof Error ? error.message : "Unexpected error";
    return NextResponse.json({ error: message, code: "INTERNAL_ERROR" }, { status: 500 });
  }
}
\n// ===== src/app/api/staff/manual/session/[sessionId]/selection/route.ts =====
import { NextResponse } from "next/server";
import { z } from "zod";

import {
  ManualSessionDisabledError,
  SessionConflictError,
  SessionNotFoundError,
  StaleContextError,
  proposeOrHoldSelection,
  loadManualSession,
} from "@/server/capacity/manual-session";
import { ManualSelectionInputError } from "@/server/capacity/table-assignment";
import { getRouteHandlerSupabaseClient, getTenantServiceSupabaseClient } from "@/server/supabase";

import type { NextRequest } from "next/server";

const selectionSchema = z.object({
  bookingId: z.string().uuid(),
  tableIds: z.array(z.string().uuid()).min(1),
  mode: z.enum(["propose", "hold"]).default("hold"),
  requireAdjacency: z.boolean().optional(),
  excludeHoldId: z.string().uuid().optional(),
  contextVersion: z.string().optional(),
  selectionVersion: z.number().int().nonnegative().optional(),
  holdTtlSeconds: z.number().int().min(30).max(600).optional(),
});

export async function PUT(req: NextRequest, { params }: { params: Promise<{ sessionId: string }> }) {
  const { sessionId } = await params;
  const supabase = await getRouteHandlerSupabaseClient();
  const {
    data: { user },
    error: authError,
  } = await supabase.auth.getUser();

  if (authError || !user) {
    return NextResponse.json({ error: "Unauthorized", code: "UNAUTHORIZED" }, { status: 401 });
  }

  const body = await req.json().catch(() => null);
  const parsed = selectionSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json(
      { error: "Invalid request payload", code: "INVALID_PAYLOAD", details: parsed.error.flatten() },
      { status: 400 },
    );
  }

  const { bookingId, tableIds, mode, requireAdjacency, excludeHoldId, contextVersion, selectionVersion, holdTtlSeconds } =
    parsed.data;

  const bookingLookup = await supabase
    .from("bookings")
    .select("restaurant_id")
    .eq("id", bookingId)
    .maybeSingle();

  if (bookingLookup.error) {
    return NextResponse.json({ error: "Failed to load booking", code: "BOOKING_LOOKUP_FAILED" }, { status: 500 });
  }
  const bookingRow = bookingLookup.data;
  if (!bookingRow?.restaurant_id) {
    return NextResponse.json({ error: "Booking not found", code: "BOOKING_NOT_FOUND" }, { status: 404 });
  }

  const membership = await supabase
    .from("restaurant_memberships")
    .select("role")
    .eq("restaurant_id", bookingRow.restaurant_id)
    .eq("user_id", user.id)
    .maybeSingle();

  if (membership.error) {
    return NextResponse.json({ error: "Failed to verify access", code: "ACCESS_LOOKUP_FAILED" }, { status: 500 });
  }
  if (!membership.data) {
    return NextResponse.json({ error: "Access denied", code: "ACCESS_DENIED" }, { status: 403 });
  }

  const serviceClient = getTenantServiceSupabaseClient(bookingRow.restaurant_id);

  try {
    const session = await loadManualSession({ sessionId, client: serviceClient });
    if (session.bookingId !== bookingId) {
      return NextResponse.json(
        { error: "Session belongs to a different booking", code: "SESSION_BOOKING_MISMATCH" },
        { status: 409 },
      );
    }
    const result = await proposeOrHoldSelection({
      sessionId,
      bookingId,
      restaurantId: bookingRow.restaurant_id,
      tableIds,
      mode,
      requireAdjacency,
      excludeHoldId,
      contextVersion,
      selectionVersion,
      holdTtlSeconds,
      createdBy: user.id,
      client: serviceClient,
    });
    return NextResponse.json({
      session: result.session,
      validation: result.validation,
      hold: result.hold ?? null,
      context: result.context,
    });
  } catch (error) {
    if (error instanceof ManualSessionDisabledError) {
      return NextResponse.json({ error: error.message, code: "SESSION_DISABLED" }, { status: 404 });
    }
    if (error instanceof SessionNotFoundError) {
      return NextResponse.json({ error: error.message, code: "SESSION_NOT_FOUND" }, { status: 404 });
    }
    if (error instanceof StaleContextError) {
      return NextResponse.json(
        {
          error: error.message,
          code: "STALE_CONTEXT",
          details: { expected: error.expected, provided: error.provided },
        },
        { status: 409 },
      );
    }
    if (error instanceof SessionConflictError) {
      return NextResponse.json(
        { error: error.message, code: error.code, details: error.details },
        { status: 409 },
      );
    }
    if (error instanceof ManualSelectionInputError) {
      return NextResponse.json({ error: error.message, code: error.code }, { status: error.status });
    }
    console.error("[staff/manual/session/selection] unexpected error", { error, sessionId, bookingId, userId: user.id });
    const message = error instanceof Error ? error.message : "Unexpected error";
    return NextResponse.json({ error: message, code: "INTERNAL_ERROR" }, { status: 500 });
  }
}
\n// ===== src/app/api/staff/manual/session/[sessionId]/confirm/route.ts =====
import { NextResponse } from "next/server";
import { z } from "zod";

import {
  ManualSessionDisabledError,
  SessionConflictError,
  SessionNotFoundError,
  StaleContextError,
  confirmSessionHold,
  loadManualSession,
} from "@/server/capacity/manual-session";
import { AssignTablesRpcError, HoldNotFoundError } from "@/server/capacity/holds";
import { ManualSelectionInputError } from "@/server/capacity/table-assignment";
import { mapAssignTablesErrorToHttp } from "@/app/api/staff/_utils/assign-tables-error";
import { getRouteHandlerSupabaseClient, getTenantServiceSupabaseClient } from "@/server/supabase";

import type { NextRequest } from "next/server";

const confirmSchema = z.object({
  bookingId: z.string().uuid(),
  holdId: z.string().uuid(),
  idempotencyKey: z.string().min(1),
  requireAdjacency: z.boolean().optional(),
  contextVersion: z.string().optional(),
  selectionVersion: z.number().int().nonnegative().optional(),
});

export async function POST(req: NextRequest, { params }: { params: Promise<{ sessionId: string }> }) {
  const { sessionId } = await params;
  const supabase = await getRouteHandlerSupabaseClient();
  const {
    data: { user },
    error: authError,
  } = await supabase.auth.getUser();

  if (authError || !user) {
    return NextResponse.json({ error: "Unauthorized", code: "UNAUTHORIZED" }, { status: 401 });
  }

  const body = await req.json().catch(() => null);
  const parsed = confirmSchema.safeParse(body);
  if (!parsed.success) {
    return NextResponse.json(
      { error: "Invalid request payload", code: "INVALID_PAYLOAD", details: parsed.error.flatten() },
      { status: 400 },
    );
  }

  const { bookingId, holdId, idempotencyKey, requireAdjacency, contextVersion, selectionVersion } = parsed.data;

  const bookingLookup = await supabase
    .from("bookings")
    .select("restaurant_id")
    .eq("id", bookingId)
    .maybeSingle();

  if (bookingLookup.error) {
    return NextResponse.json({ error: "Failed to load booking", code: "BOOKING_LOOKUP_FAILED" }, { status: 500 });
  }
  const bookingRow = bookingLookup.data;
  if (!bookingRow?.restaurant_id) {
    return NextResponse.json({ error: "Booking not found", code: "BOOKING_NOT_FOUND" }, { status: 404 });
  }

  const membership = await supabase
    .from("restaurant_memberships")
    .select("role")
    .eq("restaurant_id", bookingRow.restaurant_id)
    .eq("user_id", user.id)
    .maybeSingle();

  if (membership.error) {
    return NextResponse.json({ error: "Failed to verify access", code: "ACCESS_LOOKUP_FAILED" }, { status: 500 });
  }
  if (!membership.data) {
    return NextResponse.json({ error: "Access denied", code: "ACCESS_DENIED" }, { status: 403 });
  }

  const serviceClient = getTenantServiceSupabaseClient(bookingRow.restaurant_id);

  try {
    const session = await loadManualSession({ sessionId, client: serviceClient });
    if (session.bookingId !== bookingId) {
      return NextResponse.json(
        { error: "Session belongs to a different booking", code: "SESSION_BOOKING_MISMATCH" },
        { status: 409 },
      );
    }

    const result = await confirmSessionHold({
      sessionId,
      bookingId,
      restaurantId: bookingRow.restaurant_id,
      holdId,
      idempotencyKey,
      requireAdjacency,
      contextVersion,
      selectionVersion,
      assignedBy: user.id,
      client: serviceClient,
    });

    return NextResponse.json({
      session: result.session,
      assignments: result.assignments,
      context: result.context,
    });
  } catch (error) {
    if (error instanceof ManualSessionDisabledError) {
      return NextResponse.json({ error: error.message, code: "SESSION_DISABLED" }, { status: 404 });
    }
    if (error instanceof SessionNotFoundError) {
      return NextResponse.json({ error: error.message, code: "SESSION_NOT_FOUND" }, { status: 404 });
    }
    if (error instanceof StaleContextError) {
      return NextResponse.json(
        { error: error.message, code: "STALE_CONTEXT", details: { expected: error.expected, provided: error.provided } },
        { status: 409 },
      );
    }
    if (error instanceof SessionConflictError) {
      return NextResponse.json(
        { error: error.message, code: error.code, details: error.details },
        { status: 409 },
      );
    }
    if (error instanceof HoldNotFoundError) {
      return NextResponse.json({ error: error.message, code: "HOLD_NOT_FOUND" }, { status: 404 });
    }
    if (error instanceof ManualSelectionInputError) {
      return NextResponse.json({ error: error.message, code: error.code }, { status: error.status });
    }
    if (error instanceof AssignTablesRpcError) {
      const { status, payload } = mapAssignTablesErrorToHttp(error);
      return NextResponse.json(payload, { status });
    }
    console.error("[staff/manual/session/confirm] unexpected error", { error, sessionId, bookingId, userId: user.id });
    const message = error instanceof Error ? error.message : "Unexpected error";
    return NextResponse.json({ error: message, code: "INTERNAL_ERROR" }, { status: 500 });
  }
}
\n// ===== server/capacity/engine/public-api.ts =====
import {
  quoteTablesForBooking as _quoteTablesForBooking,
  confirmHoldAssignment as _confirmHoldAssignment,
  getManualAssignmentContext as _getManualAssignmentContext,
  evaluateManualSelection as _evaluateManualSelection,
  createManualHold as _createManualHold,
  ManualSelectionInputError,
} from '@/server/capacity/tables';

import type {
  QuoteTablesOptions,
  QuoteTablesResult,
  ManualHoldOptions,
  ManualHoldResult,
  ManualValidationResult,
  ManualAssignmentContext,
  TableAssignmentMember,
  ManualSelectionOptions,
} from '@/server/capacity/tables';
import type { Database } from '@/types/supabase';
import type { SupabaseClient } from '@supabase/supabase-js';


type DbClient = SupabaseClient<Database, 'public'>;

export { ManualSelectionInputError };

// Public Engine API: keep names concise and cohesive

export async function quoteTables(options: QuoteTablesOptions): Promise<QuoteTablesResult> {
  return _quoteTablesForBooking(options);
}

export async function confirmHold(params: {
  holdId: string;
  bookingId: string;
  idempotencyKey: string;
  requireAdjacency?: boolean;
  assignedBy?: string | null;
  client?: DbClient;
}): Promise<TableAssignmentMember[]> {
  return _confirmHoldAssignment(params);
}

export async function getManualContext(params: {
  bookingId: string;
  client?: DbClient;
}): Promise<ManualAssignmentContext> {
  return _getManualAssignmentContext(params);
}

export async function validateManualSelection(options: ManualSelectionOptions): Promise<ManualValidationResult> {
  return _evaluateManualSelection(options);
}

export async function holdManualSelection(options: ManualHoldOptions): Promise<ManualHoldResult> {
  return _createManualHold(options);
}

// Types re-export for convenience when consuming the engine
export type { QuoteTablesOptions, QuoteTablesResult, ManualHoldOptions, ManualHoldResult, ManualValidationResult, ManualAssignmentContext };
\n// ===== server/capacity/manual-session.ts =====
import { type ManualSelectionSummary } from "@/server/capacity/table-assignment";
import { getManualAssignmentContext, createManualHold, evaluateManualSelection, confirmHoldAssignment } from "@/server/capacity/table-assignment";
import { ensureClient } from "@/server/capacity/table-assignment/supabase";
import { isManualAssignmentSessionEnabled } from "@/server/feature-flags";

import type { Json } from "@/types/supabase";
import type { SupabaseClient } from "@supabase/supabase-js";

type DbClient = SupabaseClient<any, "public">;
const MAS_TABLE = "manual_assignment_sessions" as const;

export type ManualSessionState = "none" | "proposed" | "held" | "confirmed" | "expired" | "conflicted" | "cancelled";

export type ManualSessionSelection = {
  tableIds: string[];
  requireAdjacency?: boolean | null;
  summary?: ManualSelectionSummary | null;
};

export type ManualAssignmentSession = {
  id: string;
  bookingId: string;
  restaurantId: string;
  state: ManualSessionState;
  selection: ManualSessionSelection | null;
  selectionVersion: number;
  contextVersion: string | null;
  policyVersion: string | null;
  snapshotHash: string | null;
  holdId: string | null;
  expiresAt: string | null;
  createdBy: string | null;
  updatedAt: string | null;
  tableVersion?: string | null;
  adjacencyVersion?: string | null;
  flagsVersion?: string | null;
  windowVersion?: string | null;
  holdsVersion?: string | null;
  assignmentsVersion?: string | null;
};

export class ManualSessionDisabledError extends Error {
  constructor() {
    super("Manual assignment sessions are disabled");
    this.name = "ManualSessionDisabledError";
  }
}
function isTableMissingError(error: unknown): boolean {
  const code = (error as { code?: string | null })?.code ?? null;
  const message = (error as { message?: string | null })?.message ?? "";
  return code === "42P01" || message.includes("schema cache") || message.includes("does not exist");
}

export class StaleContextError extends Error {
  public readonly expected: string | null;
  public readonly provided: string | null;
  constructor(expected: string | null, provided: string | null) {
    super("Stale context; please refresh");
    this.name = "StaleContextError";
    this.expected = expected;
    this.provided = provided;
  }
}

export class SessionNotFoundError extends Error {
  constructor(message = "Session not found") {
    super(message);
    this.name = "SessionNotFoundError";
  }
}

export class SessionConflictError extends Error {
  public readonly code: string;
  public readonly details: Json | null;
  constructor(message: string, code: string, details: Json | null = null) {
    super(message);
    this.name = "SessionConflictError";
    this.code = code;
    this.details = details;
  }
}

function normalizeSessionRow(row: Record<string, any>): ManualAssignmentSession {
  return {
    id: row.id,
    bookingId: row.booking_id,
    restaurantId: row.restaurant_id,
    state: row.state,
    selection: (row.selection as ManualSessionSelection | null) ?? null,
    selectionVersion: row.selection_version ?? 0,
    contextVersion: row.context_version ?? null,
    policyVersion: row.policy_version ?? null,
    snapshotHash: row.snapshot_hash ?? null,
    holdId: row.hold_id ?? null,
    expiresAt: row.expires_at ?? null,
    createdBy: row.created_by ?? null,
    updatedAt: row.updated_at ?? null,
    tableVersion: row.table_version ?? null,
    adjacencyVersion: row.adjacency_version ?? null,
    flagsVersion: row.flags_version ?? null,
    windowVersion: row.window_version ?? null,
    holdsVersion: row.holds_version ?? null,
    assignmentsVersion: row.assignments_version ?? null,
  };
}

async function assertEnabled() {
  if (!isManualAssignmentSessionEnabled()) {
    throw new ManualSessionDisabledError();
  }
}

export async function getOrCreateManualSession(params: {
  bookingId: string;
  restaurantId: string;
  createdBy: string | null;
  client?: DbClient;
}) {
  await assertEnabled();
  const supabase = ensureClient(params.client);
  const existing = await supabase
    .from(MAS_TABLE as any)
    .select("*")
    .eq("booking_id", params.bookingId)
    .maybeSingle();

  if (existing.data) {
    return normalizeSessionRow(existing.data);
  }

  const { data: inserted, error } = await supabase
    .from(MAS_TABLE as any)
    .insert({
      booking_id: params.bookingId,
      restaurant_id: params.restaurantId,
      created_by: params.createdBy,
    })
    .select("*")
    .single();

  if (error || !inserted) {
    if (isTableMissingError(error)) {
      throw new ManualSessionDisabledError();
    }
    throw new Error(error?.message ?? "Failed to create manual assignment session");
  }

  return normalizeSessionRow(inserted);
}

export async function loadManualSession(params: { sessionId: string; client?: DbClient }) {
  await assertEnabled();
  const supabase = ensureClient(params.client);
  const { data, error } = await supabase.from(MAS_TABLE as any).select("*").eq("id", params.sessionId).maybeSingle();
  if (error) {
    if (isTableMissingError(error)) {
      throw new ManualSessionDisabledError();
    }
    throw new Error(error.message ?? "Failed to load session");
  }
  if (!data) {
    throw new SessionNotFoundError();
  }
  return normalizeSessionRow(data);
}

async function updateSession(params: {
  sessionId: string;
  patch: Record<string, any>;
  client?: DbClient;
}) {
  const supabase = ensureClient(params.client);
  const { data, error } = await supabase
    .from(MAS_TABLE as any)
    .update({
      ...params.patch,
      updated_at: new Date().toISOString(),
    })
    .eq("id", params.sessionId)
    .select("*")
    .maybeSingle();

  if (error || !data) {
    throw new Error(error?.message ?? "Failed to update session");
  }
  return normalizeSessionRow(data);
}

async function refreshSessionFromHold(session: ManualAssignmentSession, client: DbClient) {
  if (session.state !== "held" || !session.holdId) {
    return session;
  }

  const { data: holdRow, error } = await client
    .from("table_holds")
    .select("status, expires_at")
    .eq("id", session.holdId)
    .maybeSingle();

  if (error) {
    if (isTableMissingError(error)) {
      throw new ManualSessionDisabledError();
    }
    return session;
  }

  if (!holdRow) {
    return updateSession({
      sessionId: session.id,
      patch: {
        state: "cancelled",
        hold_id: null,
        selection_version: session.selectionVersion + 1,
        expires_at: null,
      },
      client,
    });
  }

  const status = (holdRow as { status?: string | null }).status ?? "active";
  const expiresAt = (holdRow as { expires_at?: string | null }).expires_at ?? session.expiresAt;
  const expired = expiresAt ? new Date(expiresAt).getTime() <= Date.now() : false;

  if (status === "active" && !expired) {
    return session;
  }

  const terminalState =
    status === "confirmed"
      ? "confirmed"
      : status === "cancelled"
        ? "cancelled"
        : "expired";

  const patch: Record<string, any> = {
    state: terminalState,
    hold_id: null,
    expires_at: expiresAt ?? null,
  };

  if (terminalState !== (session.state as string)) {
    patch.selection_version = session.selectionVersion + 1;
  }

  return updateSession({
    sessionId: session.id,
    patch,
    client,
  });
}

function buildVersionPatch(context: { contextVersion?: string | null; policyVersion?: string | null; versions?: Record<string, string | null | undefined> }) {
  const versions = context.versions ?? {};
  return {
    context_version: context.contextVersion ?? null,
    policy_version: context.policyVersion ?? null,
    table_version: (versions as any).tables ?? null,
    adjacency_version: (versions as any).adjacency ?? null,
    flags_version: (versions as any).flags ?? null,
    window_version: (versions as any).window ?? null,
    holds_version: (versions as any).holds ?? null,
    assignments_version: (versions as any).assignments ?? null,
  };
}

export async function computeManualContext(params: { bookingId: string; client?: DbClient }) {
  await assertEnabled();
  const context = await getManualAssignmentContext({ bookingId: params.bookingId, client: params.client });
  return context;
}

export async function proposeOrHoldSelection(params: {
  sessionId: string;
  bookingId: string;
  restaurantId: string;
  tableIds: string[];
  mode: "propose" | "hold";
  requireAdjacency?: boolean;
  excludeHoldId?: string | null;
  contextVersion?: string | null;
  selectionVersion?: number;
  createdBy: string | null;
  holdTtlSeconds?: number;
  client?: DbClient;
}) {
  await assertEnabled();
  const supabase = ensureClient(params.client);
  let session = await loadManualSession({ sessionId: params.sessionId, client: supabase });
  session = await refreshSessionFromHold(session, supabase);

  if (session.bookingId !== params.bookingId || session.restaurantId !== params.restaurantId) {
    throw new SessionConflictError("Session does not match booking/restaurant", "SESSION_MISMATCH");
  }

  const context = await computeManualContext({ bookingId: params.bookingId, client: supabase });
  if (params.contextVersion && context.contextVersion && params.contextVersion !== context.contextVersion) {
    throw new StaleContextError(context.contextVersion, params.contextVersion);
  }

  const nextSelectionVersion = (session.selectionVersion ?? 0) + 1;
  if (typeof params.selectionVersion === "number" && params.selectionVersion !== session.selectionVersion) {
    throw new SessionConflictError("Selection version mismatch", "SELECTION_VERSION_MISMATCH", {
      expected: session.selectionVersion,
      provided: params.selectionVersion,
    });
  }

  const baseSelection: ManualSessionSelection = {
    tableIds: params.tableIds,
    requireAdjacency: params.requireAdjacency ?? null,
    summary: null,
  };

  const validation = await evaluateManualSelection({
    bookingId: params.bookingId,
    tableIds: params.tableIds,
    requireAdjacency: params.requireAdjacency,
    excludeHoldId: params.excludeHoldId ?? null,
    client: supabase,
  });

  const summary = validation.summary ?? null;
  baseSelection.summary = summary ?? null;

  if (params.mode === "propose") {
    const updated = await updateSession({
      sessionId: session.id,
      patch: {
        selection: baseSelection,
        selection_version: nextSelectionVersion,
        state: validation.ok ? "proposed" : "conflicted",
        ...buildVersionPatch({
          contextVersion: context.contextVersion ?? null,
          policyVersion: (validation as { policyVersion?: string }).policyVersion ?? null,
          versions: context.versions,
        }),
        snapshot_hash: null,
        expires_at: null,
        hold_id: null,
      },
      client: supabase,
    });
    return {
      session: updated,
      validation,
      context,
    };
  }

  // mode === hold
  if (!params.createdBy) {
    throw new SessionConflictError("Actor required to place hold", "CREATED_BY_REQUIRED");
  }

  const holdResult = await createManualHold({
    bookingId: params.bookingId,
    tableIds: params.tableIds,
    holdTtlSeconds: params.holdTtlSeconds,
    requireAdjacency: params.requireAdjacency,
    excludeHoldId: params.excludeHoldId ?? session.holdId ?? null,
    createdBy: params.createdBy,
    client: supabase,
  });

  if (!holdResult.hold) {
    const updated = await updateSession({
      sessionId: session.id,
      patch: {
        selection: baseSelection,
        selection_version: nextSelectionVersion,
        state: "conflicted",
        context_version: context.contextVersion ?? null,
        policy_version: (validation as { policyVersion?: string }).policyVersion ?? null,
        snapshot_hash: null,
        expires_at: null,
        hold_id: null,
      },
      client: supabase,
    });
    return {
      session: updated,
      validation: holdResult.validation ?? validation,
      context,
    };
  }

  const hold = holdResult.hold;
  // Link hold to session and mark active
  await supabase
    .from("table_holds")
    .update({
      session_id: session.id,
      status: "active",
      last_touched_at: new Date().toISOString(),
    } as any)
    .eq("id", hold.id);

  const snapshotHash =
    typeof (holdResult.validation as { policyVersion?: string })?.policyVersion === "string"
      ? (holdResult.validation as { policyVersion?: string }).policyVersion
      : (hold.metadata as any)?.selection?.snapshot?.adjacency?.hash ?? null;

  const updated = await updateSession({
    sessionId: session.id,
    patch: {
      selection: baseSelection,
      selection_version: nextSelectionVersion,
      state: "held",
      hold_id: hold.id,
      expires_at: hold.expiresAt ?? null,
      ...buildVersionPatch({
        contextVersion: context.contextVersion ?? null,
        policyVersion: (holdResult.validation as { policyVersion?: string }).policyVersion ?? null,
        versions: context.versions,
      }),
      snapshot_hash: snapshotHash ?? null,
    },
    client: supabase,
  });

  // Recompute context to capture the newly created hold in the hash we return/store
  const postHoldContext = await computeManualContext({ bookingId: params.bookingId, client: supabase });
  const contextVersion = postHoldContext.contextVersion ?? context.contextVersion ?? null;
  const policyVersion = postHoldContext.policyVersion ?? (holdResult.validation as { policyVersion?: string })?.policyVersion ?? null;

  const patchedAfterContext = await updateSession({
    sessionId: session.id,
    patch: {
      ...buildVersionPatch({
        contextVersion,
        policyVersion,
        versions: postHoldContext.versions ?? context.versions,
      }),
    },
    client: supabase,
  });

  return {
    session: patchedAfterContext,
    validation: holdResult.validation,
    hold,
    context: postHoldContext,
  };
}

export async function confirmSessionHold(params: {
  sessionId: string;
  bookingId: string;
  restaurantId: string;
  holdId: string;
  idempotencyKey: string;
  requireAdjacency?: boolean;
  contextVersion?: string | null;
  selectionVersion?: number;
  assignedBy: string | null;
  client?: DbClient;
}) {
  await assertEnabled();
  const supabase = ensureClient(params.client);
  let session = await loadManualSession({ sessionId: params.sessionId, client: supabase });
  session = await refreshSessionFromHold(session, supabase);
  if (session.bookingId !== params.bookingId || session.restaurantId !== params.restaurantId) {
    throw new SessionConflictError("Session does not match booking/restaurant", "SESSION_MISMATCH");
  }
  if (session.holdId && session.holdId !== params.holdId) {
    throw new SessionConflictError("Hold does not match session", "HOLD_MISMATCH", { sessionHoldId: session.holdId });
  }
  if (typeof params.selectionVersion === "number" && params.selectionVersion !== session.selectionVersion) {
    throw new SessionConflictError("Selection version mismatch", "SELECTION_VERSION_MISMATCH", {
      expected: session.selectionVersion,
      provided: params.selectionVersion,
    });
  }

  // Ensure hold not expired / still active
  const { data: holdRow } = await supabase
    .from("table_holds")
    .select("expires_at, status, booking_id, restaurant_id")
    .eq("id", params.holdId)
    .maybeSingle();

  if (!holdRow) {
    throw new SessionConflictError("Hold not found", "HOLD_NOT_FOUND");
  }

  const typedHoldRow = holdRow as { status?: string | null; booking_id?: string | null; restaurant_id?: string | null; expires_at?: string | null };

  if (typedHoldRow.status && typedHoldRow.status !== "active") {
    throw new SessionConflictError("Hold is not active", "HOLD_INACTIVE", { status: typedHoldRow.status });
  }

  if (typedHoldRow.booking_id && typedHoldRow.booking_id !== params.bookingId) {
    throw new SessionConflictError("Hold linked to different booking", "HOLD_BOOKING_MISMATCH");
  }

  if (typedHoldRow.restaurant_id && typedHoldRow.restaurant_id !== params.restaurantId) {
    throw new SessionConflictError("Hold linked to different restaurant", "HOLD_RESTAURANT_MISMATCH");
  }

  if (typedHoldRow.expires_at && new Date(typedHoldRow.expires_at).getTime() <= Date.now()) {
  await supabase
    .from("table_holds")
    .update({ status: "expired", last_touched_at: new Date().toISOString() } as any)
    .eq("id", params.holdId);
    throw new SessionConflictError("Hold expired", "HOLD_EXPIRED");
  }

  const context = await computeManualContext({ bookingId: params.bookingId, client: supabase });
  if (params.contextVersion && context.contextVersion && params.contextVersion !== context.contextVersion) {
    throw new StaleContextError(context.contextVersion, params.contextVersion);
  }

  const assignments = await confirmHoldAssignment({
    holdId: params.holdId,
    bookingId: params.bookingId,
    idempotencyKey: params.idempotencyKey,
    requireAdjacency: params.requireAdjacency,
    assignedBy: params.assignedBy ?? undefined,
    client: supabase,
    transition: {
      targetStatus: "confirmed",
      historyReason: "manual_assign_session_confirm",
      historyChangedBy: params.assignedBy ?? null,
      historyMetadata: {
        source: "manual_assign_session",
        sessionId: params.sessionId,
        holdId: params.holdId,
      },
    },
  });

  await supabase
    .from("table_holds")
    .update({ status: "confirmed", last_touched_at: new Date().toISOString() } as any)
    .eq("id", params.holdId);

  const nextSelectionVersion = (session.selectionVersion ?? 0) + 1;
  const updated = await updateSession({
    sessionId: session.id,
    patch: {
      state: "confirmed",
      selection_version: nextSelectionVersion,
      ...buildVersionPatch({
        contextVersion: context.contextVersion ?? null,
        policyVersion: context.policyVersion ?? null,
        versions: context.versions,
      }),
      hold_id: null,
    },
    client: supabase,
  });

  return {
    session: updated,
    assignments,
    context,
  };
}
\n// ===== server/capacity/table-assignment/manual.ts =====
import { DateTime } from "luxon";

import { evaluateAdjacency as evaluateAdjacencyGraph, isAdjacencySatisfied, summarizeAdjacencyStatus } from "@/server/capacity/adjacency";
import { listActiveHoldsForBooking, createTableHold, findHoldConflicts, type HoldConflictInfo, type TableHold, type CreateTableHoldInput } from "@/server/capacity/holds";
import { getSelectorScoringConfig, getVenuePolicy, ServiceOverrunError } from "@/server/capacity/policy";
import { computePayloadChecksum, hashPolicyVersion } from "@/server/capacity/v2";
import { getAllocatorAdjacencyMode, getManualAssignmentMaxSlack, isHoldsEnabled, isHoldStrictConflictsEnabled, isAllocatorAdjacencyRequired, isAdjacencyQueryUndirected } from "@/server/feature-flags";

import { buildBusyMaps, extractConflictsForTables, resolveRequireAdjacency } from "./availability";
import { computeBookingWindowWithFallback } from "./booking-window";
import { DEFAULT_HOLD_TTL_SECONDS } from "./constants";
import { ensureClient, loadBooking, loadTablesByIds, loadTablesForRestaurant, loadAdjacency, loadContextBookings, fetchHoldsForWindow, loadTableAssignmentsForTables, loadRestaurantTimezone, releaseHoldWithRetry, extractErrorCode, type DbClient } from "./supabase";
import { ManualSelectionInputError, type ManualSelectionOptions, type ManualValidationResult, type ManualHoldOptions, type ManualHoldResult, type ManualSelectionSummary, type ManualSelectionCheck, type ManualAssignmentConflict, type ManualAssignmentContext, type ManualAssignmentContextHold, type Table, type BookingWindow } from "./types";
import { toIsoUtc, summarizeSelection } from "./utils";

const DEFAULT_MANUAL_SLACK_BUDGET = 4;

function normalizeTableForVersion(table: Table) {
  return {
    id: table.id,
    zoneId: table.zoneId,
    capacity: table.capacity,
    mobility: table.mobility,
    active: table.active,
    category: table.category,
    seatingType: table.seatingType,
  };
}

function buildTableVersion(tables: Table[]) {
  const payload = tables
    .map(normalizeTableForVersion)
    .sort((a, b) => a.id.localeCompare(b.id));
  return computePayloadChecksum(payload);
}

function buildAdjacencyVersion(adjacency: Map<string, Set<string>>) {
  const edges = Array.from(adjacency.entries())
    .map(([id, neighbors]) => ({
      id,
      neighbors: Array.from(neighbors).sort(),
    }))
    .sort((a, b) => a.id.localeCompare(b.id));
  return computePayloadChecksum(edges);
}

function buildFlagsVersion(flags: Record<string, unknown>) {
  return computePayloadChecksum(flags);
}

function buildWindowVersion(window: BookingWindow) {
  return computePayloadChecksum({
    startAt: toIsoUtc(window.block.start),
    endAt: toIsoUtc(window.block.end),
  });
}

function buildHoldsVersion(holds: ManualAssignmentContextHold[]) {
  const payload = holds
    .map((h) => ({
      id: h.id,
      tableIds: [...h.tableIds].sort(),
      startAt: h.startAt,
      endAt: h.endAt,
      expiresAt: h.expiresAt,
      bookingId: h.bookingId,
    }))
    .sort((a, b) => a.id.localeCompare(b.id));
  return computePayloadChecksum(payload);
}

function buildAssignmentsVersion(assignments: string[]) {
  return computePayloadChecksum(assignments.slice().sort());
}

function resolveManualSlackBudget(): number {
  const override = getManualAssignmentMaxSlack();
  if (typeof override === "number") {
    return override;
  }
  const selectorConfig = getSelectorScoringConfig();
  return Math.max(0, selectorConfig.maxOverage ?? DEFAULT_MANUAL_SLACK_BUDGET);
}

function buildManualChecks(params: {
  summary: ManualSelectionSummary;
  tables: Table[];
  requireAdjacency: boolean;
  adjacency: Map<string, Set<string>>;
  conflicts: ManualAssignmentConflict[];
  holdConflicts: HoldConflictInfo[];
  slackBudget: number;
}): ManualSelectionCheck[] {
  const checks: ManualSelectionCheck[] = [];
  const { summary, tables, requireAdjacency, adjacency, conflicts, holdConflicts, slackBudget } = params;

  checks.push({
    id: "capacity",
    status: summary.totalCapacity >= summary.partySize ? "ok" : "error",
    message:
      summary.totalCapacity >= summary.partySize
        ? "Capacity satisfied"
        : "Selected tables do not meet requested party size",
    details: {
      totalCapacity: summary.totalCapacity,
      partySize: summary.partySize,
      slack: summary.slack,
    },
  });

  const slackOk = summary.slack <= slackBudget;
  checks.push({
    id: "slack",
    status: slackOk ? "ok" : "error",
    message: slackOk
      ? `Slack within budget (${summary.slack} <= ${slackBudget})`
      : `Selection exceeds slack budget (allowed ${slackBudget}, actual ${summary.slack})`,
    details: {
      slack: summary.slack,
      allowedSlack: slackBudget,
    },
  });

  if (summary.zoneId === null) {
    checks.push({
      id: "zone",
      status: "error",
      message: "Tables must belong to the same zone for manual assignment",
    });
  } else {
    checks.push({
      id: "zone",
      status: "ok",
      message: `Zone ${summary.zoneId} validated`,
    });
  }

  if (tables.length > 1) {
    const allMovable = tables.every((table) => table.mobility === "movable");
    checks.push({
      id: "movable",
      status: allMovable ? "ok" : "error",
      message: allMovable
        ? "All tables are movable"
        : "Merged assignments require movable tables",
    });
  } else {
    checks.push({
      id: "movable",
      status: "ok",
      message: "Single table selection",
    });
  }

  if (requireAdjacency && tables.length > 1) {
    const adjacencyMode = getAllocatorAdjacencyMode();
    const evaluation = evaluateAdjacencyGraph(
      tables.map((table) => table.id),
      adjacency,
    );
    const adjacencyOk = isAdjacencySatisfied(evaluation, adjacencyMode);
    const failureMessage =
      adjacencyMode === "pairwise"
        ? "Tables must be adjacent to every other selected table"
        : adjacencyMode === "neighbors"
          ? "Tables must share a common neighbor/hub to be merged"
          : "Tables must remain connected when adjacency enforcement is enabled";
    checks.push({
      id: "adjacency",
      status: adjacencyOk ? "ok" : "error",
      message: adjacencyOk
        ? `Tables satisfy ${summarizeAdjacencyStatus(evaluation, tables.length)} adjacency`
        : failureMessage,
      details: {
        mode: adjacencyMode,
        status: summarizeAdjacencyStatus(evaluation, tables.length),
      },
    });
  } else {
    checks.push({
      id: "adjacency",
      status: "ok",
      message: "Adjacency not required",
      details: {
        mode: requireAdjacency ? getAllocatorAdjacencyMode() : "off",
      },
    });
  }

  checks.push({
    id: "conflict",
    status: conflicts.length === 0 && holdConflicts.length === 0 ? "ok" : "error",
    message:
      conflicts.length === 0 && holdConflicts.length === 0
        ? "No conflicting assignments"
        : "Existing assignments or holds conflict with selection",
    details: {
      conflicts,
      holdConflicts,
    },
  });

  checks.push({
    id: "holds",
    status: holdConflicts.length === 0 ? "ok" : "error",
    message: holdConflicts.length === 0 ? "No holds blocking selection" : "Tables currently on hold",
    details: {
      holds: holdConflicts,
    },
  });

  return checks;
}

export async function evaluateManualSelection(options: ManualSelectionOptions): Promise<ManualValidationResult> {
  const { bookingId, tableIds, requireAdjacency: requireAdjacencyOverride, excludeHoldId = null, client } = options;

  if (!Array.isArray(tableIds) || tableIds.length === 0) {
    throw new ManualSelectionInputError("At least one table must be selected", "TABLES_REQUIRED");
  }

  const supabase = ensureClient(client);
  const booking = await loadBooking(bookingId, supabase);
  const restaurantTimezone =
    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??
    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??
    getVenuePolicy().timezone;
  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });
  const policyVersion = hashPolicyVersion(policy);

  let window: BookingWindow;
  try {
    ({ window } = computeBookingWindowWithFallback({
      startISO: booking.start_at,
      bookingDate: booking.booking_date,
      startTime: booking.start_time,
      partySize: booking.party_size,
      policy,
    }));
  } catch (error) {
    if (error instanceof ServiceOverrunError) {
      // Surface a structured 422 that the API layer can return to the client
      // rather than bubbling a 500. Keeps math unchanged while avoiding crashes
      // in manual context fetches for after-hours/overrun bookings.
      throw new ManualSelectionInputError(error.message, "SERVICE_OVERRUN", 422);
    }
    throw error;
  }

  const selectionTables = await loadTablesByIds(booking.restaurant_id, tableIds, supabase);
  if (selectionTables.length !== tableIds.length) {
    throw new ManualSelectionInputError("One or more selected tables were not found", "TABLE_LOOKUP_FAILED");
  }

  const adjacency = await loadAdjacency(booking.restaurant_id, tableIds, supabase);

  const contextBookings = await loadContextBookings(
    booking.restaurant_id,
    booking.booking_date ?? null,
    supabase,
    {
      startIso: toIsoUtc(window.block.start),
      endIso: toIsoUtc(window.block.end),
    },
  );
  let holds: TableHold[] = [];
  if (isHoldsEnabled()) {
    try {
      holds = await listActiveHoldsForBooking({ bookingId, client: supabase });
    } catch {
      holds = [];
    }
  }

  const busy = buildBusyMaps({
    targetBookingId: bookingId,
    bookings: contextBookings,
    holds,
    excludeHoldId,
    policy,
    targetWindow: window,
  });

  const conflicts = extractConflictsForTables(busy, tableIds, window);
  let holdConflicts: HoldConflictInfo[] = [];
  try {
    holdConflicts = await findHoldConflicts({
      restaurantId: booking.restaurant_id,
      tableIds,
      startAt: toIsoUtc(window.block.start),
      endAt: toIsoUtc(window.block.end),
      excludeHoldId,
      client: supabase,
    });
  } catch {
    holdConflicts = [];
  }

  const requireAdjacency = resolveRequireAdjacency(booking.party_size, requireAdjacencyOverride);
  const summary = summarizeSelection(selectionTables, booking.party_size);
  if (booking.assigned_zone_id && summary.zoneId && booking.assigned_zone_id !== summary.zoneId) {
    throw new ManualSelectionInputError(
      `Booking is locked to zone ${booking.assigned_zone_id}; selected zone ${summary.zoneId} is not allowed`,
      "ZONE_LOCKED",
      409,
    );
  }
  const slackBudget = resolveManualSlackBudget();
  const checks = buildManualChecks({
    summary,
    tables: selectionTables,
    requireAdjacency,
    adjacency,
    conflicts,
    holdConflicts,
    slackBudget,
  });

  const ok = checks.every((check) => check.status !== "error");

  return {
    ok,
    summary,
    checks,
    policyVersion,
    slackBudget,
  };
}

export async function createManualHold(options: ManualHoldOptions): Promise<ManualHoldResult> {
  const { bookingId, tableIds, createdBy, holdTtlSeconds = DEFAULT_HOLD_TTL_SECONDS, requireAdjacency, excludeHoldId, client } = options;
  const supabase = ensureClient(client);

  const validation = await evaluateManualSelection({
    bookingId,
    tableIds,
    requireAdjacency,
    excludeHoldId,
    client: supabase,
  });

  if (!validation.ok || !validation.summary) {
    return {
      hold: null,
      validation,
    };
  }

  const booking = await loadBooking(bookingId, supabase);
  const restaurantTimezone =
    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??
    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??
    getVenuePolicy().timezone;
  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });
  const policyVersion = typeof (validation as { policyVersion?: string }).policyVersion === "string"
    ? (validation as { policyVersion?: string }).policyVersion!
    : hashPolicyVersion(policy);

  let window: BookingWindow;
  try {
    ({ window } = computeBookingWindowWithFallback({
      startISO: booking.start_at,
      bookingDate: booking.booking_date,
      startTime: booking.start_time,
      partySize: booking.party_size,
      policy,
    }));
  } catch (error) {
    if (error instanceof ServiceOverrunError) {
      throw new ManualSelectionInputError(error.message, "SERVICE_OVERRUN", 422);
    }
    throw error;
  }

  const selectionTables = await loadTablesByIds(booking.restaurant_id, tableIds, supabase);
  if (selectionTables.length !== tableIds.length) {
    throw new ManualSelectionInputError("Selected tables could not be loaded", "TABLE_LOOKUP_FAILED");
  }

  const startAtIso = toIsoUtc(window.block.start);
  const endAtIso = toIsoUtc(window.block.end);

  const expiresAt =
    options.holdExpiresAt ??
    toIsoUtc(DateTime.now().plus({ seconds: holdTtlSeconds })) ??
    toIsoUtc(window.block.start.plus({ minutes: 2 }));

  const zoneIdValue = validation.summary.zoneId ?? selectionTables[0]?.zoneId;
  if (!zoneIdValue) {
    throw new ManualSelectionInputError("Unable to determine zone for selected tables", "ZONE_REQUIRED");
  }

  // Compute adjacency/zone snapshot for freeze semantics
  const adjacency = await loadAdjacency(booking.restaurant_id, tableIds, supabase);
  const adjacencyUndirected = isAdjacencyQueryUndirected();
  const zoneIds = Array.from(new Set(selectionTables.map((t) => t.zoneId))).filter(Boolean) as string[];
  const edgeSet = new Set<string>();
  for (const a of tableIds) {
    const neighbors = adjacency.get(a);
    if (!neighbors) continue;
    for (const b of neighbors) {
      if (!tableIds.includes(b)) continue;
      const key = adjacencyUndirected
        ? ([a, b].sort((x, y) => x.localeCompare(y)) as [string, string]).join("->")
        : `${a}->${b}`;
      edgeSet.add(key);
    }
  }
  const normalizedEdges = Array.from(edgeSet).sort();
  const adjacencySnapshot = computePayloadChecksum({ undirected: adjacencyUndirected, edges: normalizedEdges });

  const holdPayload: CreateTableHoldInput = {
    bookingId,
    restaurantId: booking.restaurant_id,
    zoneId: zoneIdValue,
    tableIds,
    startAt: startAtIso,
    endAt: endAtIso,
    expiresAt,
    createdBy,
    metadata: {
      selection: {
        tableIds,
        summary: validation.summary,
        snapshot: {
          zoneIds,
          adjacency: {
            undirected: adjacencyUndirected,
            edges: normalizedEdges,
            hash: adjacencySnapshot,
          },
        },
      },
      policyVersion,
    },
    client: supabase,
  };

  const hold = await createTableHold(holdPayload);

  if (excludeHoldId) {
    try {
      await releaseHoldWithRetry({ holdId: excludeHoldId, client: supabase });
    } catch (error) {
      console.warn("[capacity][manual][holds] failed to release replaced hold", {
        bookingId,
        newHoldId: hold.id,
        previousHoldId: excludeHoldId,
        error,
      });
    }
  }

  return {
    hold,
    validation,
  };
}

export async function getManualAssignmentContext(options: {
  bookingId: string;
  client?: DbClient;
}): Promise<ManualAssignmentContext> {
  const { bookingId, client } = options;
  const supabase = ensureClient(client);
  const booking = await loadBooking(bookingId, supabase);

  const restaurantTimezone =
    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??
    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??
    getVenuePolicy().timezone;
  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });

  let window: BookingWindow;
  try {
    ({ window } = computeBookingWindowWithFallback({
      startISO: booking.start_at,
      bookingDate: booking.booking_date,
      startTime: booking.start_time,
      partySize: booking.party_size,
      policy,
    }));
  } catch (error) {
    if (error instanceof ServiceOverrunError) {
      throw new ManualSelectionInputError(error.message, "SERVICE_OVERRUN", 422);
    }
    throw error;
  }

  const tables = await loadTablesForRestaurant(booking.restaurant_id, supabase);
  const adjacency = await loadAdjacency(
    booking.restaurant_id,
    tables.map((table) => table.id),
    supabase,
  );
  const contextBookings = await loadContextBookings(
    booking.restaurant_id,
    booking.booking_date ?? null,
    supabase,
    {
      startIso: toIsoUtc(window.block.start),
      endIso: toIsoUtc(window.block.end),
    },
  );

  let holds: ManualAssignmentContextHold[] = [];
  if (isHoldsEnabled()) {
    try {
      const rawHolds = await fetchHoldsForWindow(booking.restaurant_id, window, supabase);
      holds = await hydrateHoldMetadata(rawHolds, supabase);
    } catch (error: unknown) {
      const code = extractErrorCode(error);
      if (code === "42P01") {
        console.warn("[capacity][manual][context] holds table unavailable; skipping hold hydration", {
          bookingId,
        });
      } else {
        console.warn("[capacity][manual][context] failed to list holds", { bookingId, error });
      }
      holds = [];
    }
  }

  const busy = buildBusyMaps({
    targetBookingId: bookingId,
    bookings: contextBookings,
    holds,
    policy,
    targetWindow: window,
  });

  const bookingAssignments = await loadTableAssignmentsForTables(
    bookingId,
    tables.map((table) => table.id),
    supabase,
  );

  const conflicts = extractConflictsForTables(
    busy,
    tables.map((table) => table.id),
    window,
  );

  const activeHold = holds.find((hold) => hold.bookingId === bookingId) ?? null;

  // Compute context version from holds + assignments + flags + window
  const flags = {
    holdsStrictConflicts: isHoldStrictConflictsEnabled(),
    adjacencyRequired: isAllocatorAdjacencyRequired(),
    adjacencyUndirected: isAdjacencyQueryUndirected(),
  };
  const policyVersion = hashPolicyVersion(policy);
  const tableVersion = buildTableVersion(tables);
  const adjacencyVersion = buildAdjacencyVersion(adjacency);
  const holdsVersion = buildHoldsVersion(holds);
  const assignmentsVersion = buildAssignmentsVersion(bookingAssignments.map((row) => row.table_id));
  const flagsVersion = buildFlagsVersion(flags);
  const windowVersion = buildWindowVersion(window);
  const contextVersion = computePayloadChecksum({
    holds: holdsVersion,
    assignments: assignmentsVersion,
    flags: flagsVersion,
    window: windowVersion,
    policy: policyVersion,
    adjacency: adjacencyVersion,
    tables: tableVersion,
  });
  const serverNow = toIsoUtc(DateTime.now());

  return {
    booking,
    tables,
    bookingAssignments: bookingAssignments.map((row) => row.table_id),
    holds,
    activeHold,
    conflicts,
    window: {
      startAt: toIsoUtc(window.block.start),
      endAt: toIsoUtc(window.block.end),
    },
    flags,
    contextVersion,
    policyVersion,
    versions: {
      context: contextVersion,
      policy: policyVersion,
      window: windowVersion,
      flags: flagsVersion,
      tables: tableVersion,
      adjacency: adjacencyVersion,
      holds: holdsVersion,
      assignments: assignmentsVersion,
    },
    serverNow,
  };
}

async function hydrateHoldMetadata(holds: TableHold[], client: DbClient): Promise<ManualAssignmentContextHold[]> {
  if (holds.length === 0) {
    return [];
  }
  const creatorIds = Array.from(
    new Set(
      holds
        .map((hold) => hold.createdBy)
        .filter((value): value is string => Boolean(value)),
    ),
  );

  let creators: Array<{ id: string; name: string | null; email: string | null }> = [];
  if (creatorIds.length > 0) {
    const { data, error } = await client
      .from("profiles")
      .select("id, name, email")
      .in("id", creatorIds);

    if (!error && data) {
      creators = data as Array<{ id: string; name: string | null; email: string | null }>;
    }
  }

  return holds.map((hold) => {
    const creator = creators.find((profile) => profile.id === hold.createdBy);
    return {
      ...hold,
      createdByName: creator?.name ?? null,
      createdByEmail: creator?.email ?? null,
    };
  });
}
\n// ===== server/capacity/table-assignment/supabase.ts =====
import { DateTime } from "luxon";

import { BOOKING_BLOCKING_STATUSES } from "@/lib/enums";
import { releaseTableHold } from "@/server/capacity/holds";
import {
  getContextQueryPaddingMinutes,
  isAdjacencyQueryUndirected,
} from "@/server/feature-flags";
import { getServiceSupabaseClient } from "@/server/supabase";


import { ManualSelectionInputError, type DbClient, type Table, type BookingWindow } from "./types";
import { toIsoUtc } from "./utils";

import type { TableHold } from "@/server/capacity/holds";
import type { VenuePolicy } from "@/server/capacity/policy";
import type { Tables } from "@/types/supabase";

export type { DbClient } from "./types";

const TABLE_INVENTORY_SELECT =
  "id,table_number,capacity,min_party_size,max_party_size,section,category,seating_type,mobility,zone_id,status,active,position" as const;

export type TableInventoryRow = Tables<"table_inventory">;

export type BookingRow = Tables<"bookings"> & {
  restaurants?: { timezone: string | null } | { timezone: string | null }[];
};

export type ContextBookingRow = {
  id: string;
  party_size: number;
  status: string;
  start_time: string | null;
  end_time: string | null;
  start_at: string | null;
  end_at: string | null;
  booking_date: string | null;
  seating_preference?: string | null;
  booking_table_assignments: Array<{ table_id: string | null }> | null;
};

export type TableHoldRow = Tables<"table_holds"> & {
  table_hold_members: Array<{ table_id: string | null }> | null;
};

export type BookingAssignmentRow = {
  table_id: string;
  id: string;
  start_at: string | null;
  end_at: string | null;
  merge_group_id: string | null;
};

export function ensureClient(client?: DbClient): DbClient {
  return client ?? getServiceSupabaseClient();
}

export function applyAbortSignal<T extends { abortSignal?: (signal: AbortSignal) => T }>(
  builder: T,
  signal?: AbortSignal,
): T {
  if (signal && typeof builder.abortSignal === "function") {
    return builder.abortSignal(signal);
  }
  return builder;
}

export function extractErrorCode(error: unknown): string | undefined {
  if (typeof error !== "object" || error === null) {
    return undefined;
  }
  const code = (error as { code?: unknown }).code;
  return typeof code === "string" ? code : undefined;
}

function normalizeBookingRow(row: BookingRow): BookingRow {
  if (Array.isArray(row.restaurants) && row.restaurants.length > 0) {
    return { ...row, restaurants: row.restaurants[0] ?? null };
  }
  return row;
}

export async function loadBooking(bookingId: string, client: DbClient, signal?: AbortSignal): Promise<BookingRow> {
  const bookingQuery = applyAbortSignal(
    client
      .from("bookings")
      .select(
        [
          "id",
          "restaurant_id",
          "booking_date",
          "start_time",
          "end_time",
          "start_at",
          "end_at",
          "party_size",
          "status",
          "seating_preference",
          "restaurants(timezone)",
        ].join(","),
      )
      .eq("id", bookingId),
    signal,
  );

  const { data, error } = await bookingQuery.maybeSingle();

  if (error) {
    throw new ManualSelectionInputError(error.message ?? "Failed to load booking", "BOOKING_LOOKUP_FAILED", 500);
  }

  if (!data) {
    throw new ManualSelectionInputError("Booking not found", "BOOKING_NOT_FOUND", 404);
  }

  return normalizeBookingRow(data as unknown as BookingRow);
}

type RestaurantInfo = {
  timezone: string | null;
  slug: string | null;
};

async function loadRestaurantInfo(restaurantId: string, client: DbClient, signal?: AbortSignal): Promise<RestaurantInfo> {
  const restaurantQuery = applyAbortSignal(
    client.from("restaurants").select("timezone, slug").eq("id", restaurantId),
    signal,
  );

  const { data, error } = await restaurantQuery.maybeSingle();

  if (error) {
    throw new ManualSelectionInputError(error.message ?? "Failed to load restaurant metadata", "RESTAURANT_LOOKUP_FAILED", 500);
  }

  return {
    timezone: data?.timezone ?? null,
    slug: data?.slug ?? null,
  };
}

export async function loadRestaurantTimezone(
  restaurantId: string,
  client: DbClient,
  signal?: AbortSignal,
): Promise<string | null> {
  const info = await loadRestaurantInfo(restaurantId, client, signal);
  return info.timezone;
}

export async function loadTablesForRestaurant(
  restaurantId: string,
  client: DbClient,
  signal?: AbortSignal,
): Promise<Table[]> {
  try {
    const { getInventoryCache } = await import("@/server/capacity/cache");
    const cached = getInventoryCache(restaurantId);
    if (Array.isArray(cached) && cached.length > 0) {
      return cached as Table[];
    }
  } catch {
    // ignore cache fetch failures
  }

  const query = applyAbortSignal(
    client.from("table_inventory").select(TABLE_INVENTORY_SELECT).eq("restaurant_id", restaurantId),
    signal,
  );
  const { data, error } = await query;

  if (error || !data) {
    throw new ManualSelectionInputError(error?.message ?? "Failed to load table inventory", "TABLE_INVENTORY_LOOKUP_FAILED", 500);
  }

  const rows = data as TableInventoryRow[];
  const tables = rows.map<Table>((row) => ({
    id: row.id,
    tableNumber: row.table_number,
    capacity: row.capacity ?? 0,
    minPartySize: row.min_party_size ?? null,
    maxPartySize: row.max_party_size ?? null,
    section: row.section,
    category: row.category,
    seatingType: row.seating_type,
    mobility: row.mobility,
    zoneId: row.zone_id,
    status: row.status,
    active: row.active,
    position: row.position,
  }));

  try {
    const { setInventoryCache } = await import("@/server/capacity/cache");
    setInventoryCache(restaurantId, tables);
  } catch {
    // ignore cache set failure
  }

  return tables;
}

export async function loadTablesByIds(
  restaurantId: string,
  tableIds: string[],
  client: DbClient,
  signal?: AbortSignal,
): Promise<Table[]> {
  if (tableIds.length === 0) {
    return [];
  }

  const uniqueIds = Array.from(new Set(tableIds));
  const tableQuery = applyAbortSignal(
    client
      .from("table_inventory")
      .select<typeof TABLE_INVENTORY_SELECT, TableInventoryRow>(TABLE_INVENTORY_SELECT)
      .eq("restaurant_id", restaurantId)
      .in("id", uniqueIds),
    signal,
  );

  const { data, error } = await tableQuery;

  if (error || !data) {
    return [];
  }

  const rows = data as TableInventoryRow[];

  const lookup = new Map(
    rows.map((row) => [
      row.id,
      {
        id: row.id,
        tableNumber: row.table_number,
        capacity: row.capacity ?? 0,
        minPartySize: row.min_party_size ?? null,
        maxPartySize: row.max_party_size ?? null,
        section: row.section,
        category: row.category,
        seatingType: row.seating_type,
        mobility: row.mobility,
        zoneId: row.zone_id,
        status: row.status,
        active: row.active,
        position: row.position,
      } satisfies Table,
    ]),
  );

  return tableIds.reduce<Table[]>((acc, id) => {
    const table = lookup.get(id);
    if (table) {
      acc.push(table);
    }
    return acc;
  }, []);
}

export async function loadAdjacency(
  restaurantId: string,
  tableIds: string[],
  client: DbClient,
  signal?: AbortSignal,
): Promise<Map<string, Set<string>>> {
  const uniqueTableIds = Array.from(
    new Set(
      tableIds.filter((value): value is string => typeof value === "string" && value.length > 0),
    ),
  );

  if (uniqueTableIds.length === 0) {
    return new Map();
  }

  let cachedGraph: Map<string, Set<string>> | null = null;
  try {
    const { getAdjacencyCache } = await import("@/server/capacity/cache");
    cachedGraph = getAdjacencyCache(restaurantId);
  } catch {
    cachedGraph = null;
  }
  const missing: string[] = [];
  if (cachedGraph) {
    for (const id of uniqueTableIds) {
      if (!cachedGraph.has(id)) {
        missing.push(id);
      }
    }
  }
  const needFetch = !cachedGraph || missing.length > 0;

  type AdjacencyRow = { table_a: string | null; table_b: string | null };
  const baseQuery = () => applyAbortSignal(client.from("table_adjacencies").select("table_a, table_b"), signal);
  const adjacencyUndirected = isAdjacencyQueryUndirected();
  const targetIds = needFetch && cachedGraph ? missing : uniqueTableIds;
  const forward = await baseQuery().in("table_a", targetIds);
  if (forward.error) {
    return new Map();
  }

  const reverse = adjacencyUndirected ? await baseQuery().in("table_b", targetIds) : null;
  if (reverse?.error) {
    return new Map();
  }

  const forwardRows = Array.isArray(forward.data) ? (forward.data as AdjacencyRow[]) : [];
  const reverseRows =
    adjacencyUndirected && reverse && Array.isArray(reverse.data)
      ? (reverse.data as AdjacencyRow[])
      : [];

  const map = cachedGraph ? new Map<string, Set<string>>(cachedGraph) : new Map<string, Set<string>>();
  if (targetIds.length > 0) {
    for (const id of targetIds) {
      map.delete(id);
    }
  }
  const addEdge = (from: string | null, to: string | null) => {
    if (!from || !to) {
      return;
    }
    if (!map.has(from)) {
      map.set(from, new Set());
    }
    map.get(from)!.add(to);
  };

  for (const row of forwardRows) {
    addEdge(row.table_a, row.table_b);
    if (adjacencyUndirected) {
      addEdge(row.table_b, row.table_a);
    }
  }

  if (adjacencyUndirected && reverseRows) {
    for (const row of reverseRows) {
      addEdge(row.table_a, row.table_b);
      addEdge(row.table_b, row.table_a);
    }
  }

  try {
    const { setAdjacencyCache } = await import("@/server/capacity/cache");
    setAdjacencyCache(restaurantId, map);
  } catch {
    // ignore cache set failures
  }

  const filtered = new Map<string, Set<string>>();
  for (const id of uniqueTableIds) {
    if (map.has(id)) {
      filtered.set(id, new Set(map.get(id)!));
    }
  }
  return filtered;
}

export async function loadContextBookings(
  restaurantId: string,
  bookingDate: string | null,
  client: DbClient,
  aroundWindow?: { startIso: string; endIso: string; paddingMinutes?: number },
  signal?: AbortSignal,
): Promise<ContextBookingRow[]> {
  if (!bookingDate) {
    return [];
  }

  const paddingDefault = Math.max(0, Math.min(getContextQueryPaddingMinutes(), 240));
  const pad = Math.max(0, Math.min(aroundWindow?.paddingMinutes ?? paddingDefault, 240));
  const startIso = aroundWindow?.startIso ?? null;
  const endIso = aroundWindow?.endIso ?? null;
  const padMs = pad * 60 * 1000;
  const startPad = startIso ? DateTime.fromISO(startIso, { setZone: true }).minus({ milliseconds: padMs }).toISO() : null;
  const endPad = endIso ? DateTime.fromISO(endIso, { setZone: true }).plus({ milliseconds: padMs }).toISO() : null;

  let query = client
    .from("bookings")
    .select(
      [
        "id",
        "party_size",
        "status",
        "start_time",
        "end_time",
        "start_at",
        "end_at",
        "booking_date",
        "booking_table_assignments(table_id)",
      ].join(","),
    )
    .eq("restaurant_id", restaurantId)
    .eq("booking_date", bookingDate)
    .in("status", [...BOOKING_BLOCKING_STATUSES])
    .order("start_at", { ascending: true });

  query = applyAbortSignal(query, signal);

  const hasGt = typeof (query as unknown as { gt?: unknown }).gt === "function";
  const hasLt = typeof (query as unknown as { lt?: unknown }).lt === "function";
  if (startPad && hasGt) {
    (query as unknown as { gt: (col: string, val: string) => unknown }).gt("end_at", startPad);
  }
  if (endPad && hasLt) {
    (query as unknown as { lt: (col: string, val: string) => unknown }).lt("start_at", endPad);
  }

  const { data, error } = await query;

  if (error || !data) {
    return [];
  }

  return data as unknown as ContextBookingRow[];
}

export async function loadTableAssignmentsForTables(
  bookingId: string,
  tableIds: string[],
  client: DbClient,
): Promise<BookingAssignmentRow[]> {
  if (tableIds.length === 0) {
    return [];
  }

  const { data, error } = await client
    .from("booking_table_assignments")
    .select("table_id, id, start_at, end_at, merge_group_id")
    .eq("booking_id", bookingId);

  if (error || !data) {
    return [];
  }

  const rows = data as unknown as BookingAssignmentRow[];
  return rows.filter((row) => tableIds.includes(row.table_id));
}

export async function fetchHoldsForWindow(
  restaurantId: string,
  window: BookingWindow,
  client: DbClient,
): Promise<TableHold[]> {
  const { data, error } = await client
    .from("table_holds")
    .select("*, table_hold_members(table_id)")
    .eq("restaurant_id", restaurantId)
    .gt("expires_at", new Date().toISOString())
    .lt("start_at", toIsoUtc(window.block.end))
    .gt("end_at", toIsoUtc(window.block.start));

  if (error || !data) {
    throw error ?? new Error("Failed to load holds");
  }

  const rows = data as TableHoldRow[];

  return rows.map((row) => {
    const members = row.table_hold_members ?? [];
    const tableIds = members
      .map((member) => member.table_id)
      .filter((value): value is string => typeof value === "string");
    return {
      id: row.id,
      bookingId: row.booking_id,
      restaurantId: row.restaurant_id,
      zoneId: row.zone_id,
      startAt: row.start_at,
      endAt: row.end_at,
      expiresAt: row.expires_at,
      tableIds,
      createdBy: row.created_by ?? null,
      metadata: row.metadata ?? null,
    } satisfies TableHold;
  });
}

export async function loadActiveHoldsForDate(
  restaurantId: string,
  bookingDate: string | null,
  policy: VenuePolicy,
  client: DbClient,
  signal?: AbortSignal,
): Promise<TableHold[]> {
  if (!bookingDate) {
    return [];
  }

  const day = DateTime.fromISO(bookingDate, { zone: policy.timezone ?? "UTC" });
  if (!day.isValid) {
    return [];
  }

  const dayStart = toIsoUtc(day.startOf("day"));
  const dayEnd = toIsoUtc(day.plus({ days: 1 }).startOf("day"));
  const now = toIsoUtc(DateTime.now());

  const holdsQuery = applyAbortSignal(
    client
      .from("table_holds")
      .select("*, table_hold_members(table_id)")
      .eq("restaurant_id", restaurantId)
      .gt("expires_at", now)
      .lt("start_at", dayEnd)
      .gt("end_at", dayStart),
    signal,
  );

  const { data, error } = await holdsQuery;

  if (error || !data) {
    throw error ?? new Error("Failed to load holds");
  }

  const rows = data as TableHoldRow[];

  return rows.map((row) => {
    const members = row.table_hold_members ?? [];
    const tableIds = members
      .map((member) => member.table_id)
      .filter((value): value is string => typeof value === "string");
    return {
      id: row.id,
      bookingId: row.booking_id,
      restaurantId: row.restaurant_id,
      zoneId: row.zone_id,
      startAt: row.start_at,
      endAt: row.end_at,
      expiresAt: row.expires_at,
      tableIds,
      createdBy: row.created_by ?? null,
      metadata: row.metadata ?? null,
    } satisfies TableHold;
  });
}

export async function releaseHoldWithRetry(params: {
  holdId: string;
  client: DbClient;
  attempts?: number;
  baseDelayMs?: number;
}): Promise<void> {
  const { holdId, client, attempts = 3, baseDelayMs = 50 } = params;
  for (let attempt = 1; attempt <= attempts; attempt += 1) {
    try {
      await releaseTableHold({ holdId, client });
      return;
    } catch (error) {
      if (attempt === attempts) {
        throw error;
      }
      const jitter = Math.random() * baseDelayMs;
      const delay = baseDelayMs * attempt + jitter;
      await new Promise((resolve) => setTimeout(resolve, delay));
    }
  }
}

export function findMissingHoldMetadataFields(holdRow: TableHoldRow): string[] {
  const missing: string[] = [];
  const rawMetadata = (holdRow as { metadata?: unknown }).metadata;

  if (!rawMetadata || typeof rawMetadata !== "object") {
    return ["metadata"];
  }

  const metadata = rawMetadata as Record<string, unknown>;
  if (typeof metadata.policyVersion !== "string" || metadata.policyVersion.trim().length === 0) {
    missing.push("metadata.policyVersion");
  }

  const selection = metadata.selection as Record<string, unknown> | undefined;
  if (!selection || typeof selection !== "object") {
    missing.push("metadata.selection");
    return missing;
  }

  const snapshot = selection.snapshot as Record<string, unknown> | undefined;
  if (!snapshot || typeof snapshot !== "object") {
    missing.push("metadata.selection.snapshot");
    return missing;
  }

  const zoneIds = snapshot.zoneIds;
  if (!Array.isArray(zoneIds) || zoneIds.length === 0 || zoneIds.some((zone) => typeof zone !== "string" || zone.trim().length === 0)) {
    missing.push("metadata.selection.snapshot.zoneIds");
  }

  const adjacency = snapshot.adjacency as Record<string, unknown> | undefined;
  if (!adjacency || typeof adjacency !== "object") {
    missing.push("metadata.selection.snapshot.adjacency");
    return missing;
  }

  const edges = adjacency.edges;
  if (!Array.isArray(edges) || edges.some((edge) => typeof edge !== "string")) {
    missing.push("metadata.selection.snapshot.adjacency.edges");
  }

  const hash = adjacency.hash;
  if (typeof hash !== "string" || hash.trim().length === 0) {
    missing.push("metadata.selection.snapshot.adjacency.hash");
  }

  return missing;
}
\n// ===== src/services/ops/bookings.ts =====
import { fetchJson } from '@/lib/http/fetchJson';

import type { HttpError } from '@/lib/http/errors';
import type {
  OpsBookingHeatmap,
  OpsBookingListItem,
  OpsBookingsFilters,
  OpsBookingsPage,
  OpsBookingStatus,
  OpsRejectionAnalytics,
  OpsServiceError,
  OpsStrategicSettings,
  OpsTodayBooking,
  OpsTodayBookingsSummary,
  OpsWalkInBookingPayload,
} from '@/types/ops';
import type { Tables } from '@/types/supabase';

const OPS_BOOKINGS_BASE = '/api/ops/bookings';
const OPS_DASHBOARD_BASE = '/api/ops/dashboard';
const OPS_SETTINGS_BASE = '/api/ops/settings';
const STAFF_AUTO_BASE = '/api/staff/auto';
const STAFF_MANUAL_BASE = '/api/staff/manual';
const STAFF_MANUAL_SESSION_BASE = '/api/staff/manual/session';

type SummaryParams = {
  restaurantId: string;
  date?: string | null;
};

type HeatmapParams = {
  restaurantId: string;
  startDate: string;
  endDate: string;
};

type RejectionAnalyticsParams = {
  restaurantId: string;
  from?: string | null;
  to?: string | null;
  bucket?: 'day' | 'hour';
};

type StrategicSettingsParams = {
  restaurantId: string;
};

type StrategicSettingsUpdate = {
  restaurantId: string;
  weights: {
    scarcity: number;
    demandMultiplier?: number | null;
    futureConflictPenalty?: number | null;
  };
};

type UpdateBookingInput = {
  id: string;
  startIso: string;
  endIso: string;
  partySize: number;
  notes?: string | null;
  override?: {
    apply: boolean;
    reason?: string | null;
  } | null;
};

type UpdateStatusInput = {
  id: string;
  status: 'completed' | 'no_show';
};

type LifecycleInput = {
  id: string;
  performedAt?: string;
};

type NoShowInput = {
  id: string;
  performedAt?: string;
  reason?: string | null;
};

type UndoNoShowInput = {
  id: string;
  reason?: string | null;
};

type LifecycleResponse = {
  status: OpsBookingStatus;
  checkedInAt: string | null;
  checkedOutAt: string | null;
};

type StatusSummaryParams = {
  restaurantId: string;
  from?: string | null;
  to?: string | null;
  statuses?: OpsBookingStatus[] | null;
};

type StatusSummaryResponse = {
  restaurantId: string;
  range: {
    from: string | null;
    to: string | null;
  };
  filter: {
    statuses: OpsBookingStatus[] | null;
  };
  totals: Record<OpsBookingStatus, number>;
  generatedAt: string;
};

type BookingHistoryEntry = {
  id: number;
  bookingId: string;
  fromStatus: OpsBookingStatus | null;
  toStatus: OpsBookingStatus;
  changedAt: string;
  changedBy: string | null;
  reason: string | null;
  metadata: Record<string, unknown>;
  actor: {
    id: string;
    name: string | null;
    email: string | null;
  } | null;
};

type BookingHistoryResponse = {
  bookingId: string;
  entries: BookingHistoryEntry[];
  generatedAt: string;
};

type CancelBookingInput = {
  id: string;
};

type WalkInInput = OpsWalkInBookingPayload & {
  idempotencyKey?: string;
};

type WalkInResponse = {
  booking: unknown;
  bookings: unknown;
  idempotencyKey: string | null;
  clientRequestId: string;
};

type AssignTableInput = {
  bookingId: string;
  tableId: string;
};

type TableAssignmentsResponse = {
  tableAssignments: OpsTodayBooking['tableAssignments'];
};

type AutoQuoteCandidate = {
  tableIds: string[];
  tableNumbers: string[];
  totalCapacity: number;
  tableCount: number;
  slack?: number;
  score?: number;
  adjacencyStatus?: 'single' | 'connected' | 'neighbors' | 'pairwise' | 'disconnected';
};

type AutoQuoteResponse = {
  holdId: string | null;
  expiresAt: string | null;
  window: { start: string | null; end: string | null } | null;
  candidate: AutoQuoteCandidate | null;
  alternates: AutoQuoteCandidate[];
  nextTimes: string[];
  reason?: string | null;
  zoneId?: string | null;
  requireAdjacency?: boolean | null;
  serviceFallback?: {
    usedFallback: boolean;
    fallbackService: string | null;
  };
};

type AutoQuoteInput = {
  bookingId: string;
  zoneId?: string;
  maxTables?: number;
  requireAdjacency?: boolean;
  avoidTables?: string[];
  holdTtlSeconds?: number;
};

type ConfirmHoldInput = {
  holdId: string;
  bookingId: string;
  idempotencyKey: string;
  requireAdjacency?: boolean;
  contextVersion?: string;
  selectionVersion?: number | null;
};

export type ConfirmHoldAssignment = {
  tableId: string;
  assignmentId?: string;
  startAt?: string | null;
  endAt?: string | null;
  mergeGroupId?: string | null;
};

type ConfirmHoldResponse = {
  holdId: string;
  bookingId: string;
  assignments: ConfirmHoldAssignment[];
};

export type ManualSelectionCheckStatus = 'ok' | 'warn' | 'error';
export type ManualSelectionCheckId = 'sameZone' | 'movable' | 'adjacency' | 'conflict' | 'capacity';

export type ManualSelectionCheck = {
  id: ManualSelectionCheckId;
  status: ManualSelectionCheckStatus;
  message: string;
  details?: Record<string, unknown>;
};

export type ManualSelectionSummary = {
  tableCount: number;
  totalCapacity: number;
  slack: number;
  zoneId: string | null;
  tableNumbers: string[];
  partySize: number;
};

export type ManualValidationResult = {
  ok: boolean;
  checks: ManualSelectionCheck[];
  summary: ManualSelectionSummary;
  policyVersion?: string;
};

export type ManualHoldSummary = {
  id: string;
  expiresAt: string;
  startAt: string;
  endAt: string;
  zoneId: string;
  tableIds: string[];
};

export type ManualHoldResponse = {
  hold: ManualHoldSummary | null;
  validation: ManualValidationResult;
  summary: ManualSelectionSummary;
};

export type ManualSelectionPayload = {
  bookingId: string;
  tableIds: string[];
  requireAdjacency?: boolean;
  excludeHoldId?: string;
  contextVersion?: string;
  selectionVersion?: number | null;
};

export type ManualHoldPayload = ManualSelectionPayload & {
  holdTtlSeconds?: number;
};

export type ManualAssignmentTable = {
  id: string;
  tableNumber: string;
  capacity: number;
  minPartySize: number;
  maxPartySize: number | null;
  section: string | null;
  category: string;
  seatingType: string;
  mobility: string;
  zoneId: string;
  status: string;
  active: boolean;
  position: Record<string, unknown> | null;
};

export type ManualAssignmentContextHold = {
  id: string;
  bookingId: string | null;
  restaurantId: string;
  zoneId: string;
  startAt: string;
  endAt: string;
  expiresAt: string;
  tableIds: string[];
  createdBy: string | null;
  createdByName: string | null;
  createdByEmail: string | null;
  metadata: Record<string, unknown> | null;
  countdownSeconds: number | null;
};

export type ManualAssignmentConflict = {
  tableId: string;
  bookingId: string;
  startAt: string;
  endAt: string;
  status: OpsBookingStatus | Tables<'bookings'>['status'];
};

export type ManualAssignmentContext = {
  booking: {
    id: string;
    restaurantId: string;
    bookingDate: string | null;
    startAt: string | null;
    endAt: string | null;
    partySize: number;
    status: OpsBookingStatus | Tables<'bookings'>['status'];
  };
  tables: ManualAssignmentTable[];
  bookingAssignments: string[];
  holds: ManualAssignmentContextHold[];
  activeHold: ManualAssignmentContextHold | null;
  conflicts: ManualAssignmentConflict[];
  window: {
    startAt: string | null;
    endAt: string | null;
  };
  policyVersion?: string | null;
  versions?: {
    context?: string | null;
    policy?: string | null;
    window?: string | null;
    flags?: string | null;
    tables?: string | null;
    adjacency?: string | null;
    holds?: string | null;
    assignments?: string | null;
  };
  contextVersion?: string;
  serverNow?: string | null;
};

export type ManualReleaseHoldPayload = {
  holdId: string;
  bookingId: string;
};

export type ManualAssignmentSession = {
  id: string;
  bookingId: string;
  restaurantId: string;
  state: 'none' | 'proposed' | 'held' | 'confirmed' | 'expired' | 'conflicted' | 'cancelled';
  selection?: {
    tableIds: string[];
    requireAdjacency?: boolean | null;
    summary?: ManualValidationResult['summary'] | null;
  } | null;
  selectionVersion: number;
  contextVersion?: string | null;
  policyVersion?: string | null;
  snapshotHash?: string | null;
  holdId?: string | null;
  expiresAt?: string | null;
  tableVersion?: string | null;
  adjacencyVersion?: string | null;
  flagsVersion?: string | null;
  windowVersion?: string | null;
  holdsVersion?: string | null;
  assignmentsVersion?: string | null;
};

export type ManualAssignmentContextWithSession = ManualAssignmentContext & {
  session?: ManualAssignmentSession | null;
};

export interface BookingService {
  getTodaySummary(params: SummaryParams): Promise<OpsTodayBookingsSummary>;
  getBookingHeatmap(params: HeatmapParams): Promise<OpsBookingHeatmap>;
  getRejectionAnalytics(params: RejectionAnalyticsParams): Promise<OpsRejectionAnalytics>;
  getStrategicSettings(params: StrategicSettingsParams): Promise<OpsStrategicSettings>;
  updateStrategicSettings(input: StrategicSettingsUpdate): Promise<OpsStrategicSettings>;
  listBookings(filters: OpsBookingsFilters): Promise<OpsBookingsPage>;
  updateBooking(input: UpdateBookingInput): Promise<OpsBookingListItem>;
  updateBookingStatus(input: UpdateStatusInput): Promise<{ status: OpsBookingStatus }>;
  checkInBooking(input: LifecycleInput): Promise<LifecycleResponse>;
  checkOutBooking(input: LifecycleInput): Promise<LifecycleResponse>;
  markNoShowBooking(input: NoShowInput): Promise<LifecycleResponse>;
  undoNoShowBooking(input: UndoNoShowInput): Promise<LifecycleResponse>;
  getStatusSummary(params: StatusSummaryParams): Promise<StatusSummaryResponse>;
  getBookingHistory(bookingId: string): Promise<BookingHistoryResponse>;
  cancelBooking(input: CancelBookingInput): Promise<{ id: string; status: string }>;
  createWalkInBooking(input: WalkInInput): Promise<WalkInResponse>;
  assignTable(input: AssignTableInput): Promise<TableAssignmentsResponse>;
  unassignTable(input: AssignTableInput): Promise<TableAssignmentsResponse>;
  autoQuoteTables(input: AutoQuoteInput): Promise<AutoQuoteResponse>;
  confirmHoldAssignment(input: ConfirmHoldInput): Promise<ConfirmHoldResponse>;
  manualValidateSelection(input: ManualSelectionPayload): Promise<ManualValidationResult>;
  manualHoldSelection(input: ManualHoldPayload): Promise<ManualHoldResponse>;
  manualConfirmHold(input: ConfirmHoldInput): Promise<{ session: ManualAssignmentSession | null; assignments: ConfirmHoldAssignment[]; context: ManualAssignmentContext }>;
  getManualAssignmentContext(bookingId: string, options?: { preferSession?: boolean }): Promise<ManualAssignmentContextWithSession>;
  manualEnsureSession(input: { bookingId: string }): Promise<ManualAssignmentContextWithSession>;
  manualSessionUpdateSelection(input: {
    sessionId: string;
    bookingId: string;
    tableIds: string[];
    mode: 'propose' | 'hold';
    requireAdjacency?: boolean;
    excludeHoldId?: string | null;
    contextVersion?: string | null;
    selectionVersion?: number;
    holdTtlSeconds?: number;
  }): Promise<{ session: ManualAssignmentSession; validation: ManualValidationResult; hold?: { id: string; expiresAt: string | null } | null; context: ManualAssignmentContext }>;
  manualSessionConfirm(input: {
    sessionId: string;
    bookingId: string;
    holdId: string;
    idempotencyKey: string;
    requireAdjacency?: boolean;
    contextVersion?: string | null;
    selectionVersion?: number;
  }): Promise<{ session: ManualAssignmentSession; assignments: ConfirmHoldAssignment[]; context: ManualAssignmentContext }>;
  manualReleaseHold(input: ManualReleaseHoldPayload): Promise<void>;
}

function toIsoParam(value: Date | string | null | undefined): string | undefined {
  if (!value) return undefined;
  if (value instanceof Date) {
    return Number.isNaN(value.getTime()) ? undefined : value.toISOString();
  }
  const parsed = new Date(value);
  return Number.isNaN(parsed.getTime()) ? undefined : parsed.toISOString();
}

function buildSearch(filters: OpsBookingsFilters): string {
  const params = new URLSearchParams();

  params.set('restaurantId', filters.restaurantId);
  if (filters.page) params.set('page', String(filters.page));
  if (filters.pageSize) params.set('pageSize', String(filters.pageSize));
  if (filters.status && filters.status !== 'all') params.set('status', filters.status);
  if (filters.statuses && filters.statuses.length > 0) params.set('statuses', filters.statuses.join(','));
  if (filters.sort) params.set('sort', filters.sort);
  if (filters.sortBy) params.set('sortBy', filters.sortBy);
  const fromIso = toIsoParam(filters.from ?? undefined);
  if (fromIso) params.set('from', fromIso);
  const toIso = toIsoParam(filters.to ?? undefined);
  if (toIso) params.set('to', toIso);
  const query = filters.query?.toString().trim();
  if (query) params.set('query', query);

  return params.toString();
}

function buildStatusSummarySearch(params: StatusSummaryParams): string {
  const search = new URLSearchParams({ restaurantId: params.restaurantId });
  if (params.from) {
    search.set('from', params.from);
  }
  if (params.to) {
    search.set('to', params.to);
  }
  if (params.statuses && params.statuses.length > 0) {
    search.set('statuses', params.statuses.join(','));
  }
  return search.toString();
}

function createIdempotencyKey(): string {
  if (typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function') {
    try {
      return crypto.randomUUID();
    } catch {
      // fall through
    }
  }
  return `${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;
}

async function fetchContextVersion(bookingId: string): Promise<string | null> {
  try {
    const params = new URLSearchParams({ bookingId });
    const res = await fetchJson<ManualAssignmentContext>(`${STAFF_MANUAL_BASE}/context?${params.toString()}`);
    return res?.contextVersion ?? null;
  } catch {
    return null;
  }
}

export function createBrowserBookingService(): BookingService {
  return {
    async getTodaySummary({ restaurantId, date }) {
      const params = new URLSearchParams({ restaurantId });
      if (date) params.set('date', date);
      return fetchJson<OpsTodayBookingsSummary>(`${OPS_DASHBOARD_BASE}/summary?${params.toString()}`);
    },
    async getBookingHeatmap({ restaurantId, startDate, endDate }) {
      const params = new URLSearchParams({ restaurantId, startDate, endDate });
      return fetchJson<OpsBookingHeatmap>(`${OPS_DASHBOARD_BASE}/heatmap?${params.toString()}`);
    },
    async getRejectionAnalytics({ restaurantId, from, to, bucket }) {
      const params = new URLSearchParams({ restaurantId });
      if (from) params.set('from', from);
      if (to) params.set('to', to);
      if (bucket) params.set('bucket', bucket);
      return fetchJson<OpsRejectionAnalytics>(`${OPS_DASHBOARD_BASE}/rejections?${params.toString()}`);
    },
    async getStrategicSettings({ restaurantId }) {
      const params = new URLSearchParams({ restaurantId });
      return fetchJson<OpsStrategicSettings>(`${OPS_SETTINGS_BASE}/strategic-config?${params.toString()}`);
    },
    async updateStrategicSettings({ restaurantId, weights }) {
      return fetchJson<OpsStrategicSettings>(`${OPS_SETTINGS_BASE}/strategic-config`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ restaurantId, weights }),
      });
    },
    async getStatusSummary(params) {
      const query = buildStatusSummarySearch(params);
      return fetchJson<StatusSummaryResponse>(`${OPS_BOOKINGS_BASE}/status-summary?${query}`);
    },
    async listBookings(filters) {
      const search = buildSearch(filters);
      return fetchJson<OpsBookingsPage>(`${OPS_BOOKINGS_BASE}?${search}`);
    },
    async updateBooking({ id, ...body }) {
      return fetchJson<OpsBookingListItem>(`${OPS_BOOKINGS_BASE}/${id}`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(body),
      });
    },
    async updateBookingStatus({ id, status }) {
      return fetchJson<{ status: OpsBookingStatus }>(`${OPS_BOOKINGS_BASE}/${id}/status`, {
        method: 'PATCH',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ status }),
      });
    },
    async checkInBooking({ id, performedAt }) {
      const body = performedAt ? { performedAt } : undefined;
      return fetchJson<LifecycleResponse>(`${OPS_BOOKINGS_BASE}/${id}/check-in`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: body ? JSON.stringify(body) : undefined,
      });
    },
    async checkOutBooking({ id, performedAt }) {
      const body = performedAt ? { performedAt } : undefined;
      return fetchJson<LifecycleResponse>(`${OPS_BOOKINGS_BASE}/${id}/check-out`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: body ? JSON.stringify(body) : undefined,
      });
    },
    async markNoShowBooking({ id, performedAt, reason }) {
      const payload: Record<string, unknown> = {};
      if (performedAt) payload.performedAt = performedAt;
      if (reason) payload.reason = reason;
      return fetchJson<LifecycleResponse>(`${OPS_BOOKINGS_BASE}/${id}/no-show`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: Object.keys(payload).length > 0 ? JSON.stringify(payload) : undefined,
      });
    },
    async undoNoShowBooking({ id, reason }) {
      const payload: Record<string, unknown> = {};
      if (reason) payload.reason = reason;
      return fetchJson<LifecycleResponse>(`${OPS_BOOKINGS_BASE}/${id}/undo-no-show`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: Object.keys(payload).length > 0 ? JSON.stringify(payload) : undefined,
      });
    },
    async getBookingHistory(bookingId) {
      return fetchJson<BookingHistoryResponse>(`${OPS_BOOKINGS_BASE}/${bookingId}/history`);
    },
    async cancelBooking({ id }) {
      return fetchJson<{ id: string; status: string }>(`${OPS_BOOKINGS_BASE}/${id}`, {
        method: 'DELETE',
      });
    },
    async createWalkInBooking(input) {
      const { idempotencyKey, ...payload } = input;
      const headers: HeadersInit = { 'Content-Type': 'application/json' };
      if (idempotencyKey) {
        headers['Idempotency-Key'] = idempotencyKey;
      }
      return fetchJson<WalkInResponse>(OPS_BOOKINGS_BASE, {
        method: 'POST',
        headers,
        body: JSON.stringify(payload),
      });
    },
    async assignTable({ bookingId, tableId }) {
      const headers: HeadersInit = {
        'Content-Type': 'application/json',
        'Idempotency-Key': createIdempotencyKey(),
      };

      return fetchJson<TableAssignmentsResponse>(`${OPS_BOOKINGS_BASE}/${bookingId}/tables`, {
        method: 'POST',
        headers,
        body: JSON.stringify({ tableId }),
      });
    },
    async unassignTable({ bookingId, tableId }) {
      return fetchJson<TableAssignmentsResponse>(`${OPS_BOOKINGS_BASE}/${bookingId}/tables/${tableId}`, {
        method: 'DELETE',
      });
    },
    async autoQuoteTables({ bookingId, zoneId, maxTables, requireAdjacency, avoidTables, holdTtlSeconds }) {
      const payload: Record<string, unknown> = { bookingId };
      if (zoneId) payload.zoneId = zoneId;
      if (typeof maxTables === 'number') payload.maxTables = maxTables;
      if (typeof requireAdjacency === 'boolean') payload.requireAdjacency = requireAdjacency;
      if (Array.isArray(avoidTables) && avoidTables.length > 0) payload.avoidTables = avoidTables;
      if (typeof holdTtlSeconds === 'number') payload.holdTtlSeconds = holdTtlSeconds;

      return fetchJson<AutoQuoteResponse>(`${STAFF_AUTO_BASE}/quote`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
    },
    async confirmHoldAssignment({ holdId, bookingId, idempotencyKey, requireAdjacency, contextVersion }) {
      if (!contextVersion) {
        contextVersion = await fetchContextVersion(bookingId) ?? '';
      }
      const payload: Record<string, unknown> = {
        holdId,
        bookingId,
        idempotencyKey,
        contextVersion,
      };
      if (typeof requireAdjacency === 'boolean') payload.requireAdjacency = requireAdjacency;

      return fetchJson<ConfirmHoldResponse>(`${STAFF_AUTO_BASE}/confirm`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
    },
    async manualValidateSelection({ bookingId, tableIds, requireAdjacency, excludeHoldId, contextVersion }) {
      const { session, context } = await this.manualEnsureSession({ bookingId });
      const version = contextVersion ?? context.contextVersion ?? '';
      const selectionVersion = session?.selectionVersion ?? undefined;
      const payload: Record<string, unknown> = {
        bookingId,
        tableIds,
        mode: 'propose',
        contextVersion: version,
        selectionVersion,
      };
      if (typeof requireAdjacency === 'boolean') payload.requireAdjacency = requireAdjacency;
      if (excludeHoldId) payload.excludeHoldId = excludeHoldId;

      const res = await fetchJson<{
        session: ManualAssignmentSession;
        validation: ManualValidationResult;
        context: ManualAssignmentContext;
      }>(`${STAFF_MANUAL_SESSION_BASE}/${session?.id}/selection`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
      return res.validation;
    },
    async manualHoldSelection({ bookingId, tableIds, requireAdjacency, excludeHoldId, holdTtlSeconds, contextVersion }) {
      const { session, context } = await this.manualEnsureSession({ bookingId });
      const version = contextVersion ?? context.contextVersion ?? '';
      const selectionVersion = session?.selectionVersion ?? undefined;
      const payload: Record<string, unknown> = {
        bookingId,
        tableIds,
        mode: 'hold',
        contextVersion: version,
        selectionVersion,
      };
      if (typeof requireAdjacency === 'boolean') payload.requireAdjacency = requireAdjacency;
      if (excludeHoldId) payload.excludeHoldId = excludeHoldId;
      if (typeof holdTtlSeconds === 'number') payload.holdTtlSeconds = holdTtlSeconds;

      return fetchJson<ManualHoldResponse>(`${STAFF_MANUAL_SESSION_BASE}/${session?.id}/selection`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
    },
    async manualConfirmHold({ holdId, bookingId, idempotencyKey, requireAdjacency, contextVersion }) {
      const { session, context } = await this.manualEnsureSession({ bookingId });
      const version = contextVersion ?? context.contextVersion ?? '';
      const selectionVersion = session?.selectionVersion ?? undefined;
      const payload: Record<string, unknown> = {
        bookingId,
        holdId,
        idempotencyKey,
        contextVersion: version,
      };
      if (typeof requireAdjacency === 'boolean') payload.requireAdjacency = requireAdjacency;
      if (typeof selectionVersion === 'number') payload.selectionVersion = selectionVersion;

      return fetchJson<{
        session: ManualAssignmentSession;
        assignments: ConfirmHoldAssignment[];
        context: ManualAssignmentContext;
      }>(`${STAFF_MANUAL_SESSION_BASE}/${session?.id}/confirm`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
    },
    async getManualAssignmentContext(bookingId, _options) {
      const payload = { bookingId };
      const res = await fetchJson<{ session: ManualAssignmentSession; context: ManualAssignmentContext }>(
        `${STAFF_MANUAL_SESSION_BASE}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify(payload),
        },
      );
      return { ...res.context, session: res.session };
    },
    async manualEnsureSession({ bookingId }) {
      const res = await fetchJson<{ session: ManualAssignmentSession; context: ManualAssignmentContext }>(
        `${STAFF_MANUAL_SESSION_BASE}`,
        {
          method: 'POST',
          headers: { 'Content-Type': 'application/json' },
          body: JSON.stringify({ bookingId }),
        },
      );
      return { ...res.context, session: res.session };
    },
    async manualSessionUpdateSelection({
      sessionId,
      bookingId,
      tableIds,
      mode,
      requireAdjacency,
      excludeHoldId,
      contextVersion,
      selectionVersion,
      holdTtlSeconds,
    }) {
      const payload: Record<string, unknown> = {
        bookingId,
        tableIds,
        mode,
      };
      if (typeof requireAdjacency === 'boolean') payload.requireAdjacency = requireAdjacency;
      if (excludeHoldId) payload.excludeHoldId = excludeHoldId;
      if (typeof selectionVersion === 'number') payload.selectionVersion = selectionVersion;
      if (typeof contextVersion === 'string') payload.contextVersion = contextVersion;
      if (typeof holdTtlSeconds === 'number') payload.holdTtlSeconds = holdTtlSeconds;

      return fetchJson<{
        session: ManualAssignmentSession;
        validation: ManualValidationResult;
        hold?: { id: string; expiresAt: string | null } | null;
        context: ManualAssignmentContext;
      }>(`${STAFF_MANUAL_SESSION_BASE}/${sessionId}/selection`, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
    },
    async manualSessionConfirm({
      sessionId,
      bookingId,
      holdId,
      idempotencyKey,
      requireAdjacency,
      contextVersion,
      selectionVersion,
    }) {
      const payload: Record<string, unknown> = {
        bookingId,
        holdId,
        idempotencyKey,
      };
      if (typeof requireAdjacency === 'boolean') payload.requireAdjacency = requireAdjacency;
      if (typeof contextVersion === 'string') payload.contextVersion = contextVersion;
      if (typeof selectionVersion === 'number') payload.selectionVersion = selectionVersion;

      return fetchJson<{
        session: ManualAssignmentSession;
        assignments: ConfirmHoldAssignment[];
        context: ManualAssignmentContext;
      }>(`${STAFF_MANUAL_SESSION_BASE}/${sessionId}/confirm`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(payload),
      });
    },
    async manualReleaseHold({ holdId, bookingId }) {
      await fetchJson<{ holdId: string; released: boolean }>(`${STAFF_MANUAL_BASE}/hold`, {
        method: 'DELETE',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify({ holdId, bookingId }),
      });
    },
  } satisfies BookingService;
}

export class NotImplementedBookingService implements BookingService {
  private error(message: string): never {
    throw new Error(`[ops][bookingService] ${message}`);
  }

  getTodaySummary(): Promise<OpsTodayBookingsSummary> {
    this.error('getTodaySummary not implemented');
  }

  getBookingHeatmap(): Promise<OpsBookingHeatmap> {
    this.error('getBookingHeatmap not implemented');
  }

  getRejectionAnalytics(): Promise<OpsRejectionAnalytics> {
    this.error('getRejectionAnalytics not implemented');
  }

  getStrategicSettings(): Promise<OpsStrategicSettings> {
    this.error('getStrategicSettings not implemented');
  }

  updateStrategicSettings(): Promise<OpsStrategicSettings> {
    this.error('updateStrategicSettings not implemented');
  }

  listBookings(): Promise<OpsBookingsPage> {
    this.error('listBookings not implemented');
  }

  updateBooking(): Promise<OpsBookingListItem> {
    this.error('updateBooking not implemented');
  }

  updateBookingStatus(): Promise<{ status: OpsBookingStatus }> {
    this.error('updateBookingStatus not implemented');
  }

  checkInBooking(): Promise<LifecycleResponse> {
    this.error('checkInBooking not implemented');
  }

  checkOutBooking(): Promise<LifecycleResponse> {
    this.error('checkOutBooking not implemented');
  }

  markNoShowBooking(): Promise<LifecycleResponse> {
    this.error('markNoShowBooking not implemented');
  }

  undoNoShowBooking(): Promise<LifecycleResponse> {
    this.error('undoNoShowBooking not implemented');
  }

  getStatusSummary(): Promise<StatusSummaryResponse> {
    this.error('getStatusSummary not implemented');
  }

  getBookingHistory(): Promise<BookingHistoryResponse> {
    this.error('getBookingHistory not implemented');
  }

  cancelBooking(): Promise<{ id: string; status: string }> {
    this.error('cancelBooking not implemented');
  }

  createWalkInBooking(): Promise<WalkInResponse> {
    this.error('createWalkInBooking not implemented');
  }

  assignTable(): Promise<TableAssignmentsResponse> {
    this.error('assignTable not implemented');
  }

  unassignTable(): Promise<TableAssignmentsResponse> {
    this.error('unassignTable not implemented');
  }

  autoQuoteTables(): Promise<AutoQuoteResponse> {
    this.error('autoQuoteTables not implemented');
  }

  confirmHoldAssignment(): Promise<ConfirmHoldResponse> {
    this.error('confirmHoldAssignment not implemented');
  }

  manualValidateSelection(): Promise<ManualValidationResult> {
    this.error('manualValidateSelection not implemented');
  }

  manualHoldSelection(): Promise<ManualHoldResponse> {
    this.error('manualHoldSelection not implemented');
  }

  manualConfirmHold(): Promise<{ session: ManualAssignmentSession; assignments: ConfirmHoldAssignment[]; context: ManualAssignmentContext }> {
    this.error('manualConfirmHold not implemented');
  }

  getManualAssignmentContext(): Promise<ManualAssignmentContextWithSession> {
    this.error('getManualAssignmentContext not implemented');
  }

  manualEnsureSession(): Promise<ManualAssignmentContextWithSession> {
    this.error('manualEnsureSession not implemented');
  }

  manualSessionUpdateSelection(): Promise<{
    session: ManualAssignmentSession;
    validation: ManualValidationResult;
    hold?: { id: string; expiresAt: string | null } | null;
    context: ManualAssignmentContext;
  }> {
    this.error('manualSessionUpdateSelection not implemented');
  }

  manualSessionConfirm(): Promise<{
    session: ManualAssignmentSession;
    assignments: ConfirmHoldAssignment[];
    context: ManualAssignmentContext;
  }> {
    this.error('manualSessionConfirm not implemented');
  }

  manualReleaseHold(): Promise<void> {
    this.error('manualReleaseHold not implemented');
  }
}

export type BookingServiceFactory = () => BookingService;

export function createBookingService(factory?: BookingServiceFactory): BookingService {
  try {
    return factory ? factory() : createBrowserBookingService();
  } catch (error) {
    const fallback = new NotImplementedBookingService();
    if (error instanceof Error) {
      console.error('[ops][bookingService] failed to create service', error.message);
    }
    return fallback;
  }
}

export type BookingServiceError = OpsServiceError | HttpError;
\n// ===== src/hooks/ops/useManualAssignmentContext.ts =====
'use client';

import { useQuery } from '@tanstack/react-query';
import { useEffect } from 'react';

import { useBookingService } from '@/contexts/ops-services';
import { queryKeys } from '@/lib/query/keys';
import { getRealtimeSupabaseClient } from '@/lib/supabase/realtime-client';

import type { ManualAssignmentContextWithSession } from '@/services/ops/bookings';

type UseManualAssignmentContextOptions = {
  bookingId: string | null;
  restaurantId: string | null;
  targetDate: string | null;
  enabled?: boolean;
};

export function useManualAssignmentContext({
  bookingId,
  restaurantId,
  targetDate,
  enabled = true,
}: UseManualAssignmentContextOptions) {
  const manualSessionEnabled = process.env.NEXT_PUBLIC_FEATURE_MANUAL_SESSION_ENABLED === 'true';
  const bookingService = useBookingService();
  const shouldEnable = enabled && Boolean(bookingId);

  const query = useQuery<ManualAssignmentContextWithSession>({
    queryKey: bookingId ? queryKeys.manualAssign.context(bookingId) : ['manualAssign', 'context', 'none'],
    queryFn: async () => {
      if (!bookingId) {
        throw new Error('manual assignment context requires bookingId');
      }
      return bookingService.getManualAssignmentContext(bookingId, { preferSession: manualSessionEnabled });
    },
    enabled: shouldEnable,
    staleTime: 5_000,
    refetchOnWindowFocus: false,
    refetchInterval: shouldEnable && (!process.env.NEXT_PUBLIC_FEATURE_REALTIME_FLOORPLAN || process.env.NEXT_PUBLIC_FEATURE_REALTIME_FLOORPLAN !== 'true') ? 10_000 : false,
  });

  useEffect(() => {
    const realtimeEnabled = typeof window !== 'undefined' && process.env.NEXT_PUBLIC_FEATURE_REALTIME_FLOORPLAN === 'true';
    if (!shouldEnable || !bookingId || !restaurantId || !realtimeEnabled) {
      return;
    }

    const client = getRealtimeSupabaseClient();
    const channelName = `ops-manual-assign:${restaurantId}:${targetDate ?? 'all'}`;
    const channel = client.channel(channelName, {
      config: {
        broadcast: { self: false },
      },
    });

    const handleChange = () => {
      void query.refetch();
    };

    channel.on(
      'postgres_changes',
      {
        event: '*',
        schema: 'public',
        table: 'allocations',
        filter: `restaurant_id=eq.${restaurantId}`,
      },
      handleChange,
    );

    channel.on(
      'postgres_changes',
      {
        event: '*',
        schema: 'public',
        table: 'table_holds',
        filter: `restaurant_id=eq.${restaurantId}`,
      },
      handleChange,
    );

    channel.on(
      'postgres_changes',
      {
        event: '*',
        schema: 'public',
        table: 'booking_table_assignments',
        filter: `booking_id=eq.${bookingId}`,
      },
      handleChange,
    );

    channel.subscribe();

    return () => {
      client.removeChannel(channel);
    };
  }, [bookingId, restaurantId, shouldEnable, targetDate, query]);

  return query;
}
\n// ===== src/components/features/dashboard/BookingDetailsDialog.tsx =====
'use client';

import { useMutation, useQuery, useQueryClient } from '@tanstack/react-query';
import { format } from 'date-fns';
import { Mail, Phone, Clock, Users, Calendar as CalendarIcon, AlertTriangle, Award, CheckCircle2, XCircle, Loader2, LogIn, LogOut, History, ArrowRight, Keyboard } from 'lucide-react';
import { useCallback, useEffect, useMemo, useState, type ComponentType } from 'react';

import { BookingActionButton, BookingStatusBadge, StatusTransitionAnimator } from '@/components/features/booking-state-machine';
import {
  ManualAssignmentActions,
  ManualAssignmentSummaryCard,
  ManualAssignmentValidationPanel,
} from '@/components/features/dashboard/manual-assignment';
import { TableFloorPlan } from '@/components/features/dashboard/TableFloorPlan';
import { Alert, AlertDescription, AlertTitle } from '@/components/ui/alert';
import { Badge } from '@/components/ui/badge';
import { Button } from '@/components/ui/button';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Dialog, DialogContent, DialogDescription, DialogHeader, DialogTitle, DialogTrigger } from '@/components/ui/dialog';
import { Label } from '@/components/ui/label';
import { Switch } from '@/components/ui/switch';
import { Tabs, TabsContent, TabsList, TabsTrigger } from '@/components/ui/tabs';
import { useBookingState } from '@/contexts/booking-state-machine';
import { useBookingService } from '@/contexts/ops-services';
import { useManualAssignmentContext } from '@/hooks/ops/useManualAssignmentContext';
import { useToast } from '@/hooks/use-toast';
import { queryKeys } from '@/lib/query/keys';
import { cn } from '@/lib/utils';
import { formatDateReadable, formatTimeRange, getTodayInTimezone } from '@/lib/utils/datetime';

import { extractManualHoldValidation, isManualHoldValidationError } from './manualHoldHelpers';

import type { BookingAction } from '@/components/features/booking-state-machine';
import type {
  ManualSelectionPayload,
  ManualHoldPayload,
  ManualValidationResult,
  ConfirmHoldAssignment,
} from '@/services/ops/bookings';
import type { OpsTodayBooking, OpsTodayBookingsSummary } from '@/types/ops';

const TIER_COLORS: Record<string, string> = {
  platinum: 'bg-purple-500 text-white border-purple-500',
  gold: 'bg-yellow-500 text-black border-yellow-500',
  silver: 'bg-gray-400 text-white border-gray-400',
  bronze: 'bg-amber-700 text-white border-amber-700',
};

function expandAssignmentGroups(groups: OpsTodayBooking['tableAssignments']) {
  const expanded: Array<{
    tableId: string;
    tableNumber: string;
    capacity: number | null;
    section: string | null;
  }> = [];

  for (const group of groups ?? []) {
    const members = group?.members ?? [];
    if (members.length === 0) {
      continue;
    }

    for (const member of members) {
      expanded.push({
        tableId: member.tableId,
        tableNumber: member.tableNumber ?? '',
        capacity: member.capacity ?? null,
        section: member.section ?? null,
      });
    }
  }

  return expanded;
}

function formatSlack(slack: number): string {
  if (slack === 0) {
    return 'exact fit';
  }
  if (slack > 0) {
    return `+${slack} over`;
  }
  return `${slack} short`;
}

function formatCountdownFromIso(expiresAt: string | null, nowTs: number): string | null {
  if (!expiresAt) {
    return null;
  }
  const target = Date.parse(expiresAt);
  if (Number.isNaN(target)) {
    return null;
  }
  const diffSeconds = Math.max(0, Math.floor((target - nowTs) / 1000));
  const minutes = Math.floor(diffSeconds / 60)
    .toString()
    .padStart(2, '0');
  const seconds = Math.floor(diffSeconds % 60)
    .toString()
    .padStart(2, '0');
  return `${minutes}:${seconds}`;
}

type BookingDetailsDialogProps = {
  booking: OpsTodayBooking;
  summary: OpsTodayBookingsSummary;
  allowTableAssignments: boolean;
  onCheckIn?: () => Promise<void>;
  onCheckOut?: () => Promise<void>;
  onMarkNoShow?: (options?: { performedAt?: string | null; reason?: string | null }) => Promise<void>;
  onUndoNoShow?: (reason?: string | null) => Promise<void>;
  pendingLifecycleAction?: 'check-in' | 'check-out' | 'no-show' | 'undo-no-show' | null;
  onAssignTable?: (tableId: string) => Promise<OpsTodayBooking['tableAssignments']>;
  onUnassignTable?: (tableId: string) => Promise<OpsTodayBooking['tableAssignments']>;
  tableActionState?: {
    type: 'assign' | 'unassign';
    tableId?: string | null;
  } | null;
};

type BookingDetailsTab = 'overview' | 'tables';

const MANUAL_HOLD_TTL_SECONDS = 180;

export function BookingDetailsDialog({
  booking,
  summary,
  allowTableAssignments,
  onCheckIn,
  onCheckOut,
  onMarkNoShow,
  onUndoNoShow,
  pendingLifecycleAction,
  onAssignTable: _onAssignTable,
  onUnassignTable,
  tableActionState,
}: BookingDetailsDialogProps) {
  const manualSessionEnabled = true;
  const [isOpen, setIsOpen] = useState(false);
  const [selectedTables, setSelectedTables] = useState<string[]>([]);
  const [userModifiedSelection, setUserModifiedSelection] = useState(false);
  const [validationResult, setValidationResult] = useState<ManualValidationResult | null>(null);
  const [lastValidatedAt, setLastValidatedAt] = useState<number | null>(null);
  const [requireAdjacency, setRequireAdjacency] = useState(true);
  const [lastHoldKey, setLastHoldKey] = useState<string | null>(null);
  const [currentTimestamp, setCurrentTimestamp] = useState(() => Date.now());
  const [assignments, setAssignments] = useState<OpsTodayBooking['tableAssignments']>(booking.tableAssignments);
  const [localPendingAction, setLocalPendingAction] = useState<BookingAction | null>(null);
  const [showShortcuts, setShowShortcuts] = useState(false);
  const [activeTab, setActiveTab] = useState<BookingDetailsTab>('overview');
  const [onlyAvailable, setOnlyAvailable] = useState(true);
  const [staleContext, setStaleContext] = useState(false);
  const [lastApiError, setLastApiError] = useState<null | { scope: 'validate'|'hold'|'confirm', code: string | null, message: string, details?: any }>(null);
  const [manualSessionId, setManualSessionId] = useState<string | null>(null);
  const [manualSelectionVersionState, setManualSelectionVersionState] = useState<number | null>(null);
  const lifecycleAvailability = useMemo(
    () => ({ isToday: getTodayInTimezone(summary.timezone) === summary.date }),
    [summary.date, summary.timezone],
  );

  const mailHref = booking.customerEmail ? `mailto:${booking.customerEmail}` : null;
  const phoneHref = booking.customerPhone ? `tel:${booking.customerPhone.replace(/[^+\d]/g, '')}` : null;

  const serviceDateReadable = formatDateReadable(summary.date, summary.timezone);
  const serviceTime = formatTimeRange(booking.startTime, booking.endTime, summary.timezone);
  const bookingState = useBookingState(booking.id);
  const effectiveStatus = bookingState.effectiveStatus ?? booking.status;
  const lifecyclePending = pendingLifecycleAction ?? localPendingAction;
  const isCancelled = effectiveStatus === 'cancelled';
  const showLifecycleBadges = effectiveStatus !== 'checked_in' && effectiveStatus !== 'completed';
  const bookingService = useBookingService();
  const queryClient = useQueryClient();
  const { toast } = useToast();
  const supportsTableAssignment = allowTableAssignments;
  const [isHistoryOpen, setIsHistoryOpen] = useState(false);

  const manualContextQuery = useManualAssignmentContext({
    bookingId: isOpen ? booking.id : null,
    restaurantId: summary.restaurantId,
    targetDate: summary.date,
    enabled: supportsTableAssignment && isOpen,
  });

  const {
    data: manualContextData,
    isLoading: manualContextLoading,
    isFetching: manualContextFetching,
    isError: manualContextIsError,
    error: manualContextError,
    refetch: refetchManualContext,
  } = manualContextQuery;
  const manualContext = manualContextData ?? null;
  const manualSession = (manualContext as (typeof manualContext & { session?: { id?: string | null; selectionVersion?: number | null } | null }))?.session ?? null;
  const manualSelectionVersion = manualSelectionVersionState ?? manualSession?.selectionVersion ?? null;

  const holdMutation = useMutation({
    mutationFn: async (payload: ManualHoldPayload & { selectionVersion?: number | null }) => {
      return bookingService.manualHoldSelection({
        bookingId: payload.bookingId,
        tableIds: payload.tableIds,
        requireAdjacency: payload.requireAdjacency,
        excludeHoldId: payload.excludeHoldId,
        holdTtlSeconds: payload.holdTtlSeconds,
        contextVersion: payload.contextVersion,
        selectionVersion: payload.selectionVersion ?? undefined,
      });
    },
    onSuccess: (result, variables) => {
      setStaleContext(false);
      const response: any = result;
      const validation = ('validation' in response ? response.validation : null) ?? null;
      const hold = ('hold' in response ? response.hold : null) as any;
      const sessionUpdate = ('session' in response ? response.session : null) as { selectionVersion?: number | null } | null;
      if (sessionUpdate && typeof sessionUpdate.selectionVersion === 'number') {
        setManualSelectionVersionState(sessionUpdate.selectionVersion);
      }
      setValidationResult(validation ?? null);
      setLastValidatedAt(Date.now());
      const holdKey = hold && Array.isArray(hold.tableIds) ? hold.tableIds.slice().sort().join(',') : null;
      setLastHoldKey(holdKey);
      if (hold) {
        setUserModifiedSelection(false);
        void queryClient.invalidateQueries({ queryKey: queryKeys.manualAssign.context(booking.id) });
      } else {
        setUserModifiedSelection(true);
      }
    },
    onError: async (error, variables) => {
      const code = (error as any)?.code ?? null;
      if (code === 'STALE_CONTEXT' || code === 'SELECTION_VERSION_MISMATCH' || code === 'HOLD_EXPIRED' || code === 'HOLD_INACTIVE') {
        setStaleContext(true);
        void refetchManualContext();
        return;
      }
      if (isManualHoldValidationError(error)) {
        const validation = extractManualHoldValidation(error);
        if (validation) {
          setValidationResult(validation);
        } else if (variables) {
          try {
            const result = await bookingService.manualValidateSelection({
              bookingId: variables.bookingId,
              tableIds: variables.tableIds,
              requireAdjacency: variables.requireAdjacency,
              excludeHoldId: variables.excludeHoldId,
              contextVersion: manualContext?.contextVersion ?? '',
            });
            setValidationResult(result);
          } catch (validationError) {
            const message =
              validationError instanceof Error ? validationError.message : 'Unable to validate selection';
            toast({ title: 'Validation failed', description: message, variant: 'destructive' });
          }
        }
        setUserModifiedSelection(true);
        const selectionKey = Array.isArray(variables?.tableIds)
          ? [...variables.tableIds].sort().join(',')
          : null;
        setLastHoldKey(selectionKey);
        return;
      }

      const rawDetails = (error as any)?.details ?? null;
      let details: any = rawDetails;
      if (typeof rawDetails === 'string') {
        try { details = JSON.parse(rawDetails); } catch { /* ignore */ }
      }
      const message = error instanceof Error ? error.message : 'Unable to place hold';
      toast({ title: 'Hold failed', description: message, variant: 'destructive' });
      setLastApiError({ scope: 'hold', code, message, details });
    },
  });

  const validateMutation = useMutation({
    mutationFn: (payload: ManualSelectionPayload) => bookingService.manualValidateSelection(payload),
    onSuccess: (result) => {
      setStaleContext(false);
      setValidationResult(result);
      setLastValidatedAt(Date.now());
    },
    onError: (error) => {
      const code = (error as any)?.code ?? null;
      if (code === 'STALE_CONTEXT' || code === 'SELECTION_VERSION_MISMATCH' || code === 'HOLD_EXPIRED' || code === 'HOLD_INACTIVE') {
        setStaleContext(true);
        void refetchManualContext();
        return;
      }
      const rawDetails = (error as any)?.details ?? null;
      let details: any = rawDetails;
      if (typeof rawDetails === 'string') {
        try { details = JSON.parse(rawDetails); } catch { /* ignore */ }
      }
      const message = error instanceof Error ? error.message : 'Validation failed';
      toast({ title: 'Validation failed', description: message, variant: 'destructive' });
      setLastApiError({ scope: 'validate', code, message, details });
    },
  });

  const confirmMutation = useMutation({
    mutationFn: async (holdId: string) => {
      const key =
        typeof crypto !== 'undefined' && typeof crypto.randomUUID === 'function'
          ? crypto.randomUUID()
          : `${Date.now()}-${Math.random().toString(36).slice(2, 10)}`;
      return bookingService.manualConfirmHold({
        holdId,
        bookingId: booking.id,
        idempotencyKey: key,
        requireAdjacency,
        contextVersion: manualContext?.contextVersion ?? undefined,
        selectionVersion: manualSelectionVersion ?? undefined,
      });
    },
    onSuccess: (result) => {
      setStaleContext(false);
      const response: any = result;
      const sessionUpdate = ('session' in response ? response.session : null) as { selectionVersion?: number | null } | null;
      if (sessionUpdate && typeof sessionUpdate.selectionVersion === 'number') {
        setManualSelectionVersionState(sessionUpdate.selectionVersion);
      }
      const assignments = ('assignments' in response ? response.assignments : response.assignments) as ConfirmHoldAssignment[];
      const tableMap = new Map(manualContext?.tables.map((table) => [table.id, table]) ?? []);
      const nextAssignments = assignments.map((assignment) => {
        const meta = tableMap.get(assignment.tableId);
        return {
          groupId: null,
          capacitySum: meta?.capacity ?? null,
          members: [
            {
              tableId: assignment.tableId,
              tableNumber: meta?.tableNumber ?? assignment.tableId,
              capacity: meta?.capacity ?? null,
              section: meta?.section ?? null,
            },
          ],
        };
      });
      setAssignments(nextAssignments as any);
      setSelectedTables([]);
      setValidationResult(null);
      setLastValidatedAt(null);
      setUserModifiedSelection(false);
      setLastHoldKey(null);
      toast({ title: 'Tables assigned', description: 'Manual assignment confirmed successfully.' });
      void queryClient.invalidateQueries({ queryKey: queryKeys.manualAssign.context(booking.id) });
      void queryClient.invalidateQueries({ queryKey: queryKeys.opsDashboard.summary(summary.restaurantId, summary.date ?? null) });
    },
    onError: (error) => {
      const code = (error as any)?.code ?? null;
      if (code === 'STALE_CONTEXT' || code === 'SELECTION_VERSION_MISMATCH') {
        setStaleContext(true);
        void refetchManualContext();
        return;
      }
      const rawDetails = (error as any)?.details ?? null;
      let details: any = rawDetails;
      if (typeof rawDetails === 'string') {
        try { details = JSON.parse(rawDetails); } catch { /* ignore */ }
      }
      const message = error instanceof Error ? error.message : 'Assignment failed';
      toast({ title: 'Assignment failed', description: message, variant: 'destructive' });
      setLastApiError({ scope: 'confirm', code, message, details });
    },
  });

  const handleToggleTable = useCallback((tableId: string) => {
    setSelectedTables((prev) => {
      if (prev.includes(tableId)) {
        return prev.filter((id) => id !== tableId);
      }
      return [...prev, tableId];
    });
    setUserModifiedSelection(true);
  }, []);

  useEffect(() => {
    if (!isOpen) {
      setSelectedTables([]);
      setValidationResult(null);
      setUserModifiedSelection(false);
      setLastHoldKey(null);
      setStaleContext(false);
      setActiveTab('overview');
    }
  }, [isOpen]);

  useEffect(() => {
    if (!isOpen) {
      return;
    }
    const interval = setInterval(() => setCurrentTimestamp(Date.now()), 1000);
    return () => clearInterval(interval);
  }, [isOpen]);

  useEffect(() => {
    if (!supportsTableAssignment && activeTab !== 'overview') {
      setActiveTab('overview');
    }
  }, [supportsTableAssignment, activeTab]);

  useEffect(() => {
    if (!manualContext) {
      return;
    }
    setManualSessionId(manualSession?.id ?? null);
    setManualSelectionVersionState(manualSession?.selectionVersion ?? null);
    const defaultSelection = manualContext.activeHold?.tableIds?.length
      ? manualContext.activeHold.tableIds
      : manualContext.bookingAssignments;
    if (!userModifiedSelection) {
      const normalized = Array.from(new Set(defaultSelection));
      const nextKey = normalized.slice().sort().join(',');
      const currentKey = selectedTables.slice().sort().join(',');
      if (nextKey !== currentKey) {
        setSelectedTables(normalized);
      }
    }
    if (manualContext.activeHold) {
      setLastHoldKey(manualContext.activeHold.tableIds.slice().sort().join(','));
      if (!validationResult) {
        const metadata = manualContext.activeHold.metadata;
        const selectionMeta = metadata && typeof metadata === 'object' ? (metadata as Record<string, unknown>).selection : null;
        if (selectionMeta && typeof selectionMeta === 'object') {
          const summary = (selectionMeta as { summary?: ManualValidationResult['summary'] }).summary;
          if (summary) {
            setValidationResult({ ok: true, summary, checks: [] });
            setLastValidatedAt(Date.now());
          }
        }
      }
    }
  }, [manualContext, selectedTables, userModifiedSelection, validationResult]);

  useEffect(() => {
    if (!isOpen || !manualContext) {
      return;
    }
    if (selectedTables.length === 0) {
      setValidationResult(null);
      return;
    }
    const selectionKey = [...selectedTables].sort().join(',');
    if (selectionKey === lastHoldKey || holdMutation.isPending) {
      return;
    }
    const timeout = setTimeout(() => {
      holdMutation.mutate({
        bookingId: booking.id,
        tableIds: selectedTables,
        holdTtlSeconds: MANUAL_HOLD_TTL_SECONDS,
        requireAdjacency,
        contextVersion: manualContext?.contextVersion ?? '',
        selectionVersion: manualSelectionVersion ?? undefined,
      });
    }, 800);
    return () => clearTimeout(timeout);
  }, [booking.id, holdMutation, isOpen, lastHoldKey, manualContext, requireAdjacency, selectedTables, manualSelectionVersion]);

  const {
    data: historyData,
    isLoading: historyLoading,
    isError: historyError,
    error: historyErrorObject,
    refetch: refetchHistory,
  } = useQuery({
    queryKey: queryKeys.bookings.history(booking.id),
    queryFn: async () => bookingService.getBookingHistory(booking.id),
    enabled: false,
    staleTime: 60_000,
  });

  const historyEntries = historyData?.entries ?? [];
  const historyErrorMessage = historyErrorObject instanceof Error ? historyErrorObject.message : 'Unable to load history';

  const handleOpenHistory = () => {
    setIsHistoryOpen(true);
    void refetchHistory();
  };

  const formatLifecycleTimestamp = (iso: string | null) => {
    if (!iso) return 'Not yet';
    const date = new Date(iso);
    if (Number.isNaN(date.getTime())) return 'Not yet';
    const formatter = new Intl.DateTimeFormat('en-GB', {
      timeZone: summary.timezone,
      day: 'numeric',
      month: 'short',
      hour: '2-digit',
      minute: '2-digit',
    });
    return formatter.format(date);
  };

  const formatHistoryDate = (iso: string | null | undefined) => {
    if (!iso) return null;
    const parsed = new Date(iso);
    if (Number.isNaN(parsed.getTime())) return null;
    return format(parsed, 'dd MMM yyyy, HH:mm');
  };

  const getMetadataString = (metadata: Record<string, unknown>, key: string): string | null => {
    const value = metadata?.[key as keyof typeof metadata];
    return typeof value === 'string' && value.length > 0 ? value : null;
  };

  useEffect(() => {
    setAssignments(booking.tableAssignments);
  }, [booking.tableAssignments]);

  const normalizedAssignments = useMemo(() => expandAssignmentGroups(assignments), [assignments]);

  const selectionSummary = useMemo(() => {
    if (validationResult) {
      return validationResult.summary;
    }
    if (!manualContext) {
      return null;
    }
    if (selectedTables.length === 0) {
      return null;
    }
    const tableMap = new Map(manualContext.tables.map((table) => [table.id, table]));
    let totalCapacity = 0;
    const tableNumbers: string[] = [];
    let zoneId: string | null = null;
    let zoneMismatch = false;
    for (const tableId of selectedTables) {
      const meta = tableMap.get(tableId);
      if (!meta) {
        continue;
      }
      totalCapacity += meta.capacity ?? 0;
      tableNumbers.push(meta.tableNumber ?? meta.id);
      if (zoneId === null) {
        zoneId = meta.zoneId ?? null;
      } else if (zoneId !== meta.zoneId) {
        zoneMismatch = true;
      }
    }
    if (tableNumbers.length === 0) {
      return null;
    }
    if (zoneMismatch) {
      zoneId = null;
    }
    const partySize = manualContext.booking.partySize ?? 0;
    return {
      tableCount: tableNumbers.length,
      totalCapacity,
      slack: totalCapacity - partySize,
      zoneId,
      tableNumbers,
      partySize,
    };
  }, [manualContext, selectedTables, validationResult]);

  const validationChecks = validationResult?.checks ?? [];
  const hasBlockingErrors = validationChecks.some((check) => check.status === 'error');
  const activeHold = manualContext?.activeHold ?? null;
  const otherHolds = useMemo(
    () => (manualContext ? manualContext.holds.filter((hold) => hold.bookingId && hold.bookingId !== booking.id) : []),
    [manualContext, booking.id],
  );
  const selectedTableNumbers = useMemo(() => {
    if (!manualContext) {
      return [] as string[];
    }
    const mapping = new Map(manualContext.tables.map((table) => [table.id, table.tableNumber ?? table.id]));
    return selectedTables.map((tableId) => mapping.get(tableId) ?? tableId);
  }, [manualContext, selectedTables]);

  const slackLabel = selectionSummary ? formatSlack(selectionSummary.slack) : null;
  const hasSelection = selectedTables.length > 0;
  const selectionPartySize = selectionSummary?.partySize ?? manualContext?.booking.partySize ?? booking.partySize;
  const holdCountdownLabel = activeHold ? formatCountdownFromIso(activeHold.expiresAt, currentTimestamp) : null;
  const selectionDisabled = manualContextLoading || manualContextFetching || holdMutation.isPending || confirmMutation.isPending;
  const manualContextErrorMessage = manualContextError instanceof Error ? manualContextError.message : 'Unable to load manual assignment context.';
  const confirmDisabled = selectionDisabled || !hasSelection || !activeHold || hasBlockingErrors;
  let confirmDisabledReason: string | null = null;
  if (!hasSelection) {
    confirmDisabledReason = 'Select at least one table before confirming the assignment.';
  } else if (!activeHold) {
    confirmDisabledReason = 'Validate the selection to create a hold before confirming.';
  } else if (hasBlockingErrors) {
    confirmDisabledReason = 'Resolve blocking validation errors before confirming.';
  } else if (selectionDisabled && (manualContextLoading || manualContextFetching)) {
    confirmDisabledReason = 'Loading the latest availability';
  }
  const validateDisabled = !hasSelection || selectionDisabled;
  const clearDisabled = !hasSelection || holdMutation.isPending || confirmMutation.isPending;

  const handleValidateSelection = useCallback(() => {
    if (selectedTables.length === 0) {
      toast({ title: 'Select tables', description: 'Choose one or more tables before validating.', variant: 'destructive' });
      return;
    }
    validateMutation.mutate({
      bookingId: booking.id,
      tableIds: selectedTables,
      requireAdjacency,
      excludeHoldId: manualContext?.activeHold?.id,
      contextVersion: manualContext?.contextVersion ?? '',
    });
  }, [booking.id, manualContext?.activeHold?.id, requireAdjacency, selectedTables, toast, validateMutation]);

  const handleConfirmSelection = useCallback(() => {
    if (!manualContext?.activeHold) {
      toast({ title: 'No active hold', description: 'Create a hold before confirming assignment.', variant: 'destructive' });
      return;
    }
    if (selectedTables.length === 0) {
      toast({ title: 'Select tables', description: 'Choose tables to assign before confirming.', variant: 'destructive' });
      return;
    }
    if (hasBlockingErrors) {
      toast({ title: 'Resolve validation errors', description: 'Fix blocking checks before assigning tables.', variant: 'destructive' });
      return;
    }
    confirmMutation.mutate(manualContext.activeHold.id);
  }, [confirmMutation, hasBlockingErrors, manualContext?.activeHold, selectedTables.length, toast]);

  const handleClearSelection = useCallback(async () => {
    if (manualContext?.activeHold) {
      try {
        await bookingService.manualReleaseHold({ holdId: manualContext.activeHold.id, bookingId: booking.id });
        await refetchManualContext();
      } catch (error) {
        const message = error instanceof Error ? error.message : 'Unable to release hold';
        toast({ title: 'Release failed', description: message, variant: 'destructive' });
      }
    }
    setSelectedTables([]);
    setValidationResult(null);
    setLastValidatedAt(null);
    setUserModifiedSelection(true);
    setLastHoldKey(null);
  }, [booking.id, bookingService, manualContext?.activeHold, refetchManualContext, toast]);


  useEffect(() => {
    if (!isOpen) {
      setLocalPendingAction(null);
    }
  }, [isOpen]);

  // Persist onlyAvailable toggle to localStorage for user convenience
  useEffect(() => {
    if (!isOpen) return;
    try {
      const stored = localStorage.getItem('manualAssign.onlyAvailable');
      if (stored === 'true') setOnlyAvailable(true);
      else if (stored === 'false') setOnlyAvailable(false);
    } catch {
      // ignore storage errors
    }
  }, [isOpen]);

  useEffect(() => {
    try {
      localStorage.setItem('manualAssign.onlyAvailable', String(onlyAvailable));
    } catch {
      // ignore storage errors
    }
  }, [onlyAvailable]);

  const handleUnassignTable = async (tableId: string) => {
    if (!onUnassignTable) {
      return;
    }
    try {
      const updated = await onUnassignTable(tableId);
      setAssignments(updated);
      await manualContextQuery.refetch();
    } catch {
      // Toast handled by mutation hook
    }
  };

  const handleCheckInAction = useCallback(async () => {
    if (!onCheckIn) return;
    setLocalPendingAction('check-in');
    try {
      await onCheckIn();
    } finally {
      setLocalPendingAction(null);
    }
  }, [onCheckIn]);

  const handleCheckOutAction = useCallback(async () => {
    if (!onCheckOut) return;
    setLocalPendingAction('check-out');
    try {
      await onCheckOut();
    } finally {
      setLocalPendingAction(null);
    }
  }, [onCheckOut]);

  const handleMarkNoShowAction = useCallback(
    async (options?: { performedAt?: string | null; reason?: string | null }) => {
      if (!onMarkNoShow) return;
      setLocalPendingAction('no-show');
      try {
        await onMarkNoShow(options);
      } finally {
        setLocalPendingAction(null);
      }
    },
    [onMarkNoShow],
  );

  const handleUndoNoShowAction = useCallback(
    async (reason?: string | null) => {
      if (!onUndoNoShow) return;
      setLocalPendingAction('undo-no-show');
      try {
        await onUndoNoShow(reason);
      } finally {
        setLocalPendingAction(null);
      }
    },
    [onUndoNoShow],
  );

  const handleKeyDown = useCallback(
    (event: KeyboardEvent) => {
      if (!isOpen) return;
      if (event.defaultPrevented) return;
      if (event.metaKey || event.ctrlKey || event.altKey) return;
      const target = event.target as HTMLElement | null;
      if (target) {
        const tagName = target.tagName;
        if (tagName === 'INPUT' || tagName === 'TEXTAREA' || tagName === 'SELECT' || target.isContentEditable) {
          return;
        }
      }

      if (event.key === 'Escape') {
        event.preventDefault();
        if (showShortcuts) {
          setShowShortcuts(false);
        } else {
          setIsOpen(false);
        }
        return;
      }

      if (event.key === '?' || (event.key === '/' && event.shiftKey)) {
        event.preventDefault();
        setShowShortcuts(true);
        return;
      }

      if (lifecyclePending) {
        return;
      }

      const key = event.key.toLowerCase();
      if (key === 'i' && effectiveStatus === 'confirmed') {
        event.preventDefault();
        void handleCheckInAction();
        return;
      }
      if (key === 'o' && effectiveStatus === 'checked_in') {
        event.preventDefault();
        void handleCheckOutAction();
        return;
      }
      if (key === 'n' && effectiveStatus === 'confirmed') {
        event.preventDefault();
        void handleMarkNoShowAction();
        return;
      }
      if (key === 'u' && effectiveStatus === 'no_show') {
        event.preventDefault();
        void handleUndoNoShowAction();
      }
    },
    [effectiveStatus, handleCheckInAction, handleCheckOutAction, handleMarkNoShowAction, handleUndoNoShowAction, isOpen, lifecyclePending, showShortcuts],
  );

  useEffect(() => {
    if (!isOpen) {
      return;
    }
    document.addEventListener('keydown', handleKeyDown);
    return () => {
      document.removeEventListener('keydown', handleKeyDown);
    };
  }, [handleKeyDown, isOpen]);

  return (
    <>
      <Dialog open={isOpen} onOpenChange={setIsOpen}>
        <DialogTrigger asChild>
          <Button variant="outline" size="sm" className="h-11 min-w-[100px] touch-manipulation">
            Details
          </Button>
        </DialogTrigger>
        <DialogContent className="max-w-2xl max-h-[85vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle className="flex items-center justify-between gap-3 text-xl font-semibold text-foreground">
              <span>{booking.customerName}</span>
              <div className="flex flex-wrap items-center gap-2">
                <StatusTransitionAnimator
                  status={bookingState.status}
                  effectiveStatus={bookingState.effectiveStatus}
                  isTransitioning={bookingState.isTransitioning}
                  className="inline-flex rounded-full"
                  overlayClassName="inline-flex"
                >
                  <BookingStatusBadge status={effectiveStatus} />
                </StatusTransitionAnimator>
                {showLifecycleBadges && booking.checkedInAt ? (
                  <Badge variant="outline" className="bg-emerald-50 text-emerald-700">
                    Checked in
                  </Badge>
                ) : null}
                {showLifecycleBadges && booking.checkedOutAt ? (
                  <Badge variant="outline" className="bg-slate-100 text-slate-700">
                    Checked out
                  </Badge>
                ) : null}
                {supportsTableAssignment ? (
                  <Button
                    variant="ghost"
                    size="sm"
                    className="h-8 rounded-full px-3 text-xs font-semibold"
                    onClick={() => setShowShortcuts(true)}
                  >
                    <Keyboard className="mr-1.5 h-3.5 w-3.5" aria-hidden />
                    Shortcuts
                  </Button>
                ) : null}
                <Button
                  variant="outline"
                  size="sm"
                  className="h-8 rounded-full px-3 text-xs font-semibold"
                  onClick={handleOpenHistory}
                >
                  <History className="mr-1.5 h-3.5 w-3.5" aria-hidden />
                  View history
                </Button>
              </div>
            </DialogTitle>
            <DialogDescription className="text-sm text-muted-foreground">
              {serviceDateReadable}  {serviceTime}
            </DialogDescription>
          </DialogHeader>

          <Tabs
            value={activeTab}
            onValueChange={(value) => setActiveTab(value as BookingDetailsTab)}
            className="space-y-5 py-4"
          >
            <TabsList
              className={cn('grid w-full gap-2', supportsTableAssignment ? 'grid-cols-2' : 'grid-cols-1')}
            >
              <TabsTrigger value="overview" className="text-sm font-medium">
                Overview
              </TabsTrigger>
              {supportsTableAssignment ? (
                <TabsTrigger value="tables" className="text-sm font-medium">
                  Tables
                </TabsTrigger>
              ) : null}
            </TabsList>

            <TabsContent value="overview" className="focus-visible:outline-none">
              <div className="space-y-6">
                <Card>
                  <CardHeader className="space-y-1">
                    <CardTitle className="text-base">Quick actions</CardTitle>
                    <CardDescription>Record arrivals or no-shows to keep the team in sync.</CardDescription>
                  </CardHeader>
                  <CardContent className="space-y-3">
                    <BookingActionButton
                      booking={booking}
                      pendingAction={lifecyclePending}
                      onCheckIn={handleCheckInAction}
                      onCheckOut={handleCheckOutAction}
                      onMarkNoShow={handleMarkNoShowAction}
                      onUndoNoShow={handleUndoNoShowAction}
                      showConfirmation
                      lifecycleAvailability={lifecycleAvailability}
                    />
                    {isCancelled ? (
                      <Alert variant="destructive" className="rounded-xl border border-destructive/40">
                        <AlertTitle>Booking cancelled</AlertTitle>
                        <AlertDescription>Status changes are disabled for cancelled reservations.</AlertDescription>
                      </Alert>
                    ) : null}
                    {!supportsTableAssignment ? (
                      <Alert className="rounded-xl border border-slate-200 bg-slate-50">
                        <AlertTitle>Past service date</AlertTitle>
                        <AlertDescription>Table assignment changes are locked after the service has passed.</AlertDescription>
                      </Alert>
                    ) : null}
                  </CardContent>
                </Card>

                <section className="grid gap-3 sm:grid-cols-2">
                  <InfoRow icon={Clock} label="Time" value={serviceTime} />
                  <InfoRow icon={Users} label="Guests" value={`${booking.partySize}`} />
                  <InfoRow icon={CalendarIcon} label="Service date" value={serviceDateReadable} />
                  <InfoRow icon={Mail} label="Email" value={booking.customerEmail ?? 'Not provided'} href={mailHref ?? undefined} />
                  <InfoRow icon={Phone} label="Phone" value={booking.customerPhone ?? 'Not provided'} href={phoneHref ?? undefined} />
                  <InfoRow icon={LogIn} label="Checked in" value={formatLifecycleTimestamp(booking.checkedInAt)} />
                  <InfoRow icon={LogOut} label="Checked out" value={formatLifecycleTimestamp(booking.checkedOutAt)} />
                </section>

                {booking.notes ? (
                  <section className="space-y-2">
                    <h3 className="text-sm font-semibold text-foreground">Booking notes</h3>
                    <p className="rounded-2xl border border-border/60 bg-muted/10 px-4 py-3 text-sm text-foreground">
                      {booking.notes}
                    </p>
                  </section>
                ) : null}

                {(booking.loyaltyTier ||
                  booking.allergies ||
                  booking.dietaryRestrictions ||
                  booking.seatingPreference ||
                  booking.profileNotes ||
                  booking.marketingOptIn !== null) ? (
                  <section className="space-y-3">
                    <h3 className="text-sm font-semibold text-foreground">Guest profile</h3>
                    <div className="space-y-3 rounded-2xl border border-border/60 bg-muted/10 px-4 py-4">
                      {booking.loyaltyTier ? (
                        <div className="flex items-center gap-3">
                          <Award className="h-4 w-4 text-muted-foreground" aria-hidden />
                          <div className="flex items-center gap-2">
                            <span className="text-sm text-muted-foreground">Loyalty:</span>
                            <Badge variant="outline" className={cn('text-xs font-semibold', TIER_COLORS[booking.loyaltyTier])}>
                              {booking.loyaltyTier}
                            </Badge>
                            {booking.loyaltyPoints !== null && booking.loyaltyPoints !== undefined ? (
                              <span className="text-xs text-muted-foreground">({booking.loyaltyPoints} points)</span>
                            ) : null}
                          </div>
                        </div>
                      ) : null}

                      {booking.allergies && booking.allergies.length > 0 ? (
                        <div className="flex items-start gap-3">
                          <AlertTriangle className="mt-0.5 h-4 w-4 text-orange-600" aria-hidden />
                          <div className="flex-1">
                            <span className="text-sm font-medium text-orange-600">Allergies:</span>
                            <div className="mt-1 flex flex-wrap gap-2">
                              {booking.allergies.map((allergy, idx) => (
                                <Badge key={idx} variant="outline" className="border-orange-600 text-orange-600">
                                  {allergy}
                                </Badge>
                              ))}
                            </div>
                          </div>
                        </div>
                      ) : null}

                      {booking.dietaryRestrictions && booking.dietaryRestrictions.length > 0 ? (
                        <div className="flex items-start gap-3">
                          <Users className="mt-0.5 h-4 w-4 text-muted-foreground" aria-hidden />
                          <div className="flex-1">
                            <span className="text-sm text-muted-foreground">Dietary restrictions:</span>
                            <div className="mt-1 flex flex-wrap gap-2">
                              {booking.dietaryRestrictions.map((restriction, idx) => (
                                <Badge key={idx} variant="secondary">
                                  {restriction}
                                </Badge>
                              ))}
                            </div>
                          </div>
                        </div>
                      ) : null}

                      {booking.seatingPreference ? (
                        <div className="flex items-center gap-3">
                          <CalendarIcon className="h-4 w-4 text-muted-foreground" aria-hidden />
                          <div>
                            <span className="text-sm text-muted-foreground">Seating preference:</span>
                            <span className="ml-2 text-sm text-foreground">{booking.seatingPreference}</span>
                          </div>
                        </div>
                      ) : null}

                      {booking.marketingOptIn !== null && booking.marketingOptIn !== undefined ? (
                        <div className="flex items-center gap-3">
                          {booking.marketingOptIn ? (
                            <CheckCircle2 className="h-4 w-4 text-green-600" aria-hidden />
                          ) : (
                            <XCircle className="h-4 w-4 text-muted-foreground" aria-hidden />
                          )}
                          <span className="text-sm text-muted-foreground">
                            Marketing: {booking.marketingOptIn ? 'Opted in' : 'Opted out'}
                          </span>
                        </div>
                      ) : null}

                      {booking.profileNotes ? (
                        <div className="space-y-1">
                          <span className="text-sm font-medium text-foreground">Profile notes:</span>
                          <p className="text-sm text-muted-foreground">{booking.profileNotes}</p>
                        </div>
                      ) : null}
                    </div>
                  </section>
                ) : null}
              </div>
            </TabsContent>

            {supportsTableAssignment ? (
              <TabsContent value="tables" className="focus-visible:outline-none">
                <div className="space-y-6">
                  <section className="space-y-6 rounded-2xl border border-border/60 bg-muted/10 px-4 py-5">
                    <div className="flex flex-col gap-3 sm:flex-row sm:items-start sm:justify-between">
                      <div>
                        <h3 className="text-sm font-semibold text-foreground">Manual assignment</h3>
                        <p className="text-xs text-muted-foreground">
                          Choose tables on the floor plan, review checks, then confirm to lock them in.
                        </p>
                      </div>
                      <div className="flex items-center gap-2">
                        <Label htmlFor="only-available-switch" className="text-xs text-muted-foreground">
                          Only show available
                        </Label>
                        <Switch
                          id="only-available-switch"
                          checked={onlyAvailable}
                          onCheckedChange={setOnlyAvailable}
                          aria-label="Toggle only showing available tables"
                        />
                      </div>
                    </div>

                    {manualContextIsError ? (
                      <Alert variant="destructive" className="rounded-xl border border-destructive/40 bg-destructive/10">
                        <AlertTitle>Unable to load manual assignment</AlertTitle>
                        <AlertDescription>{manualContextErrorMessage}</AlertDescription>
                      </Alert>
                    ) : (
                      <div className="grid gap-5 lg:grid-cols-[minmax(0,2fr),minmax(0,1fr)]">
                        <div className="relative space-y-3">
                          <TableFloorPlan
                            bookingId={booking.id}
                            tables={manualContext?.tables ?? []}
                            holds={manualContext?.holds ?? []}
                            conflicts={manualContext?.conflicts ?? []}
                            bookingAssignments={manualContext?.bookingAssignments ?? []}
                            selectedTableIds={selectedTables}
                            onToggle={handleToggleTable}
                            onlyAvailable={onlyAvailable}
                            disabled={selectionDisabled}
                          />
                          {manualContextLoading || manualContextFetching ? (
                            <div className="absolute inset-0 flex items-center justify-center rounded-2xl bg-background/70 backdrop-blur-sm">
                              <Loader2 className="h-5 w-5 animate-spin text-muted-foreground" aria-hidden />
                            </div>
                          ) : null}
                        </div>
                        <div className="space-y-4">
                          <ManualAssignmentSummaryCard
                            summary={selectionSummary}
                            slackLabel={slackLabel}
                            partySize={selectionPartySize}
                            tableNumbers={selectedTableNumbers}
                            requireAdjacency={requireAdjacency}
                            onAdjacencyChange={setRequireAdjacency}
                            isLoading={manualContextLoading && !manualContext}
                            activeHold={activeHold}
                            holdCountdownLabel={holdCountdownLabel}
                            otherHolds={otherHolds}
                          />
                          {staleContext ? (
                            <Alert variant="destructive" role="alert" aria-live="polite">
                              <AlertTriangle className="h-4 w-4" aria-hidden />
                              <AlertTitle>Refresh needed  context changed</AlertTitle>
                              <AlertDescription>
                                The booking context has changed (holds or assignments). Please refresh to continue.
                                <Button
                                  size="sm"
                                  variant="secondary"
                                  className="ml-2"
                                  onClick={async () => {
                                    try {
                                      await refetchManualContext();
                                      setStaleContext(false);
                                    } catch {
                                      // swallow errors; toast is handled elsewhere
                                    }
                                  }}
                                >
                                  Refresh
                                </Button>
                              </AlertDescription>
                            </Alert>
                          ) : null}
                          {lastApiError ? (
                            <Alert variant="destructive" className="rounded-xl border border-destructive/40 bg-destructive/10">
                              <AlertTriangle className="h-4 w-4" aria-hidden />
                              <AlertTitle>
                                {lastApiError.code ? `${lastApiError.code}` : 'Manual action failed'}
                              </AlertTitle>
                              <AlertDescription>
                                <div className="space-y-2">
                                  <p className="text-sm">{lastApiError.message}</p>
                                  {lastApiError.details ? (
                                    <pre className="whitespace-pre-wrap text-xs text-muted-foreground">
                                      {JSON.stringify(lastApiError.details, null, 2)}
                                    </pre>
                                  ) : null}
                                </div>
                              </AlertDescription>
                            </Alert>
                          ) : null}

                          <ManualAssignmentValidationPanel
                            checks={validationChecks}
                            lastValidatedAt={lastValidatedAt}
                            isPending={holdMutation.isPending || validateMutation.isPending}
                            hasSelection={hasSelection}
                          />
                          <ManualAssignmentActions
                            onValidate={handleValidateSelection}
                            onConfirm={handleConfirmSelection}
                            onClear={handleClearSelection}
                            disableValidate={validateDisabled}
                            disableConfirm={confirmDisabled}
                            disableClear={clearDisabled}
                            validating={holdMutation.isPending || validateMutation.isPending}
                            confirming={confirmMutation.isPending}
                            confirmDisabledReason={confirmDisabledReason}
                          />
                        </div>
                      </div>
                    )}

                    <div className="space-y-2">
                      <h4 className="text-sm font-semibold text-foreground">Assigned tables</h4>
                      {normalizedAssignments.length > 0 ? (
                        normalizedAssignments.map((assignment) => {
                          const isUnassigning =
                            tableActionState?.type === 'unassign' && tableActionState?.tableId === assignment.tableId;
                          const capacityLabel =
                            assignment.capacity && assignment.capacity > 0
                              ? `${assignment.capacity} seat${assignment.capacity === 1 ? '' : 's'}`
                              : null;
                          const meta = [capacityLabel, assignment.section ? `Section ${assignment.section}` : null]
                            .filter(Boolean)
                            .join('  ');

                          return (
                            <div
                              key={assignment.tableId}
                              className="flex items-center justify-between rounded-xl border border-border/60 bg-white px-3 py-2"
                            >
                              <div className="flex flex-col">
                                <span className="text-sm font-semibold text-foreground">Table {assignment.tableNumber}</span>
                                {meta ? <span className="text-xs text-muted-foreground">{meta}</span> : null}
                              </div>
                              <Button
                                variant="ghost"
                                size="sm"
                                className="h-8"
                                onClick={() => handleUnassignTable(assignment.tableId)}
                                disabled={isUnassigning || confirmMutation.isPending}
                              >
                                {isUnassigning ? (
                                  <>
                                    <Loader2 className="mr-2 h-4 w-4 animate-spin" aria-hidden />
                                    Removing
                                  </>
                                ) : (
                                  'Remove'
                                )}
                              </Button>
                            </div>
                          );
                        })
                      ) : (
                        <p className="text-sm text-muted-foreground">No tables assigned yet.</p>
                      )}
                    </div>
                  </section>
                </div>
              </TabsContent>
            ) : null}
          </Tabs>
        </DialogContent>
      </Dialog>
      <Dialog
        open={isHistoryOpen}
        onOpenChange={(open) => {
          setIsHistoryOpen(open);
          if (open) {
            void refetchHistory();
          }
        }}
      >
        <DialogContent className="max-w-lg max-h-[70vh] overflow-y-auto">
          <DialogHeader>
            <DialogTitle>Booking history</DialogTitle>
            <DialogDescription>Lifecycle changes recorded for this reservation.</DialogDescription>
          </DialogHeader>
          <div className="space-y-3 py-2">
            {historyLoading ? (
              <div className="flex items-center gap-2 text-sm text-muted-foreground">
                <Loader2 className="h-4 w-4 animate-spin" aria-hidden /> Loading history
              </div>
            ) : historyError ? (
              <p className="text-sm text-destructive">{historyErrorMessage}</p>
            ) : historyEntries.length === 0 ? (
              <p className="text-sm text-muted-foreground">No lifecycle changes have been recorded yet.</p>
            ) : (
              historyEntries.map((entry) => {
                const actorLabel = entry.actor?.name ?? entry.actor?.email ?? 'System';
                const actionValue = getMetadataString(entry.metadata, 'action');
                const actionLabel = actionValue ? actionValue.replace(/[-_]/g, ' ') : null;
                const performedAtLabel = formatHistoryDate(getMetadataString(entry.metadata, 'performedAt'));
                const changedAtLabel = formatHistoryDate(entry.changedAt) ?? entry.changedAt;

                return (
                  <div key={entry.id} className="rounded-xl border border-border/60 bg-muted/10 p-3">
                    <div className="flex flex-wrap items-center justify-between gap-2">
                      <div className="flex items-center gap-2">
                        {entry.fromStatus ? (
                          <BookingStatusBadge status={entry.fromStatus} size="sm" showTooltip />
                        ) : (
                          <Badge variant="outline" className="text-xs font-semibold uppercase tracking-wide">
                            New
                          </Badge>
                        )}
                        <ArrowRight className="h-3.5 w-3.5 text-muted-foreground" aria-hidden />
                        <BookingStatusBadge status={entry.toStatus} size="sm" showTooltip />
                      </div>
                      <span className="text-xs text-muted-foreground">{changedAtLabel}</span>
                    </div>
                    <p className="mt-2 text-sm font-semibold text-foreground">{actorLabel}</p>
                    {actionLabel ? (
                      <p className="text-xs uppercase tracking-wide text-muted-foreground">Action: {actionLabel}</p>
                    ) : null}
                    {entry.reason ? (
                      <p className="mt-1 text-sm text-muted-foreground">Reason: {entry.reason}</p>
                    ) : null}
                    {performedAtLabel ? (
                      <p className="mt-1 text-xs text-muted-foreground">Performed at: {performedAtLabel}</p>
                    ) : null}
                  </div>
                );
              })
            )}
          </div>
        </DialogContent>
      </Dialog>
      <Dialog open={showShortcuts} onOpenChange={setShowShortcuts}>
        <DialogContent className="max-w-md">
          <DialogHeader>
            <DialogTitle>Keyboard shortcuts</DialogTitle>
            <DialogDescription>Use these keys to manage the booking without leaving the keyboard.</DialogDescription>
          </DialogHeader>
          <div className="space-y-2">
            <ShortcutHint keys={['I']} description="Check in booking" />
            <ShortcutHint keys={['O']} description="Check out booking" />
            <ShortcutHint keys={['N']} description="Mark no-show" />
            <ShortcutHint keys={['U']} description="Undo no-show" />
            <ShortcutHint keys={['Esc']} description="Close this dialog" />
          </div>
        </DialogContent>
      </Dialog>
    </>
  );
}

type InfoRowProps = {
  icon: ComponentType<{ className?: string }>;
  label: string;
  value: string;
  href?: string;
};

function InfoRow({ icon: Icon, label, value, href }: InfoRowProps) {
  const content = (
    <div className="flex flex-col">
      <span className="text-xs font-medium uppercase tracking-wide text-muted-foreground">{label}</span>
      <span className="text-sm text-foreground">{value}</span>
    </div>
  );

  return (
    <div className="flex items-center gap-3 rounded-2xl border border-border/60 bg-muted/10 px-4 py-3">
      <Icon className="h-4 w-4 text-muted-foreground" aria-hidden />
      {href ? (
        <a href={href} className="text-sm text-primary underline-offset-4 hover:underline">
          {content}
        </a>
      ) : (
        content
      )}
    </div>
  );
}

type ShortcutHintProps = {
  keys: string[];
  description: string;
};

function ShortcutHint({ keys, description }: ShortcutHintProps) {
  return (
    <div className="flex items-center justify-between gap-3 rounded-xl border border-border/60 bg-muted/10 px-3 py-2">
      <div className="flex items-center gap-1">
        {keys.map((keyValue, index) => (
          <span key={keyValue} className="flex items-center gap-1">
            <kbd className="rounded-md border border-border bg-background px-2 py-1 text-xs font-semibold uppercase text-foreground">
              {keyValue}
            </kbd>
            {index < keys.length - 1 ? <span className="text-xs text-muted-foreground">+</span> : null}
          </span>
        ))}
      </div>
      <span className="text-sm text-muted-foreground">{description}</span>
    </div>
  );
}
\n// ===== src/components/features/dashboard/manual-assignment/index.ts =====
export * from './ManualAssignmentSummaryCard';
export * from './ManualAssignmentValidationPanel';
export * from './ManualAssignmentActions';
\n// ===== src/components/features/dashboard/manual-assignment/ManualAssignmentActions.tsx =====
'use client';

import { Loader2 } from 'lucide-react';

import { Button } from '@/components/ui/button';
import { Tooltip, TooltipContent, TooltipProvider, TooltipTrigger } from '@/components/ui/tooltip';

export type ManualAssignmentActionsProps = {
  onValidate: () => void;
  onConfirm: () => void;
  onClear: () => void;
  disableValidate: boolean;
  disableConfirm: boolean;
  disableClear: boolean;
  validating: boolean;
  confirming: boolean;
  confirmDisabledReason?: string | null;
};

export function ManualAssignmentActions({
  onValidate,
  onConfirm,
  onClear,
  disableValidate,
  disableConfirm,
  disableClear,
  validating,
  confirming,
  confirmDisabledReason,
}: ManualAssignmentActionsProps) {
  const confirmButton = (
    <Button
      size="sm"
      className="h-9 min-w-[6.5rem]"
      onClick={onConfirm}
      disabled={disableConfirm || confirming}
      aria-disabled={disableConfirm || confirming || undefined}
      aria-label={
        disableConfirm && confirmDisabledReason
          ? `Confirm assignment disabled: ${confirmDisabledReason}`
          : 'Confirm assignment'
      }
    >
      {confirming ? (
        <>
          <Loader2 className="mr-2 h-4 w-4 animate-spin" aria-hidden /> Assigning
        </>
      ) : (
        'Confirm assignment'
      )}
    </Button>
  );

  return (
    <div className="flex flex-wrap items-center gap-2">
      <Button
        variant="outline"
        size="sm"
        className="h-9"
        onClick={onValidate}
        disabled={disableValidate || validating}
      >
        {validating ? (
          <>
            <Loader2 className="mr-2 h-4 w-4 animate-spin" aria-hidden /> Validating
          </>
        ) : (
          'Validate selection'
        )}
      </Button>

      {confirmDisabledReason ? (
        <TooltipProvider>
          <Tooltip>
            {/* Wrap disabled button in a focusable span so tooltip works and is accessible */}
            <TooltipTrigger asChild>
              <span
                className="inline-flex"
                tabIndex={0}
                aria-disabled={disableConfirm || confirming || undefined}
                title={confirmDisabledReason}
                aria-label={`Confirm assignment disabled: ${confirmDisabledReason}`}
              >
                {confirmButton}
              </span>
            </TooltipTrigger>
            <TooltipContent side="top" align="center" className="max-w-xs text-xs">
              {confirmDisabledReason}
            </TooltipContent>
          </Tooltip>
        </TooltipProvider>
      ) : (
        confirmButton
      )}

      <Button
        variant="ghost"
        size="sm"
        className="h-9"
        onClick={onClear}
        disabled={disableClear || confirming}
      >
        Clear selection
      </Button>
    </div>
  );
}
\n// ===== src/components/features/dashboard/manual-assignment/ManualAssignmentSummaryCard.tsx =====
'use client';

import { useMemo, type ReactNode } from 'react';

import { Badge } from '@/components/ui/badge';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { Label } from '@/components/ui/label';
import { Skeleton } from '@/components/ui/skeleton';
import { Switch } from '@/components/ui/switch';

import type { ManualAssignmentContextHold, ManualValidationResult } from '@/services/ops/bookings';

const SECTION_LABEL = 'Selection summary';

function formatZoneLabel(summary: ManualValidationResult['summary'] | null): string {
  if (!summary) {
    return '';
  }
  if (!summary.zoneId) {
    return 'Mixed zones';
  }
  // Avoid showing UUID fragments; name is not available here. Keep simple label.
  return 'Single zone';
}

function formatSlackLabel(slackLabel: string | null, summary: ManualValidationResult['summary'] | null): string {
  if (slackLabel) {
    return slackLabel;
  }
  if (!summary) {
    return 'Awaiting selection';
  }
  return 'Calculated automatically';
}

function formatPartySize(partySize: number | null | undefined): string {
  if (typeof partySize === 'number' && !Number.isNaN(partySize)) {
    return `${partySize}`;
  }
  return '';
}

function renderTableNumbers(tableNumbers: string[]): ReactNode {
  if (tableNumbers.length === 0) {
    return null;
  }
  return (
    <div className="flex flex-wrap gap-1">
      {tableNumbers.map((tableNumber) => (
        <Badge key={tableNumber} variant="secondary" className="text-[11px]">
          #{tableNumber}
        </Badge>
      ))}
    </div>
  );
}

function HoldList({ holds, heading }: { holds: ManualAssignmentContextHold[]; heading: string }): ReactNode {
  if (holds.length === 0) {
    return null;
  }

  return (
    <div className="space-y-1">
      <p className="text-xs font-semibold uppercase text-muted-foreground">{heading}</p>
      <ul className="space-y-1 text-xs text-muted-foreground">
        {holds.map((hold) => {
          const createdBy = hold.createdByName ?? hold.createdByEmail ?? 'Unknown staff';
          return (
            <li key={hold.id} className="flex flex-wrap gap-1">
              <span className="font-medium">{hold.tableIds.length} table{hold.tableIds.length === 1 ? '' : 's'}</span>
              <span aria-hidden></span>
              <span>{createdBy}</span>
              <span aria-hidden></span>
              <span>Expires {new Date(hold.expiresAt).toLocaleTimeString([], { hour: '2-digit', minute: '2-digit' })}</span>
            </li>
          );
        })}
      </ul>
    </div>
  );
}

export type ManualAssignmentSummaryCardProps = {
  summary: ManualValidationResult['summary'] | null;
  slackLabel: string | null;
  partySize: number | null;
  tableNumbers: string[];
  requireAdjacency: boolean;
  onAdjacencyChange: (next: boolean) => void;
  isLoading?: boolean;
  activeHold: ManualAssignmentContextHold | null;
  holdCountdownLabel: string | null;
  otherHolds: ManualAssignmentContextHold[];
};

export function ManualAssignmentSummaryCard({
  summary,
  slackLabel,
  partySize,
  tableNumbers,
  requireAdjacency,
  onAdjacencyChange,
  isLoading = false,
  activeHold,
  holdCountdownLabel,
  otherHolds,
}: ManualAssignmentSummaryCardProps) {
  const derivedTableNumbers = summary?.tableNumbers ?? tableNumbers;
  const partySizeLabel = formatPartySize(summary?.partySize ?? partySize);
  const zoneLabel = useMemo(() => formatZoneLabel(summary), [summary]);
  const slackSummary = useMemo(() => formatSlackLabel(slackLabel, summary), [slackLabel, summary]);
  const activeHoldList = activeHold ? [activeHold] : [];

  return (
    <Card className="border-border/60 bg-white">
      <CardHeader className="space-y-3 pb-0">
        <div className="flex flex-col gap-3">
          <div>
            <CardTitle className="text-base font-semibold text-foreground">{SECTION_LABEL}</CardTitle>
            <CardDescription>Review capacity, adjacency, and holds before confirming.</CardDescription>
          </div>
          <div className="flex items-center justify-between rounded-lg border border-border/70 bg-muted/20 px-3 py-2">
            <div className="space-y-0.5">
              <p className="text-xs font-semibold uppercase text-muted-foreground">Adjacency</p>
              <p className="text-sm text-foreground">
                {requireAdjacency ? 'Contiguous tables required' : 'Mixed tables allowed'}
              </p>
            </div>
            <div className="flex items-center gap-2">
              <Label htmlFor="manual-assignment-adjacency" className="text-xs text-muted-foreground">
                Require adjacency
              </Label>
              <Switch
                id="manual-assignment-adjacency"
                checked={requireAdjacency}
                onCheckedChange={onAdjacencyChange}
                aria-label="Toggle adjacency requirement"
              />
            </div>
          </div>
        </div>
      </CardHeader>
      <CardContent className="space-y-4">
        {isLoading ? (
          <div className="space-y-3">
            <Skeleton className="h-16 w-full" />
            <Skeleton className="h-12 w-full" />
          </div>
        ) : (
          <>
            <dl className="grid grid-cols-2 gap-3 text-sm sm:grid-cols-3">
              <div className="space-y-0.5">
                <dt className="text-xs font-semibold uppercase text-muted-foreground">Party size</dt>
                <dd className="text-sm font-medium text-foreground">{partySizeLabel}</dd>
              </div>
              <div className="space-y-0.5">
                <dt className="text-xs font-semibold uppercase text-muted-foreground">Selected tables</dt>
                <dd className="text-sm font-medium text-foreground">{summary?.tableCount ?? 0}</dd>
              </div>
              <div className="space-y-0.5">
                <dt className="text-xs font-semibold uppercase text-muted-foreground">Total capacity</dt>
                <dd className="text-sm font-medium text-foreground">
                  {summary ? summary.totalCapacity : ''}
                  {summary ? (
                    <span className="ml-2 text-xs font-normal text-muted-foreground">{slackSummary}</span>
                  ) : null}
                </dd>
              </div>
              <div className="space-y-0.5">
                <dt className="text-xs font-semibold uppercase text-muted-foreground">Zone</dt>
                <dd className="text-sm font-medium text-foreground">{zoneLabel}</dd>
              </div>
              <div className="space-y-0.5">
                <dt className="text-xs font-semibold uppercase text-muted-foreground">Table numbers</dt>
                <dd>{renderTableNumbers(derivedTableNumbers)}</dd>
              </div>
            </dl>

            {activeHold ? (
              <HoldList holds={activeHoldList} heading={`Active hold ${holdCountdownLabel ? `(${holdCountdownLabel} left)` : ''}`} />
            ) : (
              <p className="text-xs text-muted-foreground">
                No hold yet. Selecting tables places a temporary 3minute hold automatically. Use Validate to run checks.
              </p>
            )}

            {otherHolds.length > 0 ? (
              <HoldList holds={otherHolds} heading="Other holds in this window" />
            ) : null}
          </>
        )}
      </CardContent>
    </Card>
  );
}
\n// ===== src/components/features/dashboard/manual-assignment/ManualAssignmentValidationPanel.tsx =====
'use client';

import { formatDistanceToNowStrict } from 'date-fns';
import { AlertTriangle, CheckCircle2, Loader2, XCircle } from 'lucide-react';

import { Badge } from '@/components/ui/badge';
import { Card, CardContent, CardDescription, CardHeader, CardTitle } from '@/components/ui/card';
import { cn } from '@/lib/utils';

import type { ManualSelectionCheck } from '@/services/ops/bookings';

type StatusKey = ManualSelectionCheck['status'];

const STATUS_CONFIG: Record<StatusKey, { label: string; icon: typeof CheckCircle2 }> = {
  ok: { label: 'Pass', icon: CheckCircle2 },
  warn: { label: 'Warning', icon: AlertTriangle },
  error: { label: 'Error', icon: XCircle },
};

function formatTimestamp(timestamp: number | null): string | null {
  if (!timestamp) {
    return null;
  }
  try {
    return `${formatDistanceToNowStrict(timestamp, { addSuffix: true })}`;
  } catch {
    return null;
  }
}

export type ManualAssignmentValidationPanelProps = {
  checks: ManualSelectionCheck[];
  lastValidatedAt: number | null;
  isPending: boolean;
  hasSelection: boolean;
};

export function ManualAssignmentValidationPanel({ checks, lastValidatedAt, isPending, hasSelection }: ManualAssignmentValidationPanelProps) {
  const timestampLabel = formatTimestamp(lastValidatedAt);
  const hasChecks = checks.length > 0;

  return (
    <Card className="border-border/60 bg-white">
      <CardHeader className="pb-0">
        <div className="flex items-start justify-between gap-3">
          <div>
            <CardTitle className="text-base font-semibold text-foreground">Validation checks</CardTitle>
            <CardDescription>We run policy and capacity checks every time you validate or hold tables.</CardDescription>
          </div>
          {timestampLabel ? (
            <Badge variant="outline" className="text-xs uppercase tracking-wide text-muted-foreground">
              {timestampLabel}
            </Badge>
          ) : null}
        </div>
      </CardHeader>
      <CardContent className="space-y-3">
        {isPending ? (
          <div className="flex items-center gap-2 rounded-lg border border-border/40 bg-muted/30 px-3 py-2 text-sm text-muted-foreground">
            <Loader2 className="h-4 w-4 animate-spin" aria-hidden /> Running checks
          </div>
        ) : null}

        {hasChecks ? (
          <ul className="space-y-2">
            {checks.map((check) => {
              const config = STATUS_CONFIG[check.status];
              const Icon = config.icon;
              const severityClasses =
                check.status === 'error'
                  ? 'border-destructive/40 bg-destructive/10 text-destructive'
                  : check.status === 'warn'
                    ? 'border-amber-300 bg-amber-50 text-amber-900'
                    : 'border-emerald-200 bg-emerald-50 text-emerald-900';

              return (
                <li
                  key={check.id}
                  className={cn(
                    'flex items-start gap-2 rounded-lg border px-3 py-2 text-xs',
                    severityClasses,
                  )}
                >
                  <Icon className="mt-0.5 h-4 w-4 shrink-0" aria-hidden />
                  <div className="space-y-1">
                    <div className="flex items-center gap-2">
                      <p className="text-sm font-semibold text-foreground">{check.message}</p>
                      <Badge variant="secondary" className="text-[10px] uppercase tracking-wide">
                        {config.label}
                      </Badge>
                    </div>
                    {check.details ? (
                      <pre className="whitespace-pre-wrap text-[11px] text-muted-foreground">
                        {JSON.stringify(check.details, null, 2)}
                      </pre>
                    ) : null}
                  </div>
                </li>
              );
            })}
          </ul>
        ) : (
          <p className="text-sm text-muted-foreground">
            {hasSelection
              ? 'No issues detected yet. Confirm if the summary looks good, or revalidate after changing tables.'
              : 'Select tables on the floor plan to see policy checks.'}
          </p>
        )}
      </CardContent>
    </Card>
  );
}
