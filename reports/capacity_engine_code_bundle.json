{
  "name": "capacity_engine_code_bundle",
  "generatedAt": "2025-11-04T13:37:16.819Z",
  "fileCount": 28,
  "totalBytes": 283341,
  "files": [
    {
      "path": "server/capacity/cache.ts",
      "size": 1686,
      "sha256": "3d8e97702cc5f97d7f56397468f126fe33828dc7ed3091f9e8d08cb6b995732c",
      "language": "typescript",
      "content": "type CacheEntry<T> = { value: T; expiresAt: number };\n\nconst DEFAULT_TTL_MS = 30_000; // 30s\n\ntype InventoryItem = Record<string, unknown>;\n\nconst inventoryCache = new Map<string, CacheEntry<InventoryItem[]>>();\nconst adjacencyCache = new Map<string, CacheEntry<Map<string, Set<string>>>>();\n\nfunction now(): number {\n  return Date.now();\n}\n\nfunction getWithTtl<T>(store: Map<string, CacheEntry<T>>, key: string): T | null {\n  const entry = store.get(key);\n  if (!entry) return null;\n  if (entry.expiresAt < now()) {\n    store.delete(key);\n    return null;\n  }\n  return entry.value;\n}\n\nfunction setWithTtl<T>(store: Map<string, CacheEntry<T>>, key: string, value: T, ttlMs?: number): void {\n  const expiresAt = now() + (typeof ttlMs === \"number\" && ttlMs > 0 ? ttlMs : DEFAULT_TTL_MS);\n  store.set(key, { value, expiresAt });\n}\n\nexport function getInventoryCache(restaurantId: string): InventoryItem[] | null {\n  return getWithTtl(inventoryCache, restaurantId);\n}\n\nexport function setInventoryCache(restaurantId: string, tables: InventoryItem[], ttlMs?: number): void {\n  setWithTtl(inventoryCache, restaurantId, tables, ttlMs);\n}\n\nexport function invalidateInventoryCache(restaurantId: string): void {\n  inventoryCache.delete(restaurantId);\n}\n\nexport function getAdjacencyCache(restaurantId: string): Map<string, Set<string>> | null {\n  return getWithTtl(adjacencyCache, restaurantId);\n}\n\nexport function setAdjacencyCache(\n  restaurantId: string,\n  graph: Map<string, Set<string>>,\n  ttlMs?: number,\n): void {\n  setWithTtl(adjacencyCache, restaurantId, graph, ttlMs);\n}\n\nexport function invalidateAdjacencyCache(restaurantId: string): void {\n  adjacencyCache.delete(restaurantId);\n}\n\n"
    },
    {
      "path": "server/capacity/demand-profiles.ts",
      "size": 14182,
      "sha256": "dae55e4b32d40a72b11dc0e6058caa5f5dfc82985e32464f3a6852740c998d55",
      "language": "typescript",
      "content": "import fs from \"node:fs\";\n\n\nimport { getServiceSupabaseClient } from \"@/server/supabase\";\n\nimport { getDemandProfileConfigPath } from \"./strategic-config\";\n\nimport type { ServiceKey } from \"./policy\";\nimport type { Database } from \"@/types/supabase\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\nimport type { DateTime } from \"luxon\";\n\nconst DAY_NAME_TO_NUMBER: Record<string, number> = {\n  SUNDAY: 0,\n  MONDAY: 1,\n  TUESDAY: 2,\n  WEDNESDAY: 3,\n  THURSDAY: 4,\n  FRIDAY: 5,\n  SATURDAY: 6,\n};\n\nconst CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes\nconst MINUTES_PER_DAY = 24 * 60;\n\nfunction parseTimeToMinutes(value?: string | null): number | null {\n  if (!value) {\n    return null;\n  }\n  const trimmed = value.trim();\n  if (trimmed.length === 0) {\n    return null;\n  }\n  const match = /^([0-2]?\\d):([0-5]\\d)$/.exec(trimmed);\n  if (!match) {\n    return null;\n  }\n  const hour = Number.parseInt(match[1], 10);\n  const minute = Number.parseInt(match[2], 10);\n  if (!Number.isInteger(hour) || !Number.isInteger(minute)) {\n    return null;\n  }\n  if (hour < 0 || hour > 23 || minute < 0 || minute > 59) {\n    return null;\n  }\n  return hour * 60 + minute;\n}\n\nfunction normalizeWindow(start?: string, end?: string): { startMinute: number; endMinute: number } {\n  const startMinute = parseTimeToMinutes(start) ?? 0;\n  let endMinute = parseTimeToMinutes(end) ?? MINUTES_PER_DAY;\n\n  if (endMinute <= startMinute) {\n    endMinute = startMinute === 0 ? MINUTES_PER_DAY : Math.min(startMinute + MINUTES_PER_DAY, MINUTES_PER_DAY);\n  }\n\n  return { startMinute, endMinute };\n}\n\nfunction isWithinWindow(rule: PreparedFallbackRule, minuteOfDay: number): boolean {\n  if (minuteOfDay < 0 || minuteOfDay >= MINUTES_PER_DAY) {\n    return false;\n  }\n  return minuteOfDay >= rule.startMinute && minuteOfDay < rule.endMinute;\n}\n\nfunction compareRules(a: PreparedFallbackRule, b: PreparedFallbackRule): number {\n  if (a.priority !== b.priority) {\n    return b.priority - a.priority;\n  }\n  const durationA = a.endMinute - a.startMinute;\n  const durationB = b.endMinute - b.startMinute;\n  if (durationA !== durationB) {\n    return durationA - durationB;\n  }\n  if (a.startMinute !== b.startMinute) {\n    return a.startMinute - b.startMinute;\n  }\n  return 0;\n}\n\nfunction minutesToTimeString(minutes: number): string {\n  const bounded = Math.max(0, Math.min(MINUTES_PER_DAY - 1, Math.floor(minutes)));\n  const hours = Math.floor(bounded / 60)\n    .toString()\n    .padStart(2, \"0\");\n  const mins = (bounded % 60)\n    .toString()\n    .padStart(2, \"0\");\n  return `${hours}:${mins}`;\n}\n\ntype DbClient = SupabaseClient<Database, \"public\">;\n\nexport type DemandProfileRule = {\n  label?: string;\n  serviceWindow: string;\n  days: string[];\n  start?: string;\n  end?: string;\n  multiplier: number;\n  priority?: number;\n};\n\nexport type DemandMultiplierResult = {\n  multiplier: number;\n  rule?: {\n    label?: string;\n    source: \"restaurant\" | \"default\" | \"fallback\";\n    serviceWindow?: string;\n    days?: string[];\n    start?: string;\n    end?: string;\n    priority?: number | null;\n  };\n};\n\ntype PreparedFallbackRule = {\n  label?: string;\n  serviceWindow: string;\n  multiplier: number;\n  start?: string;\n  end?: string;\n  startMinute: number;\n  endMinute: number;\n  dayNumbers: number[];\n  source: \"default\" | \"restaurant\";\n  priority: number;\n};\n\ntype PreparedFallbackProfiles = {\n  default: PreparedFallbackRule[];\n  restaurants: Map<string, PreparedFallbackRule[]>;\n};\n\ntype CacheEntry = {\n  result: DemandMultiplierResult;\n  expiresAt: number;\n};\n\nconst demandCache = new Map<string, CacheEntry>();\n\nconst EMBEDDED_DEFAULTS: DemandProfileRule[] = [\n  {\n    label: \"weekday-lunch\",\n    serviceWindow: \"lunch\",\n    days: [\"MONDAY\", \"TUESDAY\", \"WEDNESDAY\", \"THURSDAY\", \"FRIDAY\"],\n    start: \"11:30\",\n    end: \"14:30\",\n    multiplier: 0.85,\n  },\n  {\n    label: \"weekday-dinner\",\n    serviceWindow: \"dinner\",\n    days: [\"MONDAY\", \"TUESDAY\", \"WEDNESDAY\", \"THURSDAY\"],\n    start: \"17:30\",\n    end: \"21:30\",\n    multiplier: 1.15,\n  },\n  {\n    label: \"weekend-dinner-peak\",\n    serviceWindow: \"dinner\",\n    days: [\"FRIDAY\", \"SATURDAY\"],\n    start: \"18:00\",\n    end: \"22:30\",\n    multiplier: 1.35,\n  },\n  {\n    label: \"weekend-brunch\",\n    serviceWindow: \"lunch\",\n    days: [\"SATURDAY\", \"SUNDAY\"],\n    start: \"10:00\",\n    end: \"13:00\",\n    multiplier: 1.1,\n  },\n];\n\ntype FallbackConfig = {\n  default: DemandProfileRule[];\n  restaurants?: Record<string, DemandProfileRule[]>;\n};\n\nlet preparedFallbackProfiles: PreparedFallbackProfiles | null = null;\n\nfunction toDayNumber(day: string): number | null {\n  const normalized = day.trim().toUpperCase();\n  return DAY_NAME_TO_NUMBER[normalized] ?? null;\n}\n\nfunction readFallbackConfig(): FallbackConfig {\n  try {\n    const profilePath = getDemandProfileConfigPath();\n    const raw = fs.readFileSync(profilePath, \"utf8\");\n    return JSON.parse(raw) as FallbackConfig;\n  } catch (error) {\n    console.warn(\"[demand-profiles] failed to load fallback config, using embedded defaults\", {\n      error: error instanceof Error ? error.message : String(error),\n      path: getDemandProfileConfigPath(),\n    });\n    return { default: EMBEDDED_DEFAULTS };\n  }\n}\n\nfunction prepareFallbackProfiles(): PreparedFallbackProfiles {\n  if (preparedFallbackProfiles) {\n    return preparedFallbackProfiles;\n  }\n\n  const config = readFallbackConfig();\n  const defaultRules: PreparedFallbackRule[] = [];\n  const restaurantRules = new Map<string, PreparedFallbackRule[]>();\n\n  const processRuleSet = (rules: DemandProfileRule[] | undefined, source: \"default\" | \"restaurant\"): PreparedFallbackRule[] => {\n    if (!Array.isArray(rules)) {\n      return [];\n    }\n\n    const prepared: PreparedFallbackRule[] = [];\n    for (const rule of rules) {\n      if (!rule) {\n        continue;\n      }\n      const dayNumbers = (rule.days ?? [])\n        .map((day) => toDayNumber(day))\n        .filter((value): value is number => value !== null);\n\n      if (dayNumbers.length === 0) {\n        continue;\n      }\n\n      const serviceWindow = (rule.serviceWindow ?? rule.label ?? \"dinner\").toString().toLowerCase();\n      const { startMinute, endMinute } = normalizeWindow(rule.start, rule.end);\n      const priority = typeof rule.priority === \"number\" ? rule.priority : 0;\n\n      prepared.push({\n        label: rule.label,\n        serviceWindow,\n        multiplier: rule.multiplier,\n        start: rule.start,\n        end: rule.end,\n        startMinute,\n        endMinute,\n        dayNumbers,\n        source,\n        priority,\n      });\n    }\n\n    return prepared;\n  };\n\n  defaultRules.push(...processRuleSet(config.default ?? EMBEDDED_DEFAULTS, \"default\"));\n\n  if (config.restaurants) {\n    for (const [restaurantId, rules] of Object.entries(config.restaurants)) {\n      if (!Array.isArray(rules) || rules.length === 0) {\n        continue;\n      }\n      restaurantRules.set(restaurantId, processRuleSet(rules, \"restaurant\"));\n    }\n  }\n\n  preparedFallbackProfiles = {\n    default: defaultRules,\n    restaurants: restaurantRules,\n  };\n\n  return preparedFallbackProfiles;\n}\n\nfunction getFallbackRule(\n  restaurantId: string | null | undefined,\n  dayOfWeek: number,\n  serviceWindow: string,\n  minuteOfDay: number,\n): PreparedFallbackRule | null {\n  const profiles = prepareFallbackProfiles();\n  const candidates: PreparedFallbackRule[] = [];\n\n  if (restaurantId) {\n    const restaurantSpecific = profiles.restaurants.get(restaurantId);\n    if (restaurantSpecific) {\n      candidates.push(...restaurantSpecific);\n    }\n  }\n\n  candidates.push(...profiles.default);\n  const normalizedWindow = serviceWindow.toLowerCase();\n\n  const matching = candidates\n    .filter(\n      (rule) =>\n        rule.serviceWindow === normalizedWindow &&\n        rule.dayNumbers.includes(dayOfWeek) &&\n        isWithinWindow(rule, minuteOfDay),\n    )\n    .sort(compareRules);\n\n  return matching[0] ?? null;\n}\n\nfunction buildCacheKey(\n  restaurantId: string | null | undefined,\n  dayOfWeek: number,\n  serviceWindow: string,\n  minuteOfDay: number,\n): string {\n  const boundedMinute = Math.max(0, Math.min(MINUTES_PER_DAY - 1, minuteOfDay));\n  return `${restaurantId ?? \"default\"}|${dayOfWeek}|${serviceWindow.toLowerCase()}|${boundedMinute}`;\n}\n\nasync function fetchRestaurantMultiplier(params: {\n  restaurantId: string;\n  dayOfWeek: number;\n  serviceWindow: string;\n  client: DbClient;\n}): Promise<{ multiplier: number; rule: DemandMultiplierResult[\"rule\"] } | null> {\n  const { restaurantId, dayOfWeek, serviceWindow, client } = params;\n\n  const query = client\n    .from(\"demand_profiles\")\n    .select(\"multiplier, service_window, start_minute, end_minute, priority, label\")\n    .eq(\"restaurant_id\", restaurantId)\n    .eq(\"day_of_week\", dayOfWeek)\n    .eq(\"service_window\", serviceWindow)\n    .limit(1);\n\n  const { data, error } = await query.maybeSingle();\n\n  if (error) {\n    if ((error as { code?: string } | null)?.code === \"42703\") {\n      return fetchRestaurantMultiplierLegacy(params);\n    }\n    throw error;\n  }\n\n  if (!data) {\n    return null;\n  }\n\n  const row = data as unknown as {\n    multiplier: number | null;\n    service_window: string | null;\n    start_minute?: number | null;\n    end_minute?: number | null;\n    priority?: number | null;\n    label?: string | null;\n  };\n\n  const multiplier = Number(row.multiplier ?? 1);\n  const startMinuteRaw = typeof row.start_minute === \"number\" ? row.start_minute : null;\n  const endMinuteRaw = typeof row.end_minute === \"number\" ? row.end_minute : null;\n  const normalizedWindow = normalizeWindow(\n    typeof startMinuteRaw === \"number\" ? minutesToTimeString(startMinuteRaw) : undefined,\n    typeof endMinuteRaw === \"number\" ? minutesToTimeString(endMinuteRaw) : undefined,\n  );\n\n  const startLabel = startMinuteRaw !== null ? minutesToTimeString(normalizedWindow.startMinute) : null;\n  const endLabel = endMinuteRaw !== null ? minutesToTimeString(normalizedWindow.endMinute - 1) : null;\n  const priority = typeof row.priority === \"number\" ? row.priority : null;\n\n  return {\n    multiplier,\n    rule: {\n      label: row.label ?? row.service_window ?? serviceWindow,\n      serviceWindow,\n      source: \"restaurant\",\n      start: startLabel ?? undefined,\n      end: endLabel ?? undefined,\n      priority,\n    },\n  };\n}\n\nasync function fetchRestaurantMultiplierLegacy(params: {\n  restaurantId: string;\n  dayOfWeek: number;\n  serviceWindow: string;\n  client: DbClient;\n}): Promise<{ multiplier: number; rule: DemandMultiplierResult[\"rule\"] } | null> {\n  const { restaurantId, dayOfWeek, serviceWindow, client } = params;\n  const { data, error } = await client\n    .from(\"demand_profiles\")\n    .select(\"multiplier, service_window\")\n    .eq(\"restaurant_id\", restaurantId)\n    .eq(\"day_of_week\", dayOfWeek)\n    .eq(\"service_window\", serviceWindow)\n    .maybeSingle();\n\n  if (error || !data) {\n    return null;\n  }\n\n  const multiplier = Number(data.multiplier ?? 1);\n\n  return {\n    multiplier,\n    rule: {\n      label: data.service_window ?? serviceWindow,\n      serviceWindow,\n      source: \"restaurant\",\n    },\n  };\n}\n\nfunction toDemandRuleFromFallback(\n  fallback: PreparedFallbackRule,\n  localized: DateTime,\n): DemandMultiplierResult[\"rule\"] {\n  const dayName = localized.setLocale(\"en\").weekdayLong ?? \"Unknown\";\n\n  return {\n    label: fallback.label,\n    serviceWindow: fallback.serviceWindow,\n    source: fallback.source,\n    days: [dayName],\n    start: fallback.start,\n    end: fallback.end,\n    priority: fallback.priority,\n  };\n}\n\nexport async function resolveDemandMultiplier(params: {\n  restaurantId?: string | null;\n  serviceStart: DateTime;\n  serviceKey?: ServiceKey | string | null;\n  timezone?: string | null;\n  client?: DbClient;\n}): Promise<DemandMultiplierResult> {\n  const client = params.client ?? getServiceSupabaseClient();\n  const targetTimezone = params.timezone ?? params.serviceStart.zoneName ?? \"UTC\";\n  const localized = params.serviceStart.setZone(targetTimezone);\n\n  if (!localized.isValid) {\n    return { multiplier: 1, rule: { source: \"fallback\" } };\n  }\n\n  const dayOfWeek = localized.weekday % 7; // Luxon weekday: 1 (Mon) .. 7 (Sun)\n  const serviceWindow = (params.serviceKey ?? \"dinner\").toString().toLowerCase();\n  const weekdayLabel = localized.setLocale(\"en\").weekdayLong ?? localized.weekdayLong ?? \"Unknown\";\n  const minuteOfDay = localized.hour * 60 + localized.minute;\n  const cacheKey = buildCacheKey(params.restaurantId, dayOfWeek, serviceWindow, minuteOfDay);\n  const now = Date.now();\n  const cached = demandCache.get(cacheKey);\n\n  if (cached && cached.expiresAt > now) {\n    return cached.result;\n  }\n\n  let multiplier = 1;\n  let rule: DemandMultiplierResult[\"rule\"] | undefined;\n\n  if (params.restaurantId) {\n    const restaurantResult = await fetchRestaurantMultiplier({\n      restaurantId: params.restaurantId,\n      dayOfWeek,\n      serviceWindow,\n      client,\n    });\n\n    if (restaurantResult) {\n      multiplier = restaurantResult.multiplier;\n      const normalizedRule = restaurantResult.rule ?? { source: \"restaurant\" as const };\n      rule = {\n        ...normalizedRule,\n        source: normalizedRule.source ?? (\"restaurant\" as const),\n        days: [weekdayLabel],\n        priority: normalizedRule.priority ?? null,\n      };\n\n      demandCache.set(cacheKey, {\n        result: { multiplier, rule },\n        expiresAt: now + CACHE_TTL_MS,\n      });\n\n      return { multiplier, rule };\n    }\n  }\n\n  const fallbackRule = getFallbackRule(params.restaurantId ?? undefined, dayOfWeek, serviceWindow, minuteOfDay);\n  if (fallbackRule) {\n    multiplier = fallbackRule.multiplier;\n    rule = toDemandRuleFromFallback(fallbackRule, localized);\n  } else {\n    rule = {\n      source: \"fallback\",\n      serviceWindow,\n      days: [weekdayLabel],\n      priority: null,\n    };\n  }\n\n  const result: DemandMultiplierResult = { multiplier, rule };\n\n  demandCache.set(cacheKey, {\n    result,\n    expiresAt: now + CACHE_TTL_MS,\n  });\n\n  return result;\n}\n\nexport function clearDemandMultiplierCache(): void {\n  demandCache.clear();\n}\n\nexport function clearDemandProfileFallbackCache(): void {\n  preparedFallbackProfiles = null;\n}\n\nexport function clearAllDemandProfileCaches(): void {\n  clearDemandMultiplierCache();\n  clearDemandProfileFallbackCache();\n}\n"
    },
    {
      "path": "server/capacity/holds.ts",
      "size": 21233,
      "sha256": "4e79b1a1cb468cdfab04cf678d3179cc008c3cb556434813ea2d3ebf0a4d63b1",
      "language": "typescript",
      "content": "import { DateTime } from \"luxon\";\n\nimport { isHoldStrictConflictsEnabled, getHoldMinTtlSeconds, getHoldRateWindowSeconds, getHoldRateMaxPerBooking } from \"@/server/feature-flags\";\nimport { getServiceSupabaseClient } from \"@/server/supabase\";\n\nimport type { Database, Json, Tables, TablesInsert } from \"@/types/supabase\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\n\ntype DbClient = SupabaseClient<Database, \"public\">;\n\nexport type TableHold = {\n  id: string;\n  bookingId: string | null;\n  restaurantId: string;\n  zoneId: string;\n  startAt: string;\n  endAt: string;\n  expiresAt: string;\n  tableIds: string[];\n  createdBy: string | null;\n  metadata: Json | null;\n};\n\nexport type HoldConflictInfo = {\n  holdId: string;\n  bookingId: string | null;\n  tableIds: string[];\n  startAt: string;\n  endAt: string;\n  expiresAt: string;\n};\n\nexport type CreateTableHoldInput = {\n  bookingId: string | null;\n  restaurantId: string;\n  zoneId: string;\n  tableIds: string[];\n  startAt: string;\n  endAt: string;\n  expiresAt: string;\n  createdBy?: string | null;\n  metadata?: Json | null;\n  client?: DbClient;\n};\n\ntype TableHoldWindowRow = {\n  hold_id: string;\n  booking_id: string | null;\n  restaurant_id: string;\n  table_id: string;\n  start_at: string;\n  end_at: string;\n  expires_at: string;\n};\n\nexport type ReleaseTableHoldInput = {\n  holdId: string;\n  client?: DbClient;\n};\n\n// Legacy confirmTableHold path has been removed in favor of the\n// allocator v2 flow implemented in server/capacity/tables.ts\n// (confirmHoldAssignment). Keeping error classes below for reuse.\n\nexport type FindHoldConflictsInput = {\n  restaurantId: string;\n  tableIds: string[];\n  startAt: string;\n  endAt: string;\n  excludeHoldId?: string | null;\n  client?: DbClient;\n};\n\nexport type ListActiveHoldsInput = {\n  bookingId: string;\n  client?: DbClient;\n};\n\nexport type SweepExpiredHoldsInput = {\n  now?: string;\n  limit?: number;\n  client?: DbClient;\n};\n\nexport type SweepExpiredHoldsResult = {\n  total: number;\n  holdIds: string[];\n};\n\nexport type ExtendTableHoldInput = {\n  holdId: string;\n  extendSeconds?: number;\n  newExpiresAt?: string;\n  actorId?: string | null;\n  client?: DbClient;\n};\n\nexport class HoldConflictError extends Error {\n  constructor(message: string, public readonly holdId?: string) {\n    super(message);\n    this.name = \"HoldConflictError\";\n  }\n}\n\nexport class HoldNotFoundError extends Error {\n  constructor(message = \"Table hold not found\") {\n    super(message);\n    this.name = \"HoldNotFoundError\";\n  }\n}\n\nexport class AssignTablesRpcError extends Error {\n  public readonly code?: string | null;\n  public readonly details?: string | null;\n  public readonly hint?: string | null;\n\n  constructor(error: { message: string; code?: string | null; details?: string | null; hint?: string | null }) {\n    super(error.message);\n    this.name = \"AssignTablesRpcError\";\n    this.code = error.code ?? null;\n    this.details = error.details ?? null;\n    this.hint = error.hint ?? null;\n  }\n}\n\nfunction ensureClient(client?: DbClient): DbClient {\n  return client ?? getServiceSupabaseClient();\n}\n\nasync function configureHoldStrictConflictSession(client: DbClient): Promise<void> {\n  const enabled = isHoldStrictConflictsEnabled();\n  if (typeof client.rpc !== \"function\") {\n    return;\n  }\n  try {\n    const { error } = await client.rpc(\"set_hold_conflict_enforcement\", { enabled });\n    if (error) {\n      console.warn(\"[capacity.hold] failed to configure strict conflict enforcement\", {\n        enabled,\n        error: error.message ?? error,\n      });\n    }\n    // Best-effort verification\n    try {\n      const { data, error: verifyError } = await client.rpc(\"is_holds_strict_conflicts_enabled\");\n      if (verifyError) {\n        console.warn(\"[capacity.hold] strict conflict verification failed\", {\n          error: verifyError.message ?? verifyError,\n        });\n      } else if (enabled && !data) {\n        console.error(\"[capacity.hold] strict conflict enforcement not honored by server (GUC off)\");\n      }\n    } catch (e) {\n      console.warn(\"[capacity.hold] strict conflict verification errored\", {\n        error: e instanceof Error ? e.message : String(e),\n      });\n    }\n  } catch (error) {\n    console.warn(\"[capacity.hold] failed to configure strict conflict enforcement\", {\n      enabled,\n      error: error instanceof Error ? error.message : String(error),\n    });\n  }\n}\n\nfunction normalizeHold(row: Tables<\"table_holds\">, tableIds: string[]): TableHold {\n  return {\n    id: row.id,\n    bookingId: row.booking_id,\n    restaurantId: row.restaurant_id,\n    zoneId: row.zone_id,\n    startAt: row.start_at,\n    endAt: row.end_at,\n    expiresAt: row.expires_at,\n    tableIds,\n    createdBy: row.created_by,\n    metadata: row.metadata ?? null,\n  };\n}\n\ntype HoldRowWithMembers = Tables<\"table_holds\"> & {\n  table_hold_members?: unknown;\n};\n\nfunction extractTableIdsFromMembers(members: unknown): string[] {\n  if (!Array.isArray(members)) {\n    return [];\n  }\n\n  return members\n    .map((member) => {\n      if (!member || typeof member !== \"object\") {\n        return null;\n      }\n\n      const tableId = (member as { table_id?: unknown }).table_id;\n      return typeof tableId === \"string\" ? tableId : null;\n    })\n    .filter((tableId): tableId is string => tableId !== null);\n}\n\nfunction intervalsOverlap(aStart: string, aEnd: string, bStart: string, bEnd: string): boolean {\n  const startA = DateTime.fromISO(aStart);\n  const endA = DateTime.fromISO(aEnd);\n  const startB = DateTime.fromISO(bStart);\n  const endB = DateTime.fromISO(bEnd);\n  if (!startA.isValid || !endA.isValid || !startB.isValid || !endB.isValid) {\n    return false;\n  }\n  return startA < endB && startB < endA;\n}\n\nexport async function createTableHold(input: CreateTableHoldInput): Promise<TableHold> {\n  const {\n    bookingId,\n    restaurantId,\n    zoneId,\n    tableIds,\n    startAt,\n    endAt,\n    expiresAt,\n    createdBy = null,\n    metadata = null,\n    client,\n  } = input;\n\n  if (!Array.isArray(tableIds) || tableIds.length === 0) {\n    throw new HoldConflictError(\"Cannot create a hold without tables\");\n  }\n\n  const supabase = ensureClient(client);\n  await configureHoldStrictConflictSession(supabase);\n\n  // Enforce minimum TTL policy (clamp up)\n  try {\n    const minTtl = getHoldMinTtlSeconds();\n    const nowIso = DateTime.now().toUTC();\n    const requested = DateTime.fromISO(expiresAt).toUTC();\n    if (requested.isValid) {\n      const ttlSec = Math.max(0, Math.floor(requested.diff(nowIso, \"seconds\").seconds));\n      if (ttlSec < minTtl) {\n        const clamped = nowIso.plus({ seconds: minTtl }).toISO();\n        // eslint-disable-next-line @typescript-eslint/no-explicit-any\n        (input as any).expiresAt = clamped;\n      }\n    }\n  } catch {\n    // ignore TTL enforcement errors to avoid blocking\n  }\n\n  // Rate limit per user per booking within window\n  if (createdBy && bookingId) {\n    try {\n      const windowSec = getHoldRateWindowSeconds();\n      const maxPer = getHoldRateMaxPerBooking();\n      const cutoff = DateTime.now().minus({ seconds: windowSec }).toISO();\n      const { count, error: countError } = await supabase\n        .from(\"table_holds\")\n        .select(\"id\", { count: \"exact\", head: true })\n        .eq(\"booking_id\", bookingId)\n        .eq(\"created_by\", createdBy)\n        .gt(\"created_at\", cutoff as string);\n      if (!countError && typeof count === \"number\" && count >= maxPer) {\n        throw new AssignTablesRpcError({\n          message: \"Too many holds recently for this booking. Please wait before trying again.\",\n          code: \"RPC_VALIDATION\",\n          details: JSON.stringify({ reason: \"HOLD_RATE_LIMIT\", windowSeconds: windowSec, maxPerBooking: maxPer }),\n          hint: \"Reduce attempts or wait a moment, then retry.\",\n        });\n      }\n    } catch (e) {\n      if (e instanceof AssignTablesRpcError) {\n        throw e;\n      }\n      // If rate-limit check fails unexpectedly, proceed to avoid false positives.\n    }\n  }\n\n  if (isHoldStrictConflictsEnabled()) {\n    try {\n      const conflicts = await findHoldConflicts({\n        restaurantId,\n        tableIds,\n        startAt,\n        endAt,\n        client: supabase,\n      });\n      const blockingConflicts = conflicts.filter((conflict) => conflict.bookingId !== bookingId);\n      if (blockingConflicts.length > 0) {\n        const { emitHoldStrictConflict } = await import(\"./telemetry\");\n        await emitHoldStrictConflict({\n          restaurantId,\n          bookingId,\n          tableIds,\n          startAt,\n          endAt,\n          conflicts: blockingConflicts.map((conflict) => ({\n            holdId: conflict.holdId,\n            bookingId: conflict.bookingId,\n            tableIds: conflict.tableIds,\n            startAt: conflict.startAt,\n            endAt: conflict.endAt,\n            expiresAt: conflict.expiresAt,\n          })),\n        });\n        throw new HoldConflictError(\"Existing holds conflict with requested tables\", blockingConflicts[0]?.holdId);\n      }\n    } catch (error) {\n      if (error instanceof HoldConflictError) {\n        throw error;\n      }\n      console.warn(\"[capacity.hold] strict conflict evaluation failed; proceeding with relaxed checks\", {\n        restaurantId,\n        error,\n      });\n    }\n  }\n\n  const insertPayload: TablesInsert<\"table_holds\"> = {\n    booking_id: bookingId,\n    restaurant_id: restaurantId,\n    zone_id: zoneId,\n    start_at: startAt,\n    end_at: endAt,\n    expires_at: expiresAt,\n    created_by: createdBy,\n    metadata,\n  };\n\n  const { data: holdRow, error: insertError } = await supabase\n    .from(\"table_holds\")\n    .insert(insertPayload)\n    .select(\"id, booking_id, restaurant_id, zone_id, start_at, end_at, expires_at, created_by, metadata\")\n    .maybeSingle();\n\n  if (insertError || !holdRow) {\n    throw new HoldConflictError(insertError?.message ?? \"Failed to create table hold\");\n  }\n\n  const memberRows = tableIds.map((tableId) => ({\n    hold_id: holdRow.id,\n    table_id: tableId,\n  }));\n\n  const { error: memberError } = await supabase.from(\"table_hold_members\").insert(memberRows);\n\n  if (memberError) {\n    await supabase.from(\"table_holds\").delete().eq(\"id\", holdRow.id);\n    throw new HoldConflictError(memberError.message ?? \"Failed to record table hold members\", holdRow.id);\n  }\n\n  const hold = normalizeHold(holdRow as Tables<\"table_holds\">, tableIds);\n\n  const { emitHoldCreated } = await import(\"./telemetry\");\n  await emitHoldCreated({\n    holdId: hold.id,\n    bookingId: hold.bookingId,\n    restaurantId: hold.restaurantId,\n    zoneId: hold.zoneId,\n    tableIds: hold.tableIds,\n    startAt: hold.startAt,\n    endAt: hold.endAt,\n    expiresAt: hold.expiresAt,\n    actorId: createdBy,\n    metadata,\n  });\n\n  return hold;\n}\n\nexport async function releaseTableHold(input: ReleaseTableHoldInput): Promise<void> {\n  const { holdId, client } = input;\n  const supabase = ensureClient(client);\n  await configureHoldStrictConflictSession(supabase);\n  await supabase.from(\"table_hold_members\").delete().eq(\"hold_id\", holdId);\n  await supabase.from(\"table_holds\").delete().eq(\"id\", holdId);\n}\n\nexport async function extendTableHold(input: ExtendTableHoldInput): Promise<TableHold> {\n  const { holdId, extendSeconds, newExpiresAt, actorId = null, client } = input;\n  const supabase = ensureClient(client);\n  await configureHoldStrictConflictSession(supabase);\n\n  const { data: holdRow, error: fetchError } = await supabase\n    .from(\"table_holds\")\n    .select(\"*, table_hold_members(table_id)\")\n    .eq(\"id\", holdId)\n    .maybeSingle();\n\n  if (fetchError || !holdRow) {\n    throw new HoldNotFoundError();\n  }\n\n  const currentHold = holdRow as HoldRowWithMembers;\n  // Authorization: only creator or elevated role may extend the hold\n  if (!actorId) {\n    throw new AssignTablesRpcError({\n      message: \"Only the creator or elevated roles may extend holds\",\n      code: \"AUTH_FORBIDDEN\",\n      details: null,\n      hint: null,\n    });\n  }\n  if (currentHold.created_by && currentHold.created_by !== actorId) {\n    try {\n      const { data: membership } = await supabase\n        .from(\"restaurant_memberships\")\n        .select(\"role\")\n        .eq(\"restaurant_id\", currentHold.restaurant_id)\n        .eq(\"user_id\", actorId)\n        .maybeSingle();\n      const role = (membership as { role?: string } | null)?.role ?? null;\n      const elevated = role && [\"admin\", \"manager\", \"owner\"].includes(role);\n      if (!elevated) {\n        throw new AssignTablesRpcError({\n          message: \"Only the creator or elevated roles may extend holds\",\n          code: \"AUTH_FORBIDDEN\",\n          details: null,\n          hint: null,\n        });\n      }\n    } catch (e) {\n      if (e instanceof AssignTablesRpcError) {\n        throw e;\n      }\n      // If membership lookup fails, deny by default\n      throw new AssignTablesRpcError({\n        message: \"Only the creator or elevated roles may extend holds\",\n        code: \"AUTH_FORBIDDEN\",\n        details: null,\n        hint: null,\n      });\n    }\n  }\n  const memberTableIds = extractTableIdsFromMembers(currentHold.table_hold_members ?? null);\n  const currentExpires = DateTime.fromISO(currentHold.expires_at ?? \"\").toUTC();\n  if (!currentExpires.isValid) {\n    throw new HoldConflictError(\"Hold expiration timestamp invalid\", holdId);\n  }\n\n  let targetExpiry: DateTime | null = null;\n  if (typeof newExpiresAt === \"string\") {\n    const candidate = DateTime.fromISO(newExpiresAt).toUTC();\n    if (candidate.isValid) {\n      targetExpiry = candidate;\n    }\n  }\n\n  if (!targetExpiry && typeof extendSeconds === \"number\" && Number.isFinite(extendSeconds)) {\n    targetExpiry = currentExpires.plus({ seconds: extendSeconds });\n  }\n\n  if (!targetExpiry || !targetExpiry.isValid) {\n    throw new HoldConflictError(\"Cannot extend hold without a valid expiry\" , holdId);\n  }\n\n  if (targetExpiry <= currentExpires) {\n    return normalizeHold(currentHold as Tables<\"table_holds\">, memberTableIds);\n  }\n\n  const targetIso = targetExpiry.toUTC().toISO();\n  const currentExpiresIso = currentExpires.toISO();\n  if (!targetIso || !currentExpiresIso) {\n    throw new HoldConflictError(\"Failed to normalize hold expiry\", holdId);\n  }\n  const { data: updatedRow, error: updateError } = await supabase\n    .from(\"table_holds\")\n    .update({\n      expires_at: targetIso,\n      updated_at: new Date().toISOString(),\n    })\n    .eq(\"id\", holdId)\n    .select(\"*, table_hold_members(table_id)\")\n    .maybeSingle();\n\n  if (updateError || !updatedRow) {\n    throw new HoldConflictError(updateError?.message ?? \"Failed to extend hold\", holdId);\n  }\n\n  const updatedHold = updatedRow as HoldRowWithMembers;\n  const updatedTableIds = extractTableIdsFromMembers(updatedHold.table_hold_members ?? null);\n\n  const { emitHoldExtended } = await import(\"./telemetry\");\n  await emitHoldExtended({\n    holdId,\n    bookingId: updatedHold.booking_id,\n    restaurantId: updatedHold.restaurant_id,\n    zoneId: updatedHold.zone_id,\n    tableIds: updatedTableIds,\n    startAt: updatedHold.start_at,\n    endAt: updatedHold.end_at,\n    previousExpiresAt: currentExpiresIso,\n    newExpiresAt: targetIso,\n    actorId: actorId ?? updatedHold.created_by,\n    metadata: updatedHold.metadata ?? null,\n  });\n\n  return normalizeHold(updatedHold as Tables<\"table_holds\">, updatedTableIds);\n}\n\nexport async function listActiveHoldsForBooking(input: ListActiveHoldsInput): Promise<TableHold[]> {\n  const { bookingId, client } = input;\n  const supabase = ensureClient(client);\n\n  const { data, error } = await supabase\n    .from(\"table_holds\")\n    .select(\"*, table_hold_members(table_id)\")\n    .eq(\"booking_id\", bookingId)\n    .gt(\"expires_at\", new Date().toISOString());\n\n  if (error || !data) {\n    return [];\n  }\n\n  return data.map((row) => {\n    const holdRow = row as HoldRowWithMembers;\n    const memberTableIds = extractTableIdsFromMembers(holdRow.table_hold_members ?? null);\n    return normalizeHold(holdRow, memberTableIds);\n  });\n}\n\nexport async function findHoldConflicts(input: FindHoldConflictsInput): Promise<HoldConflictInfo[]> {\n  const { restaurantId, tableIds, startAt, endAt, excludeHoldId = null, client } = input;\n\n  if (!Array.isArray(tableIds) || tableIds.length === 0) {\n    return [];\n  }\n\n  const supabase = ensureClient(client);\n  await configureHoldStrictConflictSession(supabase);\n  if (!isHoldStrictConflictsEnabled()) {\n    return await findHoldConflictsLegacy({ restaurantId, tableIds, startAt, endAt, excludeHoldId, client: supabase });\n  }\n  const nowIso = new Date().toISOString();\n  const rangeLiteral = `[${startAt},${endAt})`;\n\n  try {\n    const { data, error } = await supabase\n      .from(\"table_hold_windows\")\n      .select(\"hold_id, booking_id, restaurant_id, table_id, start_at, end_at, expires_at\")\n      .eq(\"restaurant_id\", restaurantId)\n      .gt(\"expires_at\", nowIso)\n      .in(\"table_id\", tableIds)\n      .filter(\"hold_window\", \"ov\", rangeLiteral);\n\n    if (error) {\n      const code = (error as { code?: string }).code;\n      if (code === \"42P01\") {\n        return await findHoldConflictsLegacy({ restaurantId, tableIds, startAt, endAt, excludeHoldId, client: supabase });\n      }\n      console.warn(\"[capacity.hold] hold_window query failed; falling back to legacy conflict detection\", {\n        restaurantId,\n        error,\n      });\n      return await findHoldConflictsLegacy({ restaurantId, tableIds, startAt, endAt, excludeHoldId, client: supabase });\n    }\n\n    const rows = Array.isArray(data) ? (data as TableHoldWindowRow[]) : [];\n    if (rows.length === 0) {\n      return [];\n    }\n\n    const grouped = new Map<string, HoldConflictInfo>();\n\n    for (const row of rows) {\n      if (!row || (excludeHoldId && row.hold_id === excludeHoldId)) {\n        continue;\n      }\n      if (!intervalsOverlap(row.start_at, row.end_at, startAt, endAt)) {\n        continue;\n      }\n      const key = row.hold_id;\n      if (!grouped.has(key)) {\n        grouped.set(key, {\n          holdId: row.hold_id,\n          bookingId: row.booking_id,\n          tableIds: [],\n          startAt: row.start_at,\n          endAt: row.end_at,\n          expiresAt: row.expires_at,\n        });\n      }\n      const entry = grouped.get(key)!;\n      if (!entry.tableIds.includes(row.table_id)) {\n        entry.tableIds.push(row.table_id);\n      }\n    }\n\n    return Array.from(grouped.values());\n  } catch (error) {\n    const code = (error as { code?: string }).code;\n    if (code === \"42P01\") {\n      return await findHoldConflictsLegacy({ restaurantId, tableIds, startAt, endAt, excludeHoldId, client: supabase });\n    }\n    console.warn(\"[capacity.hold] conflict evaluation failed; using legacy fallback\", {\n      restaurantId,\n      error,\n    });\n    return await findHoldConflictsLegacy({ restaurantId, tableIds, startAt, endAt, excludeHoldId, client: supabase });\n  }\n}\n\nasync function findHoldConflictsLegacy(params: {\n  restaurantId: string;\n  tableIds: string[];\n  startAt: string;\n  endAt: string;\n  excludeHoldId?: string | null;\n  client: DbClient;\n}): Promise<HoldConflictInfo[]> {\n  const { restaurantId, tableIds, startAt, endAt, excludeHoldId = null, client } = params;\n\n  const query = client\n    .from(\"table_holds\")\n    .select(\"id, booking_id, start_at, end_at, expires_at, table_hold_members(table_id)\")\n    .eq(\"restaurant_id\", restaurantId)\n    .gt(\"expires_at\", new Date().toISOString())\n    .lt(\"start_at\", endAt)\n    .gt(\"end_at\", startAt);\n\n  const { data, error } = await query;\n\n  if (error || !data) {\n    return [];\n  }\n\n  const conflicts: HoldConflictInfo[] = [];\n\n  for (const row of data) {\n    if (excludeHoldId && row.id === excludeHoldId) {\n      continue;\n    }\n\n    const members = (row.table_hold_members ?? []) as Array<{ table_id: string }>;\n    const memberTableIds = members.map((member) => member.table_id);\n\n    if (!memberTableIds.some((id) => tableIds.includes(id))) {\n      continue;\n    }\n\n    if (!intervalsOverlap(row.start_at, row.end_at, startAt, endAt)) {\n      continue;\n    }\n\n    conflicts.push({\n      holdId: row.id,\n      bookingId: row.booking_id,\n      tableIds: memberTableIds,\n      startAt: row.start_at,\n      endAt: row.end_at,\n      expiresAt: row.expires_at,\n    });\n  }\n\n  return conflicts;\n}\n\n// Legacy confirmTableHold removed. See confirmHoldAssignment in tables.ts (allocator v2).\n\nexport async function sweepExpiredHolds(input?: SweepExpiredHoldsInput): Promise<SweepExpiredHoldsResult> {\n  const { now, limit = 100, client } = input ?? {};\n  const supabase = ensureClient(client);\n  await configureHoldStrictConflictSession(supabase);\n  const cutoff = now ?? new Date().toISOString();\n\n  const { data, error } = await supabase\n    .from(\"table_holds\")\n    .select(\"id\")\n    .lte(\"expires_at\", cutoff)\n    .order(\"expires_at\", { ascending: true })\n    .limit(limit);\n\n  if (error) {\n    console.warn(\"[capacity.hold] sweepExpiredHolds failed\", {\n      error,\n      cutoff,\n      limit,\n    });\n    return {\n      total: 0,\n      holdIds: [],\n    };\n  }\n\n  if (!data || data.length === 0) {\n    return {\n      total: 0,\n      holdIds: [],\n    };\n  }\n\n  const holdIds = data.map((row) => row.id);\n  await supabase.from(\"table_hold_members\").delete().in(\"hold_id\", holdIds);\n  await supabase.from(\"table_holds\").delete().in(\"id\", holdIds);\n\n  return {\n    total: holdIds.length,\n    holdIds,\n  };\n}\n"
    },
    {
      "path": "server/capacity/index.ts",
      "size": 2926,
      "sha256": "ccd9a35c05a7c8fd6331b25324d932a6bd81fe08a7d679561c08f91f1cdd1102",
      "language": "typescript",
      "content": "/**\n * Capacity & Availability Engine - Public API\n * Story 2: Service Layer Exports\n * \n * Import from this file to use the capacity engine:\n * \n * @example\n * ```typescript\n * import {\n *   checkSlotAvailability,\n *   createBookingWithCapacityCheck,\n *   findAlternativeSlots,\n * } from '@/server/capacity';\n * \n * const result = await checkSlotAvailability({\n *   restaurantId: 'uuid',\n *   date: '2025-10-20',\n *   time: '19:00',\n *   partySize: 4\n * });\n * ```\n */\n\n// =====================================================\n// Main Services\n// =====================================================\n\nexport {\n  checkSlotAvailability,\n  findAlternativeSlots,\n  calculateCapacityUtilization,\n  getServicePeriodsWithCapacity,\n} from \"./service\";\n\nexport {\n  createBookingWithCapacityCheck,\n  updateBookingWithCapacityCheck,\n  createBookingOrThrow,\n  retryWithBackoff,\n  isRetryableBookingError,\n  getBookingErrorMessage,\n} from \"./transaction\";\n\nexport {\n  createTableHold,\n  releaseTableHold,\n  extendTableHold,\n  findHoldConflicts,\n  listActiveHoldsForBooking,\n  sweepExpiredHolds,\n} from \"./holds\";\n\nexport type { SweepExpiredHoldsResult, ExtendTableHoldInput } from \"./holds\";\n\nexport {\n  findSuitableTables,\n  assignTableToBooking,\n  unassignTableFromBooking,\n  getBookingTableAssignments,\n  isTableAvailable,\n  evaluateManualSelection,\n  createManualHold,\n  ManualSelectionInputError,\n} from \"./tables\";\n\nexport {\n  defaultVenuePolicy,\n  getVenuePolicy,\n  whichService,\n  bandDuration,\n  serviceEnd,\n  ServiceNotFoundError,\n  ServiceOverrunError,\n  PolicyError,\n  getSelectorScoringConfig,\n} from \"./policy\";\n\nexport {\n  calculateRestaurantCapacityByService,\n  calculateCapacityForTables,\n  type ServiceCapacitySummary,\n  type TableRotationDetail,\n} from \"./rotations\";\n\nexport {\n  validateBookingWindow,\n  type BookingValidationInput,\n  type BookingValidationResult,\n} from \"./validation\";\n\n// =====================================================\n// Types\n// =====================================================\n\nexport type {\n  // Availability\n  AvailabilityCheckParams,\n  AvailabilityResult,\n  AlternativeSlotParams,\n  TimeSlot,\n  CapacityMetadata,\n  \n  // Booking Transaction\n  CreateBookingParams,\n  UpdateBookingParams,\n  BookingResult,\n  BookingRecord,\n  BookingErrorCode,\n  BookingErrorDetails,\n  CapacityInfo,\n  \n  // Service Periods\n  ServicePeriodWithCapacity,\n  PeriodUtilization,\n  SelectorScoringConfig,\n  SelectorScoringWeights,\n  \n  // Retry\n  RetryConfig,\n} from \"./types\";\n\nexport type {\n  // Tables (v2)\n  Table,\n  TableMatchParams,\n  TableAssignmentMember,\n  TableAssignmentGroup,\n  ManualSelectionCheck,\n  ManualSelectionSummary,\n  ManualValidationResult,\n  ManualHoldResult,\n  ManualSelectionOptions,\n  ManualHoldOptions,\n} from \"./tables\";\n\nexport {\n  // Error Classes\n  CapacityError,\n  CapacityExceededError,\n  BookingConflictError,\n  \n  // Constants\n  DEFAULT_RETRY_CONFIG,\n} from \"./types\";\n"
    },
    {
      "path": "server/capacity/metrics.ts",
      "size": 427,
      "sha256": "7f9f172d43482496663f75b980c8794390329d02f4adb78b4c95bbeeeaa7de52",
      "language": "typescript",
      "content": "export type CapacityMetricType = 'success' | 'conflict' | 'capacity_exceeded';\n\nexport type RecordCapacityMetricParams = {\n  restaurantId: string;\n  bookingDate: string;\n  startTime?: string | null;\n  metric: CapacityMetricType;\n};\n\nexport async function recordCapacityMetric(_params: RecordCapacityMetricParams): Promise<void> {\n  // Capacity metrics have been sunset; keep this hook as a no-op for backwards compatibility.\n}\n"
    },
    {
      "path": "server/capacity/planner/bitset.ts",
      "size": 2138,
      "sha256": "0a8c634d82da8e9967f09ab6559f793edbef5177328c9225a9df5398eeade0bc",
      "language": "typescript",
      "content": "import { DateTime } from \"luxon\";\n\ntype Dateish = DateTime | string | number | Date;\n\nconst SLOT_MINUTES = 5;\nconst SLOT_DURATION_MS = SLOT_MINUTES * 60 * 1000;\n\nexport type AvailabilityBitset = {\n  /**\n   * Set of slot indices that are occupied. The index is derived from\n   * `Math.floor(epochMillis / SLOT_DURATION_MS)`.\n   */\n  occupied: Set<number>;\n};\n\nfunction toDateTime(value: Dateish): DateTime {\n  if (value instanceof DateTime) {\n    return value;\n  }\n  if (value instanceof Date) {\n    return DateTime.fromJSDate(value, { zone: \"utc\" });\n  }\n  if (typeof value === \"number\") {\n    return DateTime.fromMillis(value, { zone: \"utc\" });\n  }\n  return DateTime.fromISO(value, { zone: \"utc\" });\n}\n\nfunction toSlotIndex(date: Dateish, round: \"floor\" | \"ceil\" = \"floor\"): number {\n  const millis = toDateTime(date).toMillis();\n  const quotient = millis / SLOT_DURATION_MS;\n  return round === \"floor\" ? Math.floor(quotient) : Math.ceil(quotient);\n}\n\nexport function createAvailabilityBitset(\n  windows?: Array<{ start: Dateish; end: Dateish }>,\n): AvailabilityBitset {\n  const occupied = new Set<number>();\n  if (windows) {\n    for (const window of windows) {\n      markWindow({ occupied }, window.start, window.end);\n    }\n  }\n  return { occupied };\n}\n\nexport function markWindow(bitset: AvailabilityBitset, start: Dateish, end: Dateish): void {\n  const startSlot = toSlotIndex(start, \"floor\");\n  const endSlot = toSlotIndex(end, \"ceil\");\n  for (let slot = startSlot; slot < endSlot; slot += 1) {\n    bitset.occupied.add(slot);\n  }\n}\n\nexport function isWindowFree(bitset: AvailabilityBitset, start: Dateish, end: Dateish): boolean {\n  const startSlot = toSlotIndex(start, \"floor\");\n  const endSlot = toSlotIndex(end, \"ceil\");\n  for (let slot = startSlot; slot < endSlot; slot += 1) {\n    if (bitset.occupied.has(slot)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function mergeBitsets(bitsets: AvailabilityBitset[]): AvailabilityBitset {\n  const merged = createAvailabilityBitset();\n  for (const bitset of bitsets) {\n    for (const slot of bitset.occupied) {\n      merged.occupied.add(slot);\n    }\n  }\n  return merged;\n}\n"
    },
    {
      "path": "server/capacity/policy.ts",
      "size": 8210,
      "sha256": "9841877debe6e3ccde927bba46e621b27971b0b3598ccbf3f3f0b2a10b853292",
      "language": "typescript",
      "content": "import { DateTime } from \"luxon\";\n\nimport {\n  DEFAULT_SCARCITY_WEIGHT,\n  getStrategicScarcityWeight,\n  type StrategicConfigSnapshotOptions,\n} from \"./strategic-config\";\n\nconst DEFAULT_TIMEZONE = \"Europe/London\";\n\nexport const SERVICE_KEYS = [\"lunch\", \"dinner\", \"drinks\"] as const;\nexport type ServiceKey = (typeof SERVICE_KEYS)[number];\n\nexport type TimeOfDay = {\n  hour: number;\n  minute: number;\n};\n\nexport type BufferConfig = {\n  pre: number;\n  post: number;\n};\n\nexport type TurnBand = {\n  maxPartySize: number;\n  durationMinutes: number;\n};\n\nexport type ServiceDefinition = {\n  key: ServiceKey;\n  label: string;\n  start: TimeOfDay;\n  end: TimeOfDay;\n  buffer: BufferConfig;\n  turnBands: TurnBand[];\n};\n\nexport type VenuePolicy = {\n  timezone: string;\n  services: Partial<Record<ServiceKey, ServiceDefinition>>;\n  serviceOrder: ServiceKey[];\n};\n\nexport type SelectorScoringWeights = {\n  overage: number;\n  tableCount: number;\n  fragmentation: number;\n  zoneBalance: number;\n  adjacencyCost: number;\n  scarcity: number;\n};\n\nexport const YIELD_MANAGEMENT_SCARCITY_WEIGHT = DEFAULT_SCARCITY_WEIGHT;\n\nexport type SelectorScoringConfig = {\n  weights: SelectorScoringWeights;\n  maxOverage: number;\n  maxTables: number;\n};\n\nexport type ServiceWindow = {\n  start: DateTime;\n  end: DateTime;\n};\n\nfunction cloneTurnBands(bands: TurnBand[]): TurnBand[] {\n  return bands.map((band) => ({ ...band }));\n}\n\nfunction cloneService(service: ServiceDefinition): ServiceDefinition {\n  return {\n    ...service,\n    start: { ...service.start },\n    end: { ...service.end },\n    buffer: { ...service.buffer },\n    turnBands: cloneTurnBands(service.turnBands),\n  };\n}\n\nexport const defaultVenuePolicy: VenuePolicy = {\n  timezone: DEFAULT_TIMEZONE,\n  serviceOrder: [\"lunch\", \"dinner\"],\n  services: {\n    lunch: {\n      key: \"lunch\",\n      label: \"Lunch\",\n      start: { hour: 12, minute: 0 },\n      end: { hour: 15, minute: 0 },\n      buffer: { pre: 0, post: 5 },\n      turnBands: [\n        { maxPartySize: 2, durationMinutes: 60 },\n        { maxPartySize: 4, durationMinutes: 75 },\n        { maxPartySize: 6, durationMinutes: 85 },\n        { maxPartySize: 8, durationMinutes: 85 },\n      ],\n    },\n    dinner: {\n      key: \"dinner\",\n      label: \"Dinner\",\n      start: { hour: 17, minute: 0 },\n      end: { hour: 22, minute: 0 },\n      buffer: { pre: 0, post: 5 },\n      turnBands: [\n        { maxPartySize: 2, durationMinutes: 60 },\n        { maxPartySize: 4, durationMinutes: 75 },\n        { maxPartySize: 6, durationMinutes: 85 },\n        { maxPartySize: 8, durationMinutes: 90 },\n      ],\n    },\n  },\n};\n\nconst defaultSelectorScoringConfig: SelectorScoringConfig = {\n  weights: {\n    overage: 5,\n    tableCount: 3,\n    fragmentation: 2,\n    zoneBalance: 4,\n    adjacencyCost: 1,\n    scarcity: DEFAULT_SCARCITY_WEIGHT,\n  },\n  maxOverage: 2,\n  maxTables: 3,\n};\n\nexport function getSelectorScoringConfig(options?: StrategicConfigSnapshotOptions): SelectorScoringConfig {\n  const dynamicScarcityWeight = getStrategicScarcityWeight(options);\n  return {\n    weights: {\n      ...defaultSelectorScoringConfig.weights,\n      scarcity: dynamicScarcityWeight,\n    },\n    maxOverage: defaultSelectorScoringConfig.maxOverage,\n    maxTables: defaultSelectorScoringConfig.maxTables,\n  };\n}\n\nexport function getYieldManagementScarcityWeight(options?: StrategicConfigSnapshotOptions): number {\n  return getStrategicScarcityWeight(options);\n}\n\nexport class PolicyError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"PolicyError\";\n  }\n}\n\nexport class ServiceNotFoundError extends PolicyError {\n  constructor(public readonly attempted: DateTime, message?: string) {\n    super(message ?? `No service window matches ${attempted.toISO() ?? \"provided time\"}.`);\n    this.name = \"ServiceNotFoundError\";\n  }\n}\n\nexport class ServiceOverrunError extends PolicyError {\n  constructor(\n    public readonly service: ServiceKey,\n    public readonly attemptedEnd: DateTime,\n    public readonly serviceEnd: DateTime,\n    message?: string,\n  ) {\n    super(\n      message ??\n        `Reservation would overrun ${service} service (end ${serviceEnd.toFormat(\"HH:mm\")}).`,\n    );\n    this.name = \"ServiceOverrunError\";\n  }\n}\n\ntype PolicyOptions = {\n  timezone?: string | null;\n};\n\nexport function getVenuePolicy(options?: PolicyOptions): VenuePolicy {\n  if (!options?.timezone || options.timezone === defaultVenuePolicy.timezone) {\n    return {\n      timezone: defaultVenuePolicy.timezone,\n      serviceOrder: [...defaultVenuePolicy.serviceOrder],\n      services: Object.fromEntries(\n        Object.entries(defaultVenuePolicy.services).map(([key, service]) => [\n          key,\n          service ? cloneService(service) : service,\n        ]),\n      ),\n    };\n  }\n\n  return {\n    timezone: options.timezone,\n    serviceOrder: [...defaultVenuePolicy.serviceOrder],\n    services: Object.fromEntries(\n      Object.entries(defaultVenuePolicy.services).map(([key, service]) => [\n        key,\n        service ? cloneService(service) : service,\n      ]),\n    ),\n  };\n}\n\nfunction toZonedBase(dateTime: DateTime, timezone: string): DateTime {\n  const candidate = dateTime.isValid ? dateTime : DateTime.invalid(\"Invalid start time\");\n  const zoned = candidate.setZone(timezone, { keepLocalTime: false });\n  if (!zoned.isValid) {\n    throw new PolicyError(`Invalid DateTime for policy computation: ${candidate.invalidReason ?? \"unknown reason\"}`);\n  }\n  return zoned;\n}\n\nfunction toDateTime(base: DateTime, time: TimeOfDay): DateTime {\n  return base.set({\n    hour: time.hour,\n    minute: time.minute,\n    second: 0,\n    millisecond: 0,\n  });\n}\n\nfunction resolveServiceWindow(base: DateTime, service: ServiceDefinition): ServiceWindow {\n  const start = toDateTime(base, service.start);\n  let end = toDateTime(base, service.end);\n  if (end <= start) {\n    end = end.plus({ days: 1 });\n  }\n  return { start, end };\n}\n\nfunction activeServices(policy: VenuePolicy): ServiceDefinition[] {\n  return policy.serviceOrder\n    .map((key) => policy.services[key])\n    .filter((service): service is ServiceDefinition => Boolean(service));\n}\n\nexport function whichService(dateTime: DateTime, policy: VenuePolicy = defaultVenuePolicy): ServiceKey | null {\n  const zoned = toZonedBase(dateTime, policy.timezone);\n\n  for (const service of activeServices(policy)) {\n    const window = resolveServiceWindow(zoned, service);\n    if (zoned >= window.start && zoned < window.end) {\n      return service.key;\n    }\n  }\n\n  return null;\n}\n\nexport function serviceWindowFor(\n  serviceKey: ServiceKey,\n  dateTime: DateTime,\n  policy: VenuePolicy = defaultVenuePolicy,\n): ServiceWindow {\n  const service = policy.services[serviceKey];\n  if (!service) {\n    throw new PolicyError(`Unknown service \"${serviceKey}\".`);\n  }\n\n  const zoned = toZonedBase(dateTime, policy.timezone);\n  return resolveServiceWindow(zoned, service);\n}\n\nexport function serviceEnd(\n  serviceKey: ServiceKey,\n  dateTime: DateTime,\n  policy: VenuePolicy = defaultVenuePolicy,\n): DateTime {\n  return serviceWindowFor(serviceKey, dateTime, policy).end;\n}\n\nexport function getTurnBand(\n  serviceKey: ServiceKey,\n  partySize: number,\n  policy: VenuePolicy = defaultVenuePolicy,\n): TurnBand {\n  const service = policy.services[serviceKey];\n  if (!service) {\n    throw new PolicyError(`Unknown service \"${serviceKey}\".`);\n  }\n\n  const bands = service.turnBands;\n  if (!bands || bands.length === 0) {\n    throw new PolicyError(`No turn bands configured for service \"${serviceKey}\".`);\n  }\n\n  if (!Number.isFinite(partySize) || partySize <= 0) {\n    return bands[0]!;\n  }\n\n  for (const band of bands) {\n    if (partySize <= band.maxPartySize) {\n      return band;\n    }\n  }\n\n  return bands[bands.length - 1]!;\n}\n\nexport function bandDuration(\n  serviceKey: ServiceKey,\n  partySize: number,\n  policy: VenuePolicy = defaultVenuePolicy,\n): number {\n  return getTurnBand(serviceKey, partySize, policy).durationMinutes;\n}\n\nexport function getBufferConfig(\n  serviceKey: ServiceKey,\n  policy: VenuePolicy = defaultVenuePolicy,\n): BufferConfig {\n  const service = policy.services[serviceKey];\n  if (!service) {\n    throw new PolicyError(`Unknown service \"${serviceKey}\".`);\n  }\n  return { ...service.buffer };\n}\n"
    },
    {
      "path": "server/capacity/rotations.ts",
      "size": 5827,
      "sha256": "65f3be9a2f2e6f88c4d20aae1f8fac5b82abe920cfa27bd7dfcd4c4b103881f2",
      "language": "typescript",
      "content": "import { DateTime } from \"luxon\";\n\n\nimport { getServiceSupabaseClient } from \"@/server/supabase\";\n\nimport {\n  bandDuration,\n  getBufferConfig,\n  getVenuePolicy,\n  serviceWindowFor,\n  type BufferConfig,\n  type ServiceKey,\n  type VenuePolicy,\n} from \"./policy\";\n\nimport type { Database, Tables } from \"@/types/supabase\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\n\ntype DbClient = SupabaseClient<Database, \"public\", any>;\ntype TableInventoryRow = Pick<\n  Tables<\"table_inventory\">,\n  \"id\" | \"table_number\" | \"capacity\" | \"min_party_size\" | \"max_party_size\" | \"status\"\n>;\n\nconst EXCLUDED_STATUSES = new Set<Tables<\"table_inventory\">[\"status\"]>([\"out_of_service\"]);\n\nexport type TableRotationDetail = {\n  tableId: string;\n  tableNumber: string;\n  capacity: number;\n  minPartySize: number;\n  maxPartySize: number | null;\n  status: Tables<\"table_inventory\">[\"status\"];\n  effectivePartySize: number;\n  diningMinutes: number;\n  buffer: BufferConfig;\n  blockMinutes: number;\n  rotations: number;\n  covers: number;\n};\n\nexport type ServiceCapacitySummary = {\n  service: ServiceKey;\n  serviceMinutes: number;\n  tables: TableRotationDetail[];\n  totalRotations: number;\n  totalCovers: number;\n};\n\nexport type CalculateCapacityParams = {\n  restaurantId: string;\n  services?: ServiceKey[];\n  referenceDate?: string;\n  timezone?: string | null;\n  client?: DbClient;\n};\n\nfunction anchorDate(policy: VenuePolicy, referenceDate?: string): DateTime {\n  if (referenceDate) {\n    const candidate = DateTime.fromISO(`${referenceDate}T00:00`, { zone: policy.timezone });\n    if (candidate.isValid) {\n      return candidate;\n    }\n  }\n  return DateTime.now().setZone(policy.timezone).startOf(\"day\");\n}\n\nfunction resolvePartySize(table: TableInventoryRow): number {\n  const capacity = Math.max(0, table.capacity ?? 0);\n  if (capacity === 0) {\n    return 0;\n  }\n\n  const maxParty = table.max_party_size ? Math.min(table.max_party_size, capacity) : capacity;\n  const minParty = Math.max(1, table.min_party_size ?? 1);\n  return Math.max(minParty, maxParty);\n}\n\nfunction computeBlockMinutes(service: ServiceKey, partySize: number, policy: VenuePolicy): {\n  diningMinutes: number;\n  buffer: BufferConfig;\n  blockMinutes: number;\n} {\n  const diningMinutes = bandDuration(service, partySize, policy);\n  const buffer = getBufferConfig(service, policy);\n  const blockMinutes = Math.max(0, diningMinutes + (buffer.pre ?? 0) + (buffer.post ?? 0));\n  return { diningMinutes, buffer, blockMinutes };\n}\n\nfunction summarizeServiceCapacity(\n  service: ServiceKey,\n  tables: TableInventoryRow[],\n  policy: VenuePolicy,\n  referenceDate?: string,\n): ServiceCapacitySummary | null {\n  const serviceDefinition = policy.services[service];\n  if (!serviceDefinition) {\n    return null;\n  }\n\n  const anchor = anchorDate(policy, referenceDate);\n  const window = serviceWindowFor(service, anchor, policy);\n  const serviceMinutes = Math.max(\n    0,\n    Math.floor(window.end.diff(window.start, \"minutes\").minutes),\n  );\n  if (serviceMinutes === 0) {\n    return {\n      service,\n      serviceMinutes,\n      tables: [],\n      totalRotations: 0,\n      totalCovers: 0,\n    };\n  }\n\n  const details: TableRotationDetail[] = [];\n  let totalRotations = 0;\n  let totalCovers = 0;\n\n  for (const table of tables) {\n    if (EXCLUDED_STATUSES.has(table.status) || !table.capacity || table.capacity <= 0) {\n      continue;\n    }\n\n    const partySize = resolvePartySize(table);\n    if (partySize <= 0) {\n      continue;\n    }\n\n    const { diningMinutes, buffer, blockMinutes } = computeBlockMinutes(service, partySize, policy);\n    if (blockMinutes <= 0) {\n      continue;\n    }\n\n    const rotations = Math.max(0, Math.floor(serviceMinutes / blockMinutes));\n    const covers = rotations * table.capacity;\n\n    totalRotations += rotations;\n    totalCovers += covers;\n\n    details.push({\n      tableId: table.id,\n      tableNumber: table.table_number,\n      capacity: table.capacity,\n      minPartySize: table.min_party_size ?? 1,\n      maxPartySize: table.max_party_size,\n      status: table.status,\n      effectivePartySize: partySize,\n      diningMinutes,\n      buffer,\n      blockMinutes,\n      rotations,\n      covers,\n    });\n  }\n\n  return {\n    service,\n    serviceMinutes,\n    tables: details,\n    totalRotations,\n    totalCovers,\n  };\n}\n\nasync function fetchTableInventory(\n  restaurantId: string,\n  client: DbClient,\n): Promise<TableInventoryRow[]> {\n  const { data, error } = await client\n    .from(\"table_inventory\")\n    .select(\"id, table_number, capacity, min_party_size, max_party_size, status\")\n    .eq(\"restaurant_id\", restaurantId);\n\n  if (error) {\n    throw error;\n  }\n\n  return (data ?? []) as TableInventoryRow[];\n}\n\nexport async function calculateRestaurantCapacityByService(\n  params: CalculateCapacityParams,\n): Promise<ServiceCapacitySummary[]> {\n  const { restaurantId, services, referenceDate, timezone, client } = params;\n\n  const supabase = client ?? getServiceSupabaseClient();\n  const tables = await fetchTableInventory(restaurantId, supabase);\n\n  const policy = getVenuePolicy({ timezone });\n  const serviceOrder =\n    services && services.length > 0\n      ? services\n      : policy.serviceOrder.filter((service) => Boolean(policy.services[service]));\n\n  const summaries: ServiceCapacitySummary[] = [];\n\n  for (const service of serviceOrder) {\n    const summary = summarizeServiceCapacity(service, tables, policy, referenceDate);\n    if (summary) {\n      summaries.push(summary);\n    }\n  }\n\n  return summaries;\n}\n\nexport function calculateCapacityForTables(\n  service: ServiceKey,\n  tables: TableInventoryRow[],\n  options?: { policy?: VenuePolicy; referenceDate?: string },\n): ServiceCapacitySummary | null {\n  const policy = options?.policy ?? getVenuePolicy();\n  return summarizeServiceCapacity(service, tables, policy, options?.referenceDate);\n}\n"
    },
    {
      "path": "server/capacity/scarcity.ts",
      "size": 4553,
      "sha256": "18273b517d82fdc24700bdd150904ebc36d8cca5d01bef10127651a86b911ba6",
      "language": "typescript",
      "content": "import { getServiceSupabaseClient } from \"@/server/supabase\";\n\nimport type { Table } from \"./tables\";\nimport type { Database } from \"@/types/supabase\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\n\nconst CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes\n\ntype DbClient = SupabaseClient<Database, \"public\">;\n\ntype MetricsCacheEntry = {\n  metrics: Map<string, number>;\n  expiresAt: number;\n};\n\nconst scarcityCache = new Map<string, MetricsCacheEntry>();\n\nfunction sanitizeSegment(value: string | null | undefined, fallback: string): string {\n  if (!value) {\n    return fallback;\n  }\n  return value.toString().trim().toLowerCase() || fallback;\n}\n\nexport function deriveTableType(table: Table): string {\n  const capacity = Number.isFinite(table.capacity) ? Number(table.capacity) : 0;\n  const category = sanitizeSegment(table.category as string | null | undefined, \"uncategorized\");\n  const seating = sanitizeSegment(table.seatingType as string | null | undefined, \"standard\");\n\n  return `capacity:${capacity}|category:${category}|seating:${seating}`;\n}\n\nexport function computeScarcityScore(count: number): number {\n  if (!Number.isFinite(count) || count <= 0) {\n    return 0;\n  }\n  return Number((1 / count).toFixed(4));\n}\n\nasync function fetchRestaurantMetrics(client: DbClient, restaurantId: string): Promise<Map<string, number>> {\n  const cacheEntry = scarcityCache.get(restaurantId);\n  const now = Date.now();\n  if (cacheEntry && cacheEntry.expiresAt > now) {\n    return cacheEntry.metrics;\n  }\n\n  const { data, error } = await client\n    .from(\"table_scarcity_metrics\")\n    .select(\"table_type, scarcity_score\")\n    .eq(\"restaurant_id\", restaurantId);\n\n  if (error) {\n    console.warn(\"[scarcity] failed to load metrics, falling back to heuristic\", {\n      restaurantId,\n      error: error.message,\n    });\n    return new Map();\n  }\n\n  const metrics = new Map<string, number>();\n  for (const row of data ?? []) {\n    if (!row || typeof row.table_type !== \"string\") {\n      continue;\n    }\n    const score = Number(row.scarcity_score);\n    if (Number.isFinite(score)) {\n      metrics.set(row.table_type, score);\n    }\n  }\n\n  scarcityCache.set(restaurantId, {\n    metrics,\n    expiresAt: now + CACHE_TTL_MS,\n  });\n\n  return metrics;\n}\n\nexport async function loadTableScarcityScores(params: {\n  restaurantId: string;\n  tables: Table[];\n  client?: DbClient;\n}): Promise<Map<string, number>> {\n  const { restaurantId, tables, client } = params;\n  const dbClient = client ?? getServiceSupabaseClient();\n  const metrics = await fetchRestaurantMetrics(dbClient, restaurantId);\n\n  const countsByType = new Map<string, number>();\n  const countsByCapacity = new Map<number, { tableCount: number; seatSupply: number }>();\n  for (const table of tables) {\n    const type = deriveTableType(table);\n    countsByType.set(type, (countsByType.get(type) ?? 0) + 1);\n    const capacity = Number.isFinite(table.capacity) ? Number(table.capacity) : 0;\n    if (capacity > 0) {\n      const current = countsByCapacity.get(capacity) ?? { tableCount: 0, seatSupply: 0 };\n      current.tableCount += 1;\n      current.seatSupply += capacity;\n      countsByCapacity.set(capacity, current);\n    }\n  }\n\n  const scores = new Map<string, number>();\n\n  const resolveDemandWeight = (capacity: number): number => {\n    if (!Number.isFinite(capacity) || capacity <= 0) {\n      return 0.1;\n    }\n    if (capacity <= 2) return 1.6;\n    if (capacity <= 4) return 0.18;\n    if (capacity <= 6) return 0.12;\n    return 0.08;\n  };\n\n  for (const table of tables) {\n    const type = deriveTableType(table);\n    const metricScore = metrics.get(type);\n    if (typeof metricScore === \"number\" && Number.isFinite(metricScore) && metricScore > 0) {\n      scores.set(table.id, Number(metricScore.toFixed(4)));\n      continue;\n    }\n\n    const capacity = Number.isFinite(table.capacity) ? Number(table.capacity) : 0;\n    const capacityGroup = countsByCapacity.get(capacity) ?? { tableCount: 1, seatSupply: Math.max(1, capacity) };\n    const demandWeight = resolveDemandWeight(capacity);\n    const seatSupply = Math.max(1, capacityGroup.seatSupply);\n    const fallback = Number((demandWeight / seatSupply).toFixed(4));\n    if (!metrics.has(type)) {\n      console.debug(\"[scarcity] using heuristic fallback\", {\n        restaurantId,\n        type,\n        capacity,\n        fallback,\n        tableCount: capacityGroup.tableCount,\n        seatSupply,\n      });\n    }\n    scores.set(table.id, fallback);\n  }\n\n  return scores;\n}\n\nexport function clearScarcityCache(): void {\n  scarcityCache.clear();\n}\n"
    },
    {
      "path": "server/capacity/selector.ts",
      "size": 25571,
      "sha256": "3feee6844b2ef33566639b41b1ed5becf98ffcff97b12a0f13460f0b0416ee54",
      "language": "typescript",
      "content": "import type { SelectorScoringConfig, SelectorScoringWeights } from \"./policy\";\nimport type { Table } from \"./tables\";\n\nconst DIAGNOSTIC_SKIP_KEYS = [\n  \"capacity\",\n  \"overage\",\n  \"adjacency\",\n  \"kmax\",\n  \"zone\",\n  \"limit\",\n  \"bucket\",\n  \"adjacency_frontier\",\n  \"capacity_upper_bound\",\n  \"timeout\",\n] as const;\n\nconst DEFAULT_ENUMERATION_TIMEOUT_MS = 1_000;\n\ntype DiagnosticSkipKey = (typeof DIAGNOSTIC_SKIP_KEYS)[number];\n\ntype DiagnosticSkipCounts = Record<DiagnosticSkipKey, number> & Record<string, number>;\n\nexport type CandidateMetrics = {\n  overage: number;\n  tableCount: number;\n  fragmentation: number;\n  zoneBalance: number;\n  adjacencyCost: number;\n  scarcityScore: number;\n};\n\nexport type ScoreBreakdown = {\n  slackPenalty: number;\n  demandMultiplier: number;\n  scarcityPenalty: number;\n  combinationPenalty: number;\n  structuralPenalty: number;\n  futureConflictPenalty: number;\n  total: number;\n};\n\nexport type RankedTablePlan = {\n  tables: Table[];\n  totalCapacity: number;\n  slack: number;\n  metrics: CandidateMetrics;\n  score: number;\n  tableKey: string;\n  adjacencyStatus: \"single\" | \"connected\" | \"disconnected\";\n  scoreBreakdown: ScoreBreakdown;\n};\n\nexport type CandidateDiagnostics = {\n  singlesConsidered: number;\n  combinationsEnumerated: number;\n  combinationsAccepted: number;\n  skipped: DiagnosticSkipCounts;\n  limits: {\n    kMax: number;\n    maxPlansPerSlack: number;\n    maxCombinationEvaluations: number;\n    enumerationTimeoutMs?: number;\n  };\n  totals: {\n    enumerated: number;\n    accepted: number;\n  };\n  timePruning?: {\n    prunedByTime: number;\n    candidatesAfterTimePrune: number;\n    pruned_by_time: number;\n    candidates_after_time_prune: number;\n  };\n  quoteSkips?: {\n    holdConflicts: {\n      count: number;\n      holdIds: string[];\n    };\n  };\n  performance?: {\n    totalDurationMs: number;\n    buildScoredTablePlansMs: number;\n    enumerateCombinationsMs?: number;\n    sortingMs?: number;\n    inputSize: {\n      tableCount: number;\n      partySize: number;\n      validTablesCount: number;\n      singleTableCandidatesCount: number;\n    };\n    iterations: {\n      totalEvaluations: number;\n      dfsIterations?: number;\n      earlyExit: boolean;\n      earlyExitReason?: string;\n    };\n  };\n  lookahead?: {\n    enabled: boolean;\n    evaluationMs: number;\n    futureBookingsConsidered: number;\n    penalizedPlans: number;\n    totalPenalty: number;\n    windowMinutes: number;\n    conflicts: Array<{ bookingId: string; planKey: string }>;\n    blockedPlans: string[];\n    hardBlockTriggered: boolean;\n  };\n};\n\nexport type BuildCandidatesOptions = {\n  tables: Table[];\n  partySize: number;\n  adjacency: Map<string, Set<string>>;\n  config: SelectorScoringConfig;\n  enableCombinations?: boolean;\n  kMax?: number;\n  maxPlansPerSlack?: number;\n  maxCombinationEvaluations?: number;\n  enumerationTimeoutMs?: number;\n  requireAdjacency?: boolean;\n  demandMultiplier?: number;\n  tableScarcityScores?: Map<string, number>;\n};\n\nexport type BuildCandidatesResult = {\n  plans: RankedTablePlan[];\n  fallbackReason?: string;\n  diagnostics: CandidateDiagnostics;\n};\n\nconst FALLBACK_NO_TABLES = \"No tables meet the capacity requirements for this party size.\";\nconst DEFAULT_MAX_PLANS_PER_SLACK = 50;\nconst DEFAULT_MAX_COMBINATION_EVALUATIONS = 500;\n\nfunction createSkipCounts(): DiagnosticSkipCounts {\n  return DIAGNOSTIC_SKIP_KEYS.reduce((accumulator, key) => {\n    accumulator[key] = 0;\n    return accumulator;\n  }, Object.create(null) as DiagnosticSkipCounts);\n}\n\nfunction incrementCounter(target: Record<string, number>, key: string, amount = 1): void {\n  const current = target[key] ?? 0;\n  target[key] = current + amount;\n}\n\nexport function buildScoredTablePlans(options: BuildCandidatesOptions): BuildCandidatesResult {\n  const durationStartMs = performance.now();\n\n  const {\n    tables,\n    partySize,\n    adjacency,\n    config,\n    enableCombinations = false,\n    kMax,\n    maxPlansPerSlack,\n    maxCombinationEvaluations,\n    enumerationTimeoutMs,\n    requireAdjacency = true,\n    demandMultiplier: inputDemandMultiplier,\n    tableScarcityScores: providedScarcityScores,\n  } = options;\n  const { maxOverage, weights } = config;\n  const demandMultiplier = normalizeDemandMultiplier(inputDemandMultiplier);\n  const tableScarcityScores = providedScarcityScores ?? computeTableScarcityScores(tables);\n\n  const maxAllowedCapacity = partySize + Math.max(maxOverage, 0);\n  const combinationCap = Math.max(1, Math.min(kMax ?? config.maxTables ?? 1, tables.length || 1));\n  const perSlackLimit = Math.max(1, maxPlansPerSlack ?? DEFAULT_MAX_PLANS_PER_SLACK);\n  const combinationEvaluationLimit = Math.max(1, maxCombinationEvaluations ?? DEFAULT_MAX_COMBINATION_EVALUATIONS);\n  const diagnostics: CandidateDiagnostics = {\n    singlesConsidered: 0,\n    combinationsEnumerated: 0,\n    combinationsAccepted: 0,\n    skipped: createSkipCounts(),\n    limits: {\n      kMax: combinationCap,\n      maxPlansPerSlack: perSlackLimit,\n      maxCombinationEvaluations: combinationEvaluationLimit,\n      enumerationTimeoutMs: Math.max(50, enumerationTimeoutMs ?? DEFAULT_ENUMERATION_TIMEOUT_MS),\n    },\n    totals: {\n      enumerated: 0,\n      accepted: 0,\n    },\n  };\n\n  const validTables: Table[] = [];\n  const singleTableCandidates: Table[] = [];\n\n  for (const table of tables) {\n    const capacity = table.capacity ?? 0;\n    if (!Number.isFinite(capacity) || capacity <= 0) {\n      incrementCounter(diagnostics.skipped, \"capacity\");\n      continue;\n    }\n\n    if (typeof table.minPartySize === \"number\" && table.minPartySize > 0 && partySize < table.minPartySize) {\n      incrementCounter(diagnostics.skipped, \"capacity\");\n      continue;\n    }\n\n    if (typeof table.maxPartySize === \"number\" && table.maxPartySize > 0 && partySize > table.maxPartySize) {\n      incrementCounter(diagnostics.skipped, \"capacity\");\n      continue;\n    }\n\n    if (capacity > maxAllowedCapacity) {\n      incrementCounter(diagnostics.skipped, \"overage\");\n      continue;\n    }\n\n    validTables.push(table);\n\n    if (capacity >= partySize) {\n      singleTableCandidates.push(table);\n    }\n  }\n\n  diagnostics.singlesConsidered = singleTableCandidates.length;\n\n  const plans: RankedTablePlan[] = [];\n\n  for (const table of singleTableCandidates) {\n    const adjacencyDepths = new Map<string, number>([[table.id, 0]]);\n    const metrics = computeMetrics([table], partySize, adjacencyDepths, tableScarcityScores);\n    const { score, breakdown } = computeScore(metrics, weights, demandMultiplier);\n    const totalCapacity = metrics.overage + partySize;\n    const tableKey = buildTableKey([table]);\n\n    plans.push({\n      tables: [table],\n      totalCapacity,\n      slack: metrics.overage,\n      metrics,\n      score,\n      tableKey,\n      adjacencyStatus: \"single\",\n      scoreBreakdown: breakdown,\n    });\n  }\n\n  let enumerateCombinationsMs: number | undefined;\n  let dfsIterations: number | undefined;\n  let earlyExit = false;\n  let earlyExitReason: string | undefined;\n\n  if (enableCombinations && combinationCap > 1 && validTables.length > 1) {\n    const combinationStartTime = performance.now();\n    const combinationPlans = enumerateCombinationPlans({\n      candidates: validTables,\n      partySize,\n      weights,\n      adjacency,\n      maxAllowedCapacity,\n      kMax: combinationCap,\n      bucketLimit: perSlackLimit,\n      evaluationLimit: combinationEvaluationLimit,\n      diagnostics,\n      requireAdjacency,\n      tableScarcityScores,\n      demandMultiplier,\n    });\n    enumerateCombinationsMs = performance.now() - combinationStartTime;\n\n    // Check if early exit occurred\n    if (diagnostics.combinationsEnumerated > 0) {\n      dfsIterations = diagnostics.combinationsEnumerated;\n      const limitSkipped = diagnostics.skipped.limit ?? 0;\n      if (limitSkipped > 0) {\n        earlyExit = true;\n        earlyExitReason = `evaluation_limit_reached (${combinationEvaluationLimit})`;\n      }\n    }\n\n    plans.push(...combinationPlans);\n  }\n\n  const sortStartTime = performance.now();\n  plans.sort((a, b) => comparePlans(a, b, weights));\n  const sortingMs = performance.now() - sortStartTime;\n\n  const fallbackReason = plans.length > 0 ? undefined : FALLBACK_NO_TABLES;\n\n  diagnostics.totals.enumerated = diagnostics.combinationsEnumerated + diagnostics.singlesConsidered;\n  diagnostics.totals.accepted = plans.length;\n\n  const totalDurationMs = performance.now() - durationStartMs;\n\n  // Add performance metrics to diagnostics\n  diagnostics.performance = {\n    totalDurationMs,\n    buildScoredTablePlansMs: totalDurationMs,\n    enumerateCombinationsMs,\n    sortingMs,\n    inputSize: {\n      tableCount: tables.length,\n      partySize,\n      validTablesCount: validTables.length,\n      singleTableCandidatesCount: singleTableCandidates.length,\n    },\n    iterations: {\n      totalEvaluations: diagnostics.combinationsEnumerated + diagnostics.singlesConsidered,\n      dfsIterations,\n      earlyExit,\n      earlyExitReason,\n    },\n  };\n\n  // Log performance warning if selector exceeds threshold (Sprint 0 - T0.2)\n  const SELECTOR_PERF_THRESHOLD_MS = 500;\n  if (totalDurationMs > SELECTOR_PERF_THRESHOLD_MS) {\n    console.warn(\"[PERF] buildScoredTablePlans exceeded threshold\", {\n      durationMs: totalDurationMs,\n      threshold: SELECTOR_PERF_THRESHOLD_MS,\n      inputSize: diagnostics.performance.inputSize,\n      iterations: diagnostics.performance.iterations,\n      enumerateCombinationsMs,\n      sortingMs,\n      enableCombinations,\n      kMax: combinationCap,\n      evaluationLimit: combinationEvaluationLimit,\n    });\n  }\n\n  return { plans, fallbackReason, diagnostics };\n}\n\nfunction computeMetrics(\n  tables: Table[],\n  partySize: number,\n  adjacencyDepths: Map<string, number>,\n  tableScarcityScores: Map<string, number>,\n): CandidateMetrics {\n  const capacities = tables.map((table) => table.capacity ?? 0);\n  const totalCapacity = capacities.reduce((sum, capacity) => sum + capacity, 0);\n  const maxCapacity = capacities.length > 0 ? Math.max(...capacities) : 0;\n  const overage = Math.max(totalCapacity - partySize, 0);\n  const fragmentation = Math.max(totalCapacity - maxCapacity, 0);\n  const zoneIds = new Set(tables.map((table) => table.zoneId ?? null));\n  const zoneBalance = Math.max(zoneIds.size - 1, 0);\n  const depthValues = adjacencyDepths.size > 0 ? [...adjacencyDepths.values()] : [0];\n  let adjacencyCost = Math.max(...depthValues);\n  if (adjacencyDepths.size < tables.length) {\n    adjacencyCost = Math.max(adjacencyCost, tables.length);\n  }\n  const scarcityScore = tables.reduce((sum, table) => sum + (tableScarcityScores.get(table.id) ?? 0), 0);\n\n  return {\n    overage,\n    tableCount: tables.length,\n    fragmentation,\n    zoneBalance,\n    adjacencyCost,\n    scarcityScore,\n  };\n}\n\nfunction computeScore(\n  metrics: CandidateMetrics,\n  weights: SelectorScoringWeights,\n  demandMultiplier: number,\n): { score: number; breakdown: ScoreBreakdown } {\n  const normalizedDemandMultiplier = Number.isFinite(demandMultiplier) && demandMultiplier > 0 ? demandMultiplier : 1;\n  const baseSlackPenalty = metrics.overage * weights.overage;\n  const slackPenalty = baseSlackPenalty * normalizedDemandMultiplier;\n\n  const tableCountPenalty = (metrics.tableCount - 1) * weights.tableCount;\n  const fragmentationPenalty = metrics.fragmentation * weights.fragmentation;\n  const zoneBalancePenalty = metrics.zoneBalance * weights.zoneBalance;\n  const adjacencyPenalty = metrics.adjacencyCost * weights.adjacencyCost;\n  const scarcityWeight = Math.max(0, weights.scarcity ?? 0);\n  let combinationPenalty = metrics.tableCount > 1 ? tableCountPenalty + adjacencyPenalty : 0;\n  if (combinationPenalty > 0 && scarcityWeight > 0 && metrics.tableCount > 0) {\n    const averageScarcity = metrics.scarcityScore / metrics.tableCount;\n    if (averageScarcity > 0) {\n      const scarcityFactor = Math.min(3, 1 + averageScarcity);\n      combinationPenalty *= scarcityFactor;\n    }\n  }\n  const structuralPenalty = combinationPenalty + fragmentationPenalty + zoneBalancePenalty;\n\n  const scarcityPenalty = metrics.scarcityScore * scarcityWeight;\n\n  const total = slackPenalty + structuralPenalty + scarcityPenalty;\n\n  return {\n    score: total,\n    breakdown: {\n      slackPenalty,\n      demandMultiplier: normalizedDemandMultiplier,\n      scarcityPenalty,\n      combinationPenalty,\n      structuralPenalty,\n      futureConflictPenalty: 0,\n      total,\n    },\n  };\n}\n\nfunction comparePlans(a: RankedTablePlan, b: RankedTablePlan, _weights: SelectorScoringWeights): number {\n  if (a.score !== b.score) {\n    return a.score - b.score;\n  }\n\n  if (a.metrics.overage !== b.metrics.overage) {\n    return a.metrics.overage - b.metrics.overage;\n  }\n\n  if (a.metrics.tableCount !== b.metrics.tableCount) {\n    return a.metrics.tableCount - b.metrics.tableCount;\n  }\n\n  if (a.totalCapacity !== b.totalCapacity) {\n    return a.totalCapacity - b.totalCapacity;\n  }\n\n  if (a.metrics.fragmentation !== b.metrics.fragmentation) {\n    return a.metrics.fragmentation - b.metrics.fragmentation;\n  }\n\n  if (a.metrics.adjacencyCost !== b.metrics.adjacencyCost) {\n    return a.metrics.adjacencyCost - b.metrics.adjacencyCost;\n  }\n\n  return a.tableKey.localeCompare(b.tableKey, \"en\");\n}\n\nfunction normalizeDemandMultiplier(value?: number): number {\n  if (typeof value !== \"number\" || !Number.isFinite(value)) {\n    return 1;\n  }\n  if (value <= 0) {\n    return 1;\n  }\n  return value;\n}\n\nfunction computeTableScarcityScores(tables: Table[]): Map<string, number> {\n  const capacityCounts = new Map<number, number>();\n  for (const table of tables) {\n    const capacity = table.capacity ?? 0;\n    if (!Number.isFinite(capacity) || capacity <= 0) {\n      continue;\n    }\n    const current = capacityCounts.get(capacity) ?? 0;\n    capacityCounts.set(capacity, current + 1);\n  }\n\n  const scores = new Map<string, number>();\n  for (const table of tables) {\n    const capacity = table.capacity ?? 0;\n    if (!Number.isFinite(capacity) || capacity <= 0) {\n      scores.set(table.id, 0);\n      continue;\n    }\n    const count = capacityCounts.get(capacity) ?? 0;\n    if (count <= 0) {\n      scores.set(table.id, 0);\n      continue;\n    }\n    scores.set(table.id, 1 / count);\n  }\n\n  return scores;\n}\n\nfunction buildTableKey(tables: Table[]): string {\n  return tables\n    .map((table) => table.tableNumber ?? table.id)\n    .sort((a, b) => a.localeCompare(b))\n    .join(\"+\");\n}\n\ntype CombinationPlannerArgs = {\n  candidates: Table[];\n  partySize: number;\n  weights: SelectorScoringWeights;\n  adjacency: Map<string, Set<string>>;\n  maxAllowedCapacity: number;\n  kMax: number;\n  bucketLimit: number;\n  evaluationLimit: number;\n  diagnostics: CandidateDiagnostics;\n  requireAdjacency: boolean;\n  tableScarcityScores: Map<string, number>;\n  demandMultiplier: number;\n};\n\n/**\n * Enumerates multi-table plans honoring adjacency, kMax, zone-locking, and per-slack limits.\n *\n * Tables are grouped by slack buckets and trimmed to the configured per-slack cap.\n * The search short-circuits when either the evaluation limit, zone guard, or\n * adjacency requirements disqualify further combinations, ensuring consistent\n * diagnostics for skipped plans.\n */\nfunction enumerateCombinationPlans(args: CombinationPlannerArgs): RankedTablePlan[] {\n  const {\n    candidates,\n    partySize,\n    weights,\n    adjacency,\n    maxAllowedCapacity,\n    kMax,\n    bucketLimit,\n    evaluationLimit,\n    diagnostics,\n    requireAdjacency,\n    tableScarcityScores,\n    demandMultiplier,\n  } = args;\n\n  if (kMax <= 1) {\n    return [];\n  }\n\n  const seenKeys = new Set<string>();\n  const buckets = new Map<number, RankedTablePlan[]>();\n  const sortedCandidates = [...candidates].sort((a, b) => {\n    const capacityDiff = (a.capacity ?? 0) - (b.capacity ?? 0);\n    if (capacityDiff !== 0) {\n      return capacityDiff;\n    }\n    const nameA = a.tableNumber ?? a.id;\n    const nameB = b.tableNumber ?? b.id;\n    return nameA.localeCompare(nameB);\n  });\n  const candidateLookup = new Map(sortedCandidates.map((table) => [table.id, table]));\n\n  const buildFrontier = (selectionIds: Set<string>): Set<string> => {\n    const frontierIds = new Set<string>();\n    for (const id of selectionIds) {\n      const neighbors = adjacency.get(id);\n      if (!neighbors) {\n        continue;\n      }\n      for (const neighbor of neighbors) {\n        if (!selectionIds.has(neighbor) && candidateLookup.has(neighbor)) {\n          frontierIds.add(neighbor);\n        }\n      }\n    }\n    return frontierIds;\n  };\n\n  const updateFrontierSet = (\n    currentFrontier: Set<string> | null,\n    selectionIds: Set<string>,\n    candidate: Table,\n  ): Set<string> => {\n    const next = new Set<string>();\n    if (currentFrontier) {\n      for (const id of currentFrontier) {\n        if (!selectionIds.has(id)) {\n          next.add(id);\n        }\n      }\n    }\n    const neighbors = adjacency.get(candidate.id);\n    if (neighbors) {\n      for (const neighbor of neighbors) {\n        if (!selectionIds.has(neighbor) && candidateLookup.has(neighbor)) {\n          next.add(neighbor);\n        }\n      }\n    }\n    next.delete(candidate.id);\n    return next;\n  };\n\n  const gatherCandidateIdsFromIndex = (startIndex: number, selectionIds: Set<string>): string[] => {\n    const ids: string[] = [];\n    for (let idx = startIndex; idx < sortedCandidates.length; idx += 1) {\n      const table = sortedCandidates[idx];\n      if (selectionIds.has(table.id)) {\n        continue;\n      }\n      ids.push(table.id);\n    }\n    return ids;\n  };\n\n  const computeCapacityUpperBound = (\n    candidateIds: string[],\n    remainingSlots: number,\n    baseZoneId: string | null,\n    selectionIds: Set<string>,\n  ): number => {\n    if (remainingSlots <= 0) {\n      return 0;\n    }\n    const capacities: number[] = [];\n    for (const id of candidateIds) {\n      if (selectionIds.has(id)) {\n        continue;\n      }\n      const table = candidateLookup.get(id);\n      if (!table) {\n        continue;\n      }\n      if (baseZoneId && table.zoneId && table.zoneId !== baseZoneId) {\n        continue;\n      }\n      capacities.push(table.capacity ?? 0);\n    }\n    capacities.sort((a, b) => b - a);\n    return capacities.slice(0, remainingSlots).reduce((sum, value) => sum + value, 0);\n  };\n\n  let evaluations = 0;\n  let enumerated = diagnostics.combinationsEnumerated ?? 0;\n  let accepted = diagnostics.combinationsAccepted ?? 0;\n  let limitRecorded = false;\n  let timeoutRecorded = false;\n  let stopSearch = false;\n  let timedOut = false;\n\n  const registerPlan = (plan: RankedTablePlan) => {\n    const bucket = buckets.get(plan.slack) ?? [];\n    bucket.push(plan);\n    bucket.sort((a, b) => comparePlans(a, b, weights));\n    if (bucket.length > bucketLimit) {\n      bucket.length = bucketLimit;\n      incrementCounter(diagnostics.skipped, \"bucket\");\n    }\n    buckets.set(plan.slack, bucket);\n    accepted += 1;\n    diagnostics.combinationsAccepted = accepted;\n  };\n\n  const createDfs = (startMs: number, budgetMs: number) => {\n    const dfsInner = (\n      startIndex: number,\n      selection: Table[],\n      selectionIds: Set<string>,\n      runningCapacity: number,\n      baseZoneId: string | null,\n      frontier: Set<string> | null,\n    ) => {\n      if (stopSearch) {\n        return;\n      }\n\n      if (!timedOut && performance.now() - startMs >= budgetMs) {\n        stopSearch = true;\n        timedOut = true;\n        if (!timeoutRecorded) {\n          incrementCounter(diagnostics.skipped, \"timeout\");\n          timeoutRecorded = true;\n        }\n        return;\n      }\n\n      if (requireAdjacency && frontier && frontier.size === 0 && selection.length < kMax) {\n        incrementCounter(diagnostics.skipped, \"adjacency_frontier\");\n        return;\n      }\n\n      if (selection.length >= 2 && runningCapacity >= partySize) {\n        enumerated += 1;\n        diagnostics.combinationsEnumerated = enumerated;\n\n        const key = buildTableKey(selection);\n        if (!seenKeys.has(key)) {\n          seenKeys.add(key);\n          const adjacencyEvaluation = evaluateAdjacency(selection, adjacency);\n          if (!adjacencyEvaluation.connected && requireAdjacency) {\n            incrementCounter(diagnostics.skipped, \"adjacency\");\n          } else {\n            const metrics = computeMetrics(selection, partySize, adjacencyEvaluation.depths, tableScarcityScores);\n            const { score, breakdown } = computeScore(metrics, weights, demandMultiplier);\n            const totalCapacity = metrics.overage + partySize;\n            const adjacencyStatus: RankedTablePlan[\"adjacencyStatus\"] =\n              selection.length <= 1\n                ? \"single\"\n                : adjacencyEvaluation.connected\n                  ? \"connected\"\n                  : \"disconnected\";\n            const plan: RankedTablePlan = {\n              tables: [...selection],\n              totalCapacity,\n              slack: metrics.overage,\n              metrics,\n              score,\n              tableKey: key,\n              adjacencyStatus,\n              scoreBreakdown: breakdown,\n            };\n            registerPlan(plan);\n          }\n        }\n\n        evaluations += 1;\n        if (evaluations >= evaluationLimit) {\n          stopSearch = true;\n          if (!limitRecorded) {\n            incrementCounter(diagnostics.skipped, \"limit\");\n            limitRecorded = true;\n          }\n          return;\n        }\n      }\n\n      if (selection.length >= kMax) {\n        if (runningCapacity < partySize) {\n          incrementCounter(diagnostics.skipped, \"capacity\");\n        }\n        incrementCounter(diagnostics.skipped, \"kmax\");\n        return;\n      }\n\n      const remainingSlots = kMax - selection.length;\n      if (remainingSlots > 0) {\n        let candidateIdsForUpperBound: string[] = [];\n        if (requireAdjacency) {\n          candidateIdsForUpperBound = frontier ? Array.from(frontier) : [];\n        } else {\n          candidateIdsForUpperBound = gatherCandidateIdsFromIndex(startIndex, selectionIds);\n        }\n        const capacityUpperBound = computeCapacityUpperBound(candidateIdsForUpperBound, remainingSlots, baseZoneId, selectionIds);\n        if (runningCapacity + capacityUpperBound < partySize) {\n          incrementCounter(diagnostics.skipped, \"capacity_upper_bound\");\n          return;\n        }\n      }\n\n      for (let index = startIndex; index < sortedCandidates.length; index += 1) {\n        if (stopSearch) {\n          break;\n        }\n\n        const candidate = sortedCandidates[index];\n\n        if (selectionIds.has(candidate.id)) {\n          continue;\n        }\n\n        if (requireAdjacency && frontier && !frontier.has(candidate.id)) {\n          continue;\n        }\n\n        if (selection.length > 0 && baseZoneId && candidate.zoneId && candidate.zoneId !== baseZoneId) {\n          incrementCounter(diagnostics.skipped, \"zone\");\n          continue;\n        }\n\n        if (selection.length + 1 > kMax) {\n          incrementCounter(diagnostics.skipped, \"kmax\");\n          continue;\n        }\n\n        const nextCapacity = runningCapacity + (candidate.capacity ?? 0);\n\n        if (nextCapacity > maxAllowedCapacity) {\n          incrementCounter(diagnostics.skipped, \"overage\");\n          break;\n        }\n\n        const nextZoneId = baseZoneId ?? candidate.zoneId ?? null;\n        const nextSelection = [...selection, candidate];\n        const nextSelectionIds = new Set(selectionIds);\n        nextSelectionIds.add(candidate.id);\n        const nextFrontier = requireAdjacency ? updateFrontierSet(frontier, nextSelectionIds, candidate) : null;\n\n        dfsInner(index + 1, nextSelection, nextSelectionIds, nextCapacity, nextZoneId, nextFrontier);\n      }\n    };\n\n    return dfsInner;\n  };\n\n  const dfs = createDfs(\n    performance.now(),\n    diagnostics.limits.enumerationTimeoutMs ?? DEFAULT_ENUMERATION_TIMEOUT_MS,\n  );\n\n  for (let i = 0; i < sortedCandidates.length && !stopSearch; i += 1) {\n    const base = sortedCandidates[i];\n    const baseSelection = [base];\n    const baseSelectionIds = new Set<string>([base.id]);\n    const baseFrontier = requireAdjacency ? buildFrontier(baseSelectionIds) : null;\n    dfs(i + 1, baseSelection, baseSelectionIds, base.capacity ?? 0, base.zoneId ?? null, baseFrontier);\n  }\n\n  if (timedOut) {\n    console.warn(\"[selector] combination enumeration timed out\", {\n      partySize,\n      tableCount: sortedCandidates.length,\n      timeoutMs: diagnostics.limits.enumerationTimeoutMs ?? DEFAULT_ENUMERATION_TIMEOUT_MS,\n      evaluations,\n    });\n  }\n\n  return Array.from(buckets.values())\n    .flat()\n    .sort((a, b) => comparePlans(a, b, weights));\n}\n\nfunction evaluateAdjacency(\n  tables: Table[],\n  adjacency: Map<string, Set<string>>,\n): { connected: boolean; depths: Map<string, number> } {\n  if (tables.length === 0) {\n    return { connected: true, depths: new Map() };\n  }\n\n  if (tables.length === 1) {\n    return { connected: true, depths: new Map([[tables[0].id, 0]]) };\n  }\n\n  const tableIds = tables.map((table) => table.id);\n  const selection = new Set(tableIds);\n  const depths = new Map<string, number>();\n  const queue: string[] = [];\n\n  const [firstId] = tableIds;\n  queue.push(firstId);\n  depths.set(firstId, 0);\n\n  while (queue.length > 0) {\n    const current = queue.shift();\n    if (!current) {\n      continue;\n    }\n    const neighbors = adjacency.get(current);\n    if (!neighbors) {\n      continue;\n    }\n    for (const neighbor of neighbors) {\n      if (!selection.has(neighbor) || depths.has(neighbor)) {\n        continue;\n      }\n      const depth = (depths.get(current) ?? 0) + 1;\n      depths.set(neighbor, depth);\n      queue.push(neighbor);\n    }\n  }\n\n  const connected = depths.size === selection.size;\n  return { connected, depths };\n}\n"
    },
    {
      "path": "server/capacity/service.ts",
      "size": 3571,
      "sha256": "08354c0808e3a3dc997c05866bd234652b690aba57822d939db9266b062b30a3",
      "language": "typescript",
      "content": "\nimport { getServicePeriods } from \"@/server/restaurants/servicePeriods\";\nimport { getServiceSupabaseClient } from \"@/server/supabase\";\n\nimport type {\n  AvailabilityCheckParams,\n  AvailabilityResult,\n  AlternativeSlotParams,\n  TimeSlot,\n  ServicePeriodWithCapacity,\n  PeriodUtilization,\n} from \"./types\";\nimport type { Database } from \"@/types/supabase\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\n\ntype DbClient = SupabaseClient<Database, \"public\", any>;\n\nconst DEFAULT_AVAILABLE_COVERS = Number.MAX_SAFE_INTEGER;\n\nfunction parseTimeToMinutes(value: string | null | undefined): number | null {\n  if (!value) return null;\n  const match = value.match(/^([0-9]{1,2}):([0-9]{2})(?::([0-9]{2}))?$/);\n  if (!match) return null;\n  const hours = Number.parseInt(match[1]!, 10);\n  const minutes = Number.parseInt(match[2]!, 10) + (match[3] ? Number.parseInt(match[3]!, 10) : 0);\n  return hours * 60 + minutes;\n}\n\nfunction matchServicePeriod(time: string, periods: ServicePeriodWithCapacity[]): ServicePeriodWithCapacity | null {\n  const target = parseTimeToMinutes(time);\n  if (target === null) {\n    return null;\n  }\n\n  for (const period of periods) {\n    const start = parseTimeToMinutes(period.startTime);\n    const end = parseTimeToMinutes(period.endTime);\n    if (start === null || end === null) {\n      continue;\n    }\n\n    if (end > start) {\n      if (target >= start && target < end) {\n        return period;\n      }\n    } else {\n      // Handle overnight windows (e.g. 22:00 -> 02:00)\n      if (target >= start || target < end) {\n        return period;\n      }\n    }\n  }\n\n  return null;\n}\n\nexport async function getServicePeriodsWithCapacity(\n  restaurantId: string,\n  _date?: string,\n  client?: DbClient,\n): Promise<ServicePeriodWithCapacity[]> {\n  const supabase = client ?? getServiceSupabaseClient();\n  const servicePeriods = await getServicePeriods(restaurantId, supabase);\n\n  return servicePeriods.map((period) => ({\n    periodId: period.id,\n    periodName: period.name,\n    startTime: period.startTime,\n    endTime: period.endTime,\n    maxCovers: null,\n    maxParties: null,\n    dayOfWeek: period.dayOfWeek ?? null,\n  }));\n}\n\nexport async function checkSlotAvailability(\n  params: AvailabilityCheckParams,\n  client?: DbClient,\n): Promise<AvailabilityResult> {\n  const periods = await getServicePeriodsWithCapacity(params.restaurantId, params.date, client);\n  const activePeriod = matchServicePeriod(params.time, periods);\n\n  return {\n    available: true,\n    reason: undefined,\n    metadata: {\n      servicePeriod: activePeriod?.periodName,\n      maxCovers: null,\n      bookedCovers: 0,\n      availableCovers: DEFAULT_AVAILABLE_COVERS,\n      utilizationPercent: 0,\n      maxParties: null,\n      bookedParties: 0,\n    },\n  };\n}\n\nexport async function findAlternativeSlots(\n  _params: AlternativeSlotParams,\n  _client?: DbClient,\n): Promise<TimeSlot[]> {\n  return [];\n}\n\nexport async function calculateCapacityUtilization(\n  restaurantId: string,\n  date: string,\n  client?: DbClient,\n): Promise<{ date: string; periods: PeriodUtilization[]; hasOverbooking: boolean }> {\n  const periods = await getServicePeriodsWithCapacity(restaurantId, date, client);\n\n  return {\n    date,\n    hasOverbooking: false,\n    periods: periods.map((period) => ({\n      periodId: period.periodId,\n      periodName: period.periodName,\n      startTime: period.startTime,\n      endTime: period.endTime,\n      bookedCovers: 0,\n      bookedParties: 0,\n      maxCovers: null,\n      maxParties: null,\n      utilizationPercentage: 0,\n      isOverbooked: false,\n    })),\n  };\n}\n"
    },
    {
      "path": "server/capacity/strategic-config.ts",
      "size": 9105,
      "sha256": "525b7c610b72229e523c312ca413535f938df922a273e08832368763dbc8f4e4",
      "language": "typescript",
      "content": "import path from \"node:path\";\n\nimport { env } from \"@/lib/env\";\nimport { getServiceSupabaseClient } from \"@/server/supabase\";\n\nimport type { Database } from \"@/types/supabase\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\n\nconst DEFAULT_DEMAND_PROFILE_RELATIVE_PATH = \"config/demand-profiles.json\";\nexport const DEFAULT_SCARCITY_WEIGHT = 22;\nconst MIN_SCARCITY_WEIGHT = 0;\nconst MAX_SCARCITY_WEIGHT = 1000;\nconst CACHE_TTL_MS = 30_000;\nconst GLOBAL_CACHE_KEY = \"__global__\";\n\ntype DbClient = SupabaseClient<Database, \"public\">;\n\nexport type StrategicConfigSource = \"env\" | \"db\";\n\nexport type StrategicConfigState = {\n  scarcityWeight: number;\n  demandMultiplierOverride: number | null;\n  futureConflictPenalty: number | null;\n  updatedAt: string | null;\n  source: StrategicConfigSource;\n};\n\ntype StrategicConfigCacheEntry = {\n  state: StrategicConfigState;\n  expiresAt: number;\n};\n\nexport type StrategicConfigSnapshotOptions = {\n  restaurantId?: string | null;\n};\n\nexport type StrategicConfigLoadOptions = StrategicConfigSnapshotOptions & {\n  client?: DbClient;\n  force?: boolean;\n};\n\ntype StrategicConfigOverride = Partial<StrategicConfigState> & StrategicConfigSnapshotOptions & {\n  source?: StrategicConfigSource;\n};\n\ntype StrategicConfigRow = {\n  scarcity_weight: number | null;\n  demand_multiplier_override: number | null;\n  future_conflict_penalty: number | null;\n  updated_at: string | null;\n};\n\nlet testScarcityWeight: number | null = null;\nlet testDemandProfilePath: string | null = null;\nlet testConfigOverride: Partial<StrategicConfigState> | null = null;\n\nconst configCache = new Map<string, StrategicConfigCacheEntry>();\n\nfunction clamp(value: number, min: number, max: number): number {\n  if (!Number.isFinite(value)) {\n    return min;\n  }\n  if (value < min) {\n    return min;\n  }\n  if (value > max) {\n    return max;\n  }\n  return value;\n}\n\nfunction resolveConfigPath(rawPath?: string | null): string {\n  if (!rawPath) {\n    return path.join(process.cwd(), DEFAULT_DEMAND_PROFILE_RELATIVE_PATH);\n  }\n  if (path.isAbsolute(rawPath)) {\n    return rawPath;\n  }\n  return path.join(process.cwd(), rawPath);\n}\n\nfunction computeCacheKey(restaurantId: string | null): string {\n  return restaurantId ?? GLOBAL_CACHE_KEY;\n}\n\nfunction createEnvState(): StrategicConfigState {\n  const scarcityWeight = clamp(\n    env.strategic.scarcityWeight ?? DEFAULT_SCARCITY_WEIGHT,\n    MIN_SCARCITY_WEIGHT,\n    MAX_SCARCITY_WEIGHT,\n  );\n\n  return {\n    scarcityWeight,\n    demandMultiplierOverride: null,\n    futureConflictPenalty: null,\n    updatedAt: null,\n    source: \"env\",\n  } as const;\n}\n\nfunction ensureCacheEntry(key: string): StrategicConfigCacheEntry {\n  const existing = configCache.get(key);\n  if (existing) {\n    return existing;\n  }\n\n  const base = createEnvState();\n  const entry: StrategicConfigCacheEntry = {\n    state: key === GLOBAL_CACHE_KEY ? base : { ...base },\n    expiresAt: 0,\n  };\n  configCache.set(key, entry);\n  return entry;\n}\n\nfunction applyTestOverrides(state: StrategicConfigState): StrategicConfigState {\n  const scarcity =\n    typeof testScarcityWeight === \"number\"\n      ? clamp(testScarcityWeight, MIN_SCARCITY_WEIGHT, MAX_SCARCITY_WEIGHT)\n      : state.scarcityWeight;\n\n  const base: StrategicConfigState = {\n    ...state,\n    scarcityWeight: scarcity,\n  };\n\n  if (!testConfigOverride) {\n    return base;\n  }\n\n  return {\n    ...base,\n    ...testConfigOverride,\n    scarcityWeight:\n      typeof testConfigOverride.scarcityWeight === \"number\"\n        ? clamp(testConfigOverride.scarcityWeight, MIN_SCARCITY_WEIGHT, MAX_SCARCITY_WEIGHT)\n        : base.scarcityWeight,\n    source: testConfigOverride.source ?? base.source,\n  };\n}\n\nfunction mapRowToState(row: StrategicConfigRow): StrategicConfigState {\n  const scarcity = clamp(Number(row.scarcity_weight ?? DEFAULT_SCARCITY_WEIGHT), MIN_SCARCITY_WEIGHT, MAX_SCARCITY_WEIGHT);\n  const demandOverride = row.demand_multiplier_override;\n  const futurePenalty = row.future_conflict_penalty;\n\n  return {\n    scarcityWeight: scarcity,\n    demandMultiplierOverride: demandOverride === null ? null : Number(demandOverride),\n    futureConflictPenalty: futurePenalty === null ? null : Number(futurePenalty),\n    updatedAt: row.updated_at ?? null,\n    source: \"db\",\n  };\n}\n\nasync function fetchStrategicConfigFromDb(\n  client: DbClient,\n  restaurantId: string | null,\n): Promise<StrategicConfigState | null> {\n  const query = client\n    .from(\"strategic_configs\")\n    .select(\"scarcity_weight, demand_multiplier_override, future_conflict_penalty, updated_at\")\n    .order(\"updated_at\", { ascending: false })\n    .limit(1);\n\n  const { data, error } = restaurantId\n    ? await query.eq(\"restaurant_id\", restaurantId).maybeSingle()\n    : await query.is(\"restaurant_id\", null).maybeSingle();\n\n  if (error) {\n    const errorCode = typeof error === \"object\" && error && \"code\" in error ? String((error as { code?: string }).code ?? \"\") : \"\";\n    const message = typeof error === \"object\" && error && \"message\" in error ? String((error as { message?: string }).message ?? \"\") : \"\";\n    const isMissingTable = errorCode === \"42P01\" || /unexpected table\\s+strategic_configs/i.test(message) || /relation .*strategic_configs.* does not exist/i.test(message);\n    const isMissingColumns = errorCode === \"42703\" || /column\\s+strategic_configs\\./i.test(message);\n    if (isMissingTable || isMissingColumns) {\n      console.warn(\"[strategic-config] schema unavailable; falling back to env state\", { error: message || errorCode });\n      return null;\n    }\n    throw error;\n  }\n\n  if (!data) {\n    return null;\n  }\n\n  return mapRowToState(data as StrategicConfigRow);\n}\n\nfunction storeState(key: string, state: StrategicConfigState, ttlMs: number): void {\n  const entry = ensureCacheEntry(key);\n  entry.state = { ...state };\n  entry.expiresAt = Date.now() + ttlMs;\n}\n\nexport function getDemandProfileConfigPath(): string {\n  if (testDemandProfilePath) {\n    return testDemandProfilePath;\n  }\n  return resolveConfigPath(env.strategic.demandProfilePath);\n}\n\nexport function getStrategicConfigSnapshot(options: StrategicConfigSnapshotOptions = {}): StrategicConfigState {\n  const key = computeCacheKey(options.restaurantId ?? null);\n  const entry = ensureCacheEntry(key);\n  return applyTestOverrides({ ...entry.state });\n}\n\nexport function getStrategicScarcityWeight(options: StrategicConfigSnapshotOptions = {}): number {\n  const snapshot = getStrategicConfigSnapshot(options);\n  return clamp(snapshot.scarcityWeight ?? DEFAULT_SCARCITY_WEIGHT, MIN_SCARCITY_WEIGHT, MAX_SCARCITY_WEIGHT);\n}\n\nexport async function loadStrategicConfig(options: StrategicConfigLoadOptions = {}): Promise<StrategicConfigState> {\n  const { restaurantId = null, client, force = false } = options;\n  const key = computeCacheKey(restaurantId);\n  const entry = ensureCacheEntry(key);\n  const now = Date.now();\n\n  if (!force && entry.expiresAt > now) {\n    return getStrategicConfigSnapshot({ restaurantId });\n  }\n\n  const supabase = client ?? getServiceSupabaseClient();\n\n  let loadedState: StrategicConfigState | null = null;\n\n  try {\n    if (restaurantId) {\n      loadedState = await fetchStrategicConfigFromDb(supabase, restaurantId);\n    }\n\n    if (!loadedState) {\n      loadedState = await fetchStrategicConfigFromDb(supabase, null);\n      if (loadedState) {\n        storeState(GLOBAL_CACHE_KEY, loadedState, CACHE_TTL_MS);\n      }\n    }\n  } catch (error) {\n    entry.expiresAt = now + CACHE_TTL_MS;\n    throw error;\n  }\n\n  if (!loadedState) {\n    loadedState = createEnvState();\n  }\n\n  storeState(key, loadedState, CACHE_TTL_MS);\n  return getStrategicConfigSnapshot({ restaurantId });\n}\n\nexport function applyStrategicConfigOverride(override: StrategicConfigOverride): void {\n  const key = computeCacheKey(override.restaurantId ?? null);\n  const entry = ensureCacheEntry(key);\n  const next: StrategicConfigState = {\n    ...entry.state,\n    ...override,\n    source: override.source ?? entry.state.source,\n    scarcityWeight: clamp(\n      typeof override.scarcityWeight === \"number\" ? override.scarcityWeight : entry.state.scarcityWeight,\n      MIN_SCARCITY_WEIGHT,\n      MAX_SCARCITY_WEIGHT,\n    ),\n  };\n\n  entry.state = next;\n  entry.expiresAt = Date.now() + CACHE_TTL_MS;\n}\n\nexport function invalidateStrategicConfigCache(restaurantId?: string | null): void {\n  if (typeof restaurantId === \"undefined\") {\n    configCache.clear();\n    return;\n  }\n  const key = computeCacheKey(restaurantId);\n  configCache.delete(key);\n}\n\nexport function setStrategicScarcityWeightForTests(weight?: number | null): void {\n  testScarcityWeight = typeof weight === \"number\" ? weight : null;\n}\n\nexport function setDemandProfileConfigPathForTests(overridePath?: string | null): void {\n  testDemandProfilePath = overridePath && overridePath.length > 0 ? overridePath : null;\n}\n\nexport function setStrategicConfigForTests(override: Partial<StrategicConfigState> | null): void {\n  testConfigOverride = override;\n}\n\nexport function resetStrategicConfigTestOverrides(): void {\n  testScarcityWeight = null;\n  testDemandProfilePath = null;\n  testConfigOverride = null;\n  configCache.clear();\n}\n"
    },
    {
      "path": "server/capacity/strategic-maintenance.ts",
      "size": 556,
      "sha256": "1bd822136c3e328b2dcba3a3cb2965ad6950f3b7722f30fc585e2de35f92eb10",
      "language": "typescript",
      "content": "import { clearAllDemandProfileCaches } from \"./demand-profiles\";\nimport { clearScarcityCache } from \"./scarcity\";\nimport { invalidateStrategicConfigCache } from \"./strategic-config\";\n\n/**\n * Clears all in-memory caches used by strategic scoring (scarcity + demand profiles).\n * Invoke after updating configuration files or Supabase data to ensure the planner\n * observes new weights without a process restart.\n */\nexport function clearStrategicCaches(): void {\n  clearScarcityCache();\n  clearAllDemandProfileCaches();\n  invalidateStrategicConfigCache();\n}\n"
    },
    {
      "path": "server/capacity/tables.ts",
      "size": 111319,
      "sha256": "b18804cb90e0c1d0c1554e625353f8e47f6407c784afb59087a0858eb65e2d6a",
      "language": "typescript",
      "content": "import { DateTime } from \"luxon\";\nimport { randomUUID } from \"node:crypto\";\nimport { performance } from \"node:perf_hooks\";\n\nimport { BOOKING_BLOCKING_STATUSES } from \"@/lib/enums\";\nimport {\n  getAllocatorAdjacencyMinPartySize,\n  getAllocatorKMax as getAllocatorCombinationLimit,\n  getSelectorPlannerLimits,\n  isAllocatorAdjacencyRequired,\n  isAllocatorServiceFailHard,\n  isAllocatorV2Enabled,\n  isCombinationPlannerEnabled,\n  isHoldsEnabled,\n  isHoldStrictConflictsEnabled,\n  isPlannerTimePruningEnabled,\n  isAdjacencyQueryUndirected,\n  isOpsMetricsEnabled,\n  isSelectorScoringEnabled,\n  isSelectorLookaheadEnabled,\n  getSelectorLookaheadWindowMinutes,\n  getSelectorLookaheadPenaltyWeight,\n  getSelectorLookaheadBlockThreshold,\n  getContextQueryPaddingMinutes,\n} from \"@/server/feature-flags\";\nimport { getServiceSupabaseClient } from \"@/server/supabase\";\n\nimport { resolveDemandMultiplier, type DemandMultiplierResult } from \"./demand-profiles\";\nimport {\n  AssignTablesRpcError,\n  HoldConflictError,\n  HoldNotFoundError,\n  createTableHold,\n  findHoldConflicts,\n  listActiveHoldsForBooking,\n  releaseTableHold,\n  type CreateTableHoldInput,\n  type HoldConflictInfo,\n  type TableHold,\n} from \"./holds\";\nimport { createAvailabilityBitset, markWindow, isWindowFree } from \"./planner/bitset\";\nimport {\n  bandDuration,\n  getBufferConfig,\n  getSelectorScoringConfig,\n  getVenuePolicy,\n  getYieldManagementScarcityWeight,\n  serviceEnd,\n  whichService,\n  type SelectorScoringConfig,\n  type ServiceKey,\n  type VenuePolicy,\n  ServiceNotFoundError,\n  ServiceOverrunError,\n} from \"./policy\";\nimport { loadTableScarcityScores } from \"./scarcity\";\nimport {\n  buildScoredTablePlans,\n  type RankedTablePlan,\n  type CandidateDiagnostics,\n  type BuildCandidatesResult,\n} from \"./selector\";\nimport { loadStrategicConfig } from \"./strategic-config\";\nimport { emitRpcConflict, emitSelectorQuote, summarizeCandidate, type CandidateSummary, type SelectorDecisionEvent } from \"./telemetry\";\nimport {\n  AssignmentConflictError,\n  AssignmentOrchestrator,\n  AssignmentRepositoryError,\n  AssignmentValidationError,\n  SupabaseAssignmentRepository,\n  createPlanSignature,\n  createDeterministicIdempotencyKey,\n  hashPolicyVersion,\n  computePayloadChecksum,\n  normalizeTableIds,\n} from \"./v2\";\n\nimport type { Database, Tables } from \"@/types/supabase\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\n\ntype DbClient = SupabaseClient<Database, \"public\">;\n\ntype TableInventoryRow = Tables<\"table_inventory\">;\n\nconst TABLE_INVENTORY_SELECT =\n  \"id,table_number,capacity,min_party_size,max_party_size,section,category,seating_type,mobility,zone_id,status,active,position\" as const;\n\ntype TableHoldRow = Tables<\"table_holds\"> & {\n  table_hold_members: Array<{ table_id: string | null }> | null;\n};\n\n\ntype AssignmentAvailabilityRow = {\n  table_id: string | null;\n  start_at: string | null;\n  end_at: string | null;\n  bookings: Pick<Tables<\"bookings\">, \"id\" | \"status\" | \"start_at\" | \"end_at\"> | null;\n};\n\nconst DEFAULT_HOLD_TTL_SECONDS = 180;\nconst TABLE_RESOURCE_TYPE = \"table\";\n\nexport type Table = {\n  id: string;\n  tableNumber: string;\n  capacity: number;\n  minPartySize?: number | null;\n  maxPartySize?: number | null;\n  section?: string | null;\n  category?: Tables<\"table_inventory\">[\"category\"] | string | null;\n  seatingType?: Tables<\"table_inventory\">[\"seating_type\"] | string | null;\n  mobility?: Tables<\"table_inventory\">[\"mobility\"] | string | null;\n  zoneId: string;\n  status?: Tables<\"table_inventory\">[\"status\"] | string | null;\n  active?: boolean | null;\n  position?: Tables<\"table_inventory\">[\"position\"] | null;\n};\n\nexport type TableMatchParams = {\n  partySize: number;\n  requireAdjacency?: boolean;\n  avoidTableIds?: string[];\n  zoneId?: string | null;\n};\n\nexport type TableAssignmentMember = {\n  tableId: string;\n  assignmentId: string;\n  startAt: string;\n  endAt: string;\n  mergeGroupId?: string | null;\n};\n\nexport type TableAssignmentGroup = {\n  bookingId: string;\n  tableIds: string[];\n  assignments: TableAssignmentMember[];\n};\n\nexport type ManualSelectionCheck = {\n  id: \"capacity\" | \"zone\" | \"movable\" | \"adjacency\" | \"conflict\" | \"holds\";\n  status: \"ok\" | \"warning\" | \"error\";\n  message: string;\n  details?: Record<string, unknown>;\n};\n\nexport type ManualSelectionSummary = {\n  tableCount: number;\n  totalCapacity: number;\n  slack: number;\n  zoneId: string | null;\n  tableNumbers: string[];\n  partySize: number;\n};\n\nexport type ManualValidationResult = {\n  ok: boolean;\n  summary: ManualSelectionSummary;\n  checks: ManualSelectionCheck[];\n  policyVersion?: string;\n};\n\nexport type ManualSelectionOptions = {\n  bookingId: string;\n  tableIds: string[];\n  requireAdjacency?: boolean;\n  excludeHoldId?: string | null;\n  client?: DbClient;\n};\n\nexport type ManualHoldOptions = ManualSelectionOptions & {\n  createdBy: string;\n  holdTtlSeconds?: number;\n  holdExpiresAt?: string;\n};\n\nexport type ManualHoldResult = {\n  hold: TableHold | null;\n  validation: ManualValidationResult;\n};\n\nfunction buildSelectorFeatureFlagsTelemetry(): {\n  selectorScoring: boolean;\n  opsMetrics: boolean;\n  plannerTimePruning: boolean;\n  adjacencyUndirected: boolean;\n  holdsStrictConflicts: boolean;\n  allocatorFailHard: boolean;\n  selectorLookahead: boolean;\n} {\n  return {\n    selectorScoring: isSelectorScoringEnabled(),\n    opsMetrics: isOpsMetricsEnabled(),\n    plannerTimePruning: isPlannerTimePruningEnabled(),\n    adjacencyUndirected: isAdjacencyQueryUndirected(),\n    holdsStrictConflicts: isHoldStrictConflictsEnabled(),\n    allocatorFailHard: isAllocatorServiceFailHard(),\n    selectorLookahead: isSelectorLookaheadEnabled(),\n  };\n}\n\nexport type QuoteTablesOptions = {\n  bookingId: string;\n  zoneId?: string | null;\n  maxTables?: number;\n  requireAdjacency?: boolean;\n  avoidTables?: string[];\n  holdTtlSeconds?: number;\n  createdBy: string;\n  client?: DbClient;\n};\n\nexport type QuoteTablesResult = {\n  hold: TableHold | null;\n  candidate: CandidateSummary | null;\n  alternates: CandidateSummary[];\n  nextTimes: string[];\n  reason?: string;\n  skipped?: Array<{ candidate: CandidateSummary; reason: string; conflicts: HoldConflictInfo[] }>;\n  metadata?: {\n    usedFallback: boolean;\n    fallbackService: ServiceKey | null;\n  };\n};\n\nexport type ManualAssignmentConflict = {\n  tableId: string;\n  bookingId: string | null;\n  startAt: string;\n  endAt: string;\n  source: \"booking\" | \"hold\";\n};\n\nexport type ManualAssignmentContextHold = TableHold & {\n  createdByName?: string | null;\n  createdByEmail?: string | null;\n  summary?: ManualSelectionSummary;\n};\n\nexport type ManualAssignmentContext = {\n  booking: Tables<\"bookings\">;\n  tables: Table[];\n  bookingAssignments: string[];\n  holds: ManualAssignmentContextHold[];\n  activeHold: ManualAssignmentContextHold | null;\n  conflicts: ManualAssignmentConflict[];\n  window: {\n    startAt: string | null;\n    endAt: string | null;\n  };\n  flags?: {\n    holdsStrictConflicts: boolean;\n    adjacencyRequired: boolean;\n    adjacencyUndirected: boolean;\n  };\n  // Snapshot/hash of current context (holds+assignments+flags+window)\n  contextVersion?: string;\n  // Server-authoritative clock reference for client countdowns\n  serverNow?: string;\n};\n\ntype BookingRow = Tables<\"bookings\"> & {\n  restaurants?: { timezone: string | null } | { timezone: string | null }[];\n};\n\ntype ContextBookingRow = {\n  id: string;\n  party_size: number;\n  status: string;\n  start_time: string | null;\n  end_time: string | null;\n  start_at: string | null;\n  end_at: string | null;\n  booking_date: string | null;\n  seating_preference?: string | null;\n  booking_table_assignments: Array<{ table_id: string | null }> | null;\n};\n\ntype BusyWindow = {\n  tableId: string;\n  startAt: string;\n  endAt: string;\n  bookingId: string | null;\n  source: \"booking\" | \"hold\";\n};\n\ntype AvailabilityMap = Map<\n  string,\n  {\n    bitset: ReturnType<typeof createAvailabilityBitset>;\n    windows: BusyWindow[];\n  }\n>;\n\nexport class ManualSelectionInputError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string = \"MANUAL_SELECTION_INPUT_INVALID\",\n    public readonly status = 400,\n  ) {\n    super(message);\n    this.name = \"ManualSelectionInputError\";\n  }\n}\n\nfunction ensureClient(client?: DbClient): DbClient {\n  return client ?? getServiceSupabaseClient();\n}\n\nfunction extractErrorCode(error: unknown): string | undefined {\n  if (typeof error !== \"object\" || error === null) {\n    return undefined;\n  }\n  const code = (error as { code?: unknown }).code;\n  return typeof code === \"string\" ? code : undefined;\n}\n\nfunction normalizeBookingRow(row: BookingRow): BookingRow {\n  if (Array.isArray(row.restaurants) && row.restaurants.length > 0) {\n    return { ...row, restaurants: row.restaurants[0] ?? null };\n  }\n  return row;\n}\n\nasync function releaseHoldWithRetry(params: { holdId: string; client: DbClient; attempts?: number; baseDelayMs?: number }): Promise<void> {\n  const { holdId, client, attempts = 3, baseDelayMs = 50 } = params;\n  for (let attempt = 1; attempt <= attempts; attempt += 1) {\n    try {\n      await releaseTableHold({ holdId, client });\n      return;\n    } catch (error) {\n      if (attempt === attempts) {\n        throw error;\n      }\n      const jitter = Math.random() * baseDelayMs;\n      const delay = baseDelayMs * attempt + jitter;\n      await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n  }\n}\n\nexport type BookingWindow = ReturnType<typeof computeBookingWindow>;\n\ntype BookingWindowWithFallback = {\n  window: BookingWindow;\n  usedFallback: boolean;\n  fallbackService: ServiceKey | null;\n};\n\nexport function computeBookingWindow(args: {\n  startISO?: string | null;\n  bookingDate?: string | null;\n  startTime?: string | null;\n  partySize: number;\n  policy?: VenuePolicy;\n  serviceHint?: ServiceKey | null;\n}): {\n  service: ServiceKey;\n  durationMinutes: number;\n  dining: {\n    start: DateTime;\n    end: DateTime;\n  };\n  block: {\n    start: DateTime;\n    end: DateTime;\n  };\n  clampedToServiceEnd: boolean;\n} {\n  const policy = args.policy ?? getVenuePolicy();\n  const baseStart = resolveStartDateTime(args, policy);\n  const service = resolveService(baseStart, args.serviceHint ?? null, policy);\n\n  const diningMinutes = bandDuration(service, args.partySize, policy);\n  const buffer = getBufferConfig(service, policy);\n  const diningStart = baseStart;\n  let diningEnd = diningStart.plus({ minutes: diningMinutes });\n  const blockStart = diningStart.minus({ minutes: buffer.pre ?? 0 });\n  let blockEnd = diningEnd.plus({ minutes: buffer.post ?? 0 });\n  let clampedToServiceEnd = false;\n\n  const serviceEndBoundary = serviceEnd(service, diningStart, policy);\n  if (blockEnd > serviceEndBoundary) {\n    blockEnd = serviceEndBoundary;\n    diningEnd = blockEnd.minus({ minutes: buffer.post ?? 0 });\n    if (diningEnd <= diningStart) {\n      throw new ServiceOverrunError(service, blockEnd, serviceEndBoundary);\n    }\n    clampedToServiceEnd = true;\n  }\n\n  return {\n    service,\n    durationMinutes: Math.max(1, Math.round(diningEnd.diff(diningStart, \"minutes\").minutes)),\n    dining: {\n      start: diningStart,\n      end: diningEnd,\n    },\n    block: {\n      start: blockStart,\n      end: blockEnd,\n    },\n    clampedToServiceEnd,\n  };\n}\n\ntype ComputeWindowArgs = {\n  startISO?: string | null;\n  bookingDate?: string | null;\n  startTime?: string | null;\n  partySize: number;\n  policy?: VenuePolicy;\n  serviceHint?: ServiceKey | null;\n};\n\nfunction computeBookingWindowWithFallback(args: ComputeWindowArgs): BookingWindowWithFallback {\n  const policy = args.policy ?? getVenuePolicy();\n  try {\n    const window = computeBookingWindow({ ...args, policy });\n    return {\n      window,\n      usedFallback: false,\n      fallbackService: null,\n    };\n  } catch (error) {\n    if (error instanceof ServiceNotFoundError) {\n      const serviceOrderCandidates = policy.serviceOrder.filter((key) => Boolean(policy.services[key]));\n      const servicesFallback = (Object.keys(policy.services) as ServiceKey[]).filter((key) =>\n        Boolean(policy.services[key]),\n      );\n      const fallbackService =\n        args.serviceHint && policy.services[args.serviceHint]\n          ? args.serviceHint\n          : serviceOrderCandidates[0] ?? servicesFallback[0];\n\n      if (!fallbackService || !policy.services[fallbackService]) {\n        throw error;\n      }\n\n      if (isAllocatorServiceFailHard()) {\n        throw error;\n      }\n\n      const fallbackWindow = computeBookingWindow({\n        ...args,\n        policy,\n        serviceHint: fallbackService,\n      });\n\n      console.warn(\"[capacity][window][fallback] service not found, using fallback service\", {\n        start: fallbackWindow.dining.start.toISO(),\n        fallbackService,\n        clamped: fallbackWindow.clampedToServiceEnd,\n      });\n\n      return {\n        window: fallbackWindow,\n        usedFallback: true,\n        fallbackService,\n      };\n    }\n\n    throw error;\n  }\n}\n\nfunction resolveStartDateTime(\n  args: {\n    startISO?: string | null;\n    bookingDate?: string | null;\n    startTime?: string | null;\n  },\n  policy: VenuePolicy,\n): DateTime {\n  if (args.startISO) {\n    const parsed = DateTime.fromISO(args.startISO);\n    if (!parsed.isValid) {\n      throw new ManualSelectionInputError(\"Invalid start ISO timestamp provided\", \"INVALID_START\");\n    }\n    return parsed.setZone(policy.timezone, { keepLocalTime: false });\n  }\n\n  const { bookingDate, startTime } = args;\n  if (!bookingDate || !startTime) {\n    throw new ManualSelectionInputError(\"Booking date and start time are required\", \"START_TIME_REQUIRED\");\n  }\n\n  const composed = DateTime.fromISO(`${bookingDate}T${startTime}`, { zone: policy.timezone });\n  if (!composed.isValid) {\n    throw new ManualSelectionInputError(\"Invalid booking date/time\", \"INVALID_START\");\n  }\n  return composed;\n}\n\nfunction resolveService(start: DateTime, hint: ServiceKey | null, policy: VenuePolicy): ServiceKey {\n  if (hint) {\n    return hint;\n  }\n  const found = whichService(start, policy);\n  if (!found) {\n    throw new ServiceNotFoundError(start);\n  }\n  return found;\n}\n\ntype IntervalPoint = DateTime | string | number;\ntype IntervalLike = {\n  start: IntervalPoint;\n  end: IntervalPoint;\n};\n\nfunction intervalPointToMillis(point: IntervalPoint): number | null {\n  // Robust normalization to epoch ms with DST-gap coercion when necessary.\n  if (DateTime.isDateTime(point)) {\n    if (point.isValid) {\n      const v = point.toMillis();\n      return Number.isFinite(v) ? v : null;\n    }\n    // Handle non-existent local times (e.g., DST spring-forward): advance minute-by-minute\n    const zoneName = point.zoneName ?? \"UTC\";\n    const base = {\n      year: point.year,\n      month: point.month,\n      day: point.day,\n      hour: point.hour,\n      minute: point.minute,\n      second: point.second,\n      millisecond: point.millisecond,\n    };\n    \n    // Common DST spring-forward gap fix: map 01:xx to 02:xx local\n    if (typeof base.hour === 'number' && base.hour === 1) {\n      // Map nonexistent 01:xx local times to the earliest valid instant (02:00)\n      const shifted = DateTime.fromObject({ ...base, hour: 2, minute: 0, second: 0, millisecond: 0 }, { zone: zoneName });\n      if (shifted.isValid) {\n        const vv = shifted.toMillis();\n        if (Number.isFinite(vv)) return vv;\n      }\n    }\n    for (let delta = 0; delta <= 120; delta += 1) {\n      const t = DateTime.fromObject({ ...base, minute: base.minute + delta }, { zone: zoneName });\n      if (t.isValid) {\n        const v = t.toMillis();\n        return Number.isFinite(v) ? v : null;\n      }\n    }\n    return null;\n  }\n\n  if (typeof point === \"number\") {\n    return Number.isFinite(point) ? point : null;\n  }\n\n  if (typeof point === \"string\") {\n    const parsed = DateTime.fromISO(point, { setZone: true });\n    if (parsed.isValid) {\n      const v = parsed.toMillis();\n      return Number.isFinite(v) ? v : null;\n    }\n    const m = point.match(/^(\\d{4})-(\\d{2})-(\\d{2})[T ](\\d{2}):(\\d{2})(?::(\\d{2}))?/);\n    if (m) {\n      const [, Y, M, D, H, Min, S] = m;\n      const base = {\n        year: Number(Y),\n        month: Number(M),\n        day: Number(D),\n        hour: Number(H),\n        minute: Number(Min),\n        second: S ? Number(S) : 0,\n      };\n      const zone = parsed.zoneName ?? \"UTC\";\n      for (let delta = 0; delta <= 120; delta += 1) {\n        const t = DateTime.fromObject({ ...base, minute: base.minute + delta }, { zone });\n        if (t.isValid) {\n          const v = t.toMillis();\n          return Number.isFinite(v) ? v : null;\n        }\n      }\n    }\n    return null;\n  }\n\n  return null;\n}\n\nfunction normalizeInterval(interval: IntervalLike): { start: number; end: number } | null {\n  const start = intervalPointToMillis(interval.start);\n  const end = intervalPointToMillis(interval.end);\n  if (start === null || end === null) {\n    return null;\n  }\n  if (!(start < end)) {\n    return null;\n  }\n  return { start, end };\n}\n\nfunction highResNow(): number {\n  return typeof performance !== \"undefined\" ? performance.now() : Date.now();\n}\n\nfunction roundMilliseconds(value: number): number {\n  return Math.round(value * 100) / 100;\n}\n\nfunction buildTiming(params: {\n  totalMs: number;\n  plannerMs?: number;\n  assignmentMs?: number;\n  holdMs?: number;\n}): SelectorDecisionEvent[\"timing\"] {\n  const timing: SelectorDecisionEvent[\"timing\"] = {\n    totalMs: roundMilliseconds(params.totalMs),\n  };\n\n  if (typeof params.plannerMs === \"number\" && params.plannerMs > 0) {\n    timing.plannerMs = roundMilliseconds(params.plannerMs);\n  }\n  if (typeof params.assignmentMs === \"number\" && params.assignmentMs > 0) {\n    timing.assignmentMs = roundMilliseconds(params.assignmentMs);\n  }\n  if (typeof params.holdMs === \"number\" && params.holdMs > 0) {\n    timing.holdMs = roundMilliseconds(params.holdMs);\n  }\n\n  return timing;\n}\n\n/**\n * Normalizes planner configuration details so telemetry consumers receive a\n * consistent view of the limits and feature toggles that influenced a search.\n */\nfunction composePlannerConfig(params: {\n  diagnostics: CandidateDiagnostics;\n  scoringConfig: SelectorScoringConfig;\n  combinationEnabled: boolean;\n  requireAdjacency: boolean;\n  adjacencyRequiredGlobally: boolean;\n  adjacencyMinPartySize: number | null;\n  featureFlags: ReturnType<typeof buildSelectorFeatureFlagsTelemetry>;\n  serviceFallback: {\n    usedFallback: boolean;\n    fallbackService: ServiceKey | null;\n  };\n  demandMultiplier: number;\n  demandRule?: DemandMultiplierResult[\"rule\"];\n  lookahead: Pick<LookaheadConfig, \"enabled\" | \"windowMinutes\" | \"penaltyWeight\" | \"blockThreshold\">;\n}): NonNullable<SelectorDecisionEvent[\"plannerConfig\"]> {\n  const { diagnostics, scoringConfig } = params;\n  const { limits } = diagnostics;\n\n  return {\n    combinationEnabled: params.combinationEnabled,\n    requireAdjacency: params.requireAdjacency,\n    adjacencyRequiredGlobally: params.adjacencyRequiredGlobally,\n    adjacencyMinPartySize: params.adjacencyMinPartySize,\n    kMax: limits.kMax,\n   bucketLimit: limits.maxPlansPerSlack,\n   evaluationLimit: limits.maxCombinationEvaluations,\n   maxOverage: scoringConfig.maxOverage,\n   maxTables: scoringConfig.maxTables,\n    weights: {\n      overage: scoringConfig.weights.overage,\n      tableCount: scoringConfig.weights.tableCount,\n      fragmentation: scoringConfig.weights.fragmentation,\n      zoneBalance: scoringConfig.weights.zoneBalance,\n      adjacencyCost: scoringConfig.weights.adjacencyCost,\n      scarcity: scoringConfig.weights.scarcity,\n    },\n    featureFlags: {\n      plannerTimePruning: params.featureFlags.plannerTimePruning,\n      adjacencyUndirected: params.featureFlags.adjacencyUndirected,\n      holdsStrictConflicts: params.featureFlags.holdsStrictConflicts,\n      allocatorFailHard: params.featureFlags.allocatorFailHard,\n      selectorScoring: params.featureFlags.selectorScoring,\n      opsMetrics: params.featureFlags.opsMetrics,\n      selectorLookahead: params.featureFlags.selectorLookahead,\n    },\n    serviceFallback: {\n      used: params.serviceFallback.usedFallback,\n      service: params.serviceFallback.fallbackService,\n    },\n    demandMultiplier: params.demandMultiplier,\n    demandRule: params.demandRule\n      ? {\n          label: params.demandRule.label ?? null,\n          source: params.demandRule.source,\n          serviceWindow: params.demandRule.serviceWindow ?? null,\n          days: params.demandRule.days,\n          start: params.demandRule.start ?? null,\n          end: params.demandRule.end ?? null,\n          priority: params.demandRule.priority ?? null,\n        }\n      : null,\n    lookahead: {\n      enabled: params.lookahead.enabled,\n      windowMinutes: params.lookahead.windowMinutes,\n      penaltyWeight: params.lookahead.penaltyWeight,\n      blockThreshold: params.lookahead.blockThreshold,\n    },\n  };\n}\n\n/**\n * Returns whether the half-open interval `[a.start, a.end)` intersects with `[b.start, b.end)`.\n *\n * Accepts ISO strings, Luxon {@link DateTime} instances, or epoch millisecond numbers.\n * Values are normalized to UTC and invalid intervals are treated as non-overlapping.\n */\nexport function windowsOverlap(a: IntervalLike, b: IntervalLike): boolean {\n  \n  const first = normalizeInterval(a);\n  const second = normalizeInterval(b);\n  \n  if (!first || !second) {\n    return false;\n  }\n  // Standard half-open intersection\n  if (first.start < second.end && second.start < first.end) {\n    return true;\n  }\n  // Edge case: touching at a DST transition boundary can represent overlap in local time intent.\n  // If one of the original intervals crosses a zone offset change, treat boundary-touching as overlapping.\n  const touches = first.end === second.start;\n  if (touches) {\n    const aHas = DateTime.isDateTime(a.start) && DateTime.isDateTime(a.end);\n    const bHas = DateTime.isDateTime(b.start) && DateTime.isDateTime(b.end);\n    const aDelta = aHas ? (a.end as DateTime).offset - (a.start as DateTime).offset : 0;\n    const bDelta = bHas ? (b.end as DateTime).offset - (b.start as DateTime).offset : 0;\n    // Only treat as overlap for spring-forward (positive offset change)\n    if (aDelta > 0 || bDelta > 0) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction toIsoUtc(dateTime: DateTime): string {\n  return (\n    dateTime.toUTC().toISO({ suppressMilliseconds: true }) ??\n    dateTime.toUTC().toISO() ??\n    dateTime.toUTC().toString()\n  );\n}\n\ntype TimeFilterMode = \"strict\" | \"approx\";\n\ntype TimeFilterStats = {\n  prunedByTime: number;\n  candidatesAfterTimePrune: number;\n  pruned_by_time: number;\n  candidates_after_time_prune: number;\n};\n\ntype TimeFilterOptions = {\n  busy: AvailabilityMap;\n  mode?: TimeFilterMode;\n  captureStats?: (stats: TimeFilterStats) => void;\n};\n\nfunction normalizeIsoString(value: string | null | undefined): string | null {\n  if (!value) {\n    return null;\n  }\n  const parsed = DateTime.fromISO(value);\n  if (!parsed.isValid) {\n    return null;\n  }\n  return toIsoUtc(parsed);\n}\n\nfunction filterTimeAvailableTables(\n  tables: Table[],\n  window: BookingWindow,\n  busy: AvailabilityMap | undefined,\n  mode: TimeFilterMode,\n  captureStats?: (stats: TimeFilterStats) => void,\n): Table[] {\n  if (!busy || busy.size === 0 || mode === \"approx\") {\n    captureStats?.({\n      prunedByTime: 0,\n      candidatesAfterTimePrune: tables.length,\n      pruned_by_time: 0,\n      candidates_after_time_prune: tables.length,\n    });\n    return tables;\n  }\n\n  const targetStart = toIsoUtc(window.block.start);\n  const targetEnd = toIsoUtc(window.block.end);\n  let prunedByTime = 0;\n\n  const filtered = tables.filter((table) => {\n    const entry = busy.get(table.id);\n    if (!entry) {\n      return true;\n    }\n    const free = isWindowFree(entry.bitset, targetStart, targetEnd);\n    if (!free) {\n      prunedByTime += 1;\n      return false;\n    }\n    return true;\n  });\n\n  captureStats?.({\n    prunedByTime,\n    candidatesAfterTimePrune: filtered.length,\n    pruned_by_time: prunedByTime,\n    candidates_after_time_prune: filtered.length,\n  });\n\n  return filtered;\n}\n\nexport function filterAvailableTables(\n  tables: Table[],\n  partySize: number,\n  window: ReturnType<typeof computeBookingWindow>,\n  adjacency: Map<string, Set<string>>,\n  avoidTables?: Set<string>,\n  zoneId?: string | null,\n  options?: { allowInsufficientCapacity?: boolean; timeFilter?: TimeFilterOptions },\n): Table[] {\n  const allowPartial = options?.allowInsufficientCapacity ?? false;\n  const avoid = avoidTables ?? new Set<string>();\n\n  const filtered = tables.filter((table) => {\n    if (!table) return false;\n    if (avoid.has(table.id)) return false;\n    if (zoneId && table.zoneId !== zoneId) return false;\n    if (table.active === false) return false;\n    if (typeof table.status === \"string\" && table.status.toLowerCase() === \"out_of_service\") return false;\n    const capacity = table.capacity ?? 0;\n    if (!Number.isFinite(capacity) || capacity <= 0) return false;\n    if (!allowPartial && capacity < partySize) return false;\n    if (typeof table.maxPartySize === \"number\" && table.maxPartySize > 0 && partySize > table.maxPartySize) {\n      return false;\n    }\n    if (typeof table.minPartySize === \"number\" && table.minPartySize > 0 && partySize < table.minPartySize) {\n      return false;\n    }\n    // If adjacency map is supplied and requires zone-level adjacency, ensure entry exists.\n    if (partiesRequireAdjacency(partySize) && adjacency.size > 0 && !adjacency.has(table.id)) {\n      adjacency.set(table.id, new Set());\n    }\n    return true;\n  });\n\n  const timeFiltered =\n    options?.timeFilter && window\n      ? filterTimeAvailableTables(filtered, window, options.timeFilter.busy, options.timeFilter.mode ?? \"strict\", (stats) =>\n          options.timeFilter?.captureStats?.(stats),\n        )\n      : filtered;\n\n  return timeFiltered.sort((a, b) => {\n    const capacityDiff = (a.capacity ?? 0) - (b.capacity ?? 0);\n    if (capacityDiff !== 0) return capacityDiff;\n    return a.tableNumber.localeCompare(b.tableNumber);\n  });\n}\n\n/**\n * Determines whether adjacency must be enforced for a given party size.\n *\n * The allocator-level `requireAdjacency` flag acts as a global gate, while\n * `allocator.adjacencyMinPartySize` (when provided) raises the threshold so\n * that only large parties mandate adjacency.\n */\nfunction partiesRequireAdjacency(partySize: number): boolean {\n  if (!isAllocatorAdjacencyRequired()) {\n    return false;\n  }\n  const minPartySize = getAllocatorAdjacencyMinPartySize();\n  if (typeof minPartySize === \"number\") {\n    return partySize >= minPartySize;\n  }\n  return true;\n}\n\n/**\n * Resolves the adjacency requirement for interactive flows, preferring the\n * explicit override supplied by the caller but falling back to the allocator\n * policy when no override is present.\n */\nfunction resolveRequireAdjacency(partySize: number, override?: boolean): boolean {\n  if (typeof override === \"boolean\") {\n   return override;\n  }\n  return partiesRequireAdjacency(partySize);\n}\n\ntype LookaheadConfig = {\n  enabled: boolean;\n  windowMinutes: number;\n  penaltyWeight: number;\n  blockThreshold: number;\n};\n\ntype FutureBookingCandidate = {\n  bookingId: string;\n  partySize: number;\n  window: BookingWindow;\n  busy: AvailabilityMap;\n  usedFallback: boolean;\n  fallbackService: ServiceKey | null;\n};\n\nfunction prepareLookaheadBookings(params: {\n  bookingId: string;\n  currentWindow: BookingWindow;\n  lookahead: LookaheadConfig;\n  policy: VenuePolicy;\n  contextBookings: ContextBookingRow[];\n  holds: TableHold[];\n}): FutureBookingCandidate[] {\n  const { bookingId, currentWindow, lookahead, policy, contextBookings, holds } = params;\n  if (!lookahead.enabled || lookahead.windowMinutes <= 0) {\n    return [];\n  }\n\n  const cutoff = currentWindow.block.start.plus({ minutes: lookahead.windowMinutes });\n  const candidates: FutureBookingCandidate[] = [];\n\n  for (const booking of contextBookings) {\n    if (!booking || booking.id === bookingId) {\n      continue;\n    }\n\n    const partySize = booking.party_size ?? 0;\n    if (!Number.isFinite(partySize) || partySize <= 0) {\n      continue;\n    }\n\n    const assignments = booking.booking_table_assignments ?? [];\n    if (assignments.length > 0) {\n      continue;\n    }\n\n    let computed: BookingWindowWithFallback;\n    try {\n      computed = computeBookingWindowWithFallback({\n        startISO: booking.start_at,\n        bookingDate: booking.booking_date,\n        startTime: booking.start_time,\n        partySize,\n        policy,\n      });\n    } catch {\n      continue;\n    }\n\n    const { window } = computed;\n    if (window.block.start <= currentWindow.block.start) {\n      continue;\n    }\n\n    if (window.block.start > cutoff) {\n      continue;\n    }\n\n    const busy = buildBusyMaps({\n      targetBookingId: booking.id,\n      bookings: contextBookings,\n      holds,\n      policy,\n      targetWindow: window,\n    });\n\n    candidates.push({\n      bookingId: booking.id,\n      partySize,\n      window,\n      busy,\n      usedFallback: computed.usedFallback,\n      fallbackService: computed.fallbackService,\n    });\n  }\n\n  return candidates;\n}\n\nfunction applyLookaheadPenalties(params: {\n  plans: RankedTablePlan[];\n  bookingWindow: BookingWindow;\n  tables: Table[];\n  adjacency: Map<string, Set<string>>;\n  zoneId: string | null;\n  futureBookings: FutureBookingCandidate[];\n  config: SelectorScoringConfig;\n  combinationEnabled: boolean;\n  combinationLimit: number;\n  selectorLimits: ReturnType<typeof getSelectorPlannerLimits>;\n  penaltyWeight: number;\n  blockThreshold: number;\n}): {\n  penalizedPlans: number;\n  totalPenalty: number;\n  evaluationMs: number;\n  conflicts: Array<{ bookingId: string; planKey: string }>;\n  blockedPlans: string[];\n} {\n  const {\n    plans,\n    bookingWindow,\n    tables,\n    adjacency,\n    zoneId,\n    futureBookings,\n    config,\n    combinationEnabled,\n    combinationLimit,\n    selectorLimits,\n    penaltyWeight,\n    blockThreshold,\n  } = params;\n  const start = performance.now();\n\n  if (futureBookings.length === 0 || plans.length === 0 || penaltyWeight <= 0) {\n    return {\n      penalizedPlans: 0,\n      totalPenalty: 0,\n      evaluationMs: performance.now() - start,\n      conflicts: [],\n      blockedPlans: [],\n    };\n  }\n\n  let penalizedPlans = 0;\n  let totalPenalty = 0;\n  const conflicts: Array<{ bookingId: string; planKey: string }> = [];\n  const blockedPlanKeys = new Set<string>();\n\n  for (const plan of plans) {\n    let planPenalty = 0;\n    const avoidTables = new Set(plan.tables.map((table) => table.id));\n\n    for (const future of futureBookings) {\n      if (!windowsOverlap(bookingWindow.block, future.window.block)) {\n        continue;\n      }\n\n      const requireAdjacencyForFuture = resolveRequireAdjacency(future.partySize);\n      const availableTables = filterAvailableTables(\n        tables,\n        future.partySize,\n        future.window,\n        adjacency,\n        avoidTables,\n        zoneId ?? null,\n        {\n          allowInsufficientCapacity: true,\n          timeFilter: {\n            busy: future.busy,\n            mode: \"strict\",\n          },\n        },\n      );\n\n      if (availableTables.length === 0) {\n        planPenalty += penaltyWeight;\n        conflicts.push({ bookingId: future.bookingId, planKey: plan.tableKey });\n        continue;\n      }\n\n      const futurePlans = buildScoredTablePlans({\n        tables: availableTables,\n        partySize: future.partySize,\n        adjacency,\n        config,\n        enableCombinations: combinationEnabled,\n        kMax: combinationLimit,\n        maxPlansPerSlack: selectorLimits.maxPlansPerSlack,\n        maxCombinationEvaluations: selectorLimits.maxCombinationEvaluations,\n        enumerationTimeoutMs: selectorLimits.enumerationTimeoutMs,\n        requireAdjacency: requireAdjacencyForFuture,\n        demandMultiplier: 1,\n      });\n\n      if (futurePlans.plans.length === 0) {\n        planPenalty += penaltyWeight;\n        conflicts.push({ bookingId: future.bookingId, planKey: plan.tableKey });\n      }\n    }\n\n    if (planPenalty > 0) {\n      penalizedPlans += 1;\n      totalPenalty += planPenalty;\n      plan.score += planPenalty;\n      plan.scoreBreakdown.futureConflictPenalty =\n        (plan.scoreBreakdown.futureConflictPenalty ?? 0) + planPenalty;\n      plan.scoreBreakdown.total += planPenalty;\n    }\n\n    if (blockThreshold > 0 && planPenalty >= blockThreshold) {\n      blockedPlanKeys.add(plan.tableKey);\n    }\n  }\n\n  if (blockedPlanKeys.size > 0) {\n    for (let index = plans.length - 1; index >= 0; index -= 1) {\n      if (blockedPlanKeys.has(plans[index].tableKey)) {\n        plans.splice(index, 1);\n      }\n    }\n  }\n\n  const evaluationMs = performance.now() - start;\n  return {\n    penalizedPlans,\n    totalPenalty,\n    evaluationMs,\n    conflicts,\n    blockedPlans: Array.from(blockedPlanKeys),\n  };\n}\n\nfunction sortPlansByScore(plans: RankedTablePlan[]): void {\n  plans.sort((a, b) => {\n    if (a.score !== b.score) {\n      return a.score - b.score;\n    }\n    if (a.metrics.overage !== b.metrics.overage) {\n      return a.metrics.overage - b.metrics.overage;\n    }\n    if (a.metrics.tableCount !== b.metrics.tableCount) {\n      return a.metrics.tableCount - b.metrics.tableCount;\n    }\n    if (a.totalCapacity !== b.totalCapacity) {\n      return a.totalCapacity - b.totalCapacity;\n    }\n    if (a.metrics.fragmentation !== b.metrics.fragmentation) {\n      return a.metrics.fragmentation - b.metrics.fragmentation;\n    }\n    if (a.metrics.adjacencyCost !== b.metrics.adjacencyCost) {\n      return a.metrics.adjacencyCost - b.metrics.adjacencyCost;\n    }\n    return a.tableKey.localeCompare(b.tableKey, \"en\");\n  });\n}\n\nexport function evaluateLookahead(params: {\n  lookahead: LookaheadConfig;\n  bookingId: string;\n  bookingWindow: BookingWindow;\n  plansResult: BuildCandidatesResult;\n  tables: Table[];\n  adjacency: Map<string, Set<string>>;\n  zoneId: string | null;\n  policy: VenuePolicy;\n  contextBookings: ContextBookingRow[];\n  holds: TableHold[];\n  combinationEnabled: boolean;\n  combinationLimit: number;\n  selectorLimits: ReturnType<typeof getSelectorPlannerLimits>;\n  scoringConfig: SelectorScoringConfig;\n}): CandidateDiagnostics[\"lookahead\"] {\n  const {\n    lookahead,\n    bookingId,\n    bookingWindow,\n    plansResult,\n    tables,\n    adjacency,\n    zoneId,\n    policy,\n    contextBookings,\n    holds,\n    combinationEnabled,\n    combinationLimit,\n    selectorLimits,\n    scoringConfig,\n  } = params;\n\n  if (!lookahead.enabled) {\n    return {\n      enabled: false,\n      evaluationMs: 0,\n      futureBookingsConsidered: 0,\n      penalizedPlans: 0,\n      totalPenalty: 0,\n      windowMinutes: lookahead.windowMinutes,\n      conflicts: [],\n      blockedPlans: [],\n      hardBlockTriggered: false,\n    };\n  }\n\n  const futureBookings = prepareLookaheadBookings({\n    bookingId,\n    currentWindow: bookingWindow,\n    lookahead,\n    policy,\n    contextBookings,\n    holds,\n  });\n\n  if (futureBookings.length === 0 || plansResult.plans.length === 0) {\n    return {\n      enabled: true,\n      evaluationMs: 0,\n      futureBookingsConsidered: futureBookings.length,\n      penalizedPlans: 0,\n      totalPenalty: 0,\n      windowMinutes: lookahead.windowMinutes,\n      conflicts: [],\n      blockedPlans: [],\n      hardBlockTriggered: false,\n    };\n  }\n\n  const { penalizedPlans, totalPenalty, evaluationMs, conflicts, blockedPlans } = applyLookaheadPenalties({\n    plans: plansResult.plans,\n    bookingWindow,\n    tables,\n    adjacency,\n    zoneId,\n    futureBookings,\n    config: scoringConfig,\n    combinationEnabled,\n    combinationLimit,\n    selectorLimits,\n    penaltyWeight: lookahead.penaltyWeight,\n    blockThreshold: lookahead.blockThreshold,\n  });\n\n  if (plansResult.plans.length === 0) {\n    return {\n      enabled: true,\n      evaluationMs,\n      futureBookingsConsidered: futureBookings.length,\n      penalizedPlans,\n      totalPenalty,\n      windowMinutes: lookahead.windowMinutes,\n      conflicts,\n      blockedPlans,\n      hardBlockTriggered: blockedPlans.length > 0,\n    };\n  }\n\n  if (penalizedPlans > 0) {\n    sortPlansByScore(plansResult.plans);\n  }\n\n  return {\n    enabled: true,\n    evaluationMs,\n    futureBookingsConsidered: futureBookings.length,\n    penalizedPlans,\n    totalPenalty,\n    windowMinutes: lookahead.windowMinutes,\n    conflicts,\n    blockedPlans,\n    hardBlockTriggered: blockedPlans.length > 0,\n  };\n}\n\nasync function loadBooking(bookingId: string, client: DbClient): Promise<BookingRow> {\n  const { data, error } = await client\n    .from(\"bookings\")\n    .select(\n      [\n        \"id\",\n        \"restaurant_id\",\n        \"booking_date\",\n        \"start_time\",\n        \"end_time\",\n        \"start_at\",\n        \"end_at\",\n        \"party_size\",\n        \"status\",\n        \"seating_preference\",\n        \"restaurants(timezone)\",\n      ].join(\",\"),\n    )\n    .eq(\"id\", bookingId)\n    .maybeSingle();\n\n  if (error) {\n    throw new ManualSelectionInputError(error.message ?? \"Failed to load booking\", \"BOOKING_LOOKUP_FAILED\", 500);\n  }\n\n  if (!data) {\n    throw new ManualSelectionInputError(\"Booking not found\", \"BOOKING_NOT_FOUND\", 404);\n  }\n\n  return normalizeBookingRow(data as unknown as BookingRow);\n}\n\ntype RestaurantInfo = {\n  timezone: string | null;\n  slug: string | null;\n};\n\nasync function loadRestaurantInfo(restaurantId: string, client: DbClient): Promise<RestaurantInfo> {\n  const { data, error } = await client\n    .from(\"restaurants\")\n    .select(\"timezone, slug\")\n    .eq(\"id\", restaurantId)\n    .maybeSingle();\n\n  if (error) {\n    throw new ManualSelectionInputError(error.message ?? \"Failed to load restaurant metadata\", \"RESTAURANT_LOOKUP_FAILED\", 500);\n  }\n\n  return {\n    timezone: data?.timezone ?? null,\n    slug: data?.slug ?? null,\n  };\n}\n\nasync function loadRestaurantTimezone(restaurantId: string, client: DbClient): Promise<string | null> {\n  const info = await loadRestaurantInfo(restaurantId, client);\n  return info.timezone;\n}\n\nasync function loadTablesForRestaurant(restaurantId: string, client: DbClient): Promise<Table[]> {\n  // Try cache first\n  try {\n    const { getInventoryCache } = await import(\"@/server/capacity/cache\");\n    const cached = getInventoryCache(restaurantId);\n    if (Array.isArray(cached) && cached.length > 0) {\n      return cached as Table[];\n    }\n  } catch {\n    // no-op on cache errors\n  }\n\n  const { data, error } = await client\n    .from(\"table_inventory\")\n    .select<typeof TABLE_INVENTORY_SELECT, TableInventoryRow>(TABLE_INVENTORY_SELECT)\n    .eq(\"restaurant_id\", restaurantId)\n    .order(\"table_number\", { ascending: true });\n\n  if (error || !data) {\n    return [];\n  }\n\n  const rows = data as unknown as Tables<\"table_inventory\">[];\n\n  const tables = rows.map((row) => ({\n    id: row.id,\n    tableNumber: row.table_number,\n    capacity: row.capacity ?? 0,\n    minPartySize: row.min_party_size ?? null,\n    maxPartySize: row.max_party_size ?? null,\n    section: row.section,\n    category: row.category,\n    seatingType: row.seating_type,\n    mobility: row.mobility,\n    zoneId: row.zone_id,\n    status: row.status,\n    active: row.active,\n    position: row.position,\n  }));\n\n  try {\n    const { setInventoryCache } = await import(\"@/server/capacity/cache\");\n    setInventoryCache(restaurantId, tables);\n  } catch {\n    // ignore cache set failures\n  }\n\n  return tables;\n}\n\nasync function loadTablesByIds(\n  restaurantId: string,\n  tableIds: string[],\n  client: DbClient,\n): Promise<Table[]> {\n  if (tableIds.length === 0) {\n    return [];\n  }\n\n  const uniqueIds = Array.from(new Set(tableIds));\n  const { data, error } = await client\n    .from(\"table_inventory\")\n    .select<typeof TABLE_INVENTORY_SELECT, TableInventoryRow>(TABLE_INVENTORY_SELECT)\n    .eq(\"restaurant_id\", restaurantId)\n    .in(\"id\", uniqueIds);\n\n  if (error || !data) {\n    return [];\n  }\n\n  const rows = data as unknown as TableInventoryRow[];\n\n  const lookup = new Map(\n    rows.map((row) => [\n      row.id,\n      {\n        id: row.id,\n        tableNumber: row.table_number,\n        capacity: row.capacity ?? 0,\n        minPartySize: row.min_party_size ?? null,\n        maxPartySize: row.max_party_size ?? null,\n        section: row.section,\n        category: row.category,\n        seatingType: row.seating_type,\n        mobility: row.mobility,\n        zoneId: row.zone_id,\n        status: row.status,\n        active: row.active,\n        position: row.position,\n      } satisfies Table,\n    ]),\n  );\n\n  return tableIds.reduce<Table[]>((acc, id) => {\n    const table = lookup.get(id);\n    if (table) {\n      acc.push(table);\n    }\n    return acc;\n  }, []);\n}\n\nasync function loadAdjacency(\n  restaurantId: string,\n  tableIds: string[],\n  client: DbClient,\n): Promise<Map<string, Set<string>>> {\n  const uniqueTableIds = Array.from(\n    new Set(\n      tableIds.filter((value): value is string => typeof value === \"string\" && value.length > 0),\n    ),\n  );\n\n  if (uniqueTableIds.length === 0) {\n    return new Map();\n  }\n  // Try to satisfy from cache if available\n  let cachedGraph: Map<string, Set<string>> | null = null;\n  try {\n    const { getAdjacencyCache } = await import(\"@/server/capacity/cache\");\n    cachedGraph = getAdjacencyCache(restaurantId);\n  } catch {\n    cachedGraph = null;\n  }\n  const missing: string[] = [];\n  if (cachedGraph) {\n    for (const id of uniqueTableIds) {\n      if (!cachedGraph.has(id)) {\n        missing.push(id);\n      }\n    }\n  }\n  const needFetch = !cachedGraph || missing.length > 0;\n\n  type AdjacencyRow = { table_a: string | null; table_b: string | null };\n  const baseQuery = () => client.from(\"table_adjacencies\").select(\"table_a, table_b\");\n  const adjacencyUndirected = isAdjacencyQueryUndirected();\n  const targetIds = needFetch && cachedGraph ? missing : uniqueTableIds;\n  const forward = await baseQuery().in(\"table_a\", targetIds);\n  if (forward.error) {\n    return new Map();\n  }\n\n  const reverse = adjacencyUndirected ? await baseQuery().in(\"table_b\", targetIds) : null;\n  if (reverse?.error) {\n    return new Map();\n  }\n\n  const forwardRows = Array.isArray(forward.data) ? (forward.data as AdjacencyRow[]) : [];\n  const reverseRows =\n    adjacencyUndirected && reverse && Array.isArray(reverse.data)\n      ? (reverse.data as AdjacencyRow[])\n      : [];\n\n  if (adjacencyUndirected) {\n    // Data integrity check: ensure symmetry when undirected is enabled\n    const missingReverse: Array<{ a: string; b: string }> = [];\n    const forwardSet = new Set(\n      forwardRows\n        .filter((r) => r.table_a && r.table_b)\n        .map((r) => `${r.table_a as string}->${r.table_b as string}`),\n    );\n    const reverseSet = new Set(\n      reverseRows\n        .filter((r) => r.table_a && r.table_b)\n        .map((r) => `${r.table_b as string}->${r.table_a as string}`),\n    );\n    for (const key of forwardSet) {\n      if (!reverseSet.has(key)) {\n        const [a, b] = key.split(\"->\");\n        missingReverse.push({ a, b });\n      }\n    }\n    if (missingReverse.length > 0) {\n      console.warn(\"[capacity.adjacency] asymmetry detected in table_adjacencies (undirected mode)\", {\n        missing: missingReverse.slice(0, 10),\n        total: missingReverse.length,\n      });\n    }\n  }\n\n  const map = cachedGraph ? new Map<string, Set<string>>(cachedGraph) : new Map<string, Set<string>>();\n  // If we fetched for specific targets, clear any stale cached entries for those ids\n  if (targetIds.length > 0) {\n    for (const id of targetIds) {\n      map.delete(id);\n    }\n  }\n  const addEdge = (from: string | null, to: string | null) => {\n    if (!from || !to) {\n      return;\n    }\n    if (!map.has(from)) {\n      map.set(from, new Set());\n    }\n    map.get(from)!.add(to);\n  };\n\n  for (const row of forwardRows) {\n    addEdge(row.table_a, row.table_b);\n    if (adjacencyUndirected) {\n      addEdge(row.table_b, row.table_a);\n    }\n  }\n\n  if (adjacencyUndirected) {\n    for (const row of reverseRows) {\n      addEdge(row.table_a, row.table_b);\n      addEdge(row.table_b, row.table_a);\n    }\n  }\n\n  // Update cache\n  try {\n    const { setAdjacencyCache } = await import(\"@/server/capacity/cache\");\n    setAdjacencyCache(restaurantId, map);\n  } catch {\n    // ignore cache set failures\n  }\n\n  // Return only requested nodes to reduce payloads\n  const filtered = new Map<string, Set<string>>();\n  for (const id of uniqueTableIds) {\n    if (map.has(id)) {\n      filtered.set(id, new Set(map.get(id)!));\n    }\n  }\n  return filtered;\n}\n\nasync function loadContextBookings(\n  restaurantId: string,\n  bookingDate: string | null,\n  client: DbClient,\n  aroundWindow?: { startIso: string; endIso: string; paddingMinutes?: number },\n): Promise<ContextBookingRow[]> {\n  if (!bookingDate) {\n    return [];\n  }\n\n  const paddingDefault = Math.max(0, Math.min(getContextQueryPaddingMinutes(), 240));\n  const pad = Math.max(0, Math.min(aroundWindow?.paddingMinutes ?? paddingDefault, 240));\n  const startIso = aroundWindow?.startIso ?? null;\n  const endIso = aroundWindow?.endIso ?? null;\n  const padMs = pad * 60 * 1000;\n  const startPad = startIso ? DateTime.fromISO(startIso, { setZone: true }).minus({ milliseconds: padMs }).toISO() : null;\n  const endPad = endIso ? DateTime.fromISO(endIso, { setZone: true }).plus({ milliseconds: padMs }).toISO() : null;\n\n  const query = client\n    .from(\"bookings\")\n    .select(\n      [\n        \"id\",\n        \"party_size\",\n        \"status\",\n        \"start_time\",\n        \"end_time\",\n        \"start_at\",\n        \"end_at\",\n        \"booking_date\",\n        \"booking_table_assignments(table_id)\",\n      ].join(\",\"),\n    )\n    .eq(\"restaurant_id\", restaurantId)\n    .eq(\"booking_date\", bookingDate)\n    .in(\"status\", [...BOOKING_BLOCKING_STATUSES])\n    .order(\"start_at\", { ascending: true });\n\n  const hasGt = typeof (query as unknown as { gt?: unknown }).gt === \"function\";\n  const hasLt = typeof (query as unknown as { lt?: unknown }).lt === \"function\";\n  if (startPad && hasGt) {\n    (query as unknown as { gt: (col: string, val: string) => unknown }).gt(\"end_at\", startPad);\n  }\n  if (endPad && hasLt) {\n    (query as unknown as { lt: (col: string, val: string) => unknown }).lt(\"start_at\", endPad);\n  }\n\n  const { data, error } = await query;\n\n  if (error || !data) {\n    return [];\n  }\n\n  return data as unknown as ContextBookingRow[];\n}\n\ntype BookingAssignmentRow = {\n  table_id: string;\n  id: string;\n  start_at: string | null;\n  end_at: string | null;\n  merge_group_id: string | null;\n};\n\nasync function loadTableAssignmentsForTables(\n  bookingId: string,\n  tableIds: string[],\n  client: DbClient,\n): Promise<BookingAssignmentRow[]> {\n  if (tableIds.length === 0) {\n    return [];\n  }\n\n  const { data, error } = await client\n    .from(\"booking_table_assignments\")\n    .select(\"table_id, id, start_at, end_at, merge_group_id\")\n    .eq(\"booking_id\", bookingId);\n\n  if (error || !data) {\n    return [];\n  }\n\n  const rows = data as unknown as BookingAssignmentRow[];\n  return rows.filter((row) => tableIds.includes(row.table_id));\n}\n\nfunction registerBusyWindow(\n  map: AvailabilityMap,\n  tableId: string,\n  window: { startAt: string; endAt: string; bookingId: string | null; source: \"booking\" | \"hold\" },\n): void {\n  if (!map.has(tableId)) {\n    map.set(tableId, {\n      bitset: createAvailabilityBitset(),\n      windows: [],\n    });\n  }\n  const entry = map.get(tableId)!;\n  markWindow(entry.bitset, window.startAt, window.endAt);\n  entry.windows.push({\n    tableId,\n    ...window,\n  });\n}\n\nfunction buildBusyMaps(params: {\n  targetBookingId: string;\n  bookings: ContextBookingRow[];\n  holds: TableHold[];\n  excludeHoldId?: string | null;\n  policy: VenuePolicy;\n  targetWindow?: BookingWindow | null;\n}): AvailabilityMap {\n  const { targetBookingId, bookings, holds, excludeHoldId, policy, targetWindow } = params;\n  const map: AvailabilityMap = new Map();\n  const pruneToTargetWindow = isPlannerTimePruningEnabled();\n  const targetInterval =\n    pruneToTargetWindow && targetWindow\n      ? {\n          start: toIsoUtc(targetWindow.block.start),\n          end: toIsoUtc(targetWindow.block.end),\n        }\n      : null;\n\n  for (const booking of bookings) {\n    if (booking.id === targetBookingId) continue;\n    const assignments = booking.booking_table_assignments ?? [];\n    if (assignments.length === 0) continue;\n\n    const { window } = computeBookingWindowWithFallback({\n      startISO: booking.start_at,\n      bookingDate: booking.booking_date,\n      startTime: booking.start_time,\n      partySize: booking.party_size,\n      policy,\n    });\n\n    const bookingInterval = {\n      start: toIsoUtc(window.block.start),\n      end: toIsoUtc(window.block.end),\n    };\n\n    if (targetInterval && !windowsOverlap(bookingInterval, targetInterval)) {\n      continue;\n    }\n\n    for (const assignment of assignments) {\n      if (!assignment?.table_id) continue;\n      registerBusyWindow(map, assignment.table_id, {\n        startAt: bookingInterval.start,\n        endAt: bookingInterval.end,\n        bookingId: booking.id,\n        source: \"booking\",\n      });\n    }\n  }\n\n  for (const hold of holds) {\n    if (excludeHoldId && hold.id === excludeHoldId) continue;\n    if (\n      targetInterval &&\n      !windowsOverlap(\n        { start: hold.startAt, end: hold.endAt },\n        targetInterval,\n      )\n    ) {\n      continue;\n    }\n    for (const tableId of hold.tableIds) {\n      registerBusyWindow(map, tableId, {\n        startAt: hold.startAt,\n        endAt: hold.endAt,\n        bookingId: hold.bookingId,\n        source: \"hold\",\n      });\n    }\n  }\n\n  return map;\n}\n\nfunction extractConflictsForTables(\n  busy: AvailabilityMap,\n  tableIds: string[],\n  window: ReturnType<typeof computeBookingWindow>,\n): ManualAssignmentConflict[] {\n  const conflicts: ManualAssignmentConflict[] = [];\n  const targetStart = toIsoUtc(window.block.start);\n  const targetEnd = toIsoUtc(window.block.end);\n\n  for (const tableId of tableIds) {\n    const entry = busy.get(tableId);\n    if (!entry) continue;\n    if (isWindowFree(entry.bitset, targetStart, targetEnd)) continue;\n    for (const other of entry.windows) {\n      if (windowsOverlap({ start: targetStart, end: targetEnd }, { start: other.startAt, end: other.endAt })) {\n        conflicts.push({\n          tableId,\n          bookingId: other.bookingId,\n          startAt: other.startAt,\n          endAt: other.endAt,\n          source: other.source,\n        });\n      }\n    }\n  }\n\n  return conflicts;\n}\n\nfunction formatHoldConflictReason(conflicts: HoldConflictInfo[], plan: RankedTablePlan): string {\n  if (conflicts.length === 0) {\n    return \"Conflicts with existing holds\";\n  }\n\n  const tableLookup = new Map<string, string>();\n  for (const table of plan.tables) {\n    tableLookup.set(table.id, table.tableNumber ?? table.id);\n  }\n\n  const tableLabels = new Set<string>();\n  for (const conflict of conflicts) {\n    for (const tableId of conflict.tableIds) {\n      const label = tableLookup.get(tableId) ?? tableId;\n      tableLabels.add(label);\n    }\n  }\n\n  const sortedLabels = Array.from(tableLabels).sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));\n  let message = sortedLabels.length > 0\n    ? `Conflicts with holds on tables ${sortedLabels.join(\", \")}`\n    : \"Conflicts with existing holds\";\n\n  const latestEnd = conflicts.reduce<string | null>((latest, conflict) => {\n    if (!conflict.endAt) {\n      return latest;\n    }\n    if (!latest) {\n      return conflict.endAt;\n    }\n    return conflict.endAt > latest ? conflict.endAt : latest;\n  }, null);\n\n  if (latestEnd) {\n    const retry = DateTime.fromISO(latestEnd);\n    if (retry.isValid) {\n      message += `; retry after ${retry.toUTC().toISOTime({ suppressSeconds: false, suppressMilliseconds: true })}`;\n    }\n  }\n\n  return message;\n}\n\nfunction evaluateAdjacency(\n  tableIds: string[],\n  adjacency: Map<string, Set<string>>,\n): { connected: boolean } {\n  if (tableIds.length <= 1) {\n    return { connected: true };\n  }\n  const queue = [tableIds[0]!];\n  const visited = new Set<string>([tableIds[0]!]);\n  while (queue.length > 0) {\n    const current = queue.shift();\n    if (!current) continue;\n    const neighbors = adjacency.get(current);\n    if (!neighbors) continue;\n    for (const neighbor of neighbors) {\n      if (!tableIds.includes(neighbor)) continue;\n      if (visited.has(neighbor)) continue;\n      visited.add(neighbor);\n      queue.push(neighbor);\n    }\n  }\n  return { connected: visited.size === tableIds.length };\n}\n\nfunction summarizeSelection(tables: Table[], partySize: number): ManualSelectionSummary {\n  const totalCapacity = tables.reduce((sum, table) => sum + (table.capacity ?? 0), 0);\n  const zoneIds = new Set(tables.map((table) => table.zoneId));\n  return {\n    tableCount: tables.length,\n    totalCapacity,\n    slack: Math.max(0, totalCapacity - partySize),\n    zoneId: zoneIds.size === 1 ? tables[0]?.zoneId ?? null : null,\n    tableNumbers: tables.map((table) => table.tableNumber),\n    partySize,\n  };\n}\n\nfunction buildManualChecks(params: {\n  summary: ManualSelectionSummary;\n  tables: Table[];\n  requireAdjacency: boolean;\n  adjacency: Map<string, Set<string>>;\n  conflicts: ManualAssignmentConflict[];\n  holdConflicts: HoldConflictInfo[];\n}): ManualSelectionCheck[] {\n  const checks: ManualSelectionCheck[] = [];\n  const { summary, tables, requireAdjacency, adjacency, conflicts, holdConflicts } = params;\n\n  checks.push({\n    id: \"capacity\",\n    status: summary.totalCapacity >= summary.partySize ? \"ok\" : \"error\",\n    message:\n      summary.totalCapacity >= summary.partySize\n        ? \"Capacity satisfied\"\n        : \"Selected tables do not meet requested party size\",\n    details: {\n      totalCapacity: summary.totalCapacity,\n      partySize: summary.partySize,\n      slack: summary.slack,\n    },\n  });\n\n  if (summary.zoneId === null) {\n    checks.push({\n      id: \"zone\",\n      status: \"error\",\n      message: \"Tables must belong to the same zone for manual assignment\",\n    });\n  } else {\n    checks.push({\n      id: \"zone\",\n      status: \"ok\",\n      message: `Zone ${summary.zoneId} validated`,\n    });\n  }\n\n  if (tables.length > 1) {\n    const allMovable = tables.every((table) => table.mobility === \"movable\");\n    checks.push({\n      id: \"movable\",\n      status: allMovable ? \"ok\" : \"error\",\n      message: allMovable\n        ? \"All tables are movable\"\n        : \"Merged assignments require movable tables\",\n    });\n  } else {\n    checks.push({\n      id: \"movable\",\n      status: \"ok\",\n      message: \"Single table selection\",\n    });\n  }\n\n  if (requireAdjacency && tables.length > 1) {\n    const evaluation = evaluateAdjacency(\n      tables.map((table) => table.id),\n      adjacency,\n    );\n    checks.push({\n      id: \"adjacency\",\n      status: evaluation.connected ? \"ok\" : \"error\",\n      message: evaluation.connected\n        ? \"Tables are connected\"\n        : \"Tables must be adjacent when adjacency enforcement is enabled\",\n    });\n  } else {\n    checks.push({\n      id: \"adjacency\",\n      status: \"ok\",\n      message: \"Adjacency not required\",\n    });\n  }\n\n  checks.push({\n    id: \"conflict\",\n    status: conflicts.length === 0 && holdConflicts.length === 0 ? \"ok\" : \"error\",\n    message:\n      conflicts.length === 0 && holdConflicts.length === 0\n        ? \"No conflicting assignments\"\n        : \"Existing assignments or holds conflict with selection\",\n    details: {\n      conflicts,\n      holdConflicts,\n    },\n  });\n\n  checks.push({\n    id: \"holds\",\n    status: holdConflicts.length === 0 ? \"ok\" : \"error\",\n    message: holdConflicts.length === 0 ? \"No holds blocking selection\" : \"Tables currently on hold\",\n    details: {\n      holds: holdConflicts,\n    },\n  });\n\n  return checks;\n}\n\nexport async function evaluateManualSelection(options: ManualSelectionOptions): Promise<ManualValidationResult> {\n  const { bookingId, tableIds, requireAdjacency: requireAdjacencyOverride, excludeHoldId = null, client } = options;\n\n  if (!Array.isArray(tableIds) || tableIds.length === 0) {\n    throw new ManualSelectionInputError(\"At least one table must be selected\", \"TABLES_REQUIRED\");\n  }\n\n  const supabase = ensureClient(client);\n  const booking = await loadBooking(bookingId, supabase);\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const policyVersion = hashPolicyVersion(policy);\n\n  let window: ReturnType<typeof computeBookingWindow>;\n  try {\n    ({ window } = computeBookingWindowWithFallback({\n      startISO: booking.start_at,\n      bookingDate: booking.booking_date,\n      startTime: booking.start_time,\n      partySize: booking.party_size,\n      policy,\n    }));\n  } catch (error) {\n    if (error instanceof ServiceOverrunError) {\n      // Surface a structured 422 that the API layer can return to the client\n      // rather than bubbling a 500. Keeps math unchanged while avoiding crashes\n      // in manual context fetches for after-hours/overrun bookings.\n      throw new ManualSelectionInputError(error.message, \"SERVICE_OVERRUN\", 422);\n    }\n    throw error;\n  }\n\n  const selectionTables = await loadTablesByIds(booking.restaurant_id, tableIds, supabase);\n  if (selectionTables.length !== tableIds.length) {\n    throw new ManualSelectionInputError(\"One or more selected tables were not found\", \"TABLE_LOOKUP_FAILED\");\n  }\n\n  const adjacency = await loadAdjacency(booking.restaurant_id, tableIds, supabase);\n\n  const contextBookings = await loadContextBookings(\n    booking.restaurant_id,\n    booking.booking_date ?? null,\n    supabase,\n    {\n      startIso: toIsoUtc(window.block.start),\n      endIso: toIsoUtc(window.block.end),\n    },\n  );\n  let holds: TableHold[] = [];\n  if (isHoldsEnabled()) {\n    try {\n      holds = await listActiveHoldsForBooking({ bookingId, client: supabase });\n    } catch {\n      holds = [];\n    }\n  }\n\n  const busy = buildBusyMaps({\n    targetBookingId: bookingId,\n    bookings: contextBookings,\n    holds,\n    excludeHoldId,\n    policy,\n    targetWindow: window,\n  });\n\n  const conflicts = extractConflictsForTables(busy, tableIds, window);\n  let holdConflicts: HoldConflictInfo[] = [];\n  try {\n    holdConflicts = await findHoldConflicts({\n      restaurantId: booking.restaurant_id,\n      tableIds,\n      startAt: toIsoUtc(window.block.start),\n      endAt: toIsoUtc(window.block.end),\n      excludeHoldId,\n      client: supabase,\n    });\n  } catch {\n    holdConflicts = [];\n  }\n\n  const requireAdjacency = resolveRequireAdjacency(booking.party_size, requireAdjacencyOverride);\n  const summary = summarizeSelection(selectionTables, booking.party_size);\n  const checks = buildManualChecks({\n    summary,\n    tables: selectionTables,\n    requireAdjacency,\n    adjacency,\n    conflicts,\n    holdConflicts,\n  });\n\n  const ok = checks.every((check) => check.status !== \"error\");\n\n  return {\n    ok,\n    summary,\n    checks,\n    policyVersion,\n  };\n}\n\nexport async function createManualHold(options: ManualHoldOptions): Promise<ManualHoldResult> {\n  const { bookingId, tableIds, createdBy, holdTtlSeconds = DEFAULT_HOLD_TTL_SECONDS, requireAdjacency, excludeHoldId, client } = options;\n  const supabase = ensureClient(client);\n\n  const validation = await evaluateManualSelection({\n    bookingId,\n    tableIds,\n    requireAdjacency,\n    excludeHoldId,\n    client: supabase,\n  });\n\n  if (!validation.ok || !validation.summary) {\n    return {\n      hold: null,\n      validation,\n    };\n  }\n\n  const booking = await loadBooking(bookingId, supabase);\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const policyVersion = typeof (validation as { policyVersion?: string }).policyVersion === \"string\"\n    ? (validation as { policyVersion?: string }).policyVersion!\n    : hashPolicyVersion(policy);\n\n  let window: ReturnType<typeof computeBookingWindow>;\n  try {\n    ({ window } = computeBookingWindowWithFallback({\n      startISO: booking.start_at,\n      bookingDate: booking.booking_date,\n      startTime: booking.start_time,\n      partySize: booking.party_size,\n      policy,\n    }));\n  } catch (error) {\n    if (error instanceof ServiceOverrunError) {\n      throw new ManualSelectionInputError(error.message, \"SERVICE_OVERRUN\", 422);\n    }\n    throw error;\n  }\n\n  const selectionTables = await loadTablesByIds(booking.restaurant_id, tableIds, supabase);\n  if (selectionTables.length !== tableIds.length) {\n    throw new ManualSelectionInputError(\"Selected tables could not be loaded\", \"TABLE_LOOKUP_FAILED\");\n  }\n\n  const startAtIso = toIsoUtc(window.block.start);\n  const endAtIso = toIsoUtc(window.block.end);\n\n  const expiresAt =\n    options.holdExpiresAt ??\n    toIsoUtc(DateTime.now().plus({ seconds: holdTtlSeconds })) ??\n    toIsoUtc(window.block.start.plus({ minutes: 2 }));\n\n  const zoneIdValue = validation.summary.zoneId ?? selectionTables[0]?.zoneId;\n  if (!zoneIdValue) {\n    throw new ManualSelectionInputError(\"Unable to determine zone for selected tables\", \"ZONE_REQUIRED\");\n  }\n\n  // Compute adjacency/zone snapshot for freeze semantics\n  const adjacency = await loadAdjacency(booking.restaurant_id, tableIds, supabase);\n  const adjacencyUndirected = isAdjacencyQueryUndirected();\n  const zoneIds = Array.from(new Set(selectionTables.map((t) => t.zoneId))).filter(Boolean) as string[];\n  const edgeSet = new Set<string>();\n  for (const a of tableIds) {\n    const neighbors = adjacency.get(a);\n    if (!neighbors) continue;\n    for (const b of neighbors) {\n      if (!tableIds.includes(b)) continue;\n      const key = adjacencyUndirected\n        ? ([a, b].sort((x, y) => x.localeCompare(y)) as [string, string]).join(\"->\")\n        : `${a}->${b}`;\n      edgeSet.add(key);\n    }\n  }\n  const normalizedEdges = Array.from(edgeSet).sort();\n  const adjacencySnapshot = computePayloadChecksum({ undirected: adjacencyUndirected, edges: normalizedEdges });\n\n  const holdPayload: CreateTableHoldInput = {\n    bookingId,\n    restaurantId: booking.restaurant_id,\n    zoneId: zoneIdValue,\n    tableIds,\n    startAt: startAtIso,\n    endAt: endAtIso,\n    expiresAt,\n    createdBy,\n    metadata: {\n      selection: {\n        tableIds,\n        summary: validation.summary,\n        snapshot: {\n          zoneIds,\n          adjacency: {\n            undirected: adjacencyUndirected,\n            edges: normalizedEdges,\n            hash: adjacencySnapshot,\n          },\n        },\n      },\n      policyVersion,\n    },\n    client: supabase,\n  };\n\n  const hold = await createTableHold(holdPayload);\n\n  if (excludeHoldId) {\n    try {\n      await releaseHoldWithRetry({ holdId: excludeHoldId, client: supabase });\n    } catch (error) {\n      console.warn(\"[capacity][manual][holds] failed to release replaced hold\", {\n        bookingId,\n        newHoldId: hold.id,\n        previousHoldId: excludeHoldId,\n        error,\n      });\n    }\n  }\n\n  return {\n    hold,\n    validation,\n  };\n}\n\nexport async function getManualAssignmentContext(options: {\n  bookingId: string;\n  client?: DbClient;\n}): Promise<ManualAssignmentContext> {\n  const { bookingId, client } = options;\n  const supabase = ensureClient(client);\n  const booking = await loadBooking(bookingId, supabase);\n\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n\n  let window: ReturnType<typeof computeBookingWindow>;\n  try {\n    ({ window } = computeBookingWindowWithFallback({\n      startISO: booking.start_at,\n      bookingDate: booking.booking_date,\n      startTime: booking.start_time,\n      partySize: booking.party_size,\n      policy,\n    }));\n  } catch (error) {\n    if (error instanceof ServiceOverrunError) {\n      throw new ManualSelectionInputError(error.message, \"SERVICE_OVERRUN\", 422);\n    }\n    throw error;\n  }\n\n  const tables = await loadTablesForRestaurant(booking.restaurant_id, supabase);\n  const contextBookings = await loadContextBookings(\n    booking.restaurant_id,\n    booking.booking_date ?? null,\n    supabase,\n    {\n      startIso: toIsoUtc(window.block.start),\n      endIso: toIsoUtc(window.block.end),\n    },\n  );\n\n  let holds: ManualAssignmentContextHold[] = [];\n  if (isHoldsEnabled()) {\n    try {\n      const rawHolds = await fetchHoldsForWindow(booking.restaurant_id, window, supabase);\n      holds = await hydrateHoldMetadata(rawHolds, supabase);\n    } catch (error: unknown) {\n      const code = extractErrorCode(error);\n      if (code === \"42P01\") {\n        console.warn(\"[capacity][manual][context] holds table unavailable; skipping hold hydration\", {\n          bookingId,\n        });\n      } else {\n        console.warn(\"[capacity][manual][context] failed to list holds\", { bookingId, error });\n      }\n      holds = [];\n    }\n  }\n\n  const busy = buildBusyMaps({\n    targetBookingId: bookingId,\n    bookings: contextBookings,\n    holds,\n    policy,\n    targetWindow: window,\n  });\n\n  const bookingAssignments = await loadTableAssignmentsForTables(\n    bookingId,\n    tables.map((table) => table.id),\n    supabase,\n  );\n\n  const conflicts = extractConflictsForTables(\n    busy,\n    tables.map((table) => table.id),\n    window,\n  );\n\n  const activeHold = holds.find((hold) => hold.bookingId === bookingId) ?? null;\n\n  // Compute context version from holds + assignments + flags + window\n  const flags = {\n    holdsStrictConflicts: isHoldStrictConflictsEnabled(),\n    adjacencyRequired: isAllocatorAdjacencyRequired(),\n    adjacencyUndirected: isAdjacencyQueryUndirected(),\n  };\n  const contextVersionPayload = {\n    holds: holds.map((h) => ({ id: h.id, tableIds: h.tableIds, startAt: h.startAt, endAt: h.endAt })),\n    assignments: bookingAssignments.map((row) => row.table_id),\n    flags,\n    window: {\n      startAt: toIsoUtc(window.block.start),\n      endAt: toIsoUtc(window.block.end),\n    },\n  };\n  const contextVersion = computePayloadChecksum(contextVersionPayload);\n  const serverNow = toIsoUtc(DateTime.now());\n\n  return {\n    booking,\n    tables,\n    bookingAssignments: bookingAssignments.map((row) => row.table_id),\n    holds,\n    activeHold,\n    conflicts,\n    window: {\n      startAt: toIsoUtc(window.block.start),\n      endAt: toIsoUtc(window.block.end),\n    },\n    flags,\n    contextVersion,\n    serverNow,\n  };\n}\n\nasync function hydrateHoldMetadata(holds: TableHold[], client: DbClient): Promise<ManualAssignmentContextHold[]> {\n  if (holds.length === 0) {\n    return [];\n  }\n  const creatorIds = Array.from(\n    new Set(\n      holds\n        .map((hold) => hold.createdBy)\n        .filter((value): value is string => Boolean(value)),\n    ),\n  );\n\n  let creators: Array<{ id: string; name: string | null; email: string | null }> = [];\n  if (creatorIds.length > 0) {\n    const { data, error } = await client\n      .from(\"profiles\")\n      .select(\"id, name, email\")\n      .in(\"id\", creatorIds);\n\n    if (!error && data) {\n      creators = data as Array<{ id: string; name: string | null; email: string | null }>;\n    }\n  }\n\n  return holds.map((hold) => {\n    const creator = creators.find((profile) => profile.id === hold.createdBy);\n    return {\n      ...hold,\n      createdByName: creator?.name ?? null,\n      createdByEmail: creator?.email ?? null,\n    };\n  });\n}\n\nasync function fetchHoldsForWindow(\n  restaurantId: string,\n  window: ReturnType<typeof computeBookingWindow>,\n  client: DbClient,\n): Promise<TableHold[]> {\n  const { data, error } = await client\n    .from(\"table_holds\")\n    .select(\"*, table_hold_members(table_id)\")\n    .eq(\"restaurant_id\", restaurantId)\n    .gt(\"expires_at\", new Date().toISOString())\n    .lt(\"start_at\", toIsoUtc(window.block.end))\n    .gt(\"end_at\", toIsoUtc(window.block.start));\n\n  if (error || !data) {\n    throw error ?? new Error(\"Failed to load holds\");\n  }\n\n  const rows = data as TableHoldRow[];\n\n  return rows.map((row) => {\n    const members = row.table_hold_members ?? [];\n    const tableIds = members\n      .map((member) => member.table_id)\n      .filter((value): value is string => typeof value === \"string\");\n    return {\n      id: row.id,\n      bookingId: row.booking_id,\n      restaurantId: row.restaurant_id,\n      zoneId: row.zone_id,\n      startAt: row.start_at,\n      endAt: row.end_at,\n      expiresAt: row.expires_at,\n      tableIds,\n      createdBy: row.created_by ?? null,\n      metadata: row.metadata ?? null,\n    } satisfies TableHold;\n  });\n}\n\nasync function loadActiveHoldsForDate(\n  restaurantId: string,\n  bookingDate: string | null,\n  policy: VenuePolicy,\n  client: DbClient,\n): Promise<TableHold[]> {\n  if (!bookingDate) {\n    return [];\n  }\n\n  const day = DateTime.fromISO(bookingDate, { zone: policy.timezone ?? \"UTC\" });\n  if (!day.isValid) {\n    return [];\n  }\n\n  const dayStart = toIsoUtc(day.startOf(\"day\"));\n  const dayEnd = toIsoUtc(day.plus({ days: 1 }).startOf(\"day\"));\n  const now = toIsoUtc(DateTime.now());\n\n  const { data, error } = await client\n    .from(\"table_holds\")\n    .select(\"*, table_hold_members(table_id)\")\n    .eq(\"restaurant_id\", restaurantId)\n    .gt(\"expires_at\", now)\n    .lt(\"start_at\", dayEnd)\n    .gt(\"end_at\", dayStart);\n\n  if (error || !data) {\n    throw error ?? new Error(\"Failed to load holds\");\n  }\n\n  const rows = data as TableHoldRow[];\n\n  return rows.map((row) => {\n    const members = row.table_hold_members ?? [];\n    const tableIds = members\n      .map((member) => member.table_id)\n      .filter((value): value is string => typeof value === \"string\");\n    return {\n      id: row.id,\n      bookingId: row.booking_id,\n      restaurantId: row.restaurant_id,\n      zoneId: row.zone_id,\n      startAt: row.start_at,\n      endAt: row.end_at,\n      expiresAt: row.expires_at,\n      tableIds,\n      createdBy: row.created_by ?? null,\n      metadata: row.metadata ?? null,\n    } satisfies TableHold;\n  });\n}\n\ntype RawAssignmentRecord = {\n  tableId: string;\n  startAt?: string | null;\n  endAt?: string | null;\n  mergeGroupId?: string | null;\n};\n\ntype AssignmentSyncParams = {\n  supabase: DbClient;\n  booking: BookingRow;\n  tableIds: string[];\n  idempotencyKey: string | null;\n  assignments: RawAssignmentRecord[];\n  startIso: string;\n  endIso: string;\n  actorId?: string | null;\n  mergeGroupId?: string | null;\n  holdContext?: {\n    holdId: string;\n    zoneId?: string | null;\n  };\n};\n\nfunction serializeDetails(value: unknown): string | null {\n  if (value === null || value === undefined) {\n    return null;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  try {\n    return JSON.stringify(value);\n  } catch {\n    return null;\n  }\n}\n\nasync function synchronizeAssignments(params: AssignmentSyncParams): Promise<TableAssignmentMember[]> {\n  const { supabase, booking, tableIds, idempotencyKey, assignments, startIso, endIso, actorId, mergeGroupId, holdContext } = params;\n  const uniqueTableIds = Array.from(new Set(tableIds));\n  const assignmentRows = await loadTableAssignmentsForTables(booking.id, uniqueTableIds, supabase);\n  const windowRange = `[${startIso},${endIso})`;\n\n  const needsUpdate = assignments.some((assignment) => {\n    const normalizedStart = normalizeIsoString(assignment.startAt ?? null);\n    const normalizedEnd = normalizeIsoString(assignment.endAt ?? null);\n    return normalizedStart !== startIso || normalizedEnd !== endIso;\n  });\n\n  if (needsUpdate) {\n    try {\n      await supabase\n        .from(\"booking_table_assignments\")\n        .update({ start_at: startIso, end_at: endIso })\n        .eq(\"booking_id\", booking.id)\n        .in(\"table_id\", uniqueTableIds);\n    } catch {\n      // Ignore in mocked environments.\n    }\n\n    try {\n      await supabase\n        .from(\"allocations\")\n        .update({ window: windowRange })\n        .eq(\"booking_id\", booking.id)\n        .eq(\"resource_type\", TABLE_RESOURCE_TYPE)\n        .in(\"resource_id\", uniqueTableIds);\n    } catch {\n      // Ignore missing allocation support in mocked environments.\n    }\n\n  if (idempotencyKey) {\n      try {\n        await supabase\n          .from(\"booking_assignment_idempotency\")\n          .update({\n            assignment_window: windowRange,\n            merge_group_allocation_id: mergeGroupId ?? null,\n            payload_checksum: computePayloadChecksum({\n              bookingId: booking.id,\n              tableIds: uniqueTableIds,\n              startAt: startIso,\n              endAt: endIso,\n              actorId,\n              holdId: holdContext?.holdId ?? null,\n            }) as unknown as string,\n          } as Record<string, unknown>)\n          .eq(\"booking_id\", booking.id)\n          .eq(\"idempotency_key\", idempotencyKey);\n      } catch {\n        // Ignore ledger updates in mocked environments.\n      }\n    }\n  }\n\n  const assignmentLookup = new Map<string, RawAssignmentRecord>();\n  for (const assignment of assignments) {\n    assignmentLookup.set(assignment.tableId, assignment);\n  }\n\n  const tableRowLookup = new Map(assignmentRows.map((row) => [row.table_id, row]));\n\n  const result: TableAssignmentMember[] = uniqueTableIds.map((tableId) => {\n    const row = tableRowLookup.get(tableId);\n    const assignment = assignmentLookup.get(tableId);\n    return {\n      tableId,\n      assignmentId: row?.id ?? randomUUID(),\n      startAt: startIso,\n      endAt: endIso,\n      mergeGroupId: assignment?.mergeGroupId ?? mergeGroupId ?? null,\n    };\n  });\n\n  if (holdContext) {\n    const zoneId = holdContext.zoneId ?? \"\";\n    const telemetryMetadata = holdContext.zoneId ? undefined : { unknownZone: true };\n    try {\n      const { enqueueOutboxEvent } = await import(\"@/server/outbox\");\n      await enqueueOutboxEvent({\n        eventType: \"capacity.hold.confirmed\",\n        restaurantId: booking.restaurant_id,\n        bookingId: booking.id,\n        idempotencyKey: idempotencyKey ?? null,\n        dedupeKey: `${booking.id}:${holdContext.holdId}:hold.confirmed`,\n        payload: {\n          holdId: holdContext.holdId,\n          bookingId: booking.id,\n          restaurantId: booking.restaurant_id,\n          zoneId,\n          tableIds: result.map((assignment) => assignment.tableId),\n          startAt: startIso,\n          endAt: endIso,\n          expiresAt: endIso,\n          actorId: actorId ?? null,\n          metadata: telemetryMetadata ?? null,\n        },\n      });\n    } catch (e) {\n      console.warn(\"[capacity.outbox] enqueue hold.confirmed failed\", { bookingId: booking.id, error: e });\n    }\n  }\n\n  // Enqueue assignment sync observability event (post-commit)\n  try {\n    const { enqueueOutboxEvent } = await import(\"@/server/outbox\");\n    await enqueueOutboxEvent({\n      eventType: \"capacity.assignment.sync\",\n      restaurantId: booking.restaurant_id,\n      bookingId: booking.id,\n      idempotencyKey: idempotencyKey ?? null,\n      dedupeKey: `${booking.id}:${startIso}:${endIso}:${result.map(r=>r.tableId).join(',')}`,\n      payload: {\n        bookingId: booking.id,\n        restaurantId: booking.restaurant_id,\n        tableIds: result.map((assignment) => assignment.tableId),\n        startAt: startIso,\n        endAt: endIso,\n        mergeGroupId: mergeGroupId ?? null,\n        idempotencyKey: idempotencyKey ?? null,\n      },\n    });\n  } catch (e) {\n    console.warn(\"[capacity.outbox] enqueue assignment.sync failed\", { bookingId: booking.id, error: e });\n  }\n\n  return result;\n}\n\nexport async function confirmHoldAssignment(options: {\n  holdId: string;\n  bookingId: string;\n  idempotencyKey: string;\n  requireAdjacency?: boolean;\n  assignedBy?: string | null;\n  client?: DbClient;\n}): Promise<TableAssignmentMember[]> {\n  if (!isAllocatorV2Enabled()) {\n    throw new AssignTablesRpcError({\n      message: \"Allocator v2 must be enabled to confirm holds\",\n      code: \"ALLOCATOR_V2_DISABLED\",\n      details: null,\n      hint: \"Enable allocator.v2.enabled to use confirmHoldAssignment\",\n    });\n  }\n\n  const { holdId, bookingId, requireAdjacency: requireAdjacencyOverride, assignedBy = null, client } = options;\n  const supabase = ensureClient(client);\n\n  const {\n    data: holdRow,\n    error: holdError,\n  } = await supabase\n    .from(\"table_holds\")\n    .select(\"restaurant_id, zone_id, booking_id, metadata, table_hold_members(table_id)\")\n    .eq(\"id\", holdId)\n    .maybeSingle();\n\n  if (holdError) {\n    throw new HoldNotFoundError(holdError.message ?? \"Failed to load table hold\");\n  }\n\n  if (!holdRow) {\n    throw new HoldNotFoundError();\n  }\n\n  const tableIds = Array.isArray(holdRow.table_hold_members)\n    ? (holdRow.table_hold_members as Array<{ table_id: string }>).map((member) => member.table_id)\n    : [];\n\n  const holdBookingId = (holdRow as { booking_id?: string | null }).booking_id ?? null;\n  if (holdBookingId && holdBookingId !== bookingId) {\n    await emitRpcConflict({\n      source: \"confirm_hold_booking_mismatch\",\n      bookingId,\n      restaurantId: holdRow.restaurant_id,\n      tableIds,\n      holdId,\n      error: {\n        code: \"HOLD_BOOKING_MISMATCH\",\n        message: \"Hold is already linked to a different booking\",\n        details: serializeDetails({ holdBookingId }),\n        hint: null,\n      },\n    });\n\n    throw new AssignTablesRpcError({\n      message: \"Hold is already linked to a different booking\",\n      code: \"HOLD_BOOKING_MISMATCH\",\n      details: serializeDetails({ holdBookingId }),\n      hint: null,\n    });\n  }\n\n  if (tableIds.length === 0) {\n    throw new AssignTablesRpcError({\n      message: \"Hold has no tables\",\n      code: \"HOLD_EMPTY\",\n      details: null,\n      hint: null,\n    });\n  }\n\n  const booking = await loadBooking(bookingId, supabase);\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const policyVersion = hashPolicyVersion(policy);\n  const holdPolicyVersion = (holdRow as { metadata?: { policyVersion?: string } })?.metadata?.policyVersion ?? null;\n  if (holdPolicyVersion && holdPolicyVersion !== policyVersion) {\n    throw new AssignTablesRpcError({\n      message: \"Policy has changed since hold was created\",\n      code: \"POLICY_CHANGED\",\n      details: serializeDetails({ expected: holdPolicyVersion, actual: policyVersion }),\n      hint: \"Refresh and revalidate selection before confirming.\",\n    });\n  }\n  const { window } = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n  const requireAdjacency = resolveRequireAdjacency(booking.party_size, requireAdjacencyOverride);\n\n  const startIso = toIsoUtc(window.block.start);\n  const endIso = toIsoUtc(window.block.end);\n  const normalizedTableIds = normalizeTableIds(tableIds);\n  // Verify adjacency/zone snapshot freeze\n  const selectionSnapshot = ((holdRow as { \n    metadata?: { \n      selection?: { \n        snapshot?: {\n          zoneIds?: string[];\n          adjacency?: { undirected?: boolean; edges?: string[]; hash?: string };\n        } \n      } \n    } \n  })?.metadata?.selection?.snapshot ?? null);\n  if (selectionSnapshot) {\n    const currentTables = await loadTablesByIds(booking.restaurant_id, normalizedTableIds, supabase);\n    const currentZoneIds = Array.from(new Set(currentTables.map((t) => t.zoneId))).filter(Boolean) as string[];\n    const zonesMatch = JSON.stringify([...currentZoneIds].sort()) === JSON.stringify([...(selectionSnapshot.zoneIds ?? [])].sort());\n\n    const currentAdjacency = await loadAdjacency(booking.restaurant_id, normalizedTableIds, supabase);\n    const undirected = Boolean(selectionSnapshot.adjacency?.undirected);\n    const edgeSet = new Set<string>();\n    for (const a of normalizedTableIds) {\n      const neighbors = currentAdjacency.get(a);\n      if (!neighbors) continue;\n      for (const b of neighbors) {\n        if (!normalizedTableIds.includes(b)) continue;\n        const key = undirected ? ([a, b].sort((x, y) => x.localeCompare(y)) as [string, string]).join(\"->\") : `${a}->${b}`;\n        edgeSet.add(key);\n      }\n    }\n    const nowEdges = Array.from(edgeSet).sort();\n    const nowHash = computePayloadChecksum({ undirected, edges: nowEdges });\n    const edgesMatch =\n      nowHash === selectionSnapshot.adjacency?.hash &&\n      JSON.stringify(nowEdges) === JSON.stringify([...(selectionSnapshot.adjacency?.edges ?? [])].sort());\n\n    if (!zonesMatch || !edgesMatch) {\n      throw new AssignTablesRpcError({\n        message: !zonesMatch\n          ? \"Zone assignment changed since hold was created\"\n          : \"Adjacency definition changed since hold was created\",\n        code: \"POLICY_CHANGED\",\n        details: serializeDetails({\n          zones: { expected: selectionSnapshot.zoneIds ?? [], actual: currentZoneIds },\n          adjacency: {\n            undirected,\n            expectedHash: selectionSnapshot.adjacency?.hash ?? null,\n            actualHash: nowHash,\n            expectedEdges: selectionSnapshot.adjacency?.edges ?? [],\n            actualEdges: nowEdges,\n          },\n        }),\n        hint: \"Refresh and revalidate selection before confirming.\",\n      });\n    }\n  }\n  const planSignature = createPlanSignature({\n    bookingId,\n    tableIds: normalizedTableIds,\n    startAt: startIso,\n    endAt: endIso,\n  });\n  const deterministicKey = createDeterministicIdempotencyKey({\n    tenantId: booking.restaurant_id,\n    bookingId,\n    tableIds: normalizedTableIds,\n    startAt: startIso,\n    endAt: endIso,\n    policyVersion,\n  });\n  // Optional: pre-check for mismatched payloads for same key (legacy-compatible)\n  try {\n    const { data: existing } = await supabase\n      .from(\"booking_assignment_idempotency\")\n      .select(\"idempotency_key, booking_id, table_ids, assignment_window\")\n      .eq(\"booking_id\", bookingId)\n      .eq(\"idempotency_key\", deterministicKey)\n      .maybeSingle();\n    if (existing && typeof existing === \"object\") {\n      const existingTyped = existing as { table_ids?: unknown };\n      const sameTables = Array.isArray(existingTyped.table_ids)\n        ? normalizeTableIds(existingTyped.table_ids as string[]).join(\",\") === normalizedTableIds.join(\",\")\n        : true;\n      if (!sameTables) {\n        throw new AssignTablesRpcError({\n          message: \"Idempotency mismatch for the same key\",\n          code: \"RPC_VALIDATION\",\n          details: serializeDetails({ reason: \"IDEMPOTENCY_MISMATCH\" }),\n          hint: \"Retry using the same payload as the original request.\",\n        });\n      }\n    }\n  } catch {\n    // ignore lookup errors\n  }\n\n  const orchestrator = new AssignmentOrchestrator(new SupabaseAssignmentRepository(supabase));\n  let response;\n  try {\n    response = await orchestrator.commitPlan(\n      {\n        bookingId,\n        restaurantId: booking.restaurant_id,\n        partySize: booking.party_size,\n        zoneId: holdRow.zone_id,\n        serviceDate: booking.booking_date ?? null,\n        window: {\n          startAt: startIso,\n          endAt: endIso,\n        },\n        holdId,\n      },\n      {\n        signature: planSignature,\n        tableIds: normalizedTableIds,\n        startAt: startIso,\n        endAt: endIso,\n        metadata: {\n          holdId,\n        },\n      },\n      {\n        source: \"manual\",\n        idempotencyKey: deterministicKey,\n        actorId: assignedBy,\n        metadata: {\n          requireAdjacency,\n          holdId,\n        },\n        requireAdjacency,\n      },\n    );\n  } catch (error) {\n    if (error instanceof AssignmentConflictError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_CONFLICT\",\n        details: serializeDetails(error.details),\n        hint: error.details?.hint ?? null,\n      });\n    }\n\n    if (error instanceof AssignmentValidationError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_VALIDATION\",\n        details: serializeDetails(error.details),\n        hint: null,\n      });\n    }\n\n    if (error instanceof AssignmentRepositoryError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_REPOSITORY_ERROR\",\n        details: serializeDetails(error.cause ?? null),\n        hint: null,\n      });\n    }\n\n    throw error;\n  }\n\n  try {\n    await releaseHoldWithRetry({ holdId, client: supabase });\n  } catch (e) {\n    console.warn(\"[capacity.confirm] failed to release hold after confirm; will rely on sweeper\", {\n      holdId,\n      bookingId,\n      error: e instanceof Error ? e.message : String(e),\n    });\n  }\n\n  return synchronizeAssignments({\n    supabase,\n    booking,\n    tableIds: normalizedTableIds,\n    idempotencyKey: deterministicKey,\n    assignments: response.assignments.map((assignment) => ({\n      tableId: assignment.tableId,\n      startAt: assignment.startAt,\n      endAt: assignment.endAt,\n      mergeGroupId: assignment.mergeGroupId ?? response.mergeGroupId ?? null,\n    })),\n    startIso,\n    endIso,\n    actorId: assignedBy,\n    mergeGroupId: response.mergeGroupId ?? null,\n    holdContext: {\n      holdId,\n      zoneId: holdRow.zone_id ?? null,\n    },\n  });\n}\n\nexport async function assignTableToBooking(\n  bookingId: string,\n  tableIdOrIds: string | string[],\n  assignedBy: string | null,\n  client?: DbClient,\n  options?: { idempotencyKey?: string | null; requireAdjacency?: boolean; booking?: BookingRow },\n): Promise<string> {\n  if (!isAllocatorV2Enabled()) {\n    throw new AssignTablesRpcError({\n      message: \"Allocator v2 must be enabled to assign tables\",\n      code: \"ALLOCATOR_V2_DISABLED\",\n      details: null,\n      hint: \"Enable allocator.v2.enabled to call assignTableToBooking\",\n    });\n  }\n\n  const supabase = ensureClient(client);\n  const tableIds = Array.isArray(tableIdOrIds) ? tableIdOrIds : [tableIdOrIds];\n  if (tableIds.length === 0) {\n    throw new ManualSelectionInputError(\"Must provide at least one table id\", \"TABLES_REQUIRED\");\n  }\n\n  const booking = options?.booking ?? (await loadBooking(bookingId, supabase));\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const { window } = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n  const startIso = toIsoUtc(window.block.start);\n  const endIso = toIsoUtc(window.block.end);\n  const normalizedTableIds = normalizeTableIds(tableIds);\n  const planSignature = createPlanSignature({\n    bookingId,\n    tableIds: normalizedTableIds,\n    startAt: startIso,\n    endAt: endIso,\n    salt: options?.idempotencyKey ?? undefined,\n  });\n  const policyVersion = hashPolicyVersion(policy);\n  const deterministicKey = createDeterministicIdempotencyKey({\n    tenantId: booking.restaurant_id,\n    bookingId,\n    tableIds: normalizedTableIds,\n    startAt: startIso,\n    endAt: endIso,\n    policyVersion,\n  });\n  const idempotencyKey = options?.idempotencyKey ?? deterministicKey;\n  const requireAdjacency = options?.requireAdjacency ?? false;\n\n  const orchestrator = new AssignmentOrchestrator(new SupabaseAssignmentRepository(supabase));\n  let response;\n  try {\n    response = await orchestrator.commitPlan(\n      {\n        bookingId,\n        restaurantId: booking.restaurant_id,\n        partySize: booking.party_size,\n        serviceDate: booking.booking_date ?? null,\n        window: {\n          startAt: startIso,\n          endAt: endIso,\n        },\n      },\n      {\n        signature: planSignature,\n        tableIds: normalizedTableIds,\n        startAt: startIso,\n        endAt: endIso,\n        metadata: {\n          requestSource: \"assignTableToBooking\",\n        },\n      },\n      {\n        source: \"manual\",\n        idempotencyKey,\n        actorId: assignedBy,\n        metadata: {\n          requireAdjacency,\n        },\n        requireAdjacency,\n      },\n    );\n  } catch (error) {\n    if (error instanceof AssignmentConflictError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_CONFLICT\",\n        details: serializeDetails(error.details),\n        hint: error.details?.hint ?? null,\n      });\n    }\n\n    if (error instanceof AssignmentValidationError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_VALIDATION\",\n        details: serializeDetails(error.details),\n        hint: null,\n      });\n    }\n\n    if (error instanceof AssignmentRepositoryError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_REPOSITORY_ERROR\",\n        details: serializeDetails(error.cause ?? null),\n        hint: null,\n      });\n    }\n\n    throw error;\n  }\n\n  const synchronized = await synchronizeAssignments({\n    supabase,\n    booking,\n    tableIds: normalizedTableIds,\n    idempotencyKey,\n    assignments: response.assignments.map((assignment) => ({\n      tableId: assignment.tableId,\n      startAt: assignment.startAt,\n      endAt: assignment.endAt,\n      mergeGroupId: assignment.mergeGroupId ?? response.mergeGroupId ?? null,\n    })),\n    startIso,\n    endIso,\n    actorId: assignedBy,\n    mergeGroupId: response.mergeGroupId ?? null,\n  });\n\n  const firstAssignment = synchronized[0];\n  if (!firstAssignment) {\n    throw new AssignTablesRpcError({\n      message: \"Assignment failed with no records returned\",\n      code: \"ASSIGNMENT_EMPTY\",\n      details: null,\n      hint: null,\n    });\n  }\n\n  // Enqueue assignment sync observability event (post-commit)\n  try {\n    const { enqueueOutboxEvent } = await import(\"@/server/outbox\");\n    await enqueueOutboxEvent({\n      eventType: \"capacity.assignment.sync\",\n      restaurantId: booking.restaurant_id,\n      bookingId: booking.id,\n      idempotencyKey,\n      dedupeKey: `${booking.id}:${startIso}:${endIso}:${normalizedTableIds.join(',')}`,\n      payload: {\n        bookingId: booking.id,\n        restaurantId: booking.restaurant_id,\n        tableIds: normalizedTableIds,\n        startAt: startIso,\n        endAt: endIso,\n        mergeGroupId: response.mergeGroupId ?? null,\n        idempotencyKey,\n      },\n    });\n  } catch (e) {\n    console.warn(\"[capacity.outbox] enqueue assignment.sync failed\", { bookingId: booking.id, error: e });\n  }\n\n  return firstAssignment.assignmentId;\n}\n\nexport async function unassignTableFromBooking(\n  bookingId: string,\n  tableId: string,\n  client?: DbClient,\n): Promise<boolean> {\n  const supabase = ensureClient(client);\n  const { data, error } = await supabase.rpc(\"unassign_tables_atomic\", {\n    p_booking_id: bookingId,\n    p_table_ids: [tableId],\n  });\n  if (error) {\n    return false;\n  }\n  return Array.isArray(data) && data.length > 0;\n}\n\nexport async function getBookingTableAssignments(\n  bookingId: string,\n  client?: DbClient,\n): Promise<TableAssignmentMember[]> {\n  const supabase = ensureClient(client);\n  const { data, error } = await supabase\n    .from(\"booking_table_assignments\")\n    .select(\"table_id, id, assigned_at\")\n    .eq(\"booking_id\", bookingId);\n\n  if (error || !data) {\n    return [];\n  }\n\n  return data.map((row) => ({\n    tableId: row.table_id,\n    assignmentId: row.id,\n    startAt: row.assigned_at ?? \"\",\n    endAt: row.assigned_at ?? \"\",\n    mergeGroupId: null,\n  }));\n}\n\nexport async function quoteTablesForBooking(options: QuoteTablesOptions): Promise<QuoteTablesResult> {\n  const {\n    bookingId,\n    zoneId,\n    maxTables,\n    requireAdjacency: requireAdjacencyOverride,\n    avoidTables = [],\n    holdTtlSeconds = DEFAULT_HOLD_TTL_SECONDS,\n    createdBy,\n    client,\n  } = options;\n\n  const operationStart = highResNow();\n  const supabase = ensureClient(client);\n  const booking = await loadBooking(bookingId, supabase);\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const {\n    window,\n    usedFallback: bookingWindowUsedFallback,\n    fallbackService: bookingWindowFallbackService,\n  } = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n\n  const tables = await loadTablesForRestaurant(booking.restaurant_id, supabase);\n  const adjacency = await loadAdjacency(\n    booking.restaurant_id,\n    tables.map((table) => table.id),\n    supabase,\n  );\n  const requireAdjacency = resolveRequireAdjacency(booking.party_size, requireAdjacencyOverride);\n  const timePruningEnabled = isPlannerTimePruningEnabled();\n  const lookaheadEnabled = isSelectorLookaheadEnabled();\n  let timePruningStats: TimeFilterStats | null = null;\n  let busyForPlanner: AvailabilityMap | undefined;\n  let contextBookings: ContextBookingRow[] = [];\n  let holdsForDay: TableHold[] = [];\n\n  if (timePruningEnabled || lookaheadEnabled) {\n    contextBookings = await loadContextBookings(\n      booking.restaurant_id,\n      booking.booking_date ?? null,\n      supabase,\n      {\n        startIso: toIsoUtc(window.block.start),\n        endIso: toIsoUtc(window.block.end),\n      },\n    );\n    if (isHoldsEnabled()) {\n      try {\n        holdsForDay = await loadActiveHoldsForDate(booking.restaurant_id, booking.booking_date ?? null, policy, supabase);\n      } catch (error: unknown) {\n        const code = extractErrorCode(error);\n        if (code === \"42P01\") {\n          console.warn(\"[capacity.quote] holds table unavailable; skipping hold hydration\", {\n            restaurantId: booking.restaurant_id,\n          });\n        } else {\n          console.warn(\"[capacity.quote] failed to load active holds\", {\n            restaurantId: booking.restaurant_id,\n            error,\n          });\n        }\n        holdsForDay = [];\n      }\n    }\n  }\n\n  if (timePruningEnabled) {\n    busyForPlanner = buildBusyMaps({\n      targetBookingId: booking.id,\n      bookings: contextBookings,\n      holds: holdsForDay,\n      policy,\n      targetWindow: window,\n    });\n  }\n\n  const filtered = filterAvailableTables(\n    tables,\n    booking.party_size,\n    window,\n    adjacency,\n    new Set(avoidTables),\n    zoneId ?? null,\n    {\n      allowInsufficientCapacity: true,\n      timeFilter:\n        busyForPlanner && timePruningEnabled\n          ? {\n              busy: busyForPlanner,\n              mode: \"strict\",\n              captureStats: (stats) => {\n                timePruningStats = stats;\n              },\n            }\n          : undefined,\n    },\n  );\n\n  const strategicOptions = { restaurantId: booking.restaurant_id ?? null } as const;\n  await loadStrategicConfig({ ...strategicOptions, client: supabase });\n  const baseScoringConfig = getSelectorScoringConfig(strategicOptions);\n  const selectorLimits = getSelectorPlannerLimits();\n  const combinationEnabled = isCombinationPlannerEnabled();\n  const combinationLimit = maxTables ?? getAllocatorCombinationLimit();\n  const demandMultiplierResult = await resolveDemandMultiplier({\n    restaurantId: booking.restaurant_id,\n    serviceStart: window.block.start,\n    serviceKey: window.service,\n    timezone: policy.timezone,\n    client: supabase,\n  });\n  const demandMultiplier = demandMultiplierResult?.multiplier ?? 1;\n  const demandRule = demandMultiplierResult?.rule;\n  const tableScarcityScores = await loadTableScarcityScores({\n    restaurantId: booking.restaurant_id,\n    tables: filtered,\n    client: supabase,\n  });\n  const scoringConfig: SelectorScoringConfig = {\n    ...baseScoringConfig,\n    weights: {\n      ...baseScoringConfig.weights,\n      scarcity: getYieldManagementScarcityWeight(strategicOptions),\n    },\n  };\n  const plannerStart = highResNow();\n  const plans = buildScoredTablePlans({\n    tables: filtered,\n    partySize: booking.party_size,\n    adjacency,\n    config: scoringConfig,\n    enableCombinations: combinationEnabled,\n    kMax: combinationLimit,\n    maxPlansPerSlack: selectorLimits.maxPlansPerSlack,\n    maxCombinationEvaluations: selectorLimits.maxCombinationEvaluations,\n    enumerationTimeoutMs: selectorLimits.enumerationTimeoutMs,\n    requireAdjacency,\n    demandMultiplier,\n    tableScarcityScores,\n  });\n  // const topRankedPlan = plans.plans[0] ?? null;\n  const lookaheadConfig: LookaheadConfig = {\n    enabled: lookaheadEnabled,\n    windowMinutes: getSelectorLookaheadWindowMinutes(),\n    penaltyWeight: getSelectorLookaheadPenaltyWeight(),\n    blockThreshold: getSelectorLookaheadBlockThreshold(),\n  };\n  const lookaheadDiagnostics = evaluateLookahead({\n    lookahead: lookaheadConfig,\n    bookingId: booking.id,\n    bookingWindow: window,\n    plansResult: plans,\n    tables,\n    adjacency,\n    zoneId: zoneId ?? null,\n    policy,\n    contextBookings,\n    holds: holdsForDay,\n    combinationEnabled,\n    combinationLimit,\n    selectorLimits,\n    scoringConfig,\n  });\n  plans.diagnostics.lookahead = lookaheadDiagnostics;\n  const plannerDurationMs = highResNow() - plannerStart;\n  const adjacencyRequiredGlobally = adjacency.size > 0 && isAllocatorAdjacencyRequired();\n  const adjacencyMinPartySize = getAllocatorAdjacencyMinPartySize();\n  const featureFlags = buildSelectorFeatureFlagsTelemetry();\n  const plannerConfigTelemetry = composePlannerConfig({\n    diagnostics: plans.diagnostics,\n    scoringConfig,\n    combinationEnabled,\n    requireAdjacency,\n    adjacencyRequiredGlobally,\n    adjacencyMinPartySize: adjacencyMinPartySize ?? null,\n    featureFlags,\n    serviceFallback: {\n      usedFallback: bookingWindowUsedFallback,\n      fallbackService: bookingWindowFallbackService,\n    },\n    demandMultiplier,\n    demandRule,\n    lookahead: lookaheadConfig,\n  });\n  if (!timePruningStats) {\n    timePruningStats = {\n      prunedByTime: 0,\n      candidatesAfterTimePrune: filtered.length,\n      pruned_by_time: 0,\n      candidates_after_time_prune: filtered.length,\n    };\n  }\n  plans.diagnostics.timePruning = {\n    prunedByTime: timePruningStats.prunedByTime,\n    candidatesAfterTimePrune: timePruningStats.candidatesAfterTimePrune,\n    pruned_by_time: timePruningStats.pruned_by_time,\n    candidates_after_time_prune: timePruningStats.candidates_after_time_prune,\n  };\n\n  const alternates: CandidateSummary[] = [];\n  const skippedCandidates: Array<{ candidate: CandidateSummary; reason: string; conflicts: HoldConflictInfo[] }> = [];\n  const holdConflictHoldIds = new Set<string>();\n  let holdConflictSkipCount = 0;\n\n  const applyQuoteSkipDiagnostics = () => {\n    plans.diagnostics.quoteSkips = {\n      holdConflicts: {\n        count: holdConflictSkipCount,\n        holdIds: Array.from(holdConflictHoldIds),\n      },\n    };\n  };\n\n  const recordHoldConflictSkip = (conflicts: HoldConflictInfo[], candidate: CandidateSummary, plan: RankedTablePlan) => {\n    holdConflictSkipCount += 1;\n    for (const conflict of conflicts) {\n      if (conflict.holdId) {\n        holdConflictHoldIds.add(conflict.holdId);\n      }\n    }\n    skippedCandidates.push({\n      candidate,\n      reason: formatHoldConflictReason(conflicts, plan),\n      conflicts,\n    });\n  };\n\n  for (let index = 0; index < plans.plans.length; index += 1) {\n    const plan = plans.plans[index]!;\n    const candidateSummary = summarizeCandidate({\n      tableIds: plan.tables.map((table) => table.id),\n      tableNumbers: plan.tables.map((table) => table.tableNumber),\n      totalCapacity: plan.totalCapacity,\n      tableCount: plan.tables.length,\n      slack: plan.slack,\n      score: plan.score,\n      adjacencyStatus: plan.adjacencyStatus,\n      scoreBreakdown: plan.scoreBreakdown,\n    });\n\n    const conflicts = await findHoldConflicts({\n      restaurantId: booking.restaurant_id,\n      tableIds: plan.tables.map((table) => table.id),\n      startAt: toIsoUtc(window.block.start),\n      endAt: toIsoUtc(window.block.end),\n      client: supabase,\n    });\n\n    if (conflicts.length > 0) {\n      recordHoldConflictSkip(conflicts, candidateSummary, plan);\n      continue;\n    }\n\n    if (index > 0) {\n      alternates.push(candidateSummary);\n    }\n\n    try {\n      const summary = summarizeSelection(plan.tables, booking.party_size);\n      const zoneForHold = summary.zoneId ?? plan.tables[0]?.zoneId;\n      if (!zoneForHold) {\n        continue;\n      }\n\n      const holdStart = highResNow();\n      const hold = await createTableHold({\n        bookingId,\n        restaurantId: booking.restaurant_id,\n        zoneId: zoneForHold,\n        tableIds: plan.tables.map((table) => table.id),\n        startAt: toIsoUtc(window.block.start),\n        endAt: toIsoUtc(window.block.end),\n        expiresAt: toIsoUtc(DateTime.now().plus({ seconds: holdTtlSeconds })),\n        createdBy,\n        metadata: {\n          selection: {\n            tableIds: plan.tables.map((table) => table.id),\n            summary,\n          },\n        },\n        client: supabase,\n      });\n      const holdDurationMs = highResNow() - holdStart;\n      const totalDurationMs = highResNow() - operationStart;\n\n      applyQuoteSkipDiagnostics();\n      await emitSelectorQuote({\n        restaurantId: booking.restaurant_id,\n        bookingId,\n        partySize: booking.party_size,\n        window: {\n          start: toIsoUtc(window.block.start),\n          end: toIsoUtc(window.block.end),\n        },\n        candidates: [candidateSummary, ...alternates],\n        selected: candidateSummary,\n        durationMs: roundMilliseconds(totalDurationMs),\n        featureFlags,\n        timing: buildTiming({\n          totalMs: totalDurationMs,\n          plannerMs: plannerDurationMs,\n          holdMs: holdDurationMs,\n        }),\n        plannerConfig: plannerConfigTelemetry,\n        diagnostics: plans.diagnostics,\n        holdId: hold.id,\n        expiresAt: hold.expiresAt,\n      });\n\n      return {\n        hold,\n        candidate: candidateSummary,\n        alternates,\n        nextTimes: [],\n        skipped: skippedCandidates,\n        metadata: {\n          usedFallback: bookingWindowUsedFallback,\n          fallbackService: bookingWindowFallbackService,\n        },\n      };\n    } catch (error) {\n      if (error instanceof HoldConflictError) {\n        const refreshedConflicts = await findHoldConflicts({\n          restaurantId: booking.restaurant_id,\n          tableIds: plan.tables.map((table) => table.id),\n          startAt: toIsoUtc(window.block.start),\n          endAt: toIsoUtc(window.block.end),\n          client: supabase,\n        });\n\n        recordHoldConflictSkip(refreshedConflicts, candidateSummary, plan);\n        await emitRpcConflict({\n          source: \"create_hold_conflict\",\n          bookingId,\n          restaurantId: booking.restaurant_id,\n          tableIds: plan.tables.map((table) => table.id),\n          holdId: error.holdId ?? null,\n          error: {\n            code: null,\n            message: error.message,\n            details: JSON.stringify(refreshedConflicts),\n            hint: null,\n          },\n        });\n\n        applyQuoteSkipDiagnostics();\n        continue;\n      }\n      throw error;\n    }\n  }\n  applyQuoteSkipDiagnostics();\n\n  return {\n    hold: null,\n    candidate: null,\n    alternates,\n    nextTimes: [],\n    reason: plans.fallbackReason ?? \"No suitable tables available\",\n    skipped: skippedCandidates,\n    metadata: {\n      usedFallback: bookingWindowUsedFallback,\n      fallbackService: bookingWindowFallbackService,\n    },\n  };\n}\n\nexport async function findSuitableTables(options: {\n  bookingId: string;\n  client?: DbClient;\n}): Promise<RankedTablePlan[]> {\n  const { bookingId, client } = options;\n  const supabase = ensureClient(client);\n  const booking = await loadBooking(bookingId, supabase);\n  const tables = await loadTablesForRestaurant(booking.restaurant_id, supabase);\n  const adjacency = await loadAdjacency(\n    booking.restaurant_id,\n    tables.map((table) => table.id),\n    supabase,\n  );\n  const defaultPolicy = getVenuePolicy();\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    defaultPolicy.timezone;\n  const policy =\n    restaurantTimezone === defaultPolicy.timezone\n      ? defaultPolicy\n      : getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const { window } = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n\n  const filtered = filterAvailableTables(\n    tables,\n    booking.party_size,\n    window,\n    adjacency,\n    undefined,\n    undefined,\n    { allowInsufficientCapacity: true },\n  );\n  const strategicOptions = { restaurantId: booking.restaurant_id ?? null } as const;\n  await loadStrategicConfig({ ...strategicOptions, client: supabase });\n  const baseScoringConfig = getSelectorScoringConfig(strategicOptions);\n  const requireAdjacency = partiesRequireAdjacency(booking.party_size);\n  const selectorLimits = getSelectorPlannerLimits();\n  const demandMultiplierResult = await resolveDemandMultiplier({\n    restaurantId: booking.restaurant_id,\n    serviceStart: window.block.start,\n    serviceKey: window.service,\n    timezone: policy.timezone,\n    client: supabase,\n  });\n  const demandMultiplier = demandMultiplierResult?.multiplier ?? 1;\n  const tableScarcityScores = await loadTableScarcityScores({\n    restaurantId: booking.restaurant_id,\n    tables: filtered,\n    client: supabase,\n  });\n  const scoringConfig: SelectorScoringConfig = {\n    ...baseScoringConfig,\n    weights: {\n      ...baseScoringConfig.weights,\n      scarcity: getYieldManagementScarcityWeight(strategicOptions),\n    },\n  };\n  const plans = buildScoredTablePlans({\n    tables: filtered,\n    partySize: booking.party_size,\n    adjacency,\n    config: scoringConfig,\n    enableCombinations: isCombinationPlannerEnabled(),\n    kMax: getAllocatorCombinationLimit(),\n    maxPlansPerSlack: selectorLimits.maxPlansPerSlack,\n    maxCombinationEvaluations: selectorLimits.maxCombinationEvaluations,\n    enumerationTimeoutMs: selectorLimits.enumerationTimeoutMs,\n    requireAdjacency,\n    demandMultiplier,\n    tableScarcityScores,\n  });\n\n  return plans.plans;\n}\n\nexport async function isTableAvailableV2(\n  tableId: string,\n  startISO: string,\n  partySize: number,\n  options?: {\n    excludeBookingId?: string;\n    policy?: VenuePolicy;\n    client?: DbClient;\n  },\n): Promise<boolean> {\n  const supabase = ensureClient(options?.client);\n  const policy = options?.policy ?? getVenuePolicy();\n  const { window } = computeBookingWindowWithFallback({\n    startISO,\n    partySize,\n    policy,\n  });\n\n  const startAt = toIsoUtc(window.block.start);\n  const endAt = toIsoUtc(window.block.end);\n\n  try {\n    const { data, error } = await (supabase as unknown as {\n      rpc: (\n        fn: string,\n        args: {\n          p_table_id: string;\n          p_start_at: string;\n          p_end_at: string;\n          p_exclude_booking_id: string | null;\n        },\n      ) => Promise<{ data: boolean | null; error: { message?: string; details?: string | null; hint?: string | null; code?: string | null } | null }>;\n    }).rpc(\"is_table_available_v2\", {\n      p_table_id: tableId,\n      p_start_at: startAt,\n      p_end_at: endAt,\n      p_exclude_booking_id: options?.excludeBookingId ?? null,\n    });\n\n    if (error) {\n      const code = extractErrorCode(error);\n      if (code === \"42883\" || code === \"42P01\") {\n        return await legacyTableAvailabilityCheck({\n          supabase,\n          tableId,\n          startAt,\n          endAt,\n          excludeBookingId: options?.excludeBookingId ?? null,\n        });\n      }\n      throw new AssignTablesRpcError({\n        message: error.message ?? \"Failed to query table availability\",\n        code: \"TABLE_AVAILABILITY_QUERY_FAILED\",\n        details: serializeDetails({\n          code: code ?? null,\n          details: error.details ?? null,\n          hint: error.hint ?? null,\n        }),\n        hint: null,\n      });\n    }\n\n    if (typeof data === \"boolean\") {\n      return data;\n    }\n  } catch (error) {\n    const code = extractErrorCode(error);\n    if (code !== \"42883\" && code !== \"42P01\") {\n      throw new AssignTablesRpcError({\n        message: error instanceof Error ? error.message : \"Failed to verify table availability\",\n        code: \"TABLE_AVAILABILITY_QUERY_FAILED\",\n        details: error instanceof Error ? error.stack ?? null : null,\n        hint: null,\n      });\n    }\n    return await legacyTableAvailabilityCheck({\n      supabase,\n      tableId,\n      startAt,\n      endAt,\n      excludeBookingId: options?.excludeBookingId ?? null,\n    });\n  }\n\n  return await legacyTableAvailabilityCheck({\n    supabase,\n    tableId,\n    startAt,\n    endAt,\n    excludeBookingId: options?.excludeBookingId ?? null,\n  });\n}\n\nasync function legacyTableAvailabilityCheck(params: {\n  supabase: DbClient;\n  tableId: string;\n  startAt: string;\n  endAt: string;\n  excludeBookingId?: string | null;\n}): Promise<boolean> {\n  const { supabase, tableId, startAt, endAt, excludeBookingId } = params;\n\n  const { data, error } = await supabase\n    .from(\"booking_table_assignments\")\n    .select(\"table_id, start_at, end_at, bookings(id, status, start_at, end_at)\")\n    .eq(\"table_id\", tableId);\n\n  if (error || !data) {\n    throw new AssignTablesRpcError({\n      message: error?.message ?? \"Failed to query table availability\",\n      code: \"TABLE_AVAILABILITY_QUERY_FAILED\",\n      details: serializeDetails({\n        code: (error as { code?: string })?.code ?? null,\n        details: error?.details ?? null,\n        hint: error?.hint ?? null,\n      }),\n      hint: null,\n    });\n  }\n\n  const rows = data as AssignmentAvailabilityRow[];\n  for (const row of rows) {\n    const booking = row.bookings;\n    if (excludeBookingId && booking?.id === excludeBookingId) {\n      continue;\n    }\n    if (booking && ![\"pending\", \"confirmed\", \"seated\"].includes(booking.status ?? \"\")) {\n      continue;\n    }\n    const otherStart = row.start_at ?? booking?.start_at;\n    const otherEnd = row.end_at ?? booking?.end_at;\n    if (!otherStart || !otherEnd) {\n      continue;\n    }\n    if (windowsOverlap({ start: startAt, end: endAt }, { start: otherStart, end: otherEnd })) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport async function isTableAvailable(\n  tableId: string,\n  startISO: string,\n  partySize: number,\n  options?: {\n    excludeBookingId?: string;\n    policy?: VenuePolicy;\n    client?: DbClient;\n  },\n): Promise<boolean> {\n  try {\n    return await isTableAvailableV2(tableId, startISO, partySize, options);\n  } catch (error) {\n    if (error instanceof AssignTablesRpcError) {\n      throw new AssignTablesRpcError({\n        message: \"Failed to verify table availability\",\n        code: error.code ?? \"TABLE_AVAILABILITY_QUERY_FAILED\",\n        details: error.details,\n        hint: error.hint ?? null,\n      });\n    }\n    throw error;\n  }\n}\n\nexport const __internal = {\n  computeBookingWindow,\n  windowsOverlap,\n  filterAvailableTables,\n  filterTimeAvailableTables,\n  extractConflictsForTables,\n};\n"
    },
    {
      "path": "server/capacity/telemetry.ts",
      "size": 15748,
      "sha256": "59503ef4b87282d052c2c4ddf1761501a3f0ea00208ca26e46ce0119573450f8",
      "language": "typescript",
      "content": "import { recordObservabilityEvent } from \"@/server/observability\";\n\nimport type { SelectorScoringWeights, ServiceKey } from \"./policy\";\nimport type { CandidateDiagnostics, ScoreBreakdown } from \"./selector\";\nimport type { Json } from \"@/types/supabase\";\n\nconst EMAIL_PATTERN = /[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}/gi;\n\nconst SENSITIVE_NAME_KEYS = new Set([\n  \"name\",\n  \"guestName\",\n  \"guest_name\",\n  \"customerName\",\n  \"customer_name\",\n  \"primaryGuestName\",\n  \"primary_guest_name\",\n  \"createdByName\",\n  \"created_by_name\",\n  \"assignedToName\",\n  \"assigned_to_name\",\n]);\n\nfunction redactEmails(value: string): string {\n  if (!value) {\n    return value;\n  }\n  return value.replace(EMAIL_PATTERN, \"[redacted-email]\");\n}\n\nfunction sanitizeTelemetryValue(value: unknown, key?: string): Json {\n  if (value === null || value === undefined) {\n    return null;\n  }\n\n  if (typeof value === \"string\") {\n    if (key && SENSITIVE_NAME_KEYS.has(key)) {\n      return \"[redacted]\";\n    }\n    return redactEmails(value) as Json;\n  }\n\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map((item) => sanitizeTelemetryValue(item)) as Json[];\n  }\n\n  if (typeof value === \"object\") {\n    const result: Record<string, Json> = {};\n    for (const [entryKey, entryValue] of Object.entries(value as Record<string, unknown>)) {\n      if (SENSITIVE_NAME_KEYS.has(entryKey)) {\n        result[entryKey] = \"[redacted]\";\n        continue;\n      }\n      result[entryKey] = sanitizeTelemetryValue(entryValue, entryKey);\n    }\n    return result;\n  }\n\n  return null;\n}\n\nfunction sanitizeTelemetryContext<T extends Json>(input: T): T {\n  return sanitizeTelemetryValue(input) as T;\n}\n\nexport type CandidateSummary = {\n  tableIds: string[];\n  tableNumbers: string[];\n  totalCapacity: number;\n  tableCount: number;\n  slack?: number;\n  score?: number;\n  adjacencyStatus?: \"single\" | \"connected\" | \"disconnected\";\n  scoreBreakdown?: CandidateScoreBreakdown;\n};\n\nexport type CandidateScoreBreakdown = {\n  slack_penalty: number;\n  scarcity_penalty: number;\n  structural_penalty: number;\n  demand_multiplier: number;\n  combination_penalty: number;\n  future_conflict_penalty: number;\n  total_score: number;\n};\n\nexport type AvailabilitySnapshot = {\n  totalCandidates: number;\n  remainingAfterSelection: number;\n  remainingTables: Array<{\n    id: string;\n    tableNumber: string;\n    capacity: number;\n  }>;\n};\n\nexport type StrategicPenaltyTelemetry = {\n  dominant: \"slack\" | \"scarcity\" | \"future_conflict\" | \"structural\" | \"unknown\";\n  slack: number;\n  scarcity: number;\n  futureConflict: number;\n};\n\nexport type SelectorDecisionEvent = {\n  restaurantId: string;\n  bookingId: string;\n  partySize: number;\n  window?: { start: string | null; end: string | null };\n  candidates: CandidateSummary[];\n  selected?: CandidateSummary | null;\n  skipReason?: string | null;\n  rejectionClassification?: \"hard\" | \"strategic\" | null;\n  strategicPenalties?: StrategicPenaltyTelemetry | null;\n  durationMs: number;\n  featureFlags: {\n    selectorScoring: boolean;\n    opsMetrics: boolean;\n    plannerTimePruning: boolean;\n    adjacencyUndirected: boolean;\n    holdsStrictConflicts: boolean;\n    allocatorFailHard: boolean;\n    selectorLookahead: boolean;\n  };\n  timing?: {\n    totalMs: number;\n    plannerMs?: number;\n    assignmentMs?: number;\n    holdMs?: number;\n  };\n  plannerConfig?: {\n    combinationEnabled: boolean;\n    requireAdjacency: boolean;\n    adjacencyRequiredGlobally: boolean;\n    adjacencyMinPartySize: number | null;\n    kMax: number;\n    bucketLimit: number;\n    evaluationLimit: number;\n    maxOverage: number;\n    maxTables: number;\n    weights: SelectorScoringWeights;\n    featureFlags: {\n      selectorScoring: boolean;\n      opsMetrics: boolean;\n      plannerTimePruning: boolean;\n      adjacencyUndirected: boolean;\n      holdsStrictConflicts: boolean;\n      allocatorFailHard: boolean;\n      selectorLookahead: boolean;\n    };\n    serviceFallback: {\n      used: boolean;\n      service: ServiceKey | null;\n    };\n    demandMultiplier: number;\n    demandRule: {\n      label?: string | null;\n      source: string;\n      serviceWindow?: string | null;\n      days?: string[];\n      start?: string | null;\n      end?: string | null;\n      priority?: number | null;\n    } | null;\n    lookahead: {\n      enabled: boolean;\n      windowMinutes: number;\n      penaltyWeight: number;\n      blockThreshold: number;\n    };\n  };\n  diagnostics?: CandidateDiagnostics;\n  availabilitySnapshot?: AvailabilitySnapshot | null;\n};\n\nexport type SelectorDecisionCapture = {\n  type: \"capacity.selector\";\n  timestamp: string;\n  restaurantId: string;\n  bookingId: string;\n  partySize: number;\n  window: { start: string | null; end: string | null } | null;\n  selected: CandidateSummary | null;\n  topCandidates: CandidateSummary[];\n  candidates: CandidateSummary[];\n  skipReason: string | null;\n  rejectionClassification: \"hard\" | \"strategic\" | null;\n  strategicPenalties: StrategicPenaltyTelemetry | null;\n  durationMs: number;\n  featureFlags: SelectorDecisionEvent[\"featureFlags\"];\n  timing: SelectorDecisionEvent[\"timing\"] | null;\n  plannerConfig: SelectorDecisionEvent[\"plannerConfig\"] | null;\n  diagnostics: CandidateDiagnostics | null;\n  availabilitySnapshot: AvailabilitySnapshot | null;\n};\n\nexport function buildSelectorDecisionPayload(event: SelectorDecisionEvent): SelectorDecisionCapture {\n  const payload: SelectorDecisionCapture = {\n    type: \"capacity.selector\",\n    timestamp: new Date().toISOString(),\n    restaurantId: event.restaurantId,\n    bookingId: event.bookingId,\n    partySize: event.partySize,\n    window: event.window ?? null,\n    selected: event.selected ?? null,\n    topCandidates: event.candidates,\n    candidates: event.candidates,\n    skipReason: event.skipReason ?? null,\n    rejectionClassification: event.rejectionClassification ?? null,\n    strategicPenalties: event.strategicPenalties ?? null,\n    durationMs: event.durationMs,\n    featureFlags: event.featureFlags,\n    timing: event.timing ?? null,\n    plannerConfig: event.plannerConfig ?? null,\n    diagnostics: event.diagnostics ?? null,\n    availabilitySnapshot: event.availabilitySnapshot ?? null,\n  };\n\n  return sanitizeTelemetryContext(payload) as SelectorDecisionCapture;\n}\n\nexport async function emitSelectorDecision(event: SelectorDecisionEvent): Promise<void> {\n  const sanitizedPayload = buildSelectorDecisionPayload(event);\n\n  try {\n    console.log(JSON.stringify(sanitizedPayload));\n  } catch (error) {\n    console.error(\"[capacity.selector] failed to serialize log payload\", {\n      error,\n      bookingId: event.bookingId,\n      restaurantId: event.restaurantId,\n    });\n  }\n\n  try {\n    await recordObservabilityEvent({\n      source: \"capacity.selector\",\n      eventType: event.selected ? \"capacity.selector.assignment\" : \"capacity.selector.skipped\",\n      severity: event.skipReason ? \"warning\" : \"info\",\n      context: sanitizedPayload,\n      restaurantId: event.restaurantId,\n      bookingId: event.bookingId,\n    });\n  } catch (error) {\n    console.error(\"[capacity.selector] failed to persist observability event\", {\n      error,\n      bookingId: event.bookingId,\n      restaurantId: event.restaurantId,\n    });\n  }\n}\n\nexport type SelectorQuoteEvent = SelectorDecisionEvent & {\n  holdId?: string;\n  expiresAt?: string;\n};\n\nexport async function emitSelectorQuote(event: SelectorQuoteEvent): Promise<void> {\n  const payload = {\n    ...event,\n    type: \"capacity.selector.quote\",\n  };\n\n  const sanitizedPayload = sanitizeTelemetryContext(payload as Json);\n\n  try {\n    await recordObservabilityEvent({\n      source: \"capacity.selector\",\n      eventType: \"capacity.selector.quote\",\n      severity: event.skipReason ? \"warning\" : \"info\",\n      context: sanitizedPayload,\n      restaurantId: event.restaurantId,\n      bookingId: event.bookingId,\n    });\n  } catch (error) {\n    console.error(\"[capacity.selector.quote] failed to record telemetry\", {\n      error,\n      bookingId: event.bookingId,\n      restaurantId: event.restaurantId,\n    });\n  }\n}\n\nexport type HoldTelemetryEvent = {\n  holdId: string;\n  bookingId: string | null;\n  restaurantId: string;\n  zoneId: string;\n  tableIds: string[];\n  startAt: string;\n  endAt: string;\n  expiresAt?: string;\n  actorId?: string | null;\n  reason?: string | null;\n  metadata?: Json | null;\n};\n\nexport type HoldExtendedTelemetryEvent = HoldTelemetryEvent & {\n  previousExpiresAt: string;\n  newExpiresAt: string;\n};\n\nasync function emitHoldEvent(eventType: string, payload: HoldTelemetryEvent): Promise<void> {\n  const sanitizedPayload = sanitizeTelemetryContext(payload as Json);\n  try {\n    await recordObservabilityEvent({\n      source: \"capacity.hold\",\n      eventType,\n      severity: eventType.endsWith(\"expired\") ? \"warning\" : \"info\",\n      context: sanitizedPayload,\n      restaurantId: payload.restaurantId,\n      bookingId: payload.bookingId ?? undefined,\n    });\n  } catch (error) {\n    console.error(`[capacity.hold] failed to emit ${eventType}`, {\n      error,\n      holdId: payload.holdId,\n      bookingId: payload.bookingId,\n    });\n  }\n}\n\nexport async function emitHoldCreated(event: HoldTelemetryEvent): Promise<void> {\n  await emitHoldEvent(\"capacity.hold.created\", event);\n}\n\nexport async function emitHoldConfirmed(event: HoldTelemetryEvent): Promise<void> {\n  await emitHoldEvent(\"capacity.hold.confirmed\", event);\n}\n\nexport async function emitHoldExpired(event: HoldTelemetryEvent): Promise<void> {\n  await emitHoldEvent(\"capacity.hold.expired\", event);\n}\n\nexport async function emitHoldExtended(event: HoldExtendedTelemetryEvent): Promise<void> {\n  const baseMetadata: Record<string, unknown> =\n    event.metadata && typeof event.metadata === \"object\" && !Array.isArray(event.metadata)\n      ? { ...(event.metadata as Record<string, Json>) }\n      : {};\n\n  baseMetadata.previousExpiresAt = event.previousExpiresAt;\n  baseMetadata.newExpiresAt = event.newExpiresAt;\n\n  await emitHoldEvent(\"capacity.hold.extended\", {\n    ...event,\n    expiresAt: event.newExpiresAt,\n    metadata: baseMetadata as Json,\n  });\n}\n\nexport type HoldStrictConflictEvent = {\n  restaurantId: string;\n  bookingId: string | null;\n  tableIds: string[];\n  startAt: string;\n  endAt: string;\n  conflicts: Array<{\n    holdId: string;\n    bookingId: string | null;\n    tableIds: string[];\n    startAt: string;\n    endAt: string;\n    expiresAt: string;\n  }>;\n};\n\nexport async function emitHoldStrictConflict(event: HoldStrictConflictEvent): Promise<void> {\n  const sanitizedPayload = sanitizeTelemetryContext(event as Json);\n  try {\n    await recordObservabilityEvent({\n      source: \"capacity.hold\",\n      eventType: \"capacity.hold.strict_conflict\",\n      severity: \"warning\",\n      context: sanitizedPayload,\n      restaurantId: event.restaurantId,\n      bookingId: event.bookingId ?? undefined,\n    });\n  } catch (error) {\n    console.error(\"[capacity.hold] failed to record strict conflict telemetry\", {\n      error,\n      bookingId: event.bookingId,\n      restaurantId: event.restaurantId,\n    });\n  }\n}\n\n// Manual actions metrics (validate/hold/confirm)\ntype ManualActionBase = {\n  restaurantId: string;\n  bookingId: string;\n  policyVersion?: string | null;\n  adjacencyRequired?: boolean | null;\n};\n\nexport async function emitManualValidate(event: ManualActionBase & { ok: boolean; code?: string | null }): Promise<void> {\n  const payload = sanitizeTelemetryContext({\n    type: \"capacity.manual.validate\",\n    ok: event.ok,\n    code: event.code ?? null,\n    policyVersion: event.policyVersion ?? null,\n    adjacencyRequired: Boolean(event.adjacencyRequired),\n  } as Json);\n  try {\n    await recordObservabilityEvent({\n      source: \"capacity.manual\",\n      eventType: event.ok ? \"manual.validate.ok\" : \"manual.validate.fail\",\n      severity: event.ok ? \"info\" : \"warning\",\n      context: payload,\n      restaurantId: event.restaurantId,\n      bookingId: event.bookingId,\n    });\n  } catch (error) {\n    console.error(\"[capacity.manual.validate] telemetry failed\", { error, bookingId: event.bookingId });\n  }\n}\n\nexport async function emitManualHold(event: ManualActionBase & { ok: boolean; code?: string | null }): Promise<void> {\n  const payload = sanitizeTelemetryContext({\n    type: \"capacity.manual.hold\",\n    ok: event.ok,\n    code: event.code ?? null,\n    policyVersion: event.policyVersion ?? null,\n    adjacencyRequired: Boolean(event.adjacencyRequired),\n  } as Json);\n  try {\n    await recordObservabilityEvent({\n      source: \"capacity.manual\",\n      eventType: event.ok ? \"manual.hold.ok\" : \"manual.hold.fail\",\n      severity: event.ok ? \"info\" : \"warning\",\n      context: payload,\n      restaurantId: event.restaurantId,\n      bookingId: event.bookingId,\n    });\n  } catch (error) {\n    console.error(\"[capacity.manual.hold] telemetry failed\", { error, bookingId: event.bookingId });\n  }\n}\n\nexport async function emitManualConfirm(event: ManualActionBase & { ok: boolean; code?: string | null }): Promise<void> {\n  const payload = sanitizeTelemetryContext({\n    type: \"capacity.manual.confirm\",\n    ok: event.ok,\n    code: event.code ?? null,\n    policyVersion: event.policyVersion ?? null,\n    adjacencyRequired: Boolean(event.adjacencyRequired),\n  } as Json);\n  try {\n    await recordObservabilityEvent({\n      source: \"capacity.manual\",\n      eventType: event.ok ? \"manual.confirm.ok\" : \"manual.confirm.fail\",\n      severity: event.ok ? \"info\" : \"warning\",\n      context: payload,\n      restaurantId: event.restaurantId,\n      bookingId: event.bookingId,\n    });\n  } catch (error) {\n    console.error(\"[capacity.manual.confirm] telemetry failed\", { error, bookingId: event.bookingId });\n  }\n}\n\nexport type RpcConflictEvent = {\n  source: string;\n  bookingId: string;\n  restaurantId: string;\n  tableIds: string[];\n  idempotencyKey?: string | null;\n  holdId?: string | null;\n  error: {\n    code?: string | null;\n    message: string;\n    details?: string | null;\n    hint?: string | null;\n  };\n};\n\nexport async function emitRpcConflict(event: RpcConflictEvent): Promise<void> {\n  const sanitizedPayload = sanitizeTelemetryContext(event as Json);\n  try {\n    await recordObservabilityEvent({\n      source: \"capacity.rpc\",\n      eventType: \"capacity.rpc.conflict\",\n      severity: \"warning\",\n      context: sanitizedPayload,\n      restaurantId: event.restaurantId,\n      bookingId: event.bookingId,\n    });\n  } catch (error) {\n    console.error(\"[capacity.rpc] failed to record conflict telemetry\", {\n      error,\n      bookingId: event.bookingId,\n      restaurantId: event.restaurantId,\n    });\n  }\n}\n\nexport function summarizeCandidate(input: {\n  tableIds: string[];\n  tableNumbers: (string | null | undefined)[];\n  totalCapacity: number;\n  tableCount: number;\n  slack?: number;\n  score?: number;\n  adjacencyStatus?: \"single\" | \"connected\" | \"disconnected\";\n  scoreBreakdown?: ScoreBreakdown;\n}): CandidateSummary {\n  let scoreBreakdown: CandidateScoreBreakdown | undefined;\n  if (input.scoreBreakdown) {\n    scoreBreakdown = {\n      slack_penalty: input.scoreBreakdown.slackPenalty,\n      scarcity_penalty: input.scoreBreakdown.scarcityPenalty,\n      structural_penalty: input.scoreBreakdown.structuralPenalty,\n      demand_multiplier: input.scoreBreakdown.demandMultiplier,\n      combination_penalty: input.scoreBreakdown.combinationPenalty,\n      future_conflict_penalty: input.scoreBreakdown.futureConflictPenalty,\n      total_score: input.scoreBreakdown.total,\n    };\n  }\n\n  return {\n    tableIds: input.tableIds,\n    tableNumbers: input.tableNumbers.map((value) => value ?? \"\"),\n    totalCapacity: input.totalCapacity,\n    tableCount: input.tableCount,\n    slack: input.slack,\n    score: input.score,\n    adjacencyStatus: input.adjacencyStatus,\n    scoreBreakdown,\n  };\n}\n"
    },
    {
      "path": "server/capacity/transaction.ts",
      "size": 18996,
      "sha256": "9fb4d1504389bbc75f6ad288791812ffc4b65bac6863d529ce98e8375c1fd3fe",
      "language": "typescript",
      "content": "import { randomUUID } from \"node:crypto\";\n\n\nimport { generateUniqueBookingReference, insertBookingRecord } from \"@/server/bookings\";\nimport { isAllocatorServiceFailHard } from \"@/server/feature-flags\";\nimport { recordObservabilityEvent } from \"@/server/observability\";\nimport { getServiceSupabaseClient } from \"@/server/supabase\";\n\nimport {\n  CapacityError,\n  type BookingResult,\n  type CreateBookingParams,\n  type UpdateBookingParams,\n  type BookingErrorDetails,\n  type CapacityInfo,\n  type BookingRecord,\n  DEFAULT_RETRY_CONFIG,\n  type RetryConfig,\n} from \"./types\";\n\nimport type { Database, Json } from \"@/types/supabase\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\n\ntype DbClient = SupabaseClient<Database, \"public\">;\n\ntype RetryableError = {\n  message?: string;\n  code?: string;\n};\n\nfunction isRetryableError(error: unknown): boolean {\n  if (!error || typeof error !== \"object\") {\n    return false;\n  }\n\n  const record = error as RetryableError;\n  const message = record.message?.toLowerCase() ?? \"\";\n  const code = record.code?.toLowerCase() ?? \"\";\n\n  const retryableCodes = new Set([\"40001\", \"40p01\", \"55p03\"]);\n  if (retryableCodes.has(code)) {\n    return true;\n  }\n\n  return [\n    \"serialization failure\",\n    \"deadlock detected\",\n    \"could not serialize access\",\n    \"lock not available\",\n  ].some((pattern) => message.includes(pattern));\n}\n\nexport async function retryWithBackoff<T>(\n  fn: () => Promise<T>,\n  config: RetryConfig = DEFAULT_RETRY_CONFIG,\n  context?: Record<string, unknown>,\n): Promise<T> {\n  let lastError: unknown;\n\n  for (let attempt = 0; attempt <= config.maxRetries; attempt += 1) {\n    try {\n      return await fn();\n    } catch (error) {\n      lastError = error;\n\n      if (attempt === config.maxRetries || !isRetryableError(error)) {\n        break;\n      }\n\n      const delay = config.initialDelayMs * Math.pow(config.backoffMultiplier, attempt);\n\n      recordObservabilityEvent({\n        source: \"capacity.transaction\",\n        eventType: \"booking.transaction.retry\",\n        severity: \"info\",\n        context: {\n          ...(context ?? {}),\n          attempt: attempt + 1,\n          maxRetries: config.maxRetries,\n          delayMs: delay,\n          error: error instanceof Error ? error.message : String(error),\n        },\n      });\n\n      await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n  }\n\n  throw lastError instanceof Error ? lastError : new Error(String(lastError));\n}\n\ntype CapacityRpcPayload = {\n  success?: boolean | null;\n  duplicate?: boolean | null;\n  booking?: unknown;\n  capacity?: CapacityInfo | null;\n  error?: string | null;\n  message?: string | null;\n  details?: BookingErrorDetails | null;\n  retryable?: boolean | null;\n};\n\nfunction isBookingRecordPayload(value: unknown): value is BookingRecord {\n  if (!value || typeof value !== \"object\") {\n    return false;\n  }\n\n  const record = value as Record<string, unknown>;\n  return typeof record.id === \"string\" && typeof record.restaurant_id === \"string\";\n}\n\nfunction normalizeRpcResult(payload: CapacityRpcPayload | null | undefined): BookingResult {\n  if (!payload) {\n    return {\n      success: false,\n      error: \"INTERNAL_ERROR\",\n      message: \"Capacity RPC returned no payload\",\n    };\n  }\n\n  const success = payload.success === true;\n  const booking = isBookingRecordPayload(payload.booking) ? payload.booking : undefined;\n  const capacity = payload.capacity ?? undefined;\n\n  if (success) {\n    return {\n      success: true,\n      duplicate: payload.duplicate ?? false,\n      booking,\n      capacity,\n      message: payload.message ?? undefined,\n    };\n  }\n\n  return {\n    success: false,\n    duplicate: payload.duplicate ?? false,\n    booking,\n    capacity,\n    error: (payload.error ?? \"INTERNAL_ERROR\") as BookingResult[\"error\"],\n    message: payload.message ?? undefined,\n    details: payload.details ?? undefined,\n    retryable: payload.retryable ?? undefined,\n  };\n}\n\ntype PostgrestErrorLike = {\n  code?: string | null;\n  message?: string | null;\n  details?: string | null;\n};\n\nconst MISSING_RPC_ERROR_CODES = new Set([\"PGRST202\", \"PGRST201\", \"42883\", \"42P01\"]);\n\nfunction isMissingCapacityRpcError(error: PostgrestErrorLike | null | undefined): boolean {\n  if (!error) {\n    return false;\n  }\n\n  const code = (error.code ?? \"\").toUpperCase();\n  if (code && MISSING_RPC_ERROR_CODES.has(code)) {\n    return true;\n  }\n\n  const message = (error.message ?? \"\").toLowerCase();\n  const details = (error.details ?? \"\").toLowerCase();\n  const indicators = [\n    \"no matches were found in the schema cache\",\n    \"function\",\n    \"does not exist\",\n  ];\n\n  const hasMissingPattern = (text: string) =>\n    indicators.every((indicator) => text.includes(indicator)) ||\n    text.includes(\"missing sql function\") ||\n    text.includes(\"function create_booking_with_capacity_check\");\n\n  return hasMissingPattern(message) || hasMissingPattern(details);\n}\n\nfunction mergeFallbackDetails(details: CreateBookingParams[\"details\"]): Json {\n  const base: Record<string, Json> =\n    details && typeof details === \"object\" && !Array.isArray(details)\n      ? { ...(details as Record<string, Json>) }\n      : {};\n\n  if (details && (typeof details !== \"object\" || Array.isArray(details))) {\n    base.originalDetails = details;\n  }\n\n  if (!(\"channel\" in base)) {\n    base.channel = \"api.capacity_removed\";\n  }\n\n  base.fallback = \"missing_capacity_rpc\";\n\n  return base;\n}\n\nasync function createBookingWithoutCapacity(\n  params: CreateBookingParams,\n  supabase: DbClient,\n): Promise<BookingResult> {\n  if (params.idempotencyKey) {\n    const { data: existing, error: fetchError } = await supabase\n      .from(\"bookings\")\n      .select(\"*\")\n      .eq(\"restaurant_id\", params.restaurantId)\n      .eq(\"idempotency_key\", params.idempotencyKey)\n      .maybeSingle();\n\n    if (fetchError) {\n      throw new CapacityError(\n        fetchError.message ?? \"Failed to check existing booking for idempotency\",\n        \"INTERNAL_ERROR\",\n        {\n          sqlstate: fetchError.code ?? undefined,\n          sqlerrm: fetchError.details ?? undefined,\n        },\n      );\n    }\n\n    if (existing) {\n      const booking = existing as BookingRecord;\n\n      recordObservabilityEvent({\n        source: \"capacity.transaction\",\n        eventType: \"booking.creation.fallback_duplicate\",\n        severity: \"info\",\n        context: {\n          restaurantId: params.restaurantId,\n          bookingId: booking.id,\n          idempotencyKey: params.idempotencyKey,\n        },\n      });\n\n      return {\n        success: true,\n        duplicate: true,\n        booking,\n        message: \"Booking already exists (idempotency)\",\n      };\n    }\n  }\n\n  try {\n    const reference = await generateUniqueBookingReference(supabase);\n    const clientRequestId = params.clientRequestId ?? randomUUID();\n    const booking = await insertBookingRecord(supabase, {\n      restaurant_id: params.restaurantId,\n      customer_id: params.customerId,\n      booking_date: params.bookingDate,\n      start_time: params.startTime,\n      end_time: params.endTime,\n      party_size: params.partySize,\n      booking_type: params.bookingType,\n      seating_preference: params.seatingPreference,\n      status: \"pending\",\n      reference,\n      customer_name: params.customerName,\n      customer_email: params.customerEmail,\n      customer_phone: params.customerPhone,\n      notes: params.notes ?? null,\n      marketing_opt_in: params.marketingOptIn ?? false,\n      loyalty_points_awarded: params.loyaltyPointsAwarded ?? 0,\n      source: params.source ?? \"api\",\n      auth_user_id: params.authUserId ?? null,\n      client_request_id: clientRequestId,\n      idempotency_key: params.idempotencyKey ?? null,\n      details: mergeFallbackDetails(params.details),\n    });\n\n    recordObservabilityEvent({\n      source: \"capacity.transaction\",\n      eventType: \"booking.creation.fallback_success\",\n      severity: \"info\",\n      context: {\n        restaurantId: params.restaurantId,\n        bookingId: booking.id,\n        idempotencyKey: params.idempotencyKey ?? undefined,\n      },\n    });\n\n    return {\n      success: true,\n      duplicate: false,\n      booking,\n      message: \"Booking created without capacity enforcement\",\n    };\n  } catch (error) {\n    recordObservabilityEvent({\n      source: \"capacity.transaction\",\n      eventType: \"booking.creation.fallback_failure\",\n      severity: \"error\",\n      context: {\n        restaurantId: params.restaurantId,\n        error: error instanceof Error ? error.message : String(error),\n      },\n    });\n\n    if (error instanceof CapacityError) {\n      throw error;\n    }\n\n    throw new CapacityError(\n      error instanceof Error ? error.message : \"Failed to create booking (fallback)\",\n      \"INTERNAL_ERROR\",\n    );\n  }\n}\n\nexport async function createBookingWithCapacityCheck(\n  params: CreateBookingParams,\n  client?: DbClient,\n): Promise<BookingResult> {\n  const supabase = client ?? getServiceSupabaseClient();\n\n  try {\n    recordObservabilityEvent({\n      source: \"capacity.transaction\",\n      eventType: \"booking.creation.attempt\",\n      severity: \"info\",\n      context: {\n        restaurantId: params.restaurantId,\n        bookingDate: params.bookingDate,\n        startTime: params.startTime,\n        partySize: params.partySize,\n        idempotencyKey: params.idempotencyKey ?? undefined,\n      },\n    });\n\n    const { data, error } = await supabase.rpc(\"create_booking_with_capacity_check\", {\n      p_restaurant_id: params.restaurantId,\n      p_customer_id: params.customerId,\n      p_booking_date: params.bookingDate,\n      p_start_time: params.startTime,\n      p_end_time: params.endTime,\n      p_party_size: params.partySize,\n      p_booking_type: params.bookingType,\n      p_customer_name: params.customerName,\n      p_customer_email: params.customerEmail,\n      p_customer_phone: params.customerPhone,\n      p_seating_preference: params.seatingPreference,\n      p_notes: params.notes ?? undefined,\n      p_marketing_opt_in: params.marketingOptIn ?? false,\n      p_idempotency_key: params.idempotencyKey ?? undefined,\n      p_source: params.source ?? \"api\",\n      p_auth_user_id: params.authUserId ?? undefined,\n      p_client_request_id: params.clientRequestId ?? undefined,\n      p_details: params.details ?? {},\n      p_loyalty_points_awarded: params.loyaltyPointsAwarded ?? 0,\n    });\n\n    if (error) {\n      if (isMissingCapacityRpcError(error)) {\n        const failHardModeEnabled = isAllocatorServiceFailHard();\n        const baseContext = {\n          restaurantId: params.restaurantId,\n          bookingDate: params.bookingDate,\n          startTime: params.startTime,\n          partySize: params.partySize,\n          code: error.code ?? undefined,\n          fallbackStrategy: failHardModeEnabled ? \"fail_hard\" : \"legacy_fallback\",\n        };\n\n        recordObservabilityEvent({\n          source: \"capacity.transaction\",\n          eventType: \"booking.creation.rpc_missing\",\n          severity: failHardModeEnabled ? \"error\" : \"warning\",\n          context: baseContext,\n        });\n\n        if (failHardModeEnabled) {\n          recordObservabilityEvent({\n            source: \"capacity.transaction\",\n            eventType: \"booking.creation.fallback_skipped\",\n            severity: \"error\",\n            context: baseContext,\n          });\n\n          throw new CapacityError(\n            \"Capacity enforcement unavailable\",\n            \"INTERNAL_ERROR\",\n            {\n              sqlstate: error.code ?? undefined,\n              sqlerrm: error.details ?? undefined,\n            },\n          );\n        }\n\n        return createBookingWithoutCapacity(params, supabase);\n      }\n\n      recordObservabilityEvent({\n        source: \"capacity.transaction\",\n        eventType: \"booking.creation.rpc_error\",\n        severity: \"error\",\n        context: {\n          restaurantId: params.restaurantId,\n          bookingDate: params.bookingDate,\n          startTime: params.startTime,\n          partySize: params.partySize,\n          error: error.message,\n          details: error.details ?? undefined,\n        },\n      });\n\n      throw new CapacityError(\n        error.message ?? \"Failed to execute capacity RPC\",\n        \"INTERNAL_ERROR\",\n        {\n          sqlstate: error.code ?? undefined,\n          sqlerrm: error.details ?? undefined,\n        },\n      );\n    }\n\n    const result = normalizeRpcResult(data as CapacityRpcPayload);\n\n    if (result.success) {\n      recordObservabilityEvent({\n        source: \"capacity.transaction\",\n        eventType: \"booking.creation.success\",\n        severity: \"info\",\n        context: {\n          restaurantId: params.restaurantId,\n        bookingId: result.booking?.id,\n          duplicate: result.duplicate ?? false,\n          capacity: result.capacity ?? undefined,\n        },\n      });\n    } else {\n      recordObservabilityEvent({\n        source: \"capacity.transaction\",\n        eventType: \"booking.creation.failure\",\n        severity: result.error === \"CAPACITY_EXCEEDED\" ? \"warning\" : \"error\",\n        context: {\n          restaurantId: params.restaurantId,\n          bookingDate: params.bookingDate,\n          startTime: params.startTime,\n          partySize: params.partySize,\n          error: result.error ?? \"UNKNOWN\",\n          message: result.message ?? undefined,\n          details: result.details ?? undefined,\n        },\n      });\n    }\n\n    return result;\n  } catch (error) {\n    if (error instanceof CapacityError) {\n      throw error;\n    }\n\n    const details: BookingErrorDetails | undefined =\n      error && typeof error === \"object\" && \"details\" in (error as Record<string, unknown>)\n        ? ((error as Record<string, unknown>).details as BookingErrorDetails | undefined)\n        : undefined;\n\n    recordObservabilityEvent({\n      source: \"capacity.transaction\",\n      eventType: \"booking.creation.failure\",\n      severity: \"error\",\n      context: {\n        restaurantId: params.restaurantId,\n        error: error instanceof Error ? error.message : String(error),\n      },\n    });\n\n    throw new CapacityError(\n      error instanceof Error ? error.message : \"Failed to create booking\",\n      \"INTERNAL_ERROR\",\n      details,\n    );\n  }\n}\n\nexport async function updateBookingWithCapacityCheck(\n  params: UpdateBookingParams,\n  client?: DbClient,\n): Promise<BookingResult> {\n  const supabase = client ?? getServiceSupabaseClient();\n\n  try {\n    recordObservabilityEvent({\n      source: \"capacity.transaction\",\n      eventType: \"booking.update.attempt\",\n      severity: \"info\",\n      context: {\n        restaurantId: params.restaurantId,\n        bookingId: params.bookingId,\n        bookingDate: params.bookingDate,\n        startTime: params.startTime,\n        partySize: params.partySize,\n      },\n    });\n\n    const { data, error } = await supabase.rpc(\"update_booking_with_capacity_check\", {\n      p_booking_id: params.bookingId,\n      p_restaurant_id: params.restaurantId,\n      p_customer_id: params.customerId,\n      p_booking_date: params.bookingDate,\n      p_start_time: params.startTime,\n      p_end_time: params.endTime,\n      p_party_size: params.partySize,\n      p_booking_type: params.bookingType,\n      p_customer_name: params.customerName,\n      p_customer_email: params.customerEmail,\n      p_customer_phone: params.customerPhone,\n      p_seating_preference: params.seatingPreference,\n      p_notes: params.notes ?? undefined,\n      p_marketing_opt_in: params.marketingOptIn ?? false,\n      p_auth_user_id: params.authUserId ?? undefined,\n      p_client_request_id: params.clientRequestId ?? undefined,\n      p_details: params.details ?? {},\n      p_loyalty_points_awarded: params.loyaltyPointsAwarded ?? 0,\n      p_source: params.source ?? \"api\",\n    });\n\n    if (error) {\n      recordObservabilityEvent({\n        source: \"capacity.transaction\",\n        eventType: \"booking.update.rpc_error\",\n        severity: \"error\",\n        context: {\n          restaurantId: params.restaurantId,\n          bookingId: params.bookingId,\n          error: error.message,\n          details: error.details ?? undefined,\n        },\n      });\n\n      throw new CapacityError(\n        error.message ?? \"Failed to execute capacity update RPC\",\n        \"INTERNAL_ERROR\",\n        {\n          sqlstate: error.code ?? undefined,\n          sqlerrm: error.details ?? undefined,\n        },\n      );\n    }\n\n    const result = normalizeRpcResult(data as CapacityRpcPayload);\n\n    if (result.success) {\n      recordObservabilityEvent({\n        source: \"capacity.transaction\",\n        eventType: \"booking.update.success\",\n        severity: \"info\",\n        context: {\n          restaurantId: params.restaurantId,\n          bookingId: params.bookingId,\n          capacity: result.capacity ?? undefined,\n        },\n      });\n    } else {\n      recordObservabilityEvent({\n        source: \"capacity.transaction\",\n        eventType: \"booking.update.failure\",\n        severity: result.error === \"CAPACITY_EXCEEDED\" ? \"warning\" : \"error\",\n        context: {\n          restaurantId: params.restaurantId,\n          bookingId: params.bookingId,\n          bookingDate: params.bookingDate,\n          startTime: params.startTime,\n          partySize: params.partySize,\n          error: result.error ?? \"UNKNOWN\",\n          message: result.message ?? undefined,\n          details: result.details ?? undefined,\n        },\n      });\n    }\n\n    return result;\n  } catch (error) {\n    if (error instanceof CapacityError) {\n      throw error;\n    }\n\n    const details: BookingErrorDetails | undefined =\n      error && typeof error === \"object\" && \"details\" in (error as Record<string, unknown>)\n        ? ((error as Record<string, unknown>).details as BookingErrorDetails | undefined)\n        : undefined;\n\n    recordObservabilityEvent({\n      source: \"capacity.transaction\",\n      eventType: \"booking.update.failure\",\n      severity: \"error\",\n      context: {\n        restaurantId: params.restaurantId,\n        bookingId: params.bookingId,\n        error: error instanceof Error ? error.message : String(error),\n      },\n    });\n\n    throw new CapacityError(\n      error instanceof Error ? error.message : \"Failed to update booking\",\n      \"INTERNAL_ERROR\",\n      details,\n    );\n  }\n}\n\nexport async function createBookingOrThrow(\n  params: CreateBookingParams,\n  client?: DbClient,\n): Promise<BookingResult> {\n  const result = await createBookingWithCapacityCheck(params, client);\n\n  if (result.success) {\n    return result;\n  }\n\n  const message = result.message ?? \"Booking creation failed\";\n  throw new CapacityError(message, result.error ?? \"INTERNAL_ERROR\", result.details);\n}\n\nexport function isRetryableBookingError(result: BookingResult): boolean {\n  return result.retryable === true;\n}\n\nexport function getBookingErrorMessage(result: BookingResult): string {\n  if (result.success) {\n    return result.message ?? \"Booking created successfully\";\n  }\n\n  if (result.message) {\n    return result.message;\n  }\n\n  const details = result.details ? JSON.stringify(result.details) : \"\";\n  return details.length > 0 ? `Booking failed: ${details}` : \"Booking failed\";\n}\n"
    },
    {
      "path": "server/capacity/types.ts",
      "size": 6881,
      "sha256": "960d0edbb71a3665766ee7c22c6cefac3a565c4bd49b342832bd53c9a40955a4",
      "language": "typescript",
      "content": "/**\n * Capacity & Availability Engine - Type Definitions\n * Story 2: Service Layer Types\n */\n\nimport type { BookingType } from \"@/lib/enums\";\nimport type { Database, Json } from \"@/types/supabase\";\n\n// =====================================================\n// Availability Check Types\n// =====================================================\n\nexport type AvailabilityCheckParams = {\n  restaurantId: string;\n  date: string; // YYYY-MM-DD\n  time: string; // HH:MM\n  partySize: number;\n  seatingPreference?: string;\n};\n\nexport type AvailabilityResult = {\n  available: boolean;\n  reason?: string;\n  alternatives?: TimeSlot[];\n  metadata: CapacityMetadata;\n};\n\nexport type TimeSlot = {\n  time: string; // HH:MM\n  available: boolean;\n  utilizationPercent: number;\n  bookedCovers?: number;\n  maxCovers?: number;\n};\n\nexport type CapacityMetadata = {\n  servicePeriod?: string;\n  maxCovers: number | null;\n  bookedCovers: number;\n  availableCovers: number;\n  utilizationPercent: number;\n  maxParties?: number | null;\n  bookedParties?: number;\n};\n\n// =====================================================\n// Alternative Slot Search Types\n// =====================================================\n\nexport type AlternativeSlotParams = {\n  restaurantId: string;\n  date: string;\n  partySize: number;\n  preferredTime: string;\n  maxAlternatives?: number; // Default: 5\n  searchWindowMinutes?: number; // Default: 120 (2 hours)\n};\n\n// =====================================================\n// Booking Transaction Types\n// =====================================================\n\nexport type CreateBookingParams = {\n  restaurantId: string;\n  customerId: string;\n  bookingDate: string; // YYYY-MM-DD\n  startTime: string; // HH:MM\n  endTime: string; // HH:MM\n  partySize: number;\n  bookingType: BookingType;\n  customerName: string;\n  customerEmail: string;\n  customerPhone: string;\n  seatingPreference: Database[\"public\"][\"Enums\"][\"seating_preference_type\"];\n  notes?: string | null;\n  marketingOptIn?: boolean;\n  idempotencyKey?: string | null;\n  source?: string;\n  authUserId?: string | null;\n  clientRequestId?: string | null;\n  loyaltyPointsAwarded?: number;\n  details?: Json | null;\n};\n\nexport type UpdateBookingParams = {\n  bookingId: string;\n  restaurantId: string;\n  customerId: string;\n  bookingDate: string; // YYYY-MM-DD\n  startTime: string; // HH:MM\n  endTime: string; // HH:MM\n  partySize: number;\n  bookingType: BookingType;\n  customerName: string;\n  customerEmail: string;\n  customerPhone: string;\n  seatingPreference: Database[\"public\"][\"Enums\"][\"seating_preference_type\"];\n  notes?: string | null;\n  marketingOptIn?: boolean;\n  source?: string;\n  authUserId?: string | null;\n  clientRequestId?: string | null;\n  loyaltyPointsAwarded?: number;\n  details?: Json | null;\n};\n\nexport type BookingResult = {\n  success: boolean;\n  duplicate?: boolean;\n  booking?: BookingRecord;\n  capacity?: CapacityInfo;\n  error?: BookingErrorCode;\n  message?: string;\n  details?: BookingErrorDetails;\n  retryable?: boolean;\n};\n\nexport type BookingErrorCode =\n  | \"CAPACITY_EXCEEDED\"\n  | \"BOOKING_CONFLICT\"\n  | \"INTERNAL_ERROR\"\n  | \"BOOKING_OUTSIDE_OPERATING_HOURS\"\n  | \"OPERATING_HOURS_CLOSED\"\n  | \"PAST_TIME_BLOCKED\"\n  | \"INVALID_PARAMS\";\n\nexport type BookingErrorDetails = {\n  maxCovers?: number;\n  bookedCovers?: number;\n  requestedCovers?: number;\n  availableCovers?: number;\n  servicePeriod?: string;\n  maxParties?: number;\n  bookedParties?: number;\n  availableParties?: number;\n  sqlstate?: string;\n  sqlerrm?: string;\n  timezone?: string;\n  originalTimezone?: string;\n};\n\nexport type CapacityInfo = {\n  servicePeriod?: string;\n  maxCovers: number;\n  bookedCovers: number;\n  availableCovers: number;\n  utilizationPercent: number;\n};\n\nexport type { SelectorScoringConfig, SelectorScoringWeights } from \"./policy\";\n\n// =====================================================\n// Database RPC Response Types\n// =====================================================\n\nexport type RpcBookingResponse = {\n  success: boolean;\n  duplicate?: boolean;\n  booking?: Record<string, unknown>; // Full booking record as JSONB\n  capacity?: CapacityInfo;\n  error?: BookingErrorCode;\n  message?: string;\n  details?: BookingErrorDetails;\n  retryable?: boolean;\n};\n\n// =====================================================\n// Booking Record Type (from database)\n// =====================================================\n\nexport type BookingRecord = {\n  id: string;\n  restaurant_id: string;\n  customer_id: string;\n  booking_date: string;\n  start_time: string;\n  end_time: string;\n  start_at: string | null;\n  end_at: string | null;\n  party_size: number;\n  booking_type: string;\n  seating_preference: string;\n  status: string;\n  reference: string;\n  customer_name: string;\n  customer_email: string;\n  customer_phone: string;\n  notes?: string | null;\n  marketing_opt_in: boolean;\n  loyalty_points_awarded?: number;\n  source?: string;\n  auth_user_id?: string | null;\n  idempotency_key?: string | null;\n  details: Json | null;\n  created_at: string;\n  updated_at: string;\n};\n\n// =====================================================\n// Service Period Types (reused from ops/capacity.ts)\n// =====================================================\n\nexport type ServicePeriodWithCapacity = {\n  periodId: string;\n  periodName: string;\n  startTime: string;\n  endTime: string;\n  maxCovers: number | null;\n  maxParties: number | null;\n  dayOfWeek: number | null;\n};\n\nexport type PeriodUtilization = {\n  periodId: string;\n  periodName: string;\n  startTime: string;\n  endTime: string;\n  bookedCovers: number;\n  bookedParties: number;\n  maxCovers: number | null;\n  maxParties: number | null;\n  utilizationPercentage: number;\n  isOverbooked: boolean;\n};\n\n// =====================================================\n// Retry Configuration\n// =====================================================\n\nexport type RetryConfig = {\n  maxRetries: number;\n  initialDelayMs: number;\n  backoffMultiplier: number; // e.g., 2 for exponential backoff\n};\n\nexport const DEFAULT_RETRY_CONFIG: RetryConfig = {\n  maxRetries: 3,\n  initialDelayMs: 100,\n  backoffMultiplier: 2,\n};\n\n// =====================================================\n// Error Classes\n// =====================================================\n\nexport class CapacityError extends Error {\n  constructor(\n    message: string,\n    public code: BookingErrorCode,\n    public details?: BookingErrorDetails\n  ) {\n    super(message);\n    this.name = \"CapacityError\";\n  }\n}\n\nexport class BookingConflictError extends CapacityError {\n  constructor(message: string, details?: BookingErrorDetails) {\n    super(message, \"BOOKING_CONFLICT\", details);\n    this.name = \"BookingConflictError\";\n  }\n}\n\nexport class CapacityExceededError extends CapacityError {\n  constructor(message: string, details?: BookingErrorDetails) {\n    super(message, \"CAPACITY_EXCEEDED\", details);\n    this.name = \"CapacityExceededError\";\n  }\n}\n"
    },
    {
      "path": "server/capacity/v2/errors.ts",
      "size": 774,
      "sha256": "478a49c9441f74bf6176dced6a6dac1565472da3a899ec1b52205759d5b648c2",
      "language": "typescript",
      "content": "export type ConflictDetails = {\n  tableIds: string[];\n  blockingBookingId?: string;\n  window?: { start: string; end: string };\n  hint?: string | null;\n  raw?: unknown;\n};\n\nexport class AssignmentConflictError extends Error {\n  constructor(message: string, public readonly details?: ConflictDetails) {\n    super(message);\n    this.name = \"AssignmentConflictError\";\n  }\n}\n\nexport class AssignmentValidationError extends Error {\n  constructor(message: string, public readonly details?: Record<string, unknown>) {\n    super(message);\n    this.name = \"AssignmentValidationError\";\n  }\n}\n\nexport class AssignmentRepositoryError extends Error {\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n    this.name = \"AssignmentRepositoryError\";\n  }\n}\n"
    },
    {
      "path": "server/capacity/v2/index.ts",
      "size": 204,
      "sha256": "089db03d80917f49f86192da5a66419d985380265147dc451c4883f2aefe13a6",
      "language": "typescript",
      "content": "export * from \"./types\";\nexport * from \"./repository\";\nexport * from \"./planner\";\nexport * from \"./orchestrator\";\nexport * from \"./errors\";\nexport * from \"./supabase-repository\";\nexport * from \"./utils\";\n"
    },
    {
      "path": "server/capacity/v2/orchestrator.ts",
      "size": 2268,
      "sha256": "909a98a0e6a07573dd262ba93b81748a767cb68a17876cb8890a6782da8c5ded",
      "language": "typescript",
      "content": "import { isAllocatorV2Enabled, isAllocatorV2ShadowMode, isAllocatorV2ForceLegacy } from \"@/server/feature-flags\";\n\nimport {\n  AssignmentConflictError,\n  AssignmentRepositoryError,\n  AssignmentValidationError,\n} from \"./errors\";\nimport { NoopAssignmentRepository } from \"./supabase-repository\";\n\nimport type { AssignmentRepository } from \"./repository\";\nimport type {\n  AssignmentCommitRequest,\n  AssignmentCommitResponse,\n  AssignmentContext,\n  AssignmentPlan,\n  AssignmentSource,\n} from \"./types\";\n\nexport type CommitPlanOptions = {\n  source: AssignmentSource;\n  idempotencyKey: string;\n  actorId?: string | null;\n  metadata?: Record<string, unknown>;\n  shadow?: boolean;\n  requireAdjacency?: boolean;\n};\n\nexport class AssignmentOrchestrator {\n  constructor(\n    private readonly repository: AssignmentRepository,\n    private readonly shadowRepository: AssignmentRepository = new NoopAssignmentRepository(),\n  ) {}\n\n  async commitPlan(\n    context: AssignmentContext,\n    plan: AssignmentPlan,\n    options: CommitPlanOptions,\n  ): Promise<AssignmentCommitResponse> {\n    const allocatorDisabled = !isAllocatorV2Enabled();\n    const shadowMode = options.shadow ?? isAllocatorV2ShadowMode();\n\n    if (isAllocatorV2ForceLegacy() && !shadowMode) {\n      throw new AssignmentRepositoryError(\"Allocator v2 force-legacy mode is active; cannot commit plan.\");\n    }\n\n    if (allocatorDisabled && !shadowMode) {\n      throw new AssignmentRepositoryError(\"Allocator v2 is disabled. Enable shadow or commit mode before invoking orchestrator.\");\n    }\n\n    const request: AssignmentCommitRequest = {\n      context,\n      plan,\n      source: options.source,\n      idempotencyKey: options.idempotencyKey,\n      actorId: options.actorId,\n      metadata: options.metadata,\n      shadow: shadowMode,\n      requireAdjacency: options.requireAdjacency,\n    };\n\n    const targetRepository = shadowMode && allocatorDisabled ? this.shadowRepository : this.repository;\n\n    try {\n      return await targetRepository.commitAssignment(request);\n    } catch (error) {\n      if (error instanceof AssignmentConflictError || error instanceof AssignmentValidationError) {\n        throw error;\n      }\n      throw new AssignmentRepositoryError(\"Allocator v2 repository failure\", error);\n    }\n  }\n}\n"
    },
    {
      "path": "server/capacity/v2/planner.ts",
      "size": 1153,
      "sha256": "ba9141af901b12147cba34eaa313e351efd46650d18e895f856d78bf9ea8e7b0",
      "language": "typescript",
      "content": "import { buildScoredTablePlans, type BuildCandidatesResult } from \"../selector\";\n\nimport type { SelectorScoringConfig } from \"../policy\";\nimport type { Table } from \"../tables\";\n\nexport type PlannerInput = {\n  tables: Table[];\n  partySize: number;\n  adjacency: Map<string, Set<string>>;\n  config: SelectorScoringConfig;\n  enableCombinations: boolean;\n  kMax: number;\n  requireAdjacency: boolean;\n  maxPlansPerSlack?: number;\n  maxCombinationEvaluations?: number;\n  demandMultiplier?: number;\n  tableScarcityScores?: Map<string, number>;\n};\n\nexport type PlannerResult = BuildCandidatesResult;\n\nexport function generateCandidatePlans(input: PlannerInput): PlannerResult {\n  return buildScoredTablePlans({\n    tables: input.tables,\n    partySize: input.partySize,\n    adjacency: input.adjacency,\n    config: input.config,\n    enableCombinations: input.enableCombinations,\n    kMax: input.kMax,\n    requireAdjacency: input.requireAdjacency,\n    maxPlansPerSlack: input.maxPlansPerSlack,\n    maxCombinationEvaluations: input.maxCombinationEvaluations,\n    demandMultiplier: input.demandMultiplier,\n    tableScarcityScores: input.tableScarcityScores,\n  });\n}\n"
    },
    {
      "path": "server/capacity/v2/repository.ts",
      "size": 214,
      "sha256": "1ba2d44654c7ea7c7ba3967e1ae508510fa5e9af6568888d0b688d9c40dc0e9a",
      "language": "typescript",
      "content": "import type { AssignmentCommitRequest, AssignmentCommitResponse } from \"./types\";\n\nexport interface AssignmentRepository {\n  commitAssignment(request: AssignmentCommitRequest): Promise<AssignmentCommitResponse>;\n}\n"
    },
    {
      "path": "server/capacity/v2/supabase-repository.ts",
      "size": 5978,
      "sha256": "6e07ab6591af8d77c6b9870ce3d38be059b61dfe64930683c0271e0085912e74",
      "language": "typescript",
      "content": "import { getServiceSupabaseClient } from \"@/server/supabase\";\n\nimport { AssignmentConflictError, AssignmentRepositoryError, AssignmentValidationError } from \"./errors\";\n\nimport type { AssignmentRepository } from \"./repository\";\nimport type {\n  AssignmentCommitRequest,\n  AssignmentCommitResponse,\n  AssignmentRecord,\n} from \"./types\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\n\ntype PostgrestError = {\n  code?: string;\n  message?: string;\n  details?: string | null;\n  hint?: string | null;\n};\n\ntype AssignTablesAtomicRow = {\n  table_id: string;\n  start_at: string;\n  end_at: string;\n  merge_group_id: string | null;\n  assignment_id?: string | null;\n};\n\nfunction extractUuids(value: string | null | undefined): string[] {\n  if (!value) return [];\n  const matches = value.match(/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/gi);\n  return matches ? matches.map((entry) => entry.toLowerCase()) : [];\n}\n\nfunction parseBlockingBookingId(message: string, details: string | null | undefined): string | undefined {\n  const sources = [message, details ?? \"\"];\n  for (const source of sources) {\n    const match = source.match(/booking\\s+([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/i);\n    if (match) {\n      return match[1].toLowerCase();\n    }\n  }\n  return undefined;\n}\n\nfunction buildConflictError(params: {\n  error: PostgrestError;\n  request: AssignmentCommitRequest;\n}): AssignmentConflictError {\n  const { error, request } = params;\n  const conflictTables = new Set<string>();\n  for (const tableId of request.plan.tableIds) {\n    conflictTables.add(tableId.toLowerCase());\n  }\n  for (const uuid of extractUuids(error.message)) {\n    conflictTables.add(uuid);\n  }\n  for (const uuid of extractUuids(error.details)) {\n    conflictTables.add(uuid);\n  }\n\n  const blockingBookingId = parseBlockingBookingId(error.message ?? \"\", error.details);\n\n  return new AssignmentConflictError(error.message ?? \"Assignment conflict\", {\n    tableIds: Array.from(conflictTables),\n    blockingBookingId,\n    window: {\n      start: request.plan.startAt,\n      end: request.plan.endAt,\n    },\n    hint: error.hint ?? undefined,\n    raw: {\n      code: error.code,\n      details: error.details,\n      metadata: request.metadata ?? null,\n    },\n  });\n}\n\nfunction buildValidationError(params: {\n  error: PostgrestError;\n  request: AssignmentCommitRequest;\n}): AssignmentValidationError {\n  const { error, request } = params;\n  return new AssignmentValidationError(error.message ?? \"Assignment validation failed\", {\n    code: error.code,\n    details: error.details,\n    hint: error.hint,\n    plan: {\n      tableIds: request.plan.tableIds,\n      startAt: request.plan.startAt,\n      endAt: request.plan.endAt,\n    },\n    context: {\n      bookingId: request.context.bookingId,\n      restaurantId: request.context.restaurantId,\n    },\n  });\n}\n\nfunction translateSupabaseError(params: {\n  error: PostgrestError;\n  request: AssignmentCommitRequest;\n}): never {\n  const { error, request } = params;\n  const code = (error.code ?? \"\").toUpperCase();\n  const message = error.message ?? \"assign_tables_atomic_v2 failed\";\n  const normalized = message.toLowerCase();\n\n  if (normalized.includes(\"capacity_exceeded_post_assignment\")) {\n    throw buildConflictError({\n      error: {\n        ...error,\n        message: \"Capacity exceeded after assignment\",\n        hint: error.hint ?? \"Release tables or adjust capacity overrides before retrying.\",\n      },\n      request,\n    });\n  }\n\n  if (\n    code === \"23505\" ||\n    code === \"P0001\" ||\n    normalized.includes(\"duplicate\") ||\n    normalized.includes(\"overlap\") ||\n    normalized.includes(\"conflict\")\n  ) {\n    throw buildConflictError({ error, request });\n  }\n\n  if (\n    code === \"23514\" ||\n    code === \"23503\" ||\n    code === \"23502\" ||\n    code === \"22023\" ||\n    code === \"22000\" ||\n    code === \"P0002\" ||\n    code === \"P0003\" ||\n    normalized.includes(\"requires at least one\") ||\n    normalized.includes(\"not assigned\") ||\n    normalized.includes(\"missing\") ||\n    normalized.includes(\"invalid\")\n  ) {\n    throw buildValidationError({ error, request });\n  }\n\n  throw new AssignmentRepositoryError(message, error);\n}\n\nexport class SupabaseAssignmentRepository implements AssignmentRepository {\n  constructor(private readonly client: SupabaseClient = getServiceSupabaseClient()) {}\n\n  async commitAssignment(request: AssignmentCommitRequest): Promise<AssignmentCommitResponse> {\n    const { context, plan, idempotencyKey, actorId, shadow } = request;\n    const supabase = this.client;\n\n    if (!context.window) {\n      throw new AssignmentValidationError(\"Assignment window not provided in context\", { context });\n    }\n\n    const requireAdjacency = request.requireAdjacency ?? true;\n\n    const payload = {\n      p_booking_id: context.bookingId,\n      p_table_ids: plan.tableIds,\n      p_idempotency_key: idempotencyKey,\n      p_require_adjacency: requireAdjacency,\n      p_assigned_by: actorId ?? null,\n      p_start_at: plan.startAt,\n      p_end_at: plan.endAt,\n    };\n\n    const { data, error } = await supabase.rpc(\"assign_tables_atomic_v2\", payload);\n\n    if (error) {\n      translateSupabaseError({ error, request });\n    }\n\n    const rows = (data ?? []) as AssignTablesAtomicRow[];\n    const assignments: AssignmentRecord[] = rows.map((row) => ({\n      tableId: row.table_id,\n      startAt: row.start_at,\n      endAt: row.end_at,\n      mergeGroupId: row.merge_group_id ?? null,\n      assignmentId: row.assignment_id ?? undefined,\n    }));\n\n    return {\n      attemptId: `rpc-${plan.signature}`,\n      assignments,\n      mergeGroupId: assignments[0]?.mergeGroupId ?? null,\n      shadow: shadow ?? false,\n    };\n  }\n}\n\nexport class NoopAssignmentRepository implements AssignmentRepository {\n  async commitAssignment(_request: AssignmentCommitRequest): Promise<AssignmentCommitResponse> {\n    return {\n      attemptId: \"noop\",\n      assignments: [],\n      mergeGroupId: null,\n      shadow: true,\n    };\n  }\n}\n"
    },
    {
      "path": "server/capacity/v2/types.ts",
      "size": 1407,
      "sha256": "14de8de7be51bb9c2692ef17cef8275285c8dd78065c63a8c0fad49ebee4a7c1",
      "language": "typescript",
      "content": "import type { CandidateSummary } from \"../telemetry\";\n\nexport type AssignmentSource = \"manual\" | \"auto\";\n\nexport type AssignmentPlan = {\n  /** Deterministic hash representing the candidate plan (tables + window + constraints). */\n  signature: string;\n  tableIds: string[];\n  startAt: string;\n  endAt: string;\n  metadata?: Record<string, unknown>;\n  candidate?: CandidateSummary;\n};\n\nexport type AssignmentContext = {\n  bookingId: string;\n  restaurantId: string;\n  partySize: number;\n  zoneId?: string | null;\n  serviceDate?: string | null;\n  window?: {\n    startAt: string;\n    endAt: string;\n  };\n  holdId?: string | null;\n};\n\nexport type AssignmentRecord = {\n  tableId: string;\n  startAt: string;\n  endAt: string;\n  mergeGroupId: string | null;\n  assignmentId?: string;\n};\n\nexport type AssignmentCommitRequest = {\n  context: AssignmentContext;\n  plan: AssignmentPlan;\n  source: AssignmentSource;\n  idempotencyKey: string;\n  actorId?: string | null;\n  metadata?: Record<string, unknown>;\n  shadow?: boolean;\n  requireAdjacency?: boolean;\n};\n\nexport type AssignmentCommitResponse = {\n  attemptId: string;\n  assignments: AssignmentRecord[];\n  mergeGroupId?: string | null;\n  telemetryId?: string;\n  shadow?: boolean;\n};\n\nexport type AssignmentAttemptDiagnostics = {\n  planSignature: string;\n  candidateCount: number;\n  generatedAt: string;\n  skipped?: number;\n  conflictDetails?: Record<string, unknown>;\n};\n"
    },
    {
      "path": "server/capacity/v2/utils.ts",
      "size": 2365,
      "sha256": "9b073a4bb80b87ad6ab5073c7dadf0e875ea2e1c0db0522d8812afc404f57cc6",
      "language": "typescript",
      "content": "import { createHash } from \"node:crypto\";\n\nimport type { VenuePolicy } from \"../policy\";\n\nfunction stableJson(value: unknown): string {\n  try {\n    return JSON.stringify(value, Object.keys(value as object).sort());\n  } catch {\n    return JSON.stringify(value);\n  }\n}\n\n/**\n * Returns a lexicographically sorted array of unique table ids.\n */\nexport function normalizeTableIds(tableIds: string[]): string[] {\n  return Array.from(new Set(tableIds)).sort((a, b) => a.localeCompare(b));\n}\n\ntype PlanSignatureInput = {\n  bookingId: string;\n  tableIds: string[];\n  startAt: string;\n  endAt: string;\n  salt?: string;\n};\n\n/**\n * Deterministically derives a short signature for a plan based on booking scope\n * and assignment window. Used for idempotency and telemetry correlation.\n */\nexport function createPlanSignature(input: PlanSignatureInput): string {\n  const normalizedTableIds = normalizeTableIds(input.tableIds);\n  const hash = createHash(\"sha256\");\n\n  hash.update(input.bookingId);\n  hash.update(\"|\");\n  hash.update(normalizedTableIds.join(\",\"));\n  hash.update(\"|\");\n  hash.update(input.startAt);\n  hash.update(\"|\");\n  hash.update(input.endAt);\n\n  if (input.salt) {\n    hash.update(\"|\");\n    hash.update(input.salt);\n  }\n\n  return hash.digest(\"hex\").slice(0, 16);\n}\n\nexport function hashPolicyVersion(policy: VenuePolicy): string {\n  const hash = createHash(\"sha256\");\n  hash.update(stableJson({\n    timezone: policy.timezone,\n    serviceOrder: policy.serviceOrder,\n    services: policy.services,\n  }));\n  return hash.digest(\"hex\").slice(0, 16);\n}\n\nexport function createDeterministicIdempotencyKey(input: {\n  tenantId: string;\n  bookingId: string;\n  tableIds: string[];\n  startAt: string;\n  endAt: string;\n  policyVersion: string;\n}): string {\n  const normalizedTableIds = normalizeTableIds(input.tableIds);\n  const hash = createHash(\"sha256\");\n  hash.update(input.tenantId);\n  hash.update(\"|\");\n  hash.update(input.bookingId);\n  hash.update(\"|\");\n  hash.update(normalizedTableIds.join(\",\"));\n  hash.update(\"|\");\n  hash.update(input.startAt);\n  hash.update(\"|\");\n  hash.update(input.endAt);\n  hash.update(\"|\");\n  hash.update(input.policyVersion);\n  return hash.digest(\"hex\").slice(0, 24);\n}\n\nexport function computePayloadChecksum(payload: unknown): string {\n  const hash = createHash(\"sha256\");\n  hash.update(stableJson(payload));\n  return hash.digest(\"hex\");\n}\n"
    },
    {
      "path": "server/capacity/validation.ts",
      "size": 3281,
      "sha256": "48dc95b0c029d8f8573166b40cdf7ce1ea9f9c475668123fe53b8df49883ae99",
      "language": "typescript",
      "content": "\nimport { getVenuePolicy, ServiceNotFoundError, ServiceOverrunError, whichService, type ServiceKey, type VenuePolicy } from \"./policy\";\nimport { __internal as tableInternals } from \"./tables\";\n\nimport type { DateTime } from \"luxon\";\n\ntype ComputeBookingWindow = (args: {\n  startISO?: string | null;\n  bookingDate?: string | null;\n  startTime?: string | null;\n  partySize: number;\n  policy: VenuePolicy;\n  serviceHint?: ServiceKey | null;\n}) => {\n  service: ServiceKey;\n  durationMinutes: number;\n  dining: {\n    start: DateTime;\n    end: DateTime;\n  };\n  block: {\n    start: DateTime;\n    end: DateTime;\n  };\n};\n\nconst computeBookingWindow = tableInternals.computeBookingWindow as ComputeBookingWindow;\n\nexport type BookingValidationInput = {\n  startISO?: string | null;\n  bookingDate?: string | null;\n  startTime?: string | null;\n  partySize: number;\n  dwellMinutes?: number | null;\n  allowAfterHours?: boolean;\n  serviceHint?: ServiceKey | null;\n  timezone?: string | null;\n  policyOverride?: VenuePolicy;\n};\n\nexport type BookingValidationResult = {\n  ok: boolean;\n  reasons: string[];\n  service?: ServiceKey;\n  dining?: {\n    start: string;\n    end: string;\n  };\n  block?: {\n    start: string;\n    end: string;\n  };\n  expectedDiningMinutes?: number;\n};\n\nfunction ensureIso(dateTime: DateTime | null | undefined): string | null {\n  if (!dateTime || !dateTime.isValid) {\n    return null;\n  }\n  return dateTime.toISO();\n}\n\nexport function validateBookingWindow(input: BookingValidationInput): BookingValidationResult {\n  const {\n    startISO,\n    bookingDate,\n    startTime,\n    partySize,\n    dwellMinutes,\n    allowAfterHours = false,\n    serviceHint,\n    timezone,\n    policyOverride,\n  } = input;\n\n  const reasons: string[] = [];\n\n  if (!Number.isFinite(partySize) || partySize <= 0) {\n    reasons.push(\"party_size_must_be_positive\");\n  }\n\n  const policy = policyOverride ?? getVenuePolicy({ timezone });\n\n  let window: ReturnType<typeof computeBookingWindow> | null = null;\n\n  try {\n    window = computeBookingWindow({\n      startISO,\n      bookingDate,\n      startTime,\n      partySize,\n      policy,\n      serviceHint: serviceHint ?? null,\n    });\n  } catch (error) {\n    if (error instanceof ServiceNotFoundError) {\n      if (!allowAfterHours) {\n        reasons.push(\"outside_service_hours\");\n      }\n    } else if (error instanceof ServiceOverrunError) {\n      if (!allowAfterHours) {\n        reasons.push(\"booking_exceeds_service_end\");\n      }\n    } else {\n      reasons.push(\"unable_to_compute_window\");\n    }\n  }\n\n  if (!window) {\n    return {\n      ok: reasons.length === 0,\n      reasons,\n    };\n  }\n\n  const service = window.service ?? whichService(window.dining.start, policy);\n  if (dwellMinutes) {\n    const minimumDining = window.dining.end.diff(window.dining.start, \"minutes\").minutes;\n    if (dwellMinutes < minimumDining) {\n      reasons.push(\"dwell_below_minimum\");\n    }\n  }\n\n  return {\n    ok: reasons.length === 0,\n    reasons,\n    service,\n    dining: {\n      start: ensureIso(window.dining.start)!,\n      end: ensureIso(window.dining.end)!,\n    },\n    block: {\n      start: ensureIso(window.block.start)!,\n      end: ensureIso(window.block.end)!,\n    },\n    expectedDiningMinutes: window.dining.end.diff(window.dining.start, \"minutes\").minutes,\n  };\n}\n"
    },
    {
      "path": "server/feature-flags.ts",
      "size": 6534,
      "sha256": "909bb037138bf802a8481266c3c9a52be11907d3e47684f000bc609075c98465",
      "language": "typescript",
      "content": "import { env } from \"@/lib/env\";\nimport { getFeatureFlagOverride, type FeatureFlagKey } from \"@/server/feature-flags-overrides\";\n\nconst loyaltyPilotIds = new Set(\n  (env.featureFlags.loyaltyPilotRestaurantIds ?? \"\")\n    .split(\",\")\n    .map((value) => value.trim())\n    .filter((value) => value.length > 0),\n);\n\nfunction isProductionEnv(): boolean {\n  return env.node.env === \"production\";\n}\n\nfunction resolveFeatureFlag(flag: FeatureFlagKey, fallback: boolean): boolean {\n  const override = getFeatureFlagOverride(flag);\n  if (typeof override === \"boolean\") {\n    return override;\n  }\n  return fallback;\n}\n\nexport function isLoyaltyPilotRestaurant(restaurantId: string): boolean {\n  if (!restaurantId) return false;\n  return loyaltyPilotIds.has(restaurantId);\n}\n\nexport function isAllocationsDualWriteEnabled(): boolean {\n  return env.featureFlags.allocationsDualWrite ?? false;\n}\n\nexport function isSelectorScoringEnabled(): boolean {\n  return env.featureFlags.selectorScoring ?? false;\n}\n\nexport function isSelectorLookaheadEnabled(): boolean {\n  return env.featureFlags.selectorLookahead?.enabled ?? false;\n}\n\nexport function getSelectorLookaheadWindowMinutes(): number {\n  return env.featureFlags.selectorLookahead?.windowMinutes ?? 120;\n}\n\nexport function getSelectorLookaheadPenaltyWeight(): number {\n  return env.featureFlags.selectorLookahead?.penaltyWeight ?? 500;\n}\n\nexport function getSelectorLookaheadBlockThreshold(): number {\n  return env.featureFlags.selectorLookahead?.blockThreshold ?? 0;\n}\n\nexport function isCombinationPlannerEnabled(): boolean {\n  return env.featureFlags.combinationPlanner ?? false;\n}\n\nexport function isAdjacencyValidationEnabled(): boolean {\n  return env.featureFlags.adjacencyValidation ?? false;\n}\n\nexport function isOpsMetricsEnabled(): boolean {\n  return env.featureFlags.opsMetrics ?? false;\n}\n\nexport function isOpsRejectionAnalyticsEnabled(): boolean {\n  return env.featureFlags.opsRejectionAnalytics ?? false;\n}\n\nexport function isHoldsEnabled(): boolean {\n  return env.featureFlags.holds.enabled ?? true;\n}\n\nexport function isAllocatorMergesEnabled(): boolean {\n  return env.featureFlags.allocator.mergesEnabled ?? !isProductionEnv();\n}\n\nexport function isPlannerTimePruningEnabled(): boolean {\n  const defaultValue = env.featureFlags.planner?.timePruningEnabled ?? false;\n  return resolveFeatureFlag(\"planner.time_pruning.enabled\", defaultValue);\n}\n\nexport function isAllocatorV2ForceLegacy(): boolean {\n  return env.featureFlags.allocatorV2?.forceLegacy ?? false;\n}\n\nexport function isAllocatorV2Enabled(): boolean {\n  if (isAllocatorV2ForceLegacy()) {\n    return false;\n  }\n  return env.featureFlags.allocatorV2?.enabled ?? false;\n}\n\nexport function isAllocatorV2ShadowMode(): boolean {\n  if (isAllocatorV2ForceLegacy()) {\n    return false;\n  }\n  return env.featureFlags.allocatorV2?.shadow ?? false;\n}\n\nexport function isAllocatorAdjacencyRequired(): boolean {\n  return env.featureFlags.allocator.requireAdjacency ?? true;\n}\n\nexport function isAllocatorServiceFailHard(): boolean {\n  const defaultValue = env.featureFlags.allocator?.service?.failHard ?? false;\n  return resolveFeatureFlag(\"allocator.service.fail_hard\", defaultValue);\n}\n\nexport function getAllocatorKMax(): number {\n  const configured = env.featureFlags.allocator.kMax ?? 3;\n  return Math.max(1, Math.min(configured, 5));\n}\n\nexport function getAllocatorAdjacencyMinPartySize(): number | null {\n  const value = env.featureFlags.allocator.adjacencyMinPartySize;\n  return typeof value === \"number\" ? value : null;\n}\n\nexport function getSelectorPlannerLimits(): {\n  maxPlansPerSlack?: number;\n  maxCombinationEvaluations?: number;\n  enumerationTimeoutMs?: number;\n} {\n  const { selector } = env.featureFlags;\n  const maxPlansPerSlack =\n    typeof selector?.maxPlansPerSlack === \"number\" ? selector.maxPlansPerSlack : undefined;\n  const maxCombinationEvaluations =\n    typeof selector?.maxCombinationEvaluations === \"number\" ? selector.maxCombinationEvaluations : undefined;\n  const enumerationTimeoutMs =\n    typeof selector?.enumerationTimeoutMs === \"number\" ? selector.enumerationTimeoutMs : undefined;\n  return {\n    ...(maxPlansPerSlack ? { maxPlansPerSlack } : {}),\n    ...(maxCombinationEvaluations ? { maxCombinationEvaluations } : {}),\n    ...(enumerationTimeoutMs ? { enumerationTimeoutMs } : {}),\n  };\n}\n\nexport function isHoldStrictConflictsEnabled(): boolean {\n  const defaultValue = env.featureFlags.holds?.strictConflicts ?? false;\n  return resolveFeatureFlag(\"holds.strict_conflicts.enabled\", defaultValue);\n}\n\nexport function isAdjacencyQueryUndirected(): boolean {\n  const defaultValue = env.featureFlags.adjacency?.queryUndirected ?? true;\n  return resolveFeatureFlag(\"adjacency.query.undirected\", defaultValue);\n}\n\nexport function getContextQueryPaddingMinutes(): number {\n  // Narrow context queries to +/- X minutes around booking window\n  // Defaults to 60 minutes if not configured\n  const value = env.featureFlags.context?.queryPaddingMinutes;\n  if (typeof value === \"number\" && Number.isFinite(value) && value >= 0 && value <= 240) {\n    return Math.floor(value);\n  }\n  return 60;\n}\n\nexport function getHoldMinTtlSeconds(): number {\n  const value = env.featureFlags.holds?.minTtlSeconds ?? 60;\n  return Math.max(1, Math.min(value, 3600));\n}\n\nexport function getHoldRateWindowSeconds(): number {\n  const value = env.featureFlags.holds?.rate?.windowSeconds ?? 60;\n  return Math.max(5, Math.min(value, 3600));\n}\n\nexport function getHoldRateMaxPerBooking(): number {\n  const value = env.featureFlags.holds?.rate?.maxPerBooking ?? 5;\n  return Math.max(1, Math.min(value, 100));\n}\n\n// ------------------------------\n// Booking Auto-Assignment\n// ------------------------------\nexport function isAutoAssignOnBookingEnabled(): boolean {\n  return env.featureFlags.autoAssignOnBooking ?? false;\n}\n\nexport function getAutoAssignMaxRetries(): number {\n  return env.featureFlags.autoAssign?.maxRetries ?? 3;\n}\n\nexport function getAutoAssignRetryDelaysMs(): number[] {\n  const raw = env.featureFlags.autoAssign?.retryDelaysMs;\n  if (typeof raw !== 'string' || raw.trim().length === 0) {\n    return [5000, 15000, 45000];\n  }\n  const parts = raw.split(',').map((s) => Number(s.trim())).filter((n) => Number.isFinite(n) && n >= 0);\n  if (parts.length === 0) return [5000, 15000, 45000];\n  // clamp to reasonable\n  return parts.map((n) => Math.max(0, Math.min(n, 5 * 60 * 1000)));\n}\n\nexport function getAutoAssignStartCutoffMinutes(): number {\n  return env.featureFlags.autoAssign?.startCutoffMinutes ?? 10;\n}\n"
    },
    {
      "path": "server/supabase.ts",
      "size": 6234,
      "sha256": "45b8402204d692767804ba2e6cf8e2d5ee372d72bfae387d561075ff6a1b9e1f",
      "language": "typescript",
      "content": "import { createServerClient } from \"@supabase/ssr\";\nimport { createClient, type SupabaseClient } from \"@supabase/supabase-js\";\nimport { cookies } from \"next/headers\";\nimport { type NextRequest } from \"next/server\";\n\nimport { env, getEnv } from \"@/lib/env\";\n\nimport type { Database } from \"@/types/supabase\";\nimport type { NextResponse} from \"next/server\";\n\nexport { BOOKING_BLOCKING_STATUSES } from \"@/lib/enums\";\n\nlet serviceClient: SupabaseClient<Database> | null = null;\nlet strictHoldInitStarted = false;\nlet strictHoldEnforcementActive: boolean | null = null;\n\nconst runtimeEnv = getEnv();\nconst { url: SUPABASE_URL, anonKey: SUPABASE_ANON_KEY, serviceKey: SUPABASE_SERVICE_ROLE_KEY } = env.supabase;\nconst DEFAULT_RESTAURANT_FALLBACK_ID = \"39cb1346-20fb-4fa2-b163-0230e1caf749\";\nconst DEFAULT_RESTAURANT_SLUG = runtimeEnv.NEXT_PUBLIC_DEFAULT_RESTAURANT_SLUG;\n\nlet cachedDefaultRestaurantId: string | null =\n  runtimeEnv.NEXT_PUBLIC_DEFAULT_RESTAURANT_ID ?? env.misc.bookingDefaultRestaurantId ?? null;\nlet resolvingDefaultRestaurantId: Promise<string> | null = null;\n\ntype CookieReader = {\n  getAll: () => { name: string; value: string }[];\n};\n\ntype CookieWriter = {\n  set: (options: { name: string; value: string; [key: string]: unknown }) => void;\n};\n\ntype NextCookies = Awaited<ReturnType<typeof cookies>>;\n\nfunction createCookieAdapter(store: CookieReader, writer?: CookieWriter) {\n  return {\n    getAll: () => store.getAll().map(({ name, value }) => ({ name, value })),\n    ...(writer\n      ? {\n          setAll: (cookiesToSet: { name: string; value: string; options: Record<string, unknown> }[]) => {\n            cookiesToSet.forEach(({ name, value, options }) => {\n              writer.set({ name, value, ...options });\n            });\n          },\n        }\n      : {}),\n  };\n}\n\nexport function getServiceSupabaseClient(): SupabaseClient<Database> {\n  if (!serviceClient) {\n    serviceClient = createClient<Database>(SUPABASE_URL, SUPABASE_SERVICE_ROLE_KEY, {\n      auth: {\n        persistSession: false,\n      },\n    });\n\n    // Best-effort startup initialization for strict hold conflict enforcement.\n    // This config sets the session GUC and verifies it is honored.\n    // We intentionally do not await here to avoid blocking cold starts.\n    if (!strictHoldInitStarted) {\n      strictHoldInitStarted = true;\n      void (async () => {\n        try {\n          // Attempt to enable strict enforcement for this service session\n          await serviceClient!.rpc(\"set_hold_conflict_enforcement\", { enabled: true });\n          // Verify it stuck (function returns the server-side view of the GUC)\n          const { data, error } = await serviceClient!.rpc(\"is_holds_strict_conflicts_enabled\");\n          if (error) {\n            strictHoldEnforcementActive = false;\n            console.error(\"[supabase] strict hold enforcement self-check failed\", {\n              code: error.code ?? null,\n              message: error.message ?? String(error),\n            });\n          } else {\n            strictHoldEnforcementActive = Boolean(data);\n            if (!strictHoldEnforcementActive) {\n              console.error(\"[supabase] strict hold enforcement not honored by server (GUC off)\");\n            } else {\n              console.info(\"[supabase] strict hold enforcement active\");\n            }\n          }\n        } catch (err) {\n          strictHoldEnforcementActive = false;\n          console.error(\"[supabase] strict hold enforcement init error\", {\n            error: err instanceof Error ? err.message : String(err),\n          });\n        }\n      })();\n    }\n  }\n\n  return serviceClient;\n}\n\nexport async function getServerComponentSupabaseClient(): Promise<SupabaseClient<Database>> {\n  const cookieStore = await cookies();\n  return createServerClient<Database>(SUPABASE_URL, SUPABASE_ANON_KEY, {\n    cookies: createCookieAdapter(cookieStore),\n  });\n}\n\nexport async function getRouteHandlerSupabaseClient(\n  cookieStore?: NextCookies,\n): Promise<SupabaseClient<Database>> {\n  const store = cookieStore ?? (await cookies());\n  return createServerClient<Database>(SUPABASE_URL, SUPABASE_ANON_KEY, {\n    cookies: createCookieAdapter(store, store as CookieWriter),\n  });\n}\n\nexport function getMiddlewareSupabaseClient(req: NextRequest, res: NextResponse): SupabaseClient<Database> {\n  return createServerClient<Database>(SUPABASE_URL, SUPABASE_ANON_KEY, {\n    cookies: createCookieAdapter(req.cookies, res.cookies),\n  });\n}\n\n/**\n * Returns whether the initial strict hold enforcement self-check succeeded for the service client.\n * This is a best-effort signal for ops visibility and conditional behavior.\n */\nexport function isStrictHoldEnforcementActive(): boolean | null {\n  return strictHoldEnforcementActive;\n}\n\nexport async function getDefaultRestaurantId(): Promise<string> {\n  if (env.misc.bookingDefaultRestaurantId) {\n    return env.misc.bookingDefaultRestaurantId;\n  }\n\n  if (cachedDefaultRestaurantId) {\n    return cachedDefaultRestaurantId;\n  }\n\n  if (!resolvingDefaultRestaurantId) {\n    const service = getServiceSupabaseClient();\n\n    const resolve = async (): Promise<string> => {\n      try {\n        if (DEFAULT_RESTAURANT_SLUG) {\n          const { data, error } = await service\n            .from(\"restaurants\")\n            .select(\"id\")\n            .eq(\"slug\", DEFAULT_RESTAURANT_SLUG)\n            .maybeSingle();\n\n          if (!error && data?.id) {\n            return data.id;\n          }\n        }\n\n        const { data, error } = await service\n          .from(\"restaurants\")\n          .select(\"id\")\n          .order(\"created_at\", { ascending: true })\n          .limit(1)\n          .maybeSingle();\n\n        if (!error && data?.id) {\n          return data.id;\n        }\n      } catch (cause) {\n        console.error(\"[supabase][default-restaurant] failed to resolve id\", cause);\n      }\n\n      return DEFAULT_RESTAURANT_FALLBACK_ID;\n    };\n\n    resolvingDefaultRestaurantId = resolve().then((value) => {\n      cachedDefaultRestaurantId = value ?? DEFAULT_RESTAURANT_FALLBACK_ID;\n      return cachedDefaultRestaurantId;\n    });\n  }\n\n  const resolved = await resolvingDefaultRestaurantId;\n  cachedDefaultRestaurantId = resolved ?? DEFAULT_RESTAURANT_FALLBACK_ID;\n  return cachedDefaultRestaurantId;\n}\n\n\n"
    }
  ]
}
