{
  "reserve/features/reservations/wizard/hooks/useConfirmationStep.ts": "'use client';\n\nimport { useCallback, useEffect, useMemo, useState } from 'react';\n\nimport { downloadCalendarEvent, shareReservationDetails } from '@/lib/reservations/share';\nimport { reservationConfigResult } from '@reserve/shared/config/reservations';\nimport {\n  formatReservationSummaryDate,\n  formatReservationTime,\n} from '@reserve/shared/formatting/booking';\nimport { normalizeTime } from '@reserve/shared/time';\nimport { DEFAULT_VENUE } from '@shared/config/venue';\n\nimport { useWizardDependencies } from '../di';\n\nimport type {\n  ConfirmationFeedback,\n  ConfirmationStatus,\n  ConfirmationStepController,\n  ConfirmationStepProps,\n} from '../ui/steps/confirmation-step/types';\n\nconst buildReservationWindow = (state: ConfirmationStepProps['state']) => {\n  const booking = state.lastConfirmed;\n  const date = booking?.booking_date ?? state.details.date ?? '';\n  if (!date) return null;\n  const time = booking?.start_time ?? normalizeTime(state.details.time);\n  const normalizedTime = normalizeTime(time);\n  const iso = normalizedTime ? `${date}T${normalizedTime}:00` : `${date}T00:00:00`;\n  const start = new Date(iso);\n  if (Number.isNaN(start.getTime())) return null;\n  const durationMinutes = state.details.reservationDurationMinutes;\n  const fallbackDuration = reservationConfigResult.config.defaultDurationMinutes;\n  const safeDuration = durationMinutes > 0 ? durationMinutes : fallbackDuration;\n  const end = new Date(start.getTime() + safeDuration * 60 * 1000);\n  return { start, end };\n};\n\nexport function useConfirmationStep({\n  state,\n  onNewBooking,\n  onClose,\n  onActionsChange,\n}: ConfirmationStepProps): ConfirmationStepController {\n  const { errorReporter } = useWizardDependencies();\n  const booking = state.lastConfirmed;\n  const details = state.details;\n  const isLoading = state.loading;\n\n  const venue = useMemo(\n    () => ({\n      ...DEFAULT_VENUE,\n      id: details.restaurantId || DEFAULT_VENUE.id,\n      name: details.restaurantName || DEFAULT_VENUE.name,\n      address: details.restaurantAddress || DEFAULT_VENUE.address,\n      timezone: details.restaurantTimezone || DEFAULT_VENUE.timezone,\n    }),\n    [\n      details.restaurantAddress,\n      details.restaurantId,\n      details.restaurantName,\n      details.restaurantTimezone,\n    ],\n  );\n\n  const [calendarLoading, setCalendarLoading] = useState(false);\n  const [walletLoading, setWalletLoading] = useState(false);\n  const [feedback, setFeedback] = useState<ConfirmationFeedback | null>(null);\n\n  const dismissFeedback = useCallback(() => setFeedback(null), []);\n\n  const reference = booking?.reference ?? 'Pending';\n  const guestName = booking?.customer_name ?? details.name;\n  const summaryDate = details.date ? formatReservationSummaryDate(details.date) : 'TBC';\n  const summaryTime = details.time ? formatReservationTime(details.time) : 'TBC';\n  const partyText = `${details.party} ${details.party === 1 ? 'guest' : 'guests'}`;\n\n  const status: ConfirmationStatus = isLoading\n    ? 'pending'\n    : booking?.status === 'pending' || booking?.status === 'pending_allocation'\n      ? 'pending'\n      : state.lastAction === 'update'\n        ? 'updated'\n        : 'confirmed';\n\n  const heading =\n    status === 'pending'\n      ? 'Booking pending'\n      : status === 'updated'\n        ? 'Booking updated'\n        : 'Booking confirmed';\n\n  const description =\n    status === 'pending'\n      ? `Your request has been received. You'll shortly get a confirmation email at ${details.email}.`\n      : status === 'updated'\n        ? `Your reservation was updated. A confirmation email has been sent to ${details.email}.`\n        : `A confirmation email has been sent to ${details.email}.`;\n\n  const reservationWindow = useMemo(() => buildReservationWindow(state), [state]);\n\n  const showFeedback = useCallback((variant: ConfirmationFeedback['variant'], message: string) => {\n    setFeedback({ variant, message });\n  }, []);\n\n  const sharePayload = useMemo(\n    () => ({\n      reservationId: booking?.id ?? state.details.bookingId ?? 'reservation',\n      reference: booking?.reference ?? null,\n      guestName,\n      partySize: booking?.party_size ?? details.party,\n      startAt: reservationWindow?.start.toISOString() ?? null,\n      endAt: reservationWindow?.end.toISOString() ?? null,\n      venueName: venue.name,\n      venueAddress: venue.address,\n      venueTimezone: venue.timezone,\n    }),\n    [\n      booking?.id,\n      booking?.reference,\n      booking?.party_size,\n      details.party,\n      state.details.bookingId,\n      guestName,\n      reservationWindow?.start,\n      reservationWindow?.end,\n      venue.name,\n      venue.address,\n      venue.timezone,\n    ],\n  );\n\n  const handleAddToCalendar = useCallback(() => {\n    setCalendarLoading(true);\n    try {\n      const result = downloadCalendarEvent(sharePayload);\n      showFeedback(result.variant, result.message);\n    } finally {\n      setCalendarLoading(false);\n    }\n  }, [sharePayload, showFeedback]);\n\n  const handleAddToWallet = useCallback(async () => {\n    setWalletLoading(true);\n    try {\n      const result = await shareReservationDetails(sharePayload);\n      showFeedback(result.variant, result.message);\n    } catch (error) {\n      errorReporter.capture(error, {\n        scope: 'confirmation.share',\n        reservationId: state.lastConfirmed?.id,\n      });\n      showFeedback('error', \"We couldn't share the reservation details. Please try again.\");\n    } finally {\n      setWalletLoading(false);\n    }\n  }, [errorReporter, sharePayload, showFeedback, state.lastConfirmed?.id]);\n\n  const handleClose = useCallback(() => {\n    onClose();\n  }, [onClose]);\n\n  const handleNewBooking = useCallback(() => {\n    onNewBooking();\n  }, [onNewBooking]);\n\n  useEffect(() => {\n    onActionsChange([\n      {\n        id: 'confirmation-close',\n        label: 'Close confirmation',\n        ariaLabel: 'Close confirmation',\n        variant: 'ghost',\n        icon: 'X',\n        onClick: handleClose,\n        disabled: isLoading,\n        role: 'secondary',\n      },\n      {\n        id: 'confirmation-calendar',\n        label: 'Add reservation to calendar',\n        ariaLabel: 'Add reservation to calendar',\n        variant: 'outline',\n        icon: 'Calendar',\n        onClick: handleAddToCalendar,\n        loading: calendarLoading,\n        disabled: isLoading,\n        role: 'support',\n      },\n      {\n        id: 'confirmation-wallet',\n        label: 'Add reservation to wallet',\n        ariaLabel: 'Add reservation to wallet',\n        variant: 'outline',\n        icon: 'Wallet',\n        onClick: handleAddToWallet,\n        loading: walletLoading,\n        disabled: isLoading,\n        role: 'support',\n      },\n      {\n        id: 'confirmation-new',\n        label: 'Start a new booking',\n        ariaLabel: 'Start a new booking',\n        variant: 'default',\n        icon: 'Plus',\n        onClick: handleNewBooking,\n        disabled: isLoading,\n        role: 'primary',\n      },\n    ]);\n  }, [\n    calendarLoading,\n    handleAddToCalendar,\n    handleAddToWallet,\n    handleClose,\n    handleNewBooking,\n    isLoading,\n    onActionsChange,\n    walletLoading,\n  ]);\n\n  return {\n    booking,\n    details,\n    venue,\n    status,\n    isLoading,\n    heading,\n    description,\n    reference,\n    guestName,\n    summaryDate,\n    summaryTime,\n    partyText,\n    reservationWindow,\n    calendarLoading,\n    walletLoading,\n    feedback,\n    dismissFeedback,\n    handleAddToCalendar,\n    handleAddToWallet,\n    handleClose,\n    handleNewBooking,\n  };\n}\n",
  "reserve/features/reservations/wizard/hooks/useDetailsStepForm.ts": "'use client';\n\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { useCallback, useEffect, useMemo } from 'react';\nimport { useForm } from 'react-hook-form';\n\nimport { track } from '@shared/lib/analytics';\n\nimport {\n  createDetailsFormSchema,\n  type DetailsFormInputValues,\n  type DetailsFormValues,\n} from '../model/schemas';\n\nimport type { BookingDetails, StepAction } from '../model/reducer';\nimport type { DetailsStepProps, DetailsStepController } from '../ui/steps/details-step/types';\n\nexport function useDetailsStepForm({\n  state,\n  actions,\n  onActionsChange,\n  onTrack = track,\n  mode = 'customer',\n}: DetailsStepProps): DetailsStepController {\n  const schema = useMemo(() => createDetailsFormSchema(mode), [mode]);\n  const form = useForm<DetailsFormInputValues, unknown, DetailsFormValues>({\n    resolver: zodResolver(schema),\n    mode: 'onChange',\n    reValidateMode: 'onBlur',\n    defaultValues: {\n      name: state.details.name ?? '',\n      email: state.details.email ?? '',\n      phone: state.details.phone ?? '',\n      rememberDetails: state.details.rememberDetails ?? true,\n      marketingOptIn: state.details.marketingOptIn ?? true,\n      agree: state.details.agree ?? false,\n    },\n  });\n\n  const normalizeValues = useCallback(\n    (values: DetailsFormInputValues): DetailsFormValues => ({\n      ...values,\n      rememberDetails: values.rememberDetails ?? true,\n      marketingOptIn: values.marketingOptIn ?? true,\n      agree: values.agree ?? false,\n    }),\n    [],\n  );\n\n  useEffect(() => {\n    const current = normalizeValues(form.getValues());\n    const nextInput: DetailsFormInputValues = {\n      name: state.details.name ?? '',\n      email: state.details.email ?? '',\n      phone: state.details.phone ?? '',\n      rememberDetails: state.details.rememberDetails ?? true,\n      marketingOptIn: state.details.marketingOptIn ?? true,\n      agree: state.details.agree ?? false,\n    };\n    const next = normalizeValues(nextInput);\n\n    if (\n      current.name !== next.name ||\n      current.email !== next.email ||\n      current.phone !== next.phone ||\n      current.rememberDetails !== next.rememberDetails ||\n      current.marketingOptIn !== next.marketingOptIn ||\n      current.agree !== next.agree\n    ) {\n      form.reset(nextInput, { keepDirty: false, keepTouched: false });\n    }\n  }, [\n    form,\n    normalizeValues,\n    state.details.agree,\n    state.details.email,\n    state.details.marketingOptIn,\n    state.details.name,\n    state.details.phone,\n    state.details.rememberDetails,\n  ]);\n\n  const updateField = useCallback(\n    <K extends keyof BookingDetails>(key: K, value: BookingDetails[K]) => {\n      actions.updateDetails(key, value);\n    },\n    [actions],\n  );\n\n  const handleBack = useCallback(() => {\n    actions.goToStep(1);\n  }, [actions]);\n\n  const handleError = useCallback(\n    (errors: Record<string, unknown>) => {\n      const firstKey = Object.keys(errors)[0];\n      if (firstKey) {\n        form.setFocus(firstKey as keyof DetailsFormValues, { shouldSelect: true });\n      }\n    },\n    [form],\n  );\n\n  const handleSubmit = useCallback(\n    (values: DetailsFormValues) => {\n      const trimmedName = values.name.trim();\n      const trimmedEmail = values.email.trim();\n      const trimmedPhone = values.phone.trim();\n\n      updateField('name', trimmedName);\n      updateField('email', trimmedEmail);\n      updateField('phone', trimmedPhone);\n      updateField('rememberDetails', values.rememberDetails);\n      updateField('marketingOptIn', values.marketingOptIn);\n      updateField('agree', values.agree);\n\n      onTrack('details_submit', {\n        marketing_opt_in: values.marketingOptIn ? 1 : 0,\n        terms_checked: values.agree ? 1 : 0,\n      });\n\n      actions.goToStep(3);\n    },\n    [actions, onTrack, updateField],\n  );\n\n  const { isSubmitting, isValid } = form.formState;\n\n  const handleReview = useCallback(() => {\n    form.handleSubmit(handleSubmit, handleError)();\n  }, [form, handleError, handleSubmit]);\n\n  const detailsActions = useMemo<StepAction[]>(\n    () => [\n      {\n        id: 'details-back',\n        label: 'Back',\n        icon: 'ChevronLeft',\n        variant: 'outline',\n        disabled: isSubmitting,\n        onClick: handleBack,\n        role: 'secondary',\n      },\n      {\n        id: 'details-review',\n        label: 'Review booking',\n        icon: 'Check',\n        variant: 'default',\n        disabled: isSubmitting || !isValid,\n        loading: isSubmitting,\n        onClick: handleReview,\n        role: 'primary',\n      },\n    ],\n    [handleBack, handleReview, isSubmitting, isValid],\n  );\n\n  useEffect(() => {\n    onActionsChange(detailsActions);\n  }, [detailsActions, onActionsChange]);\n\n  return {\n    form,\n    handleBack,\n    handleSubmit,\n    handleError,\n    isSubmitting,\n    isValid,\n    handlers: {\n      changeName: (value: string) => updateField('name', value),\n      changeEmail: (value: string) => updateField('email', value),\n      changePhone: (value: string) => updateField('phone', value),\n      toggleRemember: (value: boolean) => updateField('rememberDetails', value),\n      toggleMarketing: (value: boolean) => updateField('marketingOptIn', value),\n      toggleAgree: (value: boolean) => updateField('agree', value),\n    },\n  };\n}\n",
  "reserve/features/reservations/wizard/hooks/usePlanStepForm.ts": "'use client';\n\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { useQueryClient } from '@tanstack/react-query';\nimport { useCallback, useEffect, useMemo, useRef, useState } from 'react';\nimport { useForm } from 'react-hook-form';\n\nimport { emit } from '@/lib/analytics/emit';\nimport { useTimeSlots } from '@reserve/features/reservations/wizard/services';\nimport {\n  fetchReservationSchedule,\n  scheduleQueryKey,\n} from '@reserve/features/reservations/wizard/services/schedule';\nimport { formatDateForInput } from '@reserve/shared/formatting/booking';\nimport { toMinutes } from '@reserve/shared/time';\n\nimport { planFormSchema, type PlanFormValues } from '../model/schemas';\n\nimport type { BookingDetails, StepAction } from '../model/reducer';\nimport type {\n  PlanStepFormProps,\n  PlanStepFormState,\n  PlanStepUnavailableReason,\n} from '../ui/steps/plan-step/types';\nimport type { BookingOption } from '@reserve/shared/booking';\n\nconst MONTH_KEY_FORMATTER = (value: Date) =>\n  `${value.getFullYear()}-${String(value.getMonth() + 1).padStart(2, '0')}`;\n\nconst toMonthStart = (value: Date) => new Date(value.getFullYear(), value.getMonth(), 1);\n\nconst deriveUnavailableReason = (\n  nextSchedule: { isClosed: boolean; slots: { disabled: boolean }[] } | null,\n): PlanStepUnavailableReason | null => {\n  if (!nextSchedule) {\n    return 'unknown';\n  }\n  if (nextSchedule.isClosed) {\n    return 'closed';\n  }\n  const hasEnabledSlot = nextSchedule.slots.some((slot) => !slot.disabled);\n  return hasEnabledSlot ? null : 'no-slots';\n};\n\nconst buildMonthDateKeys = (\n  monthStart: Date,\n  minSelectableDate: Date,\n  limit?: number,\n): string[] => {\n  const start = toMonthStart(monthStart);\n  const end = new Date(start.getFullYear(), start.getMonth() + 1, 0);\n  const keys: string[] = [];\n\n  const normalizedMin = new Date(minSelectableDate);\n  normalizedMin.setHours(0, 0, 0, 0);\n  const maxEntries =\n    typeof limit === 'number' && Number.isFinite(limit) && limit > 0\n      ? Math.floor(limit)\n      : Number.POSITIVE_INFINITY;\n\n  for (let cursor = new Date(start); cursor <= end; cursor.setDate(cursor.getDate() + 1)) {\n    if (cursor < normalizedMin) {\n      continue;\n    }\n    keys.push(formatDateForInput(new Date(cursor)));\n    if (maxEntries > 0 && keys.length >= maxEntries) {\n      break;\n    }\n  }\n\n  return keys;\n};\n\nconst parseDateKey = (value: string | null | undefined): Date | null => {\n  if (!value) {\n    return null;\n  }\n  const [yearPart, monthPart, dayPart] = value.split('-');\n  const year = Number.parseInt(yearPart ?? '', 10);\n  const month = Number.parseInt(monthPart ?? '', 10);\n  const day = Number.parseInt(dayPart ?? '', 10);\n  if (!Number.isFinite(year) || !Number.isFinite(month) || !Number.isFinite(day)) {\n    return null;\n  }\n  const next = new Date(year, month - 1, day);\n  return Number.isNaN(next.getTime()) ? null : next;\n};\n\ntype UnavailableDateTrackingArgs = {\n  restaurantSlug: string | null | undefined;\n  date: string | null | undefined;\n  minDate: Date;\n};\n\ntype UnavailableDateTrackingResult = {\n  unavailableDates: Map<string, PlanStepUnavailableReason>;\n  prefetchVisibleMonth: (value: Date | null | undefined) => void;\n  updateUnavailableDate: (dateKey: string, reason: PlanStepUnavailableReason | null) => void;\n  normalizedMinDate: Date;\n  currentUnavailabilityReason: PlanStepUnavailableReason | null;\n};\n\nfunction useUnavailableDateTracking({\n  restaurantSlug,\n  date,\n  minDate,\n}: UnavailableDateTrackingArgs): UnavailableDateTrackingResult {\n  const queryClient = useQueryClient();\n  const prefetchedMonthsRef = useRef<Set<string>>(new Set());\n  const [unavailableDates, setUnavailableDates] = useState<Map<string, PlanStepUnavailableReason>>(\n    () => new Map(),\n  );\n\n  const normalizedMinDate = useMemo(() => {\n    const next = new Date(minDate);\n    next.setHours(0, 0, 0, 0);\n    return next;\n  }, [minDate]);\n\n  const updateUnavailableDate = useCallback(\n    (dateKey: string, reason: PlanStepUnavailableReason | null) => {\n      setUnavailableDates((prev) => {\n        const existing = prev.get(dateKey) ?? null;\n        if (existing === reason) {\n          return prev;\n        }\n        const nextMap = new Map(prev);\n        if (reason) {\n          nextMap.set(dateKey, reason);\n        } else {\n          nextMap.delete(dateKey);\n        }\n        return nextMap;\n      });\n    },\n    [],\n  );\n\n  const prefetchVisibleMonth = useCallback(\n    (value: Date | null | undefined) => {\n      if (!value) {\n        return;\n      }\n      const slug = restaurantSlug?.trim();\n      if (!slug) {\n        return;\n      }\n\n      const monthStart = toMonthStart(value);\n      const monthStarts: Date[] = [monthStart];\n\n      const previousMonth = new Date(monthStart.getFullYear(), monthStart.getMonth() - 1, 1);\n      if (previousMonth >= normalizedMinDate) {\n        monthStarts.push(previousMonth);\n      }\n\n      const nextMonth = new Date(monthStart.getFullYear(), monthStart.getMonth() + 1, 1);\n      monthStarts.push(nextMonth);\n\n      monthStarts.forEach((month) => {\n        const monthKey = MONTH_KEY_FORMATTER(month);\n        if (prefetchedMonthsRef.current.has(monthKey)) {\n          return;\n        }\n        prefetchedMonthsRef.current.add(monthKey);\n\n        const dateKeys = buildMonthDateKeys(month, normalizedMinDate);\n        if (dateKeys.length === 0) {\n          return;\n        }\n\n        void Promise.all(\n          dateKeys.map(async (dateKey) => {\n            try {\n              const scheduleResult = await queryClient.fetchQuery({\n                queryKey: scheduleQueryKey(slug, dateKey),\n                queryFn: ({ signal }) => fetchReservationSchedule(slug, dateKey, signal),\n                staleTime: 60_000,\n              });\n              const reason = deriveUnavailableReason(scheduleResult);\n              updateUnavailableDate(dateKey, reason);\n            } catch (error) {\n              if (process.env.NODE_ENV !== 'production') {\n                console.error('[plan-step] failed to prefetch schedule', { date: dateKey, error });\n              }\n              emit('schedule.fetch.miss', { restaurantSlug: slug, date: dateKey });\n              updateUnavailableDate(dateKey, 'unknown');\n            }\n          }),\n        );\n      });\n    },\n    [normalizedMinDate, queryClient, restaurantSlug, updateUnavailableDate],\n  );\n\n  useEffect(() => {\n    const initialMonth = parseDateKey(date) ?? normalizedMinDate;\n    prefetchVisibleMonth(initialMonth);\n  }, [date, normalizedMinDate, prefetchVisibleMonth]);\n\n  useEffect(() => {\n    prefetchedMonthsRef.current.clear();\n  }, [restaurantSlug]);\n\n  const currentUnavailabilityReason = useMemo<PlanStepUnavailableReason | null>(() => {\n    if (!date) {\n      return null;\n    }\n    return unavailableDates.get(date) ?? null;\n  }, [date, unavailableDates]);\n\n  return {\n    unavailableDates,\n    prefetchVisibleMonth,\n    updateUnavailableDate,\n    normalizedMinDate,\n    currentUnavailabilityReason,\n  };\n}\n\ntype PlanSlotDataArgs = {\n  restaurantSlug: string | null | undefined;\n  date: string | null | undefined;\n  time: string | null | undefined;\n};\n\ntype PlanSlotDataResult = {\n  slots: ReturnType<typeof useTimeSlots>['slots'];\n  serviceAvailability: ReturnType<typeof useTimeSlots>['serviceAvailability'];\n  inferBookingOption: ReturnType<typeof useTimeSlots>['inferBookingOption'];\n  schedule: ReturnType<typeof useTimeSlots>['schedule'];\n  availableBookingOptions: ReturnType<typeof useTimeSlots>['availableBookingOptions'];\n  isScheduleLoading: boolean;\n  enabledSlots: ReturnType<typeof useTimeSlots>['slots'];\n  hasAvailableSlots: boolean;\n  intervalMinutes: number | null;\n  latestSelectableMinutes: number | null;\n};\n\nfunction usePlanSlotData({ restaurantSlug, date, time }: PlanSlotDataArgs): PlanSlotDataResult {\n  const {\n    slots,\n    serviceAvailability,\n    inferBookingOption,\n    schedule,\n    availableBookingOptions,\n    isLoading: isScheduleLoading,\n  } = useTimeSlots({\n    restaurantSlug,\n    date,\n    selectedTime: time,\n  });\n\n  const enabledSlots = useMemo(() => slots.filter((slot) => !slot.disabled), [slots]);\n  const hasAvailableSlots = enabledSlots.length > 0;\n  const intervalMinutes =\n    typeof schedule?.intervalMinutes === 'number' && schedule.intervalMinutes > 0\n      ? schedule.intervalMinutes\n      : null;\n  const closingMinutes = schedule?.window?.closesAt ? toMinutes(schedule.window.closesAt) : null;\n  const configuredBufferMinutes =\n    typeof schedule?.lastSeatingBufferMinutes === 'number' && schedule.lastSeatingBufferMinutes > 0\n      ? schedule.lastSeatingBufferMinutes\n      : null;\n  const guardMinutes =\n    closingMinutes !== null\n      ? Math.max(\n          0,\n          Math.max(\n            configuredBufferMinutes ?? 0,\n            typeof schedule?.defaultDurationMinutes === 'number'\n              ? schedule.defaultDurationMinutes\n              : 0,\n          ),\n        )\n      : null;\n  const latestSelectableMinutes =\n    closingMinutes !== null && guardMinutes !== null\n      ? Math.max(0, closingMinutes - guardMinutes)\n      : null;\n\n  return {\n    slots,\n    serviceAvailability,\n    inferBookingOption,\n    schedule,\n    availableBookingOptions,\n    isScheduleLoading,\n    enabledSlots,\n    hasAvailableSlots,\n    intervalMinutes,\n    latestSelectableMinutes,\n  };\n}\n\nexport function usePlanStepForm({\n  state,\n  actions,\n  onActionsChange,\n  onTrack,\n  minDate,\n}: PlanStepFormProps): PlanStepFormState {\n  const form = useForm<PlanFormValues>({\n    resolver: zodResolver(planFormSchema),\n    mode: 'onChange',\n    reValidateMode: 'onBlur',\n    defaultValues: {\n      date: state.details.date ?? '',\n      time: state.details.time ?? '',\n      party: state.details.party ?? 1,\n      bookingType: state.details.bookingType,\n      notes: state.details.notes ?? '',\n    },\n  });\n\n  const {\n    unavailableDates,\n    prefetchVisibleMonth,\n    updateUnavailableDate,\n    normalizedMinDate,\n    currentUnavailabilityReason,\n  } = useUnavailableDateTracking({\n    restaurantSlug: state.details.restaurantSlug,\n    date: state.details.date,\n    minDate,\n  });\n\n  const {\n    slots,\n    serviceAvailability,\n    inferBookingOption,\n    schedule,\n    availableBookingOptions,\n    isScheduleLoading,\n    enabledSlots,\n    hasAvailableSlots,\n    intervalMinutes,\n    latestSelectableMinutes,\n  } = usePlanSlotData({\n    restaurantSlug: state.details.restaurantSlug,\n    date: state.details.date,\n    time: state.details.time,\n  });\n\n  const lastValidDateRef = useRef<string | null>(state.details.date ?? null);\n\n  useEffect(() => {\n    form.reset(\n      {\n        date: state.details.date ?? '',\n        time: state.details.time ?? enabledSlots[0]?.value ?? '',\n        party: state.details.party ?? 1,\n        bookingType: state.details.bookingType,\n        notes: state.details.notes ?? '',\n      },\n      { keepDirty: false, keepTouched: false },\n    );\n  }, [\n    form,\n    state.details.date,\n    state.details.time,\n    state.details.party,\n    state.details.bookingType,\n    state.details.notes,\n    enabledSlots,\n  ]);\n\n  const updateField = useCallback(\n    <K extends keyof BookingDetails>(key: K, value: BookingDetails[K]) => {\n      if (state.details[key] === value) {\n        return;\n      }\n      actions.updateDetails(key, value);\n    },\n    [actions, state.details],\n  );\n\n  const fallbackTime = enabledSlots[0]?.value ?? '';\n\n  useEffect(() => {\n    if (!state.details.time && fallbackTime) {\n      updateField('time', fallbackTime);\n      form.setValue('time', fallbackTime, { shouldDirty: false, shouldValidate: true });\n    }\n  }, [fallbackTime, form, state.details.time, updateField]);\n\n  const normalizeToInterval = useCallback(\n    (value: string) => {\n      if (!value) {\n        return '';\n      }\n\n      const [hoursPart, minutesPart] = value.split(':');\n      const hours = Number.parseInt(hoursPart ?? '', 10);\n      const minutes = Number.parseInt(minutesPart ?? '', 10);\n\n      if (Number.isNaN(hours) || Number.isNaN(minutes) || hours < 0 || hours > 23 || minutes < 0) {\n        return value;\n      }\n\n      if (!intervalMinutes || intervalMinutes <= 0) {\n        return value;\n      }\n\n      const totalMinutes = Math.max(0, hours * 60 + minutes);\n      const cappedMinutes =\n        typeof latestSelectableMinutes === 'number'\n          ? Math.min(totalMinutes, latestSelectableMinutes)\n          : totalMinutes;\n      const normalizedMinutes = Math.floor(cappedMinutes / intervalMinutes) * intervalMinutes;\n      const nextHours = Math.floor(normalizedMinutes / 60);\n      const nextMinutes = normalizedMinutes % 60;\n\n      return `${nextHours.toString().padStart(2, '0')}:${nextMinutes.toString().padStart(2, '0')}`;\n    },\n    [intervalMinutes, latestSelectableMinutes],\n  );\n\n  const submitForm = useCallback(\n    (values: PlanFormValues) => {\n      const normalizedTime = normalizeToInterval(values.time);\n\n      updateField('date', values.date);\n      updateField('time', normalizedTime);\n      updateField('party', values.party);\n      updateField('bookingType', values.bookingType);\n      updateField('notes', values.notes ?? '');\n      form.setValue('time', normalizedTime, { shouldDirty: false, shouldValidate: true });\n      actions.goToStep(2);\n    },\n    [actions, form, normalizeToInterval, updateField],\n  );\n\n  const handleError = useCallback(\n    (errors: Record<string, unknown>) => {\n      const firstKey = Object.keys(errors)[0];\n      if (firstKey) {\n        form.setFocus(firstKey as keyof PlanFormValues, { shouldSelect: true });\n      }\n    },\n    [form],\n  );\n\n  const selectDate = useCallback(\n    (value: Date | undefined | null) => {\n      const formatted = value ? formatDateForInput(value) : '';\n      form.setValue('date', formatted, { shouldDirty: true, shouldValidate: true });\n      updateField('date', formatted);\n      if (formatted) {\n        onTrack?.('select_date', { date: formatted });\n      }\n    },\n    [form, onTrack, updateField],\n  );\n\n  const selectTime = useCallback(\n    (value: string, options?: { commit?: boolean }) => {\n      if (!hasAvailableSlots) {\n        return;\n      }\n\n      if (options?.commit === false) {\n        form.setValue('time', value, { shouldDirty: true, shouldValidate: false });\n        return;\n      }\n\n      const normalized = normalizeToInterval(value);\n      form.setValue('time', normalized, { shouldDirty: true, shouldValidate: true });\n      updateField('time', normalized);\n\n      const inferredService = inferBookingOption(normalized);\n      form.setValue('bookingType', inferredService, { shouldDirty: true, shouldValidate: true });\n      updateField('bookingType', inferredService);\n\n      onTrack?.('select_time', {\n        time: normalized,\n        booking_type: inferredService,\n      });\n    },\n    [form, hasAvailableSlots, inferBookingOption, normalizeToInterval, onTrack, updateField],\n  );\n\n  const changeParty = useCallback(\n    (direction: 'decrement' | 'increment') => {\n      const current = form.getValues('party');\n      const next = direction === 'decrement' ? Math.max(1, current - 1) : Math.min(12, current + 1);\n      form.setValue('party', next, { shouldDirty: true, shouldValidate: true });\n      updateField('party', next);\n      onTrack?.('select_party', { party: next });\n    },\n    [form, onTrack, updateField],\n  );\n\n  const changeOccasion = useCallback(\n    (value: BookingOption) => {\n      form.setValue('bookingType', value, { shouldDirty: true, shouldValidate: true });\n      updateField('bookingType', value);\n      onTrack?.('select_time', {\n        time: form.getValues('time'),\n        booking_type: value,\n      });\n    },\n    [form, onTrack, updateField],\n  );\n\n  const commitNotes = useCallback(\n    (value: string) => {\n      updateField('notes', value ?? '');\n    },\n    [updateField],\n  );\n\n  useEffect(() => {\n    if (!schedule) {\n      return;\n    }\n\n    const scheduleDate = schedule.date;\n    const derivedReason = deriveUnavailableReason(schedule);\n\n    updateUnavailableDate(scheduleDate, derivedReason);\n\n    const isCurrentDate = scheduleDate === state.details.date;\n\n    if (derivedReason) {\n      if (derivedReason === 'closed') {\n        emit('selection.blocked.closed', {\n          restaurantSlug: state.details.restaurantSlug,\n          date: scheduleDate,\n        });\n      }\n      if (isCurrentDate) {\n        const fallbackDate = lastValidDateRef.current;\n        if (fallbackDate && fallbackDate !== scheduleDate) {\n          form.setValue('date', fallbackDate, { shouldDirty: true, shouldValidate: true });\n          updateField('date', fallbackDate);\n        } else if (!fallbackDate) {\n          form.setValue('date', '', { shouldDirty: true, shouldValidate: true });\n          updateField('date', '');\n        }\n\n        if (form.getValues('time')) {\n          form.setValue('time', '', { shouldDirty: true, shouldValidate: true });\n          updateField('time', '');\n        }\n\n        const dateMessage =\n          derivedReason === 'closed'\n            ? 'We’re closed on the selected date. Please choose a different day.'\n            : derivedReason === 'no-slots'\n              ? 'No reservation times are available for the selected date. Please choose another day.'\n              : 'Schedule not loaded yet—scroll to load month.';\n        form.setError('date', { type: 'manual', message: dateMessage });\n        form.setError('time', {\n          type: 'manual',\n          message: 'Select another date to continue.',\n        });\n      }\n      return;\n    }\n\n    if (isCurrentDate) {\n      form.clearErrors(['date', 'time']);\n      lastValidDateRef.current = scheduleDate;\n\n      const currentTime = form.getValues('time');\n      const hasCurrentSlot =\n        currentTime && enabledSlots.some((slot) => slot.value === currentTime && !slot.disabled);\n\n      if (!hasCurrentSlot) {\n        const nextSlot = enabledSlots[0]?.value ?? '';\n        if (nextSlot) {\n          form.setValue('time', nextSlot, { shouldDirty: false, shouldValidate: true });\n          updateField('time', nextSlot);\n          const inferredService = inferBookingOption(nextSlot);\n          form.setValue('bookingType', inferredService, {\n            shouldDirty: false,\n            shouldValidate: true,\n          });\n          updateField('bookingType', inferredService);\n        } else if (form.getValues('time')) {\n          form.setValue('time', '', { shouldDirty: true, shouldValidate: true });\n          updateField('time', '');\n        }\n      }\n    } else if (!derivedReason && !schedule.isClosed) {\n      lastValidDateRef.current = scheduleDate;\n    }\n  }, [\n    enabledSlots,\n    form,\n    inferBookingOption,\n    schedule,\n    state.details.date,\n    state.details.restaurantSlug,\n    updateField,\n    updateUnavailableDate,\n  ]);\n\n  useEffect(() => {\n    const duration = schedule?.defaultDurationMinutes;\n    if (!duration || duration <= 0) {\n      return;\n    }\n    if (state.details.reservationDurationMinutes === duration) {\n      return;\n    }\n    updateField('reservationDurationMinutes', duration);\n  }, [schedule?.defaultDurationMinutes, state.details.reservationDurationMinutes, updateField]);\n\n  const handleContinue = useCallback(() => {\n    form.handleSubmit(submitForm, handleError)();\n  }, [form, handleError, submitForm]);\n\n  const planStepActions = useMemo<StepAction[]>(\n    () => [\n      {\n        id: 'plan-continue',\n        label: 'Continue',\n        icon: 'ChevronDown',\n        variant: 'default',\n        disabled: form.formState.isSubmitting || !form.formState.isValid,\n        loading: form.formState.isSubmitting,\n        onClick: handleContinue,\n        role: 'primary',\n      },\n    ],\n    [form.formState.isSubmitting, form.formState.isValid, handleContinue],\n  );\n\n  useEffect(() => {\n    onActionsChange(planStepActions);\n  }, [onActionsChange, planStepActions]);\n\n  return {\n    form,\n    slots,\n    availability: serviceAvailability,\n    availableBookingOptions,\n    occasionCatalog: schedule?.occasionCatalog ?? [],\n    handlers: {\n      selectDate,\n      selectTime,\n      changeParty,\n      changeOccasion,\n      commitNotes,\n      prefetchMonth: (month: Date) => {\n        prefetchVisibleMonth(month);\n      },\n    },\n    minDate: normalizedMinDate,\n    intervalMinutes,\n    unavailableDates,\n    hasAvailableSlots,\n    isScheduleLoading,\n    schedule,\n    currentUnavailabilityReason,\n    isSubmitting: form.formState.isSubmitting,\n    isValid: form.formState.isValid,\n    submitForm,\n    handleError,\n  } as const;\n}\n",
  "reserve/features/reservations/wizard/hooks/useReviewStep.ts": "'use client';\n\nimport { useCallback, useEffect, useMemo } from 'react';\n\nimport {\n  formatReservationSummaryDate,\n  formatReservationTime,\n} from '@reserve/shared/formatting/booking';\n\nimport { useWizardDependencies } from '../di';\n\nimport type {\n  ReviewStepProps,\n  ReviewStepController,\n  ReviewSummary,\n} from '../ui/steps/review-step/types';\n\nexport function useReviewStep({\n  state,\n  actions,\n  onConfirm,\n  onActionsChange,\n}: ReviewStepProps): ReviewStepController {\n  const details = state.details;\n  const { analytics } = useWizardDependencies();\n\n  useEffect(() => {\n    if (details.date && details.time) {\n      analytics.track('confirm_open', {\n        date: details.date,\n        time: details.time,\n        party: details.party,\n      });\n    } else {\n      analytics.track('confirm_open');\n    }\n  }, [analytics, details.date, details.party, details.time]);\n\n  const summary: ReviewSummary = useMemo(() => {\n    const summaryDate = details.date ? formatReservationSummaryDate(details.date) : 'TBC';\n    const summaryTime = details.time ? formatReservationTime(details.time) : 'TBC';\n    const partyText = `${details.party} ${details.party === 1 ? 'guest' : 'guests'}`;\n    const summaryValue =\n      details.date && details.time\n        ? `${details.party} at ${formatReservationTime(details.time)} on ${formatReservationSummaryDate(details.date)}`\n        : partyText;\n\n    return {\n      summaryValue,\n      summaryDate,\n      summaryTime,\n      partyText,\n    };\n  }, [details.date, details.party, details.time]);\n\n  const handleEdit = useCallback(() => {\n    actions.goToStep(1);\n  }, [actions]);\n\n  const handleConfirm = useCallback(() => {\n    onConfirm();\n  }, [onConfirm]);\n\n  useEffect(() => {\n    onActionsChange([\n      {\n        id: 'review-edit',\n        label: 'Edit details',\n        icon: 'Pencil',\n        variant: 'outline',\n        onClick: handleEdit,\n        role: 'secondary',\n      },\n      {\n        id: 'review-confirm',\n        label: state.submitting ? 'Processing…' : 'Confirm booking',\n        icon: state.submitting ? undefined : 'Check',\n        variant: 'default',\n        disabled: state.submitting,\n        loading: state.submitting,\n        onClick: handleConfirm,\n        role: 'primary',\n      },\n    ]);\n  }, [handleConfirm, handleEdit, onActionsChange, state.submitting]);\n\n  return {\n    details,\n    summary,\n    isSubmitting: state.submitting,\n    error: state.error,\n    handleEdit,\n    handleConfirm,\n  };\n}\n",
  "reserve/features/reservations/wizard/ui/steps/ConfirmationStep.tsx": "'use client';\n\nimport { AlertTriangle, CheckCircle2, Info, XCircle } from 'lucide-react';\nimport React, { useEffect, useMemo, useState } from 'react';\n\nimport { useConfirmationStep } from '@features/reservations/wizard/hooks/useConfirmationStep';\nimport { Alert, AlertDescription, AlertIcon } from '@shared/ui/alert';\nimport { Button } from '@shared/ui/button';\n\nimport { WizardStep } from '../WizardStep';\n\nimport type { ConfirmationStepProps } from './confirmation-step/types';\n\nconst STATUS_ICON_MAP = {\n  confirmed: { Icon: CheckCircle2, className: 'text-emerald-500' },\n  updated: { Icon: CheckCircle2, className: 'text-emerald-500' },\n} as const;\n\nconst FEEDBACK_ICON_MAP = {\n  success: CheckCircle2,\n  warning: AlertTriangle,\n  error: XCircle,\n  info: Info,\n} as const;\n\nexport function ConfirmationStep(props: ConfirmationStepProps) {\n  const controller = useConfirmationStep(props);\n  const { status, handleClose } = controller;\n\n  const { Icon: StatusIcon, className: statusIconClass } =\n    controller.status === 'pending'\n      ? { Icon: Info, className: 'text-blue-600' }\n      : STATUS_ICON_MAP[controller.status];\n\n  const FeedbackIcon = useMemo(() => {\n    if (!controller.feedback) return null;\n    return FEEDBACK_ICON_MAP[controller.feedback.variant];\n  }, [controller.feedback]);\n\n  // Auto-redirect to thank-you after 5s when pending, with visible countdown\n  const [redirectIn, setRedirectIn] = useState<number | null>(null);\n  useEffect(() => {\n    if (status !== 'pending') {\n      setRedirectIn(null);\n      return;\n    }\n    setRedirectIn(5);\n    const interval = setInterval(() => {\n      setRedirectIn((prev) => (prev !== null && prev > 0 ? prev - 1 : 0));\n    }, 1000);\n    const timeout = setTimeout(() => {\n      handleClose();\n    }, 5000);\n    return () => {\n      clearInterval(interval);\n      clearTimeout(timeout);\n    };\n  }, [status, handleClose]);\n\n  return (\n    <WizardStep\n      step={4}\n      title={controller.heading}\n      description={controller.description}\n      icon={<StatusIcon className={`h-6 w-6 ${statusIconClass}`} aria-hidden />}\n      contentClassName=\"space-y-6\"\n    >\n      {controller.status === 'pending' ? (\n        <div className=\"space-y-2\" aria-live=\"polite\">\n          <p className=\"text-xs text-muted-foreground\">\n            It’s okay to leave this screen. We’ll send the confirmation via email.\n          </p>\n          <div className=\"h-1.5 w-full overflow-hidden rounded bg-muted/50\">\n            <div\n              className=\"h-full bg-blue-600 transition-[width] duration-1000 ease-linear\"\n              style={{ width: `${((5 - (redirectIn ?? 5)) / 5) * 100}%` }}\n            />\n          </div>\n          <p className=\"text-[11px] text-muted-foreground\">\n            Redirecting to summary in {redirectIn ?? 5}s…\n          </p>\n        </div>\n      ) : null}\n      <p className=\"sr-only\" aria-live=\"polite\">\n        {controller.status === 'pending'\n          ? 'Reservation is being confirmed. Please wait.'\n          : `Reference ${controller.reference}. Reservation for ${controller.partyText} at ${controller.summaryTime} on ${controller.summaryDate}.`}\n      </p>\n      {controller.feedback ? (\n        <Alert\n          variant={\n            controller.feedback.variant === 'error'\n              ? 'destructive'\n              : controller.feedback.variant === 'warning'\n                ? 'warning'\n                : controller.feedback.variant === 'success'\n                  ? 'success'\n                  : 'info'\n          }\n          role={controller.feedback.variant === 'error' ? 'alert' : 'status'}\n          className=\"items-start gap-3\"\n        >\n          <AlertIcon>\n            {FeedbackIcon ? <FeedbackIcon className=\"h-4 w-4\" aria-hidden /> : null}\n          </AlertIcon>\n          <div className=\"flex w-full flex-col gap-3 sm:flex-row sm:items-center sm:justify-between\">\n            <AlertDescription>{controller.feedback.message}</AlertDescription>\n            <Button\n              variant=\"ghost\"\n              size=\"sm\"\n              onClick={controller.dismissFeedback}\n              disabled={controller.isLoading}\n              className=\"self-end sm:self-auto\"\n            >\n              Dismiss\n            </Button>\n          </div>\n        </Alert>\n      ) : null}\n      <div className=\"rounded-xl border border-border bg-card p-5 shadow-sm\">\n        <dl className=\"grid gap-4 sm:grid-cols-2\">\n          <div>\n            <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">Reference</dt>\n            <dd className=\"text-sm font-semibold text-foreground\">{controller.reference}</dd>\n          </div>\n          <div>\n            <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">Guest</dt>\n            <dd className=\"text-sm font-semibold text-foreground\">{controller.guestName}</dd>\n          </div>\n          <div>\n            <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">When</dt>\n            <dd className=\"text-sm font-medium text-foreground\">\n              {controller.summaryDate} at {controller.summaryTime}\n            </dd>\n          </div>\n          <div>\n            <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">Guests</dt>\n            <dd className=\"text-sm font-medium text-foreground\">{controller.partyText}</dd>\n          </div>\n        </dl>\n      </div>\n    </WizardStep>\n  );\n}\n\nexport type { ConfirmationStepProps } from './confirmation-step/types';\n",
  "reserve/features/reservations/wizard/ui/steps/DetailsStep.tsx": "'use client';\n\nimport { AlertCircle } from 'lucide-react';\nimport React, { useEffect, useMemo, useState } from 'react';\nimport { useWatch } from 'react-hook-form';\n\nimport { cn } from '@/lib/utils';\nimport { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from '@shared/ui/accordion';\nimport { Alert, AlertDescription, AlertIcon } from '@shared/ui/alert';\nimport { Checkbox } from '@shared/ui/checkbox';\nimport {\n  Form,\n  FormControl,\n  FormDescription,\n  FormField,\n  FormItem,\n  FormLabel,\n  FormMessage,\n} from '@shared/ui/form';\nimport { Input } from '@shared/ui/input';\nimport { Label } from '@shared/ui/label';\n\nimport { useWizardDependencies } from '../../di';\nimport { useDetailsStepForm } from '../../hooks/useDetailsStepForm';\nimport { WizardStep } from '../WizardStep';\n\nimport type { DetailsStepProps } from './details-step/types';\n\nconst CONTACT_SECTION_CLASS = 'space-y-4 rounded-xl border border-border bg-card p-5 shadow-sm';\nconst basePreferenceLabelClass =\n  'hover:bg-accent/50 flex w-full items-start gap-3 rounded-lg border p-3 transition-colors has-[[aria-checked=true]]:border-primary has-[[aria-checked=true]]:bg-primary/10 dark:has-[[aria-checked=true]]:border-primary/60 dark:has-[[aria-checked=true]]:bg-primary/20';\n\nconst optionalPreferenceLabelClass = (checked: boolean) =>\n  cn(basePreferenceLabelClass, checked ? 'border-primary/60' : 'border-border bg-muted/40');\n\nconst requiredPreferenceLabelClass = (checked: boolean) =>\n  cn(\n    basePreferenceLabelClass,\n    checked\n      ? 'border-primary/60'\n      : 'border-destructive/40 bg-destructive/10 text-destructive-foreground dark:text-destructive-foreground',\n  );\n\nexport function DetailsStep({ mode = 'customer', ...props }: DetailsStepProps) {\n  const { analytics } = useWizardDependencies();\n  const controller = useDetailsStepForm({\n    ...props,\n    mode,\n    onTrack: props.onTrack ?? analytics.track,\n  });\n  const { form, handleSubmit, handleError, handlers } = controller;\n  const { errors } = form.formState;\n  const rememberDetailsValue = useWatch({ control: form.control, name: 'rememberDetails' });\n  const marketingOptInValue = useWatch({ control: form.control, name: 'marketingOptIn' });\n  const agreeValue = useWatch({ control: form.control, name: 'agree' });\n  const contactLocks = props.contactLocks ?? {};\n  const isNameLocked = Boolean(contactLocks.name);\n  const isEmailLocked = Boolean(contactLocks.email);\n  const isPhoneLocked = Boolean(contactLocks.phone);\n\n  const preferenceSummary = useMemo(() => {\n    const parts = [\n      rememberDetailsValue ? 'Details saved' : 'Details not saved',\n      marketingOptInValue ? 'Updates on' : 'Updates off',\n      agreeValue ? 'Terms accepted' : 'Terms pending',\n    ];\n    return parts.join(' • ');\n  }, [rememberDetailsValue, marketingOptInValue, agreeValue]);\n\n  const [accordionValue, setAccordionValue] = useState<string | undefined>();\n\n  useEffect(() => {\n    if (errors.agree) {\n      setAccordionValue('preferences');\n    }\n  }, [errors.agree]);\n\n  return (\n    <WizardStep\n      step={2}\n      title=\"Tell us how to reach you\"\n      description=\"We’ll send confirmation and any updates to the contact details below.\"\n      contentClassName=\"space-y-6 md:space-y-8\"\n    >\n      <Form {...form}>\n        <form\n          className=\"space-y-6 md:space-y-8\"\n          onSubmit={form.handleSubmit(handleSubmit, handleError)}\n          noValidate\n        >\n          <button type=\"submit\" className=\"hidden\" aria-hidden />\n\n          <section className={CONTACT_SECTION_CLASS}>\n            <h3 className=\"text-lg font-semibold text-foreground\">Contact details</h3>\n            <div className=\"space-y-4\">\n              <FormField\n                control={form.control}\n                name=\"name\"\n                render={({ field }) => (\n                  <FormItem>\n                    <FormLabel>Full name</FormLabel>\n                    <FormControl>\n                      <Input\n                        type=\"text\"\n                        placeholder=\"Jane Smith\"\n                        autoComplete=\"name\"\n                        value={field.value}\n                        disabled={isNameLocked}\n                        onChange={(event) => {\n                          const next = event.target.value;\n                          field.onChange(next);\n                          handlers.changeName(next);\n                        }}\n                      />\n                    </FormControl>\n                    <FormMessage>{errors.name?.message}</FormMessage>\n                  </FormItem>\n                )}\n              />\n\n              <FormField\n                control={form.control}\n                name=\"email\"\n                render={({ field }) => (\n                  <FormItem>\n                    <FormLabel>Email address{mode === 'ops' ? ' (optional)' : ''}</FormLabel>\n                    <FormControl>\n                      <Input\n                        type=\"email\"\n                        placeholder=\"you@example.com\"\n                        autoComplete=\"email\"\n                        value={field.value}\n                        disabled={isEmailLocked}\n                        onChange={(event) => {\n                          const next = event.target.value;\n                          field.onChange(next);\n                          handlers.changeEmail(next);\n                        }}\n                      />\n                    </FormControl>\n                    {isEmailLocked ? (\n                      <FormDescription className=\"text-xs text-muted-foreground\">\n                        Email is linked to your account. Update it from your profile to change it.\n                      </FormDescription>\n                    ) : null}\n                    <FormMessage>{errors.email?.message}</FormMessage>\n                  </FormItem>\n                )}\n              />\n\n              <FormField\n                control={form.control}\n                name=\"phone\"\n                render={({ field }) => (\n                  <FormItem>\n                    <FormLabel>UK phone number{mode === 'ops' ? ' (optional)' : ''}</FormLabel>\n                    <FormControl>\n                      <Input\n                        type=\"tel\"\n                        placeholder=\"07123 456789\"\n                        autoComplete=\"tel\"\n                        inputMode=\"tel\"\n                        value={field.value}\n                        disabled={isPhoneLocked}\n                        onChange={(event) => {\n                          const next = event.target.value;\n                          field.onChange(next);\n                          handlers.changePhone(next);\n                        }}\n                      />\n                    </FormControl>\n                    <FormMessage>{errors.phone?.message}</FormMessage>\n                  </FormItem>\n                )}\n              />\n            </div>\n          </section>\n\n          <section className={CONTACT_SECTION_CLASS}>\n            <Accordion\n              type=\"single\"\n              collapsible\n              value={accordionValue}\n              onValueChange={(next) => setAccordionValue(next ?? undefined)}\n              className=\"w-full\"\n            >\n              <AccordionItem value=\"preferences\">\n                <AccordionTrigger>\n                  <span className=\"flex flex-col text-left\">\n                    <span className=\"text-base font-semibold text-foreground\">Preferences</span>\n                    <span\n                      className={\n                        agreeValue ? 'text-sm text-muted-foreground' : 'text-sm text-destructive'\n                      }\n                    >\n                      {preferenceSummary}\n                    </span>\n                  </span>\n                </AccordionTrigger>\n                <AccordionContent>\n                  <div className=\"space-y-4 pt-4\">\n                    <FormField\n                      control={form.control}\n                      name=\"rememberDetails\"\n                      render={({ field }) => {\n                        const checkboxId = 'remember-details';\n                        return (\n                          <FormItem className=\"space-y-1\">\n                            <Label\n                              htmlFor={checkboxId}\n                              className={optionalPreferenceLabelClass(Boolean(field.value))}\n                            >\n                              <FormControl>\n                                <Checkbox\n                                  id={checkboxId}\n                                  checked={field.value}\n                                  onCheckedChange={(next) => {\n                                    const value = next === true;\n                                    field.onChange(value);\n                                    handlers.toggleRemember(value);\n                                  }}\n                                  className=\"h-4 w-4 rounded-[4px] border border-muted-foreground/50 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background data-[state=checked]:border-primary data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\"\n                                />\n                              </FormControl>\n                              <div className=\"space-y-1\">\n                                <span className=\"text-sm font-semibold text-foreground\">\n                                  Save contact details for next time\n                                </span>\n                                <p className=\"text-sm text-muted-foreground\">\n                                  We’ll pre-fill your info the next time you book on this device.\n                                </p>\n                              </div>\n                            </Label>\n                          </FormItem>\n                        );\n                      }}\n                    />\n\n                    <FormField\n                      control={form.control}\n                      name=\"marketingOptIn\"\n                      render={({ field }) => {\n                        const checkboxId = 'marketing-opt-in';\n                        return (\n                          <FormItem className=\"space-y-1\">\n                            <Label\n                              htmlFor={checkboxId}\n                              className={optionalPreferenceLabelClass(Boolean(field.value))}\n                            >\n                              <FormControl>\n                                <Checkbox\n                                  id={checkboxId}\n                                  checked={field.value}\n                                  onCheckedChange={(next) => {\n                                    const value = next === true;\n                                    field.onChange(value);\n                                    handlers.toggleMarketing(value);\n                                  }}\n                                  className=\"h-4 w-4 rounded-[4px] border border-muted-foreground/50 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background data-[state=checked]:border-primary data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\"\n                                />\n                              </FormControl>\n                              <div className=\"space-y-1\">\n                                <span className=\"text-sm font-semibold text-foreground\">\n                                  Send me occasional updates\n                                </span>\n                                <p className=\"text-sm text-muted-foreground\">\n                                  News on seasonal menus, experiences, and exclusive events.\n                                </p>\n                              </div>\n                            </Label>\n                          </FormItem>\n                        );\n                      }}\n                    />\n\n                    <FormField\n                      control={form.control}\n                      name=\"agree\"\n                      render={({ field }) => {\n                        const checkboxId = 'agree-terms';\n                        return (\n                          <FormItem className=\"space-y-3\">\n                            <Label\n                              htmlFor={checkboxId}\n                              className={requiredPreferenceLabelClass(Boolean(field.value))}\n                            >\n                              <FormControl>\n                                <Checkbox\n                                  id={checkboxId}\n                                  checked={field.value}\n                                  onCheckedChange={(next) => {\n                                    const value = next === true;\n                                    field.onChange(value);\n                                    handlers.toggleAgree(value);\n                                  }}\n                                  className=\"h-4 w-4 rounded-[4px] border border-muted-foreground/50 focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background data-[state=checked]:border-primary data-[state=checked]:bg-primary data-[state=checked]:text-primary-foreground\"\n                                />\n                              </FormControl>\n                              <div className=\"space-y-1 text-sm text-muted-foreground\">\n                                <span className=\"text-foreground font-semibold\">\n                                  I agree to the terms and privacy notice\n                                </span>\n                                <span>\n                                  Required to confirm your booking. View our\n                                  <a\n                                    href=\"/terms\"\n                                    className=\"ml-1 text-foreground underline underline-offset-4\"\n                                    onClick={(event) => event.stopPropagation()}\n                                  >\n                                    terms\n                                  </a>\n                                  and\n                                  <a\n                                    href=\"/privacy-policy\"\n                                    className=\"ml-1 text-foreground underline underline-offset-4\"\n                                    onClick={(event) => event.stopPropagation()}\n                                  >\n                                    privacy policy\n                                  </a>\n                                  .\n                                </span>\n                              </div>\n                            </Label>\n                            <FormMessage className=\"sr-only\">{errors.agree?.message}</FormMessage>\n                            {errors.agree ? (\n                              <Alert\n                                variant=\"destructive\"\n                                role=\"alert\"\n                                className=\"flex items-start gap-3\"\n                              >\n                                <AlertIcon>\n                                  <AlertCircle className=\"h-4 w-4\" aria-hidden />\n                                </AlertIcon>\n                                <AlertDescription>{errors.agree.message}</AlertDescription>\n                              </Alert>\n                            ) : null}\n                          </FormItem>\n                        );\n                      }}\n                    />\n                  </div>\n                </AccordionContent>\n              </AccordionItem>\n            </Accordion>\n          </section>\n        </form>\n      </Form>\n    </WizardStep>\n  );\n}\n\nexport type { DetailsStepProps } from './details-step/types';\n",
  "reserve/features/reservations/wizard/ui/steps/PlanStep.tsx": "'use client';\n\nimport { AlertTriangle } from 'lucide-react';\nimport React, { useMemo } from 'react';\n\nimport { Alert, AlertDescription, AlertIcon } from '@shared/ui/alert';\n\nimport { WizardStep } from '../WizardStep';\nimport { PlanStepForm } from './plan-step/PlanStepForm';\n\nimport type { State, StepAction } from '../../model/reducer';\nimport type { WizardActions } from '../../model/store';\nimport type { AnalyticsEvent } from '@shared/lib/analytics';\n\nfunction getMinSelectableDate(timezone: string | null | undefined) {\n  const now = new Date();\n\n  if (!timezone) {\n    now.setHours(0, 0, 0, 0);\n    return now;\n  }\n\n  try {\n    const formatter = new Intl.DateTimeFormat('en-CA', {\n      timeZone: timezone,\n      year: 'numeric',\n      month: '2-digit',\n      day: '2-digit',\n    });\n    const parts = formatter.formatToParts(now);\n    const year = Number.parseInt(parts.find((part) => part.type === 'year')?.value ?? '', 10);\n    const month = Number.parseInt(parts.find((part) => part.type === 'month')?.value ?? '', 10);\n    const day = Number.parseInt(parts.find((part) => part.type === 'day')?.value ?? '', 10);\n\n    if (Number.isFinite(year) && Number.isFinite(month) && Number.isFinite(day)) {\n      return new Date(year, month - 1, day, 0, 0, 0, 0);\n    }\n  } catch (error) {\n    if (process.env.NODE_ENV !== 'production') {\n      console.warn('[plan-step] failed to derive timezone-adjusted min date', {\n        timezone,\n        error,\n      });\n    }\n  }\n\n  now.setHours(0, 0, 0, 0);\n  return now;\n}\n\nconst TITLE = 'Plan your visit';\nconst DESCRIPTION =\n  'Choose a date, time, party size, and any preferences. We’ll show the best options available.';\n\nexport interface PlanStepProps {\n  state: State;\n  actions: Pick<WizardActions, 'updateDetails' | 'goToStep'>;\n  onActionsChange: (actions: StepAction[]) => void;\n  onTrack?: (event: AnalyticsEvent, payload?: Record<string, unknown>) => void;\n  planAlert?: string | null;\n}\n\nexport function PlanStep({ state, actions, onActionsChange, onTrack, planAlert }: PlanStepProps) {\n  const minSelectableDate = useMemo(() => {\n    return getMinSelectableDate(state.details.restaurantTimezone);\n  }, [state.details.restaurantTimezone]);\n\n  const alertMessage = planAlert ?? state.error;\n\n  return (\n    <WizardStep step={1} title={TITLE} description={DESCRIPTION}>\n      {alertMessage ? (\n        <Alert variant=\"destructive\" role=\"alert\" className=\"items-start\">\n          <AlertIcon>\n            <AlertTriangle className=\"h-4 w-4\" aria-hidden />\n          </AlertIcon>\n          <AlertDescription>{alertMessage}</AlertDescription>\n        </Alert>\n      ) : null}\n      <PlanStepForm\n        state={state}\n        actions={actions}\n        onActionsChange={onActionsChange}\n        onTrack={onTrack}\n        minDate={minSelectableDate}\n      />\n    </WizardStep>\n  );\n}\n",
  "reserve/features/reservations/wizard/ui/steps/ReviewStep.tsx": "'use client';\n\nimport { AlertTriangle } from 'lucide-react';\nimport React from 'react';\n\nimport { useReviewStep } from '@features/reservations/wizard/hooks/useReviewStep';\nimport { formatBookingLabel } from '@reserve/shared/formatting/booking';\nimport { Alert, AlertDescription, AlertIcon } from '@shared/ui/alert';\n\nimport { WizardStep } from '../WizardStep';\n\nimport type { ReviewStepProps } from './review-step/types';\n\nexport function ReviewStep(props: ReviewStepProps) {\n  const { details, summary, error } = useReviewStep(props);\n\n  return (\n    <WizardStep\n      step={3}\n      title=\"Review and confirm\"\n      description=\"Double-check the details below. You can edit any section before confirming.\"\n      contentClassName=\"space-y-4\"\n    >\n      <div className=\"space-y-4\">\n        <p className=\"sr-only\" aria-live=\"polite\">\n          {`Review details for ${summary.summaryValue}. Press confirm to finalise your reservation.`}\n        </p>\n        {error ? (\n          <Alert variant=\"destructive\" role=\"alert\" className=\"items-start\">\n            <AlertIcon>\n              <AlertTriangle className=\"h-4 w-4\" aria-hidden />\n            </AlertIcon>\n            <AlertDescription>{error}</AlertDescription>\n          </Alert>\n        ) : null}\n        <dl className=\"grid gap-4 rounded-2xl border border-border bg-card p-5 shadow-sm sm:grid-cols-2 lg:grid-cols-3\">\n          <div className=\"space-y-1\">\n            <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">Summary</dt>\n            <dd className=\"text-sm font-semibold text-foreground\">{summary.summaryValue}</dd>\n          </div>\n          <div className=\"space-y-1\">\n            <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">Venue</dt>\n            <dd className=\"text-sm font-medium text-foreground\">{details.restaurantName}</dd>\n          </div>\n          <div className=\"space-y-1\">\n            <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">\n              Party size\n            </dt>\n            <dd className=\"text-sm font-medium text-foreground\">\n              {details.party} {details.party === 1 ? 'guest' : 'guests'}\n            </dd>\n          </div>\n          <div className=\"space-y-1\">\n            <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">Full name</dt>\n            <dd className=\"text-sm font-medium text-foreground\">{details.name}</dd>\n          </div>\n          <div className=\"space-y-1\">\n            <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">Email</dt>\n            <dd className=\"text-sm font-medium text-foreground\">{details.email}</dd>\n          </div>\n          <div className=\"space-y-1\">\n            <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">Phone</dt>\n            <dd className=\"text-sm font-medium text-foreground\">{details.phone}</dd>\n          </div>\n          <div className=\"space-y-1\">\n            <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">\n              Booking type\n            </dt>\n            <dd className=\"text-sm font-medium text-foreground\">\n              {formatBookingLabel(details.bookingType)}\n            </dd>\n          </div>\n          <div className=\"space-y-1\">\n            <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">\n              Marketing updates\n            </dt>\n            <dd className=\"text-sm font-medium text-foreground\">\n              {details.marketingOptIn ? 'Subscribed' : 'Not subscribed'}\n            </dd>\n          </div>\n          {details.notes ? (\n            <div className=\"space-y-1 sm:col-span-2\">\n              <dt className=\"text-xs uppercase tracking-[0.18em] text-muted-foreground\">Notes</dt>\n              <dd className=\"text-sm text-muted-foreground\">{details.notes}</dd>\n            </div>\n          ) : null}\n        </dl>\n      </div>\n    </WizardStep>\n  );\n}\n\nexport type { ReviewStepProps } from './review-step/types';\n",
  "reserve/features/reservations/wizard/ui/steps/confirmation-step/types.ts": "import type { State, StepAction } from '../../../model/reducer';\n\nexport interface ConfirmationStepProps {\n  state: State;\n  onNewBooking: () => void;\n  onClose: () => void;\n  onActionsChange: (actions: StepAction[]) => void;\n}\n\nexport type ConfirmationStatus = 'pending' | 'confirmed' | 'updated';\n\nexport type ConfirmationFeedback = {\n  variant: 'info' | 'success' | 'warning' | 'error';\n  message: string;\n};\n\nexport type ConfirmationStepController = {\n  booking: State['lastConfirmed'];\n  details: State['details'];\n  venue: {\n    id: string;\n    name: string;\n    address: string;\n    timezone: string;\n  };\n  status: ConfirmationStatus;\n  isLoading: boolean;\n  heading: string;\n  description: string;\n  reference: string;\n  guestName: string;\n  summaryDate: string;\n  summaryTime: string;\n  partyText: string;\n  reservationWindow: { start: Date; end: Date } | null;\n  calendarLoading: boolean;\n  walletLoading: boolean;\n  feedback: ConfirmationFeedback | null;\n  dismissFeedback: () => void;\n  handleAddToCalendar: () => void;\n  handleAddToWallet: () => Promise<void> | void;\n  handleClose: () => void;\n  handleNewBooking: () => void;\n};\n",
  "reserve/features/reservations/wizard/ui/steps/details-step/types.ts": "import type { BookingWizardMode, State, StepAction } from '../../../model/reducer';\nimport type { DetailsFormInputValues, DetailsFormValues } from '../../../model/schemas';\nimport type { WizardActions } from '../../../model/store';\nimport type { AnalyticsEvent } from '@shared/lib/analytics';\nimport type { UseFormReturn } from 'react-hook-form';\n\nexport type DetailsContactLocks = Partial<Record<'name' | 'email' | 'phone', boolean>>;\n\nexport interface DetailsStepProps {\n  state: State;\n  actions: Pick<WizardActions, 'updateDetails' | 'goToStep'>;\n  onActionsChange: (actions: StepAction[]) => void;\n  onTrack?: (event: AnalyticsEvent, payload?: Record<string, unknown>) => void;\n  contactLocks?: DetailsContactLocks;\n  mode?: BookingWizardMode;\n}\n\nexport type DetailsStepController = {\n  form: UseFormReturn<DetailsFormInputValues, unknown, DetailsFormValues>;\n  handleBack: () => void;\n  handleSubmit: (values: DetailsFormValues) => void;\n  handleError: (errors: Record<string, unknown>) => void;\n  isSubmitting: boolean;\n  isValid: boolean;\n  handlers: {\n    changeName: (value: string) => void;\n    changeEmail: (value: string) => void;\n    changePhone: (value: string) => void;\n    toggleRemember: (value: boolean) => void;\n    toggleMarketing: (value: boolean) => void;\n    toggleAgree: (value: boolean) => void;\n  };\n};\n",
  "reserve/features/reservations/wizard/ui/steps/plan-step/PlanStepForm.tsx": "'use client';\n\nimport { AlertCircle } from 'lucide-react';\nimport React, { useCallback, useMemo } from 'react';\nimport { useController, useWatch } from 'react-hook-form';\n\nimport { formatDateForInput } from '@reserve/shared/formatting/booking';\nimport { Accordion, AccordionContent, AccordionItem, AccordionTrigger } from '@shared/ui/accordion';\nimport { Alert, AlertDescription, AlertIcon } from '@shared/ui/alert';\nimport { Form, FormField } from '@shared/ui/form';\n\nimport {\n  Calendar24Field,\n  NotesField,\n  OccasionPicker,\n  PartySizeField,\n  TimeSlotGrid,\n} from './components';\nimport { usePlanStepForm } from '../../../hooks/usePlanStepForm';\n\nimport type { PlanStepFormProps, PlanStepFormState } from './types';\n\ntype PlanStepFormContentProps = {\n  state: PlanStepFormState;\n};\n\nconst UNKNOWN_AVAILABILITY_COPY = 'Schedule not loaded yet—scroll to load month.';\n\nfunction PlanStepFormContent({ state }: PlanStepFormContentProps) {\n  const { control, formState, handleSubmit, getValues } = state.form;\n  const {\n    field: dateField,\n    fieldState: { error: dateFieldError },\n  } = useController({ name: 'date', control });\n  const {\n    field: timeField,\n    fieldState: { error: timeFieldError },\n  } = useController({ name: 'time', control });\n  const bookingTypeValue = useWatch({ name: 'bookingType', control });\n  const notesValue = useWatch({ name: 'notes', control });\n\n  const occasionOptions = React.useMemo(\n    () =>\n      state.occasionCatalog.map((definition) => ({\n        key: definition.key,\n        label: definition.shortLabel ?? definition.label,\n        description: definition.description ?? null,\n      })),\n    [state.occasionCatalog],\n  );\n\n  const selectedOccasionLabel = React.useMemo(() => {\n    const match = occasionOptions.find((option) => option.key === bookingTypeValue);\n    if (match) {\n      return match.label;\n    }\n    if (bookingTypeValue) {\n      return bookingTypeValue.replace(/\\b\\w/g, (char) => char.toUpperCase());\n    }\n    return undefined;\n  }, [bookingTypeValue, occasionOptions]);\n\n  const isDateUnavailable = useCallback(\n    (day: Date) => {\n      const key = formatDateForInput(day);\n      return state.unavailableDates.has(key);\n    },\n    [state.unavailableDates],\n  );\n\n  const timeDisabled = state.currentUnavailabilityReason !== null;\n\n  const unavailableCopy = useMemo(() => {\n    switch (state.currentUnavailabilityReason) {\n      case 'closed':\n        return 'We’re closed on this date. Please choose a different day.';\n      case 'no-slots':\n        return 'All reservation times are taken on this date. Please choose a different day.';\n      case 'unknown':\n        return UNKNOWN_AVAILABILITY_COPY;\n      default:\n        return null;\n    }\n  }, [state.currentUnavailabilityReason]);\n\n  const accordionSummary = useMemo(() => {\n    const selectedSlot = state.slots.find((slot) => slot.value === timeField.value);\n    const timeSummary = timeField.value\n      ? `Time: ${selectedSlot?.display ?? timeField.value}`\n      : 'Time not selected';\n\n    const label = selectedOccasionLabel;\n    const hasNotes = Boolean(notesValue?.trim()?.length);\n\n    const parts = [timeSummary];\n\n    if (label) {\n      parts.push(`Occasion: ${label}`);\n    }\n\n    if (hasNotes) {\n      parts.push('Notes added');\n    }\n\n    if (!label && !hasNotes) {\n      parts.push('Occasion or notes optional');\n    }\n\n    return parts.join(' • ');\n  }, [notesValue, selectedOccasionLabel, state.slots, timeField.value]);\n\n  return (\n    <form\n      className=\"space-y-8\"\n      onSubmit={handleSubmit(state.submitForm, state.handleError)}\n      noValidate\n    >\n      <button type=\"submit\" className=\"hidden\" aria-hidden />\n      <div className=\"grid gap-6 md:grid-cols-2\">\n        <Calendar24Field\n          date={{\n            value: dateField.value,\n            minDate: state.minDate,\n            onSelect: (next) => {\n              state.handlers.selectDate(next);\n            },\n            onBlur: dateField.onBlur,\n            error: dateFieldError?.message ?? formState.errors.date?.message,\n          }}\n          time={{\n            value: timeField.value,\n            onChange: (next, options) => {\n              state.handlers.selectTime(next, options);\n            },\n            onBlur: () => {\n              timeField.onBlur?.();\n              state.handlers.selectTime(getValues('time'), { commit: true });\n            },\n            error: timeFieldError?.message ?? formState.errors.time?.message,\n          }}\n          suggestions={state.slots}\n          intervalMinutes={state.intervalMinutes ?? undefined}\n          isDateUnavailable={isDateUnavailable}\n          isTimeDisabled={timeDisabled}\n          unavailableMessage={unavailableCopy ?? undefined}\n          onMonthChange={state.handlers.prefetchMonth}\n        />\n\n        <FormField\n          control={control}\n          name=\"party\"\n          render={({ field }) => (\n            <PartySizeField\n              value={field.value}\n              onChange={state.handlers.changeParty}\n              error={formState.errors.party?.message}\n            />\n          )}\n        />\n      </div>\n\n      {unavailableCopy ? (\n        <Alert variant=\"warning\" className=\"border border-dashed\">\n          <AlertIcon>\n            <AlertCircle className=\"h-4 w-4\" aria-hidden />\n          </AlertIcon>\n          <AlertDescription>{unavailableCopy}</AlertDescription>\n        </Alert>\n      ) : null}\n\n      <Accordion\n        type=\"single\"\n        collapsible\n        className=\"overflow-hidden rounded-xl border border-border bg-card text-card-foreground\"\n      >\n        <AccordionItem value=\"details\">\n          <AccordionTrigger>\n            <span className=\"flex flex-col text-left\">\n              <span className=\"text-base font-semibold text-foreground\">\n                Time, occasion & notes\n              </span>\n              <span className=\"text-sm font-normal text-muted-foreground\">{accordionSummary}</span>\n            </span>\n          </AccordionTrigger>\n          <AccordionContent>\n            <div className=\"space-y-6 pt-4\">\n              <TimeSlotGrid\n                slots={timeDisabled ? [] : state.slots}\n                value={timeField.value}\n                onSelect={(next) => {\n                  state.handlers.selectTime(next);\n                  timeField.onBlur?.();\n                }}\n              />\n              <FormField\n                control={control}\n                name=\"bookingType\"\n                render={({ field }) => (\n                  <OccasionPicker\n                    value={field.value}\n                    options={occasionOptions}\n                    onChange={state.handlers.changeOccasion}\n                    availability={state.availability}\n                    availableOptions={state.availableBookingOptions}\n                    error={formState.errors.bookingType?.message}\n                  />\n                )}\n              />\n\n              <FormField\n                control={control}\n                name=\"notes\"\n                render={({ field }) => (\n                  <NotesField\n                    value={field.value ?? ''}\n                    onChange={(next) => {\n                      field.onChange(next);\n                    }}\n                    onBlur={(next) => {\n                      field.onBlur();\n                      state.handlers.commitNotes(next);\n                    }}\n                    error={formState.errors.notes?.message}\n                  />\n                )}\n              />\n            </div>\n          </AccordionContent>\n        </AccordionItem>\n      </Accordion>\n    </form>\n  );\n}\n\nexport function PlanStepForm(props: PlanStepFormProps) {\n  const state = usePlanStepForm(props);\n\n  return (\n    <Form {...state.form}>\n      <PlanStepFormContent state={state} />\n    </Form>\n  );\n}\n\nexport type { PlanStepFormProps } from './types';\n",
  "reserve/features/reservations/wizard/ui/steps/plan-step/components/Calendar24Field.tsx": "'use client';\n\nimport { endOfDay } from 'date-fns';\nimport { ChevronDownIcon } from 'lucide-react';\nimport React, { useCallback, useEffect, useId, useMemo, useState } from 'react';\n\nimport { formatReservationDate } from '@reserve/shared/formatting/booking';\nimport { cn } from '@shared/lib/cn';\nimport { Button } from '@shared/ui/button';\nimport { Calendar } from '@shared/ui/calendar';\nimport { Input } from '@shared/ui/input';\nimport { Label } from '@shared/ui/label';\nimport { Popover, PopoverContent, PopoverTrigger } from '@shared/ui/popover';\n\nimport type { TimeSlotDescriptor } from '@reserve/features/reservations/wizard/services';\n\nconst DATE_DESCRIPTION = 'Pick a date to see available times.';\nconst TIME_DESCRIPTION = 'Choose the time that works best for your party.';\n\nexport type Calendar24FieldProps = {\n  date: {\n    value: string;\n    minDate: Date;\n    onSelect: (value: Date | undefined | null) => void;\n    onBlur?: () => void;\n    error?: string;\n  };\n  time: {\n    value: string;\n    onChange: (value: string, options?: { commit?: boolean }) => void;\n    onBlur?: () => void;\n    error?: string;\n  };\n  suggestions?: TimeSlotDescriptor[];\n  intervalMinutes?: number;\n  isDateUnavailable?: (date: Date) => boolean;\n  isTimeDisabled?: boolean;\n  unavailableMessage?: string;\n  onMonthChange?: (month: Date) => void;\n};\n\nexport function Calendar24Field({\n  date,\n  time,\n  suggestions = [],\n  intervalMinutes,\n  isDateUnavailable,\n  isTimeDisabled = false,\n  unavailableMessage,\n  onMonthChange,\n}: Calendar24FieldProps) {\n  const resolvedIntervalMinutes =\n    typeof intervalMinutes === 'number' && intervalMinutes > 0 ? intervalMinutes : undefined;\n  const timeStepSeconds = resolvedIntervalMinutes\n    ? Math.max(60, Math.round(resolvedIntervalMinutes * 60))\n    : 60;\n  const [open, setOpen] = useState(false);\n  const baseId = useId();\n  const dateButtonId = `${baseId}-date`;\n  const timeInputId = `${baseId}-time`;\n  const timeListId = `${baseId}-time-options`;\n  const dateDescriptionId = `${baseId}-date-description`;\n  const timeDescriptionId = `${baseId}-time-description`;\n  const dateErrorId = date.error ? `${baseId}-date-error` : undefined;\n  const timeErrorId = time.error ? `${baseId}-time-error` : undefined;\n\n  const label = useMemo(\n    () => (date.value ? formatReservationDate(date.value) : 'Select date'),\n    [date.value],\n  );\n  const selectedDate = useMemo(() => (date.value ? new Date(date.value) : undefined), [date.value]);\n  const initialMonth = useMemo(() => {\n    const base = selectedDate ?? date.minDate;\n    return new Date(base.getFullYear(), base.getMonth(), 1);\n  }, [date.minDate, selectedDate]);\n  const initialMonthTime = initialMonth.getTime();\n\n  useEffect(() => {\n    if (!onMonthChange) {\n      return;\n    }\n    onMonthChange(new Date(initialMonthTime));\n  }, [initialMonthTime, onMonthChange]);\n\n  const enabledSuggestions = useMemo(\n    () => suggestions.filter((slot) => !slot.disabled),\n    [suggestions],\n  );\n  const showSuggestions = !isTimeDisabled && enabledSuggestions.length > 0;\n  const inputValue = time.value ?? '';\n  const resolvedUnavailableMessage =\n    unavailableMessage ?? 'No available times for the selected date.';\n\n  const disabledMatcher = useCallback(\n    (day?: Date) => {\n      if (!day) {\n        return false;\n      }\n      if (endOfDay(day) < date.minDate) {\n        return true;\n      }\n      if (typeof isDateUnavailable === 'function') {\n        return isDateUnavailable(day);\n      }\n      return false;\n    },\n    [date.minDate, isDateUnavailable],\n  );\n\n  return (\n    <div className=\"flex flex-col gap-4 md:flex-row\">\n      <div className=\"flex flex-1 flex-col gap-3\">\n        <Label htmlFor={dateButtonId} className=\"px-1\">\n          Date\n        </Label>\n        <Popover open={open} onOpenChange={setOpen}>\n          <PopoverTrigger asChild>\n            <Button\n              id={dateButtonId}\n              variant=\"outline\"\n              className=\"w-full justify-between font-normal\"\n              aria-haspopup=\"dialog\"\n              aria-expanded={open}\n              aria-invalid={Boolean(date.error)}\n              aria-describedby={\n                [dateDescriptionId, dateErrorId].filter(Boolean).join(' ') || undefined\n              }\n            >\n              <span>{label}</span>\n              <ChevronDownIcon className=\"h-4 w-4\" aria-hidden />\n            </Button>\n          </PopoverTrigger>\n          <PopoverContent className=\"w-auto overflow-hidden p-0\" align=\"start\">\n            <Calendar\n              mode=\"single\"\n              selected={selectedDate}\n              defaultMonth={initialMonth}\n              fromDate={date.minDate}\n              onSelect={(next) => {\n                date.onSelect(next);\n                date.onBlur?.();\n                setOpen(false);\n              }}\n              onMonthChange={(month) => {\n                onMonthChange?.(month);\n              }}\n              disabled={disabledMatcher}\n              initialFocus\n            />\n          </PopoverContent>\n        </Popover>\n        <p id={dateDescriptionId} className=\"px-1 text-[0.8rem] text-muted-foreground\">\n          {DATE_DESCRIPTION}\n        </p>\n        {date.error ? (\n          <p id={dateErrorId} className=\"px-1 text-[0.8rem] font-medium text-destructive\">\n            {date.error}\n          </p>\n        ) : null}\n      </div>\n\n      <div className=\"flex flex-1 flex-col gap-3\">\n        <Label htmlFor={timeInputId} className=\"px-1\">\n          Time\n        </Label>\n        <div className=\"flex flex-col gap-2\">\n          <div className=\"relative\">\n            <Input\n              id={timeInputId}\n              type=\"time\"\n              value={inputValue}\n              step={timeStepSeconds}\n              onChange={(event) => {\n                if (isTimeDisabled) {\n                  return;\n                }\n                const value = event.target.value;\n                time.onChange(value, { commit: false });\n              }}\n              onBlur={(event) => {\n                if (isTimeDisabled) {\n                  time.onBlur?.();\n                  return;\n                }\n                time.onBlur?.();\n                time.onChange(event.target.value, { commit: true });\n              }}\n              aria-invalid={Boolean(time.error)}\n              aria-describedby={\n                [timeDescriptionId, timeErrorId].filter(Boolean).join(' ') || undefined\n              }\n              list={showSuggestions ? timeListId : undefined}\n              placeholder=\"--:--\"\n              className={cn(\n                'bg-background text-base font-normal appearance-none [&::-webkit-calendar-picker-indicator]:hidden [&::-webkit-calendar-picker-indicator]:appearance-none',\n                !inputValue ? 'text-foreground' : undefined,\n              )}\n              disabled={isTimeDisabled}\n            />\n            {!inputValue ? (\n              <span\n                aria-hidden=\"true\"\n                className={cn(\n                  'pointer-events-none absolute left-3 top-1/2 -translate-y-1/2 text-base text-muted-foreground transition-opacity',\n                  isTimeDisabled ? 'opacity-70' : 'opacity-100',\n                )}\n              >\n                --:--\n              </span>\n            ) : null}\n          </div>\n          {showSuggestions ? (\n            <datalist id={timeListId}>\n              {enabledSuggestions.map((slot) => (\n                <option\n                  key={slot.value}\n                  value={slot.value}\n                  label={`${slot.display} • ${slot.label}`}\n                />\n              ))}\n            </datalist>\n          ) : (\n            <p className=\"px-1 text-[0.8rem] text-muted-foreground\" aria-live=\"polite\">\n              {resolvedUnavailableMessage}\n            </p>\n          )}\n        </div>\n        <p id={timeDescriptionId} className=\"px-1 text-[0.8rem] text-muted-foreground\">\n          {TIME_DESCRIPTION}\n        </p>\n        {time.error ? (\n          <p id={timeErrorId} className=\"px-1 text-[0.8rem] font-medium text-destructive\">\n            {time.error}\n          </p>\n        ) : null}\n      </div>\n    </div>\n  );\n}\n",
  "reserve/features/reservations/wizard/ui/steps/plan-step/components/NotesField.tsx": "'use client';\n\nimport React, { useMemo } from 'react';\n\nimport { FormControl, FormDescription, FormItem, FormLabel, FormMessage } from '@shared/ui/form';\nimport { Textarea } from '@shared/ui/textarea';\n\nconst DESCRIPTION = 'Optional. Share anything we should know before you arrive.';\nconst MAX_LENGTH = 500;\n\nexport type NotesFieldProps = {\n  value: string;\n  onChange: (value: string) => void;\n  onBlur?: (value: string) => void;\n  error?: string;\n};\n\nexport function NotesField({ value, onChange, onBlur, error }: NotesFieldProps) {\n  const lengthLabel = useMemo(() => `${value.length} / ${MAX_LENGTH}`, [value.length]);\n\n  return (\n    <FormItem className=\"space-y-3\">\n      <FormLabel htmlFor=\"notes\">Notes</FormLabel>\n      <FormControl>\n        <Textarea\n          id=\"notes\"\n          placeholder=\"Birthday, accessibility needs, allergies…\"\n          value={value}\n          onChange={(event) => onChange(event.target.value)}\n          onBlur={(event) => {\n            onBlur?.(event.target.value);\n          }}\n          rows={4}\n          spellCheck\n        />\n      </FormControl>\n      <FormDescription>{DESCRIPTION}</FormDescription>\n      <div className=\"text-right text-xs text-srx-ink-soft\" aria-live=\"polite\">\n        {lengthLabel}\n      </div>\n      <FormMessage>{error}</FormMessage>\n    </FormItem>\n  );\n}\n",
  "reserve/features/reservations/wizard/ui/steps/plan-step/components/OccasionPicker.tsx": "'use client';\n\nimport React from 'react';\n\nimport { FormDescription, FormItem, FormLabel, FormMessage } from '@shared/ui/form';\nimport { ToggleGroup, ToggleGroupItem } from '@shared/ui/toggle-group';\n\nimport type { ServiceAvailability } from '@reserve/features/reservations/wizard/services';\nimport type { OccasionKey } from '@reserve/shared/occasions';\n\nconst DESCRIPTION = 'Let us know the occasion so we can tailor the experience.';\n\nexport type OccasionPickerOption = {\n  key: OccasionKey;\n  label: string;\n  description?: string | null;\n};\n\nexport type OccasionPickerProps = {\n  value: OccasionKey;\n  options: OccasionPickerOption[];\n  availability: ServiceAvailability;\n  availableOptions: OccasionKey[];\n  onChange: (value: OccasionKey) => void;\n  error?: string;\n};\n\nexport function OccasionPicker({\n  value,\n  options,\n  availability: _availability,\n  availableOptions,\n  onChange,\n  error,\n}: OccasionPickerProps) {\n  const allowed = React.useMemo(() => new Set(availableOptions), [availableOptions]);\n  const services = React.useMemo(\n    () => new Map(Object.entries(_availability.services)),\n    [_availability.services],\n  );\n\n  return (\n    <FormItem className=\"space-y-3\">\n      <FormLabel>Occasion</FormLabel>\n      <ToggleGroup\n        type=\"single\"\n        className=\"grid grid-cols-2 gap-2 sm:grid-cols-3\"\n        value={value}\n        onValueChange={(next) => {\n          if (next) onChange(next as OccasionKey);\n        }}\n      >\n        {options.map((option) => {\n          const serviceState = services.get(option.key) ?? 'disabled';\n          const enabled = allowed.has(option.key) && serviceState === 'enabled';\n          const ariaDisabled = !enabled;\n          return (\n            <ToggleGroupItem\n              key={option.key}\n              value={option.key}\n              aria-disabled={ariaDisabled}\n              disabled={ariaDisabled}\n              className=\"h-11\"\n            >\n              {option.label}\n            </ToggleGroupItem>\n          );\n        })}\n      </ToggleGroup>\n      <FormDescription>{DESCRIPTION}</FormDescription>\n      <FormMessage>{error}</FormMessage>\n    </FormItem>\n  );\n}\n",
  "reserve/features/reservations/wizard/ui/steps/plan-step/components/PartySizeField.tsx": "'use client';\n\nimport React from 'react';\n\nimport { Button } from '@shared/ui/button';\nimport { FormDescription, FormItem, FormLabel, FormMessage } from '@shared/ui/form';\n\nconst DESCRIPTION = 'Tables of more than 12? Call us and we’ll help.';\n\nexport type PartySizeFieldProps = {\n  value: number;\n  onChange: (direction: 'decrement' | 'increment') => void;\n  error?: string;\n};\n\nexport function PartySizeField({ value, onChange, error }: PartySizeFieldProps) {\n  return (\n    <FormItem className=\"space-y-3\">\n      <FormLabel>Party size</FormLabel>\n      <div className=\"flex items-center gap-3\">\n        <Button\n          type=\"button\"\n          variant=\"outline\"\n          size=\"icon\"\n          onClick={() => onChange('decrement')}\n          aria-label=\"Decrease guests\"\n        >\n          -\n        </Button>\n        <div className=\"text-lg font-semibold\" aria-live=\"polite\">\n          {value}\n        </div>\n        <Button\n          type=\"button\"\n          variant=\"outline\"\n          size=\"icon\"\n          onClick={() => onChange('increment')}\n          aria-label=\"Increase guests\"\n        >\n          +\n        </Button>\n      </div>\n      <FormDescription>{DESCRIPTION}</FormDescription>\n      <FormMessage>{error}</FormMessage>\n    </FormItem>\n  );\n}\n",
  "reserve/features/reservations/wizard/ui/steps/plan-step/components/TimeSlotGrid.tsx": "'use client';\n\nimport React, { useEffect, useMemo, useRef } from 'react';\n\nimport { cn } from '@shared/lib/cn';\nimport { Badge } from '@shared/ui/badge';\n\nimport type { TimeSlotDescriptor } from '@reserve/features/reservations/wizard/services';\n\ntype TimeSlotGridProps = {\n  slots: TimeSlotDescriptor[];\n  value: string;\n  onSelect: (value: string) => void;\n  scrollToValue?: string | null;\n};\n\nfunction buildGroups(slots: TimeSlotDescriptor[]) {\n  const groups = new Map<string, TimeSlotDescriptor[]>();\n  slots.forEach((slot) => {\n    const existing = groups.get(slot.label);\n    if (existing) {\n      existing.push(slot);\n    } else {\n      groups.set(slot.label, [slot]);\n    }\n  });\n  return groups;\n}\n\nexport function TimeSlotGrid({ slots, value, onSelect, scrollToValue }: TimeSlotGridProps) {\n  const groupedSlots = useMemo(() => buildGroups(slots), [slots]);\n  const activeValue = value;\n  const containerRef = useRef<HTMLDivElement>(null);\n  const lastScrolledValueRef = useRef<string | null>(null);\n\n  useEffect(() => {\n    if (!scrollToValue) {\n      return;\n    }\n    if (lastScrolledValueRef.current === scrollToValue) {\n      return;\n    }\n    const container = containerRef.current;\n    if (!container) {\n      return;\n    }\n    const target = container.querySelector<HTMLElement>(`[data-slot-value=\"${scrollToValue}\"]`);\n    if (!target) {\n      return;\n    }\n    lastScrolledValueRef.current = scrollToValue;\n    target.scrollIntoView({ block: 'center', inline: 'center', behavior: 'smooth' });\n  }, [scrollToValue, slots]);\n\n  if (slots.length === 0) {\n    return null;\n  }\n\n  return (\n    <section\n      aria-label=\"Available times\"\n      className=\"flex flex-col gap-3 rounded-xl border border-border bg-card/80 p-4 shadow-sm\"\n      ref={containerRef}\n    >\n      <div className=\"flex items-center justify-between\">\n        <h3 className=\"text-sm font-semibold text-foreground\">Pick a time</h3>\n        <p className=\"text-xs text-muted-foreground\" aria-live=\"polite\">\n          Showing {slots.length} {slots.length === 1 ? 'option' : 'options'}\n        </p>\n      </div>\n      {[...groupedSlots.entries()].map(([label, entries]) => (\n        <div key={label} className=\"space-y-2\">\n          <div className=\"flex items-center gap-2\">\n            <h4 className=\"text-xs font-semibold uppercase tracking-[0.22em] text-muted-foreground\">\n              {label}\n            </h4>\n            {entries[0]?.availability.labels.happyHour ? (\n              <Badge variant=\"secondary\" className=\"text-[11px] font-medium\">\n                Happy hour\n              </Badge>\n            ) : null}\n            {entries[0]?.availability.labels.drinksOnly ? (\n              <Badge variant=\"outline\" className=\"text-[11px] font-medium\">\n                Drinks only\n              </Badge>\n            ) : null}\n          </div>\n          <div className=\"grid grid-cols-2 gap-2 sm:grid-cols-3 lg:grid-cols-4\">\n            {entries.map((slot) => {\n              const isActive = slot.value === activeValue;\n              return (\n                <button\n                  key={slot.value}\n                  type=\"button\"\n                  className={cn(\n                    'flex h-12 items-center justify-center rounded-lg border text-sm font-semibold transition-colors focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 focus-visible:ring-offset-background',\n                    'touch-manipulation',\n                    slot.disabled\n                      ? 'cursor-not-allowed border-border/60 bg-muted text-muted-foreground'\n                      : isActive\n                        ? 'border-primary bg-primary text-primary-foreground hover:bg-primary/90'\n                        : 'border-border bg-card hover:border-primary/60 hover:bg-primary/10',\n                  )}\n                  aria-pressed={isActive}\n                  aria-label={`${slot.display}, ${label}`}\n                  disabled={slot.disabled}\n                  onClick={() => onSelect(slot.value)}\n                  data-slot-value={slot.value}\n                  style={{ WebkitTapHighlightColor: 'rgba(0,0,0,0)', touchAction: 'manipulation' }}\n                >\n                  {slot.display}\n                </button>\n              );\n            })}\n          </div>\n        </div>\n      ))}\n    </section>\n  );\n}\n",
  "reserve/features/reservations/wizard/ui/steps/plan-step/components/index.ts": "export * from './Calendar24Field';\nexport * from './PartySizeField';\nexport * from './NotesField';\nexport * from './OccasionPicker';\nexport * from './TimeSlotGrid';\n",
  "reserve/features/reservations/wizard/ui/steps/plan-step/types.ts": "import type { State, StepAction } from '../../../model/reducer';\nimport type { PlanFormValues } from '../../../model/schemas';\nimport type { WizardActions } from '../../../model/store';\nimport type {\n  ReservationSchedule,\n  ServiceAvailability,\n  TimeSlotDescriptor,\n} from '@reserve/features/reservations/wizard/services';\nimport type { BookingOption } from '@reserve/shared/booking';\nimport type { OccasionDefinition } from '@reserve/shared/occasions';\nimport type { AnalyticsEvent } from '@shared/lib/analytics';\nimport type { UseFormReturn } from 'react-hook-form';\n\nexport interface PlanStepFormProps {\n  state: State;\n  actions: Pick<WizardActions, 'updateDetails' | 'goToStep'>;\n  onActionsChange: (actions: StepAction[]) => void;\n  onTrack?: (event: AnalyticsEvent, payload?: Record<string, unknown>) => void;\n  minDate: Date;\n}\n\nexport type PlanStepFormHandlers = {\n  selectDate: (value: Date | undefined | null) => void;\n  selectTime: (value: string, options?: { commit?: boolean }) => void;\n  changeParty: (direction: 'decrement' | 'increment') => void;\n  changeOccasion: (value: BookingOption) => void;\n  commitNotes: (value: string) => void;\n  prefetchMonth: (month: Date) => void;\n};\n\nexport type PlanStepUnavailableReason = 'closed' | 'no-slots' | 'unknown';\n\nexport type PlanStepFormState = {\n  form: UseFormReturn<PlanFormValues>;\n  slots: TimeSlotDescriptor[];\n  availability: ServiceAvailability;\n  availableBookingOptions: BookingOption[];\n  occasionCatalog: OccasionDefinition[];\n  handlers: PlanStepFormHandlers;\n  minDate: Date;\n  intervalMinutes: number | null;\n  unavailableDates: Map<string, PlanStepUnavailableReason>;\n  hasAvailableSlots: boolean;\n  isScheduleLoading: boolean;\n  schedule: ReservationSchedule | null;\n  currentUnavailabilityReason: PlanStepUnavailableReason | null;\n  isSubmitting: boolean;\n  isValid: boolean;\n  submitForm: (values: PlanFormValues) => void;\n  handleError: (errors: Record<string, unknown>) => void;\n};\n",
  "reserve/features/reservations/wizard/ui/steps/review-step/types.ts": "import type { State, StepAction } from '../../../model/reducer';\nimport type { WizardActions } from '../../../model/store';\n\nexport interface ReviewStepProps {\n  state: State;\n  actions: Pick<WizardActions, 'goToStep'>;\n  onConfirm: () => void | Promise<void>;\n  onActionsChange: (actions: StepAction[]) => void;\n}\n\nexport type ReviewSummary = {\n  summaryValue: string;\n  summaryDate: string;\n  summaryTime: string;\n  partyText: string;\n};\n\nexport type ReviewStepController = {\n  details: State['details'];\n  summary: ReviewSummary;\n  isSubmitting: boolean;\n  error: State['error'];\n  handleEdit: () => void;\n  handleConfirm: () => void;\n};\n"
}
