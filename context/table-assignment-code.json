{
  "server/capacity/table-assignment/assignment.ts": "import { randomUUID } from \"node:crypto\";\n\nimport { AssignTablesRpcError, HoldNotFoundError } from \"@/server/capacity/holds\";\nimport { getVenuePolicy } from \"@/server/capacity/policy\";\nimport { emitRpcConflict } from \"@/server/capacity/telemetry\";\nimport { isAllocatorV2Enabled, isPolicyRequoteEnabled } from \"@/server/feature-flags\";\nimport { recordObservabilityEvent } from \"@/server/observability\";\n\nimport { resolveRequireAdjacency } from \"./availability\";\nimport { computeBookingWindowWithFallback } from \"./booking-window\";\nimport { DEFAULT_HOLD_TTL_SECONDS, TABLE_RESOURCE_TYPE } from \"./constants\";\nimport { quoteTablesForBooking } from \"./quote\";\nimport {\n  ensureClient,\n  applyAbortSignal,\n  findMissingHoldMetadataFields,\n  loadBooking,\n  loadTablesByIds,\n  loadAdjacency,\n  loadRestaurantTimezone,\n  releaseHoldWithRetry,\n  loadTableAssignmentsForTables,\n  type DbClient,\n  type TableHoldRow,\n  type BookingRow,\n} from \"./supabase\";\nimport {\n  AssignmentOrchestrator,\n  AssignmentConflictError,\n  AssignmentRepositoryError,\n  AssignmentValidationError,\n  SupabaseAssignmentRepository,\n  createPlanSignature,\n  createDeterministicIdempotencyKey,\n  computePayloadChecksum,\n  hashPolicyVersion,\n  normalizeTableIds,\n} from \"../v2\";\nimport { ManualSelectionInputError, type TableAssignmentMember } from \"./types\";\nimport { serializeDetails, toIsoUtc, normalizeIsoString } from \"./utils\";\n\nimport type { Tables, Json } from \"@/types/supabase\";\n\nlet confirmHoldAssignmentRpcAvailable: boolean | undefined;\n\ntype ConfirmHoldTransition = {\n  targetStatus: Tables<\"bookings\">[\"status\"];\n  historyReason: string;\n  historyMetadata?: Json;\n  historyChangedBy?: string | null;\n};\n\ntype ConfirmHoldAssignmentOptions = {\n  holdId: string;\n  bookingId: string;\n  idempotencyKey?: string;\n  requireAdjacency?: boolean;\n  assignedBy?: string | null;\n  client?: DbClient;\n  signal?: AbortSignal;\n  transition?: ConfirmHoldTransition;\n};\n\ntype RawAssignmentRecord = {\n  tableId: string;\n  startAt?: string | null;\n  endAt?: string | null;\n  mergeGroupId?: string | null;\n};\n\ntype AssignmentSyncParams = {\n  supabase: DbClient;\n  booking: BookingRow;\n  tableIds: string[];\n  idempotencyKey: string | null;\n  assignments: RawAssignmentRecord[];\n  startIso: string;\n  endIso: string;\n  actorId?: string | null;\n  mergeGroupId?: string | null;\n  holdContext?: {\n    holdId: string;\n    zoneId?: string | null;\n  };\n};\n\nfunction isSchemaCacheMissError(error: AssignTablesRpcError): boolean {\n  const code = (error.code ?? \"\").toUpperCase();\n  if (code === \"PGRST202\" || code === \"PGRST204\") {\n    return true;\n  }\n  const message = (error.message ?? \"\").toLowerCase();\n  return message.includes(\"schema cache\");\n}\n\ntype LegacyConfirmContext = {\n  supabase: DbClient;\n  booking: BookingRow;\n  holdRow: TableHoldRow;\n  normalizedTableIds: string[];\n  startIso: string;\n  endIso: string;\n  assignedBy: string | null;\n  idempotencyKey: string;\n  requireAdjacency: boolean;\n  holdId: string;\n  transition?: ConfirmHoldTransition;\n};\n\nasync function synchronizeAssignments(params: AssignmentSyncParams): Promise<TableAssignmentMember[]> {\n  const { supabase, booking, tableIds, idempotencyKey, assignments, startIso, endIso, actorId, mergeGroupId, holdContext } = params;\n  const uniqueTableIds = Array.from(new Set(tableIds));\n  const assignmentRows = await loadTableAssignmentsForTables(booking.id, uniqueTableIds, supabase);\n  const windowRange = `[${startIso},${endIso})`;\n\n  const needsUpdate = assignments.some((assignment) => {\n    const normalizedStart = normalizeIsoString(assignment.startAt ?? null);\n    const normalizedEnd = normalizeIsoString(assignment.endAt ?? null);\n    return normalizedStart !== startIso || normalizedEnd !== endIso;\n  });\n\n  if (needsUpdate) {\n    try {\n      await supabase\n        .from(\"booking_table_assignments\")\n        .update({ start_at: startIso, end_at: endIso })\n        .eq(\"booking_id\", booking.id)\n        .in(\"table_id\", uniqueTableIds);\n    } catch {\n      // Ignore in mocked environments.\n    }\n\n    try {\n      await supabase\n        .from(\"allocations\")\n        .update({ window: windowRange })\n        .eq(\"booking_id\", booking.id)\n        .eq(\"resource_type\", TABLE_RESOURCE_TYPE)\n        .in(\"resource_id\", uniqueTableIds);\n    } catch {\n      // Ignore missing allocation support in mocked environments.\n    }\n\n    if (idempotencyKey) {\n      try {\n        await supabase\n          .from(\"booking_assignment_idempotency\")\n          .update({\n            assignment_window: windowRange,\n            merge_group_allocation_id: mergeGroupId ?? null,\n            payload_checksum: computePayloadChecksum({\n              bookingId: booking.id,\n              tableIds: uniqueTableIds,\n              startAt: startIso,\n              endAt: endIso,\n              actorId,\n              holdId: holdContext?.holdId ?? null,\n            }) as unknown as string,\n          } as Record<string, unknown>)\n          .eq(\"booking_id\", booking.id)\n          .eq(\"idempotency_key\", idempotencyKey);\n      } catch {\n        // Ignore ledger updates in mocked environments.\n      }\n    }\n  }\n\n  const assignmentLookup = new Map<string, RawAssignmentRecord>();\n  for (const assignment of assignments) {\n    assignmentLookup.set(assignment.tableId, assignment);\n  }\n\n  const tableRowLookup = new Map(assignmentRows.map((row) => [row.table_id, row]));\n\n  const result: TableAssignmentMember[] = uniqueTableIds.map((tableId) => {\n    const row = tableRowLookup.get(tableId);\n    const assignment = assignmentLookup.get(tableId);\n    return {\n      tableId,\n      assignmentId: row?.id ?? randomUUID(),\n      startAt: startIso,\n      endAt: endIso,\n      mergeGroupId: assignment?.mergeGroupId ?? mergeGroupId ?? null,\n    };\n  });\n\n  if (holdContext) {\n    const zoneId = holdContext.zoneId ?? \"\";\n    const telemetryMetadata = holdContext.zoneId ? undefined : { unknownZone: true };\n    try {\n      const { enqueueOutboxEvent } = await import(\"@/server/outbox\");\n      await enqueueOutboxEvent({\n        eventType: \"capacity.hold.confirmed\",\n        restaurantId: booking.restaurant_id,\n        bookingId: booking.id,\n        idempotencyKey: idempotencyKey ?? null,\n        dedupeKey: `${booking.id}:${holdContext.holdId}:hold.confirmed`,\n        payload: {\n          holdId: holdContext.holdId,\n          bookingId: booking.id,\n          restaurantId: booking.restaurant_id,\n          zoneId,\n          tableIds: result.map((assignment) => assignment.tableId),\n          startAt: startIso,\n          endAt: endIso,\n          expiresAt: endIso,\n          actorId: actorId ?? null,\n          metadata: telemetryMetadata ?? null,\n        },\n      });\n    } catch (e) {\n      console.warn(\"[capacity.outbox] enqueue hold.confirmed failed\", { bookingId: booking.id, error: e });\n    }\n  }\n\n  try {\n    const { enqueueOutboxEvent } = await import(\"@/server/outbox\");\n    await enqueueOutboxEvent({\n      eventType: \"capacity.assignment.sync\",\n      restaurantId: booking.restaurant_id,\n      bookingId: booking.id,\n      idempotencyKey: idempotencyKey ?? null,\n      dedupeKey: `${booking.id}:${startIso}:${endIso}:${result.map((assignment) => assignment.tableId).join(\",\")}`,\n      payload: {\n        bookingId: booking.id,\n        restaurantId: booking.restaurant_id,\n        tableIds: result.map((assignment) => assignment.tableId),\n        startAt: startIso,\n        endAt: endIso,\n        mergeGroupId: mergeGroupId ?? null,\n        idempotencyKey: idempotencyKey ?? null,\n      },\n    });\n  } catch (e) {\n    console.warn(\"[capacity.outbox] enqueue assignment.sync failed\", { bookingId: booking.id, error: e });\n  }\n\n  return result;\n}\n\nasync function confirmHoldAssignmentLegacy(ctx: LegacyConfirmContext): Promise<TableAssignmentMember[]> {\n  const {\n    supabase,\n    booking,\n    holdRow,\n    normalizedTableIds,\n    startIso,\n    endIso,\n    assignedBy,\n    idempotencyKey,\n    requireAdjacency,\n    holdId,\n  } = ctx;\n  const actorId = assignedBy ?? null;\n  const legacyHoldRow = holdRow;\n\n  const planSignature = createPlanSignature({\n    bookingId: booking.id,\n    tableIds: normalizedTableIds,\n    startAt: startIso,\n    endAt: endIso,\n    salt: idempotencyKey ?? undefined,\n  });\n\n  const orchestrator = new AssignmentOrchestrator(new SupabaseAssignmentRepository(supabase));\n  let response;\n  try {\n    response = await orchestrator.commitPlan(\n      {\n        bookingId: booking.id,\n        restaurantId: booking.restaurant_id,\n        partySize: booking.party_size,\n        serviceDate: booking.booking_date ?? null,\n        window: { startAt: startIso, endAt: endIso },\n      },\n      {\n        signature: planSignature,\n        tableIds: normalizedTableIds,\n        startAt: startIso,\n        endAt: endIso,\n        metadata: { requestSource: \"confirmHoldAssignmentFallback\" },\n      },\n      {\n        source: \"auto\",\n        idempotencyKey,\n        actorId,\n        metadata: { requireAdjacency, fallback: true },\n        requireAdjacency,\n      },\n    );\n  } catch (error) {\n    if (error instanceof AssignmentConflictError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_CONFLICT\",\n        details: serializeDetails(error.details),\n        hint: error.details?.hint ?? null,\n      });\n    }\n    if (error instanceof AssignmentValidationError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_VALIDATION\",\n        details: serializeDetails(error.details),\n        hint: null,\n      });\n    }\n    if (error instanceof AssignmentRepositoryError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_REPOSITORY_ERROR\",\n        details: serializeDetails(error.cause ?? null),\n        hint: null,\n      });\n    }\n    throw error;\n  }\n\n  const assignmentPayload = response.assignments.map((assignment) => ({\n    tableId: assignment.tableId,\n    startAt: assignment.startAt,\n    endAt: assignment.endAt,\n    mergeGroupId: assignment.mergeGroupId ?? response.mergeGroupId ?? null,\n  }));\n\n  const synchronized = await synchronizeAssignments({\n    supabase,\n    booking,\n    tableIds: normalizedTableIds,\n    idempotencyKey,\n    assignments: assignmentPayload,\n    startIso,\n    endIso,\n    actorId,\n    mergeGroupId: response.mergeGroupId ?? null,\n    holdContext: {\n      holdId,\n      zoneId: legacyHoldRow.zone_id ?? null,\n    },\n  });\n\n  const transition = ctx.transition;\n  if (transition?.targetStatus) {\n    const targetStatus = transition.targetStatus;\n    if (booking.status !== targetStatus) {\n      const nowIso = new Date().toISOString();\n      const { data: transitionRows, error: transitionError } = await supabase.rpc(\"apply_booking_state_transition\", {\n        p_booking_id: booking.id,\n        p_status: targetStatus,\n        p_checked_in_at: booking.checked_in_at ?? null,\n        p_checked_out_at: booking.checked_out_at ?? null,\n        p_updated_at: nowIso,\n        p_history_from: booking.status,\n        p_history_to: targetStatus,\n        p_history_changed_by: transition.historyChangedBy ?? null,\n        p_history_changed_at: nowIso,\n        p_history_reason: transition.historyReason ?? \"auto_assign_confirm\",\n        p_history_metadata: transition.historyMetadata ?? {},\n      });\n\n      if (transitionError) {\n        throw new AssignTablesRpcError({\n          message: transitionError.message ?? \"Failed to transition booking status after assignment\",\n          code: transitionError.code ?? \"BOOKING_STATUS_TRANSITION_FAILED\",\n          details: serializeDetails(transitionError.details ?? null),\n          hint: transitionError.hint ?? null,\n        });\n      }\n\n      const transitionRow = Array.isArray(transitionRows) ? transitionRows[0] : null;\n      booking.status = (transitionRow?.status as Tables<\"bookings\">[\"status\"] | undefined) ?? targetStatus;\n      if (\"checked_in_at\" in booking) {\n        (booking as BookingRow).checked_in_at = (transitionRow?.checked_in_at as string | null | undefined) ?? booking.checked_in_at ?? null;\n      }\n      if (\"checked_out_at\" in booking) {\n        (booking as BookingRow).checked_out_at = (transitionRow?.checked_out_at as string | null | undefined) ?? booking.checked_out_at ?? null;\n      }\n    }\n  }\n\n  try {\n    await releaseHoldWithRetry({ holdId, client: supabase });\n  } catch (releaseError) {\n    console.warn(\"[capacity.confirm][fallback] failed to release hold\", {\n      holdId,\n      bookingId: booking.id,\n      error: releaseError instanceof Error ? releaseError.message : String(releaseError),\n    });\n  }\n\n  await recordObservabilityEvent({\n    source: \"capacity.confirm\",\n    eventType: \"confirm_hold.rpc_fallback_succeeded\",\n    restaurantId: booking.restaurant_id ?? undefined,\n    bookingId: booking.id,\n    context: {\n      holdId,\n      tableCount: normalizedTableIds.length,\n    },\n    severity: \"info\",\n  }).catch(() => {});\n\n  return synchronized;\n}\n\nexport async function confirmHoldAssignment(options: ConfirmHoldAssignmentOptions): Promise<TableAssignmentMember[]> {\n  if (!isAllocatorV2Enabled()) {\n    throw new AssignTablesRpcError({\n      message: \"Allocator v2 must be enabled to confirm holds\",\n      code: \"ALLOCATOR_V2_DISABLED\",\n      details: null,\n      hint: \"Enable allocator.v2.enabled to use confirmHoldAssignment\",\n    });\n  }\n\n  const {\n    holdId,\n    bookingId,\n    idempotencyKey: providedIdempotencyKey,\n    requireAdjacency: requireAdjacencyOverride,\n    assignedBy = null,\n    client,\n    signal,\n    transition,\n  } = options;\n  const supabase = ensureClient(client);\n  const actorId = assignedBy ?? null;\n\n  const holdQuery = applyAbortSignal(\n    supabase\n      .from(\"table_holds\")\n      .select(\"id, restaurant_id, zone_id, booking_id, metadata, table_hold_members(table_id)\")\n      .eq(\"id\", holdId),\n    signal,\n  );\n  const { data: holdRow, error: holdError } = await holdQuery.maybeSingle();\n\n  if (holdError) {\n    throw new HoldNotFoundError(holdError.message ?? \"Failed to load table hold\");\n  }\n\n  if (!holdRow) {\n    throw new HoldNotFoundError();\n  }\n\n  const missingMetadataFields = findMissingHoldMetadataFields(holdRow as TableHoldRow);\n  if (missingMetadataFields.length > 0) {\n    await recordObservabilityEvent({\n      source: \"capacity.confirm\",\n      eventType: \"holds.metadata.invalid\",\n      severity: \"warning\",\n      restaurantId: holdRow.restaurant_id ?? undefined,\n      bookingId,\n      context: {\n        holdId,\n        missingFields: missingMetadataFields,\n      },\n    });\n\n    throw new AssignTablesRpcError({\n      message: \"Hold metadata incomplete; regenerate hold before confirming\",\n      code: \"HOLD_METADATA_INCOMPLETE\",\n      details: serializeDetails({ missingFields: missingMetadataFields }),\n      hint: \"Re-create hold to capture latest selection snapshot.\",\n    });\n  }\n\n  const typedHoldRow = holdRow as TableHoldRow;\n  const holdMetadata = (typedHoldRow.metadata ?? null) as\n    | {\n        policyVersion?: string | null;\n        selection?: {\n          snapshot?: {\n            zoneIds?: string[];\n            adjacency?: { undirected?: boolean; edges?: string[]; hash?: string };\n          };\n        };\n      }\n    | null;\n\n  const tableIds = Array.isArray(typedHoldRow.table_hold_members)\n    ? (typedHoldRow.table_hold_members as Array<{ table_id: string }>).map((member) => member.table_id)\n    : [];\n\n  const holdBookingId = typedHoldRow.booking_id ?? null;\n  if (holdBookingId && holdBookingId !== bookingId) {\n    await emitRpcConflict({\n      source: \"confirm_hold_booking_mismatch\",\n      bookingId,\n      restaurantId: holdRow.restaurant_id,\n      tableIds,\n      holdId,\n      error: {\n        code: \"HOLD_BOOKING_MISMATCH\",\n        message: \"Hold is already linked to a different booking\",\n        details: serializeDetails({ holdBookingId }),\n        hint: null,\n      },\n    });\n\n    throw new AssignTablesRpcError({\n      message: \"Hold is already linked to a different booking\",\n      code: \"HOLD_BOOKING_MISMATCH\",\n      details: serializeDetails({ holdBookingId }),\n      hint: null,\n    });\n  }\n\n  if (tableIds.length === 0) {\n    throw new AssignTablesRpcError({\n      message: \"Hold has no tables\",\n      code: \"HOLD_EMPTY\",\n      details: null,\n      hint: null,\n    });\n  }\n\n  const booking = await loadBooking(bookingId, supabase);\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const policyVersion = hashPolicyVersion(policy);\n  const holdPolicyVersion = typeof holdMetadata?.policyVersion === \"string\" ? holdMetadata.policyVersion : null;\n  if (holdPolicyVersion && holdPolicyVersion !== policyVersion) {\n    throw new AssignTablesRpcError({\n      message: \"Policy has changed since hold was created\",\n      code: \"POLICY_CHANGED\",\n      details: serializeDetails({ expected: holdPolicyVersion, actual: policyVersion }),\n      hint: \"Refresh and revalidate selection before confirming.\",\n    });\n  }\n  const { window } = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n  const requireAdjacency = resolveRequireAdjacency(booking.party_size, requireAdjacencyOverride);\n\n  const startIso = toIsoUtc(window.block.start);\n  const endIso = toIsoUtc(window.block.end);\n  const normalizedTableIds = normalizeTableIds(tableIds);\n  // Verify adjacency/zone snapshot freeze\n  let adjacencySnapshotHash: string | null = null;\n  const selectionSnapshot = holdMetadata?.selection?.snapshot ?? null;\n  if (selectionSnapshot) {\n    const currentTables = await loadTablesByIds(booking.restaurant_id, normalizedTableIds, supabase, signal);\n    const currentZoneIds = Array.from(new Set(currentTables.map((t) => t.zoneId))).filter(Boolean) as string[];\n    const zonesMatch = JSON.stringify([...currentZoneIds].sort()) === JSON.stringify([...(selectionSnapshot.zoneIds ?? [])].sort());\n\n    const currentAdjacency = await loadAdjacency(booking.restaurant_id, normalizedTableIds, supabase, signal);\n    const undirected = Boolean(selectionSnapshot.adjacency?.undirected);\n    const edgeSet = new Set<string>();\n    for (const a of normalizedTableIds) {\n      const neighbors = currentAdjacency.get(a);\n      if (!neighbors) continue;\n      for (const b of neighbors) {\n        if (!normalizedTableIds.includes(b)) continue;\n        const key = undirected ? ([a, b].sort((x, y) => x.localeCompare(y)) as [string, string]).join(\"->\") : `${a}->${b}`;\n        edgeSet.add(key);\n      }\n    }\n    const nowEdges = Array.from(edgeSet).sort();\n    const nowHash = computePayloadChecksum({ undirected, edges: nowEdges });\n    adjacencySnapshotHash = nowHash;\n    const edgesMatch =\n      nowHash === selectionSnapshot.adjacency?.hash &&\n      JSON.stringify(nowEdges) === JSON.stringify([...(selectionSnapshot.adjacency?.edges ?? [])].sort());\n\n    if (!zonesMatch || !edgesMatch) {\n      throw new AssignTablesRpcError({\n        message: !zonesMatch\n          ? \"Zone assignment changed since hold was created\"\n          : \"Adjacency definition changed since hold was created\",\n        code: \"POLICY_CHANGED\",\n        details: serializeDetails({\n          zones: { expected: selectionSnapshot.zoneIds ?? [], actual: currentZoneIds },\n          adjacency: {\n            undirected,\n            expectedHash: selectionSnapshot.adjacency?.hash ?? null,\n            actualHash: nowHash,\n            expectedEdges: selectionSnapshot.adjacency?.edges ?? [],\n            actualEdges: nowEdges,\n          },\n        }),\n        hint: \"Refresh and revalidate selection before confirming.\",\n      });\n    }\n  }\n  const deterministicKey = createDeterministicIdempotencyKey({\n    tenantId: booking.restaurant_id,\n    bookingId,\n    tableIds: normalizedTableIds,\n    startAt: startIso,\n    endAt: endIso,\n    policyVersion,\n  });\n  // Optional: pre-check for mismatched payloads for same key (legacy-compatible)\n  try {\n    const ledgerLookup = applyAbortSignal(\n      supabase\n        .from(\"booking_assignment_idempotency\")\n        .select(\"idempotency_key, booking_id, table_ids, assignment_window\")\n        .eq(\"booking_id\", bookingId)\n        .eq(\"idempotency_key\", deterministicKey),\n      signal,\n    );\n    const { data: existing } = await ledgerLookup.maybeSingle();\n    if (existing && typeof existing === \"object\") {\n      const existingTyped = existing as { table_ids?: unknown };\n      const sameTables = Array.isArray(existingTyped.table_ids)\n        ? normalizeTableIds(existingTyped.table_ids as string[]).join(\",\") === normalizedTableIds.join(\",\")\n        : true;\n      if (!sameTables) {\n        throw new AssignTablesRpcError({\n          message: \"Idempotency mismatch for the same key\",\n          code: \"RPC_VALIDATION\",\n          details: serializeDetails({ reason: \"IDEMPOTENCY_MISMATCH\" }),\n          hint: \"Retry using the same payload as the original request.\",\n        });\n      }\n    }\n  } catch {\n    // ignore lookup errors\n  }\n\n  const effectiveIdempotencyKey = providedIdempotencyKey ?? deterministicKey;\n  const fallbackContext: LegacyConfirmContext = {\n    supabase,\n    booking,\n    holdRow: typedHoldRow,\n    normalizedTableIds,\n    startIso,\n    endIso,\n    assignedBy,\n    idempotencyKey: effectiveIdempotencyKey,\n    requireAdjacency,\n    holdId,\n    transition,\n  };\n\n  if (confirmHoldAssignmentRpcAvailable === false) {\n    return confirmHoldAssignmentLegacy(fallbackContext);\n  }\n\n  const rpcArgs = {\n    p_hold_id: holdId,\n    p_booking_id: bookingId,\n    p_idempotency_key: effectiveIdempotencyKey,\n    p_require_adjacency: requireAdjacency,\n    p_assigned_by: assignedBy ?? undefined,\n    p_window_start: startIso,\n    p_window_end: endIso,\n    p_expected_policy_version: policyVersion,\n    p_expected_adjacency_hash: adjacencySnapshotHash ?? undefined,\n    p_target_status: transition?.targetStatus ?? undefined,\n    p_history_reason: transition?.historyReason ?? \"auto_assign_confirm\",\n    p_history_metadata: transition?.historyMetadata ?? {},\n    p_history_changed_by: transition?.historyChangedBy ?? undefined,\n  };\n\n  const rpcCall = applyAbortSignal(supabase.rpc(\"confirm_hold_assignment_tx\", rpcArgs), signal);\n  const { data: rpcData, error: rpcError } = await rpcCall;\n\n  if (rpcError) {\n    const rpcFailure = new AssignTablesRpcError({\n      message: rpcError.message ?? \"confirm_hold_assignment_tx failed\",\n      code: rpcError.code ?? \"RPC_EXECUTION_FAILED\",\n      details: serializeDetails(rpcError.details ?? null),\n      hint: rpcError.hint ?? null,\n    });\n\n    if (isSchemaCacheMissError(rpcFailure)) {\n      console.warn(\"[capacity.confirm] confirm_hold_assignment_tx unavailable, falling back\", {\n        bookingId,\n        holdId,\n        code: rpcFailure.code,\n        message: rpcFailure.message,\n      });\n      confirmHoldAssignmentRpcAvailable = false;\n      await recordObservabilityEvent({\n        source: \"capacity.confirm\",\n        eventType: \"confirm_hold.rpc_schema_cache_miss\",\n        restaurantId: booking.restaurant_id ?? undefined,\n        bookingId,\n        context: {\n          holdId,\n          code: rpcFailure.code ?? null,\n        },\n        severity: \"warning\",\n      }).catch(() => {});\n      return confirmHoldAssignmentLegacy(fallbackContext);\n    }\n\n    throw rpcFailure;\n  }\n\n  const rows = Array.isArray(rpcData) ? rpcData : [];\n  if (rows.length === 0) {\n    throw new AssignTablesRpcError({\n      message: \"confirm_hold_assignment_tx returned no assignments\",\n      code: \"ASSIGNMENT_EMPTY\",\n      details: null,\n      hint: null,\n    });\n  }\n\n  confirmHoldAssignmentRpcAvailable = true;\n\n  const assignmentPayload = rows.map((row) => ({\n    tableId: row.table_id,\n    startAt: row.start_at,\n    endAt: row.end_at,\n    mergeGroupId: row.merge_group_id ?? null,\n  }));\n  const mergeGroupId = rows[0]?.merge_group_id ?? null;\n\n  return synchronizeAssignments({\n    supabase,\n    booking,\n    tableIds: normalizedTableIds,\n    idempotencyKey: effectiveIdempotencyKey,\n    assignments: assignmentPayload,\n    startIso,\n    endIso,\n    actorId,\n    mergeGroupId,\n    holdContext: {\n      holdId,\n      zoneId: typedHoldRow.zone_id ?? null,\n    },\n  });\n}\n\ntype AtomicConfirmOptions = {\n  bookingId: string;\n  holdId: string;\n  idempotencyKey: string;\n  assignedBy?: string | null;\n  historyReason: string;\n  historyMetadata?: Json;\n  historyChangedBy?: string | null;\n  signal?: AbortSignal;\n  client?: DbClient;\n  policyRetryAttempts?: number;\n};\n\ntype BookingAssignmentState = {\n  bookingState: Tables<\"bookings\">[\"status\"] | null;\n  assignmentCount: number;\n  restaurantId: string | null;\n};\n\nasync function fetchBookingAssignmentState(params: {\n  bookingId: string;\n  client: DbClient;\n  signal?: AbortSignal;\n}): Promise<BookingAssignmentState> {\n  const { bookingId, client, signal } = params;\n\n  const bookingQuery = applyAbortSignal(\n    client.from(\"bookings\").select(\"status, restaurant_id\").eq(\"id\", bookingId),\n    signal,\n  );\n  const { data: bookingRow } = await bookingQuery.maybeSingle();\n\n  const assignmentsQuery = applyAbortSignal(\n    client\n      .from(\"booking_table_assignments\")\n      .select(\"table_id\", { count: \"exact\", head: true })\n      .eq(\"booking_id\", bookingId),\n    signal,\n  );\n  const { count: assignmentCount } = await assignmentsQuery;\n\n  return {\n    bookingState: (bookingRow?.status as Tables<\"bookings\">[\"status\"] | null) ?? null,\n    assignmentCount: typeof assignmentCount === \"number\" ? assignmentCount : 0,\n    restaurantId: (bookingRow?.restaurant_id as string | null) ?? null,\n  };\n}\n\nasync function reconcileOrphanedAssignments(params: {\n  bookingId: string;\n  holdId?: string;\n  client: DbClient;\n  signal?: AbortSignal;\n}): Promise<void> {\n  const { bookingId, holdId, client, signal } = params;\n\n  const assignmentLookup = applyAbortSignal(\n    client.from(\"booking_table_assignments\").select(\"table_id\").eq(\"booking_id\", bookingId),\n    signal,\n  );\n  const { data: assignmentRows } = await assignmentLookup;\n  const tableIds = (assignmentRows ?? [])\n    .map((row) => row.table_id)\n    .filter((value): value is string => typeof value === \"string\" && value.length > 0);\n\n  if (tableIds.length > 0) {\n    try {\n      await client.rpc(\"unassign_tables_atomic\", {\n        p_booking_id: bookingId,\n        p_table_ids: tableIds,\n      });\n    } catch (unassignError) {\n      console.warn(\"[capacity.atomic] failed to unassign tables during reconciliation\", {\n        bookingId,\n        tableIds,\n        error: unassignError instanceof Error ? unassignError.message : String(unassignError),\n      });\n    }\n  }\n\n  if (holdId) {\n    try {\n      await releaseHoldWithRetry({ holdId, client });\n    } catch (releaseError) {\n      console.warn(\"[capacity.atomic] failed to release hold during reconciliation\", {\n        holdId,\n        bookingId,\n        error: releaseError instanceof Error ? releaseError.message : String(releaseError),\n      });\n    }\n  }\n}\n\ntype PolicyDriftDetails = {\n  expectedHash?: string;\n  actualHash?: string;\n  adjacency?: {\n    expectedEdges?: string[];\n    actualEdges?: string[];\n    expectedHash?: string;\n    actualHash?: string;\n  };\n  zones?: {\n    expected?: Json;\n    actual?: Json;\n  };\n  raw?: Json;\n};\n\nfunction isPolicyChangedError(error: unknown): error is AssignTablesRpcError {\n  return error instanceof AssignTablesRpcError && error.code === \"POLICY_CHANGED\";\n}\n\nfunction extractPolicyDriftDetails(error: AssignTablesRpcError): PolicyDriftDetails {\n  if (!error.details) {\n    return { raw: null };\n  }\n\n  try {\n    const parsed = JSON.parse(error.details) as Json;\n    const parsedRecord = (typeof parsed === \"object\" && parsed !== null ? parsed : null) as\n      | Record<string, Json>\n      | null;\n    const details: PolicyDriftDetails = { raw: parsed };\n\n    if (parsedRecord) {\n      if (typeof parsedRecord.expected === \"string\") {\n        details.expectedHash = parsedRecord.expected;\n      }\n      if (typeof parsedRecord.actual === \"string\") {\n        details.actualHash = parsedRecord.actual;\n      }\n\n      const adjacency = parsedRecord.adjacency as Record<string, Json> | undefined;\n      if (adjacency && typeof adjacency === \"object\") {\n        const expectedEdges = adjacency.expectedEdges;\n        const actualEdges = adjacency.actualEdges;\n        details.adjacency = {\n          expectedEdges: Array.isArray(expectedEdges) ? (expectedEdges as string[]) : undefined,\n          actualEdges: Array.isArray(actualEdges) ? (actualEdges as string[]) : undefined,\n          expectedHash: typeof adjacency.expectedHash === \"string\" ? adjacency.expectedHash : undefined,\n          actualHash: typeof adjacency.actualHash === \"string\" ? adjacency.actualHash : undefined,\n        };\n      }\n\n      const zones = parsedRecord.zones as Record<string, Json> | undefined;\n      if (zones && typeof zones === \"object\") {\n        details.zones = {\n          expected: zones.expected,\n          actual: zones.actual,\n        };\n      }\n    }\n\n    return details;\n  } catch {\n    return { raw: error.details };\n  }\n}\n\nasync function publishPolicyDriftNotification(params: {\n  bookingId: string;\n  restaurantId?: string | null;\n  holdId: string;\n  attempt: number;\n  recovered: boolean;\n  details: PolicyDriftDetails;\n}): Promise<void> {\n  try {\n    const { enqueueOutboxEvent } = await import(\"@/server/outbox\");\n    await enqueueOutboxEvent({\n      eventType: \"capacity.policy.drift\",\n      restaurantId: params.restaurantId ?? null,\n      bookingId: params.bookingId,\n      payload: {\n        holdId: params.holdId,\n        attempt: params.attempt,\n        recovered: params.recovered,\n        details: params.details,\n      },\n    });\n  } catch (error) {\n    console.warn(\"[capacity.policy] failed to enqueue drift notification\", {\n      error: error instanceof Error ? error.message : String(error),\n    });\n  }\n}\n\nasync function confirmWithPolicyRetry(params: {\n  supabase: DbClient;\n  bookingId: string;\n  restaurantId?: string | null;\n  holdId: string;\n  idempotencyKey: string;\n  assignedBy: string | null;\n  transition: ConfirmHoldTransition;\n  signal?: AbortSignal;\n  maxAttempts: number;\n  enableRetry: boolean;\n  contextRef: { currentHoldId: string };\n}): Promise<{ assignments: TableAssignmentMember[]; attempts: number }> {\n  const {\n    supabase,\n    bookingId,\n    restaurantId,\n    idempotencyKey,\n    assignedBy,\n    transition,\n    signal,\n    maxAttempts,\n    enableRetry,\n    contextRef,\n  } = params;\n\n  const totalAttempts = enableRetry ? Math.max(1, maxAttempts) : 1;\n  let attempt = 0;\n  let driftDetected = false;\n  let driftNotificationSent = false;\n  let lastError: unknown = null;\n\n  while (attempt < totalAttempts) {\n    try {\n      const assignments = await confirmHoldAssignment({\n        holdId: contextRef.currentHoldId,\n        bookingId,\n        idempotencyKey,\n        assignedBy,\n        client: supabase,\n        signal,\n        transition,\n      });\n\n      if (driftDetected) {\n        await recordObservabilityEvent({\n          source: \"capacity.policy\",\n          eventType: \"policy_drift.recovered\",\n          restaurantId: restaurantId ?? undefined,\n          bookingId,\n          context: {\n            attempts: attempt + 1,\n            holdId: contextRef.currentHoldId,\n          },\n        });\n\n        await publishPolicyDriftNotification({\n          bookingId,\n          restaurantId,\n          holdId: contextRef.currentHoldId,\n          attempt: attempt + 1,\n          recovered: true,\n          details: { raw: null },\n        });\n      }\n\n      return { assignments, attempts: attempt + 1 };\n    } catch (error) {\n      if (isPolicyChangedError(error) && enableRetry && attempt < totalAttempts - 1) {\n        driftDetected = true;\n        const details = extractPolicyDriftDetails(error);\n\n        await recordObservabilityEvent({\n          source: \"capacity.policy\",\n          eventType: \"policy_drift.detected\",\n          severity: \"warning\",\n          restaurantId: restaurantId ?? undefined,\n          bookingId,\n          context: {\n            attempt: attempt + 1,\n            holdId: contextRef.currentHoldId,\n            details,\n          },\n        });\n\n        if (!driftNotificationSent) {\n          driftNotificationSent = true;\n          await publishPolicyDriftNotification({\n            bookingId,\n            restaurantId,\n            holdId: contextRef.currentHoldId,\n            attempt: attempt + 1,\n            recovered: false,\n            details,\n          });\n        }\n\n        try {\n          await releaseHoldWithRetry({ holdId: contextRef.currentHoldId, client: supabase });\n        } catch (releaseError) {\n          console.warn(\"[capacity.policy] failed to release hold during policy drift retry\", {\n            holdId: contextRef.currentHoldId,\n            error: releaseError instanceof Error ? releaseError.message : String(releaseError),\n          });\n        }\n\n        const quote = await quoteTablesForBooking({\n          bookingId,\n          createdBy: assignedBy ?? \"policy-retry\",\n          holdTtlSeconds: DEFAULT_HOLD_TTL_SECONDS,\n          client: supabase,\n          signal,\n        });\n\n        if (!quote.hold) {\n          lastError = new AssignTablesRpcError({\n            message: \"Failed to re-quote tables after policy drift\",\n            code: \"POLICY_REQUOTE_FAILED\",\n            details: serializeDetails({ reason: quote.reason ?? \"NO_HOLD\" }),\n            hint: quote.reason ?? null,\n          });\n          break;\n        }\n\n        contextRef.currentHoldId = quote.hold.id;\n        attempt += 1;\n        continue;\n      }\n\n      lastError = error;\n      break;\n    }\n  }\n\n  if (driftDetected) {\n    await recordObservabilityEvent({\n      source: \"capacity.policy\",\n      eventType: \"policy_drift.failed\",\n      severity: \"error\",\n      restaurantId: restaurantId ?? undefined,\n      bookingId,\n      context: {\n        attempt: attempt + 1,\n        holdId: contextRef.currentHoldId,\n        error: lastError instanceof Error ? lastError.message : String(lastError),\n      },\n    });\n  }\n\n  if (lastError instanceof Error) {\n    throw lastError;\n  }\n\n  throw new AssignTablesRpcError({\n    message: \"Policy drift retry failed\",\n    code: \"POLICY_RETRY_FAILED\",\n    details: serializeDetails({ reason: \"UNKNOWN\" }),\n    hint: null,\n  });\n}\n\nexport async function atomicConfirmAndTransition(options: AtomicConfirmOptions): Promise<TableAssignmentMember[]> {\n  const {\n    bookingId,\n    holdId,\n    idempotencyKey,\n    assignedBy = null,\n    historyReason,\n    historyMetadata,\n    historyChangedBy = null,\n    signal,\n    client,\n  } = options;\n\n  const supabase = ensureClient(client);\n  const preState = await fetchBookingAssignmentState({ bookingId, client: supabase, signal });\n\n  recordObservabilityEvent({\n    source: \"capacity.atomic_confirm\",\n    eventType: \"transaction.started\",\n    restaurantId: preState.restaurantId ?? undefined,\n    bookingId,\n    context: {\n      holdId,\n      idempotencyKey,\n      preStatus: preState.bookingState,\n      preAssignments: preState.assignmentCount,\n    },\n  }).catch((startError) => {\n    console.warn(\"[capacity.atomic_confirm] failed to record start event\", {\n      error: startError instanceof Error ? startError.message : String(startError),\n    });\n  });\n\n  const policyContext = { currentHoldId: holdId };\n  const policyRetryEnabled = isPolicyRequoteEnabled();\n\n  try {\n    const { assignments } = await confirmWithPolicyRetry({\n      supabase,\n      bookingId,\n      restaurantId: preState.restaurantId ?? undefined,\n      holdId,\n      idempotencyKey,\n      assignedBy,\n      signal,\n      transition: {\n        targetStatus: \"confirmed\",\n        historyReason,\n        historyMetadata,\n        historyChangedBy,\n      },\n      maxAttempts: options.policyRetryAttempts ?? 2,\n      enableRetry: policyRetryEnabled,\n      contextRef: policyContext,\n    });\n\n    const postState = await fetchBookingAssignmentState({ bookingId, client: supabase, signal });\n\n    if (postState.bookingState !== \"confirmed\" || postState.assignmentCount === 0) {\n      await reconcileOrphanedAssignments({\n        bookingId,\n        holdId: policyContext.currentHoldId,\n        client: supabase,\n        signal,\n      });\n\n      recordObservabilityEvent({\n        source: \"capacity.atomic_confirm\",\n        eventType: \"transaction.reconciled_mismatch\",\n        restaurantId: postState.restaurantId ?? undefined,\n        bookingId,\n        context: {\n          holdId: policyContext.currentHoldId,\n          idempotencyKey,\n          postStatus: postState.bookingState,\n          postAssignments: postState.assignmentCount,\n        },\n        severity: \"warning\",\n      });\n\n      throw new AssignTablesRpcError({\n        message: \"Atomic confirmation completed but reconciliation failed\",\n        code: \"STATE_RECONCILIATION_FAILED\",\n        details: serializeDetails({\n          bookingState: postState.bookingState,\n          assignmentCount: postState.assignmentCount,\n        }),\n        hint: \"Investigate mismatch and retry confirmation if safe.\",\n      });\n    }\n\n    recordObservabilityEvent({\n      source: \"capacity.atomic_confirm\",\n      eventType: \"transaction.succeeded\",\n      restaurantId: postState.restaurantId ?? undefined,\n      bookingId,\n      context: {\n        holdId: policyContext.currentHoldId,\n        idempotencyKey,\n        assignments: postState.assignmentCount,\n      },\n    }).catch((successError) => {\n      console.warn(\"[capacity.atomic_confirm] failed to record success event\", {\n        error: successError instanceof Error ? successError.message : String(successError),\n      });\n    });\n\n    return assignments;\n  } catch (error) {\n    await reconcileOrphanedAssignments({\n      bookingId,\n      holdId: policyContext.currentHoldId,\n      client: supabase,\n      signal,\n    });\n\n    recordObservabilityEvent({\n      source: \"capacity.atomic_confirm\",\n      eventType: \"transaction.failed\",\n      restaurantId: preState.restaurantId ?? undefined,\n      bookingId,\n      context: {\n        holdId: policyContext.currentHoldId,\n        idempotencyKey,\n        error: error instanceof Error ? error.message : String(error),\n      },\n      severity: \"error\",\n    });\n\n    throw error;\n  }\n}\n\nexport async function assignTableToBooking(\n  bookingId: string,\n  tableIdOrIds: string | string[],\n  assignedBy: string | null,\n  client?: DbClient,\n  options?: { idempotencyKey?: string | null; requireAdjacency?: boolean; booking?: BookingRow },\n): Promise<string> {\n  if (!isAllocatorV2Enabled()) {\n    throw new AssignTablesRpcError({\n      message: \"Allocator v2 must be enabled to assign tables\",\n      code: \"ALLOCATOR_V2_DISABLED\",\n      details: null,\n      hint: \"Enable allocator.v2.enabled to call assignTableToBooking\",\n    });\n  }\n\n  const supabase = ensureClient(client);\n  const tableIds = Array.isArray(tableIdOrIds) ? tableIdOrIds : [tableIdOrIds];\n  if (tableIds.length === 0) {\n    throw new ManualSelectionInputError(\"Must provide at least one table id\", \"TABLES_REQUIRED\");\n  }\n\n  const booking = options?.booking ?? (await loadBooking(bookingId, supabase));\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const { window } = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n  const startIso = toIsoUtc(window.block.start);\n  const endIso = toIsoUtc(window.block.end);\n  const normalizedTableIds = normalizeTableIds(tableIds);\n  const planSignature = createPlanSignature({\n    bookingId,\n    tableIds: normalizedTableIds,\n    startAt: startIso,\n    endAt: endIso,\n    salt: options?.idempotencyKey ?? undefined,\n  });\n  const policyVersion = hashPolicyVersion(policy);\n  const deterministicKey = createDeterministicIdempotencyKey({\n    tenantId: booking.restaurant_id,\n    bookingId,\n    tableIds: normalizedTableIds,\n    startAt: startIso,\n    endAt: endIso,\n    policyVersion,\n  });\n  const idempotencyKey = options?.idempotencyKey ?? deterministicKey;\n  const requireAdjacency = options?.requireAdjacency ?? false;\n\n  const orchestrator = new AssignmentOrchestrator(new SupabaseAssignmentRepository(supabase));\n  let response;\n  try {\n    response = await orchestrator.commitPlan(\n      {\n        bookingId,\n        restaurantId: booking.restaurant_id,\n        partySize: booking.party_size,\n        serviceDate: booking.booking_date ?? null,\n        window: {\n          startAt: startIso,\n          endAt: endIso,\n        },\n      },\n      {\n        signature: planSignature,\n        tableIds: normalizedTableIds,\n        startAt: startIso,\n        endAt: endIso,\n        metadata: {\n          requestSource: \"assignTableToBooking\",\n        },\n      },\n      {\n        source: \"manual\",\n        idempotencyKey,\n        actorId: assignedBy,\n        metadata: {\n          requireAdjacency,\n        },\n        requireAdjacency,\n      },\n    );\n  } catch (error) {\n    if (error instanceof AssignmentConflictError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_CONFLICT\",\n        details: serializeDetails(error.details),\n        hint: error.details?.hint ?? null,\n      });\n    }\n\n    if (error instanceof AssignmentValidationError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_VALIDATION\",\n        details: serializeDetails(error.details),\n        hint: null,\n      });\n    }\n\n    if (error instanceof AssignmentRepositoryError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_REPOSITORY_ERROR\",\n        details: serializeDetails(error.cause ?? null),\n        hint: null,\n      });\n    }\n\n    throw error;\n  }\n\n  const synchronized = await synchronizeAssignments({\n    supabase,\n    booking,\n    tableIds: normalizedTableIds,\n    idempotencyKey,\n    assignments: response.assignments.map((assignment) => ({\n      tableId: assignment.tableId,\n      startAt: assignment.startAt,\n      endAt: assignment.endAt,\n      mergeGroupId: assignment.mergeGroupId ?? response.mergeGroupId ?? null,\n    })),\n    startIso,\n    endIso,\n    actorId: assignedBy,\n    mergeGroupId: response.mergeGroupId ?? null,\n  });\n\n  const firstAssignment = synchronized[0];\n  if (!firstAssignment) {\n    throw new AssignTablesRpcError({\n      message: \"Assignment failed with no records returned\",\n      code: \"ASSIGNMENT_EMPTY\",\n      details: null,\n      hint: null,\n    });\n  }\n\n  // Enqueue assignment sync observability event (post-commit)\n  try {\n    const { enqueueOutboxEvent } = await import(\"@/server/outbox\");\n    await enqueueOutboxEvent({\n      eventType: \"capacity.assignment.sync\",\n      restaurantId: booking.restaurant_id,\n      bookingId: booking.id,\n      idempotencyKey,\n      dedupeKey: `${booking.id}:${startIso}:${endIso}:${normalizedTableIds.join(',')}`,\n      payload: {\n        bookingId: booking.id,\n        restaurantId: booking.restaurant_id,\n        tableIds: normalizedTableIds,\n        startAt: startIso,\n        endAt: endIso,\n        mergeGroupId: response.mergeGroupId ?? null,\n        idempotencyKey,\n      },\n    });\n  } catch (e) {\n    console.warn(\"[capacity.outbox] enqueue assignment.sync failed\", { bookingId: booking.id, error: e });\n  }\n\n  return firstAssignment.assignmentId;\n}\n\nexport async function unassignTableFromBooking(\n  bookingId: string,\n  tableId: string,\n  client?: DbClient,\n): Promise<boolean> {\n  const supabase = ensureClient(client);\n  const { data, error } = await supabase.rpc(\"unassign_tables_atomic\", {\n    p_booking_id: bookingId,\n    p_table_ids: [tableId],\n  });\n  if (error) {\n    return false;\n  }\n  return Array.isArray(data) && data.length > 0;\n}\n\nexport async function getBookingTableAssignments(\n  bookingId: string,\n  client?: DbClient,\n): Promise<TableAssignmentMember[]> {\n  const supabase = ensureClient(client);\n  const { data, error } = await supabase\n    .from(\"booking_table_assignments\")\n    .select(\"table_id, id, assigned_at\")\n    .eq(\"booking_id\", bookingId);\n\n  if (error || !data) {\n    return [];\n  }\n\n  return data.map((row) => ({\n    tableId: row.table_id,\n    assignmentId: row.id,\n    startAt: row.assigned_at ?? \"\",\n    endAt: row.assigned_at ?? \"\",\n    mergeGroupId: null,\n  }));\n}\n",
  "server/capacity/table-assignment/availability.ts": "import { performance } from \"node:perf_hooks\";\n\nimport { AssignTablesRpcError } from \"@/server/capacity/holds\";\nimport { createAvailabilityBitset, markWindow, isWindowFree } from \"@/server/capacity/planner/bitset\";\nimport { getVenuePolicy, type VenuePolicy, type SelectorScoringConfig, type ServiceKey } from \"@/server/capacity/policy\";\nimport { buildScoredTablePlans, type RankedTablePlan, type CandidateDiagnostics, type BuildCandidatesResult } from \"@/server/capacity/selector\";\nimport { windowsOverlap } from \"@/server/capacity/time-windows\";\nimport { getAllocatorAdjacencyMinPartySize, isAllocatorAdjacencyRequired, isPlannerTimePruningEnabled } from \"@/server/feature-flags\";\n\nimport { computeBookingWindowWithFallback, type BookingWindowWithFallback } from \"./booking-window\";\nimport { ensureClient, extractErrorCode, type ContextBookingRow } from \"./supabase\";\nimport { type BookingWindow, type Table, type ManualAssignmentConflict, type DbClient } from \"./types\";\nimport { toIsoUtc, serializeDetails } from \"./utils\";\n\nimport type { TableHold } from \"@/server/capacity/holds\";\nimport type { getSelectorPlannerLimits} from \"@/server/feature-flags\";\nimport type { Tables } from \"@/types/supabase\";\n\ntype BusyWindow = {\n  tableId: string;\n  startAt: string;\n  endAt: string;\n  bookingId: string | null;\n  source: \"booking\" | \"hold\";\n};\n\nexport type AvailabilityMap = Map<\n  string,\n  {\n    bitset: ReturnType<typeof createAvailabilityBitset>;\n    windows: BusyWindow[];\n  }\n>;\n\nexport type TimeFilterMode = \"strict\" | \"approx\";\n\nexport type TimeFilterStats = {\n  prunedByTime: number;\n  candidatesAfterTimePrune: number;\n  pruned_by_time: number;\n  candidates_after_time_prune: number;\n};\n\nexport type TimeFilterOptions = {\n  busy: AvailabilityMap;\n  mode?: TimeFilterMode;\n  captureStats?: (stats: TimeFilterStats) => void;\n};\n\nexport function filterTimeAvailableTables(\n  tables: Table[],\n  window: BookingWindow,\n  busy: AvailabilityMap | undefined,\n  mode: TimeFilterMode,\n  captureStats?: (stats: TimeFilterStats) => void,\n): Table[] {\n  const DEBUG = process.env.CAPACITY_DEBUG === '1' || process.env.CAPACITY_DEBUG === 'true';\n  if (!busy || busy.size === 0 || mode === \"approx\") {\n    captureStats?.({\n      prunedByTime: 0,\n      candidatesAfterTimePrune: tables.length,\n      pruned_by_time: 0,\n      candidates_after_time_prune: tables.length,\n    });\n    if (DEBUG) {\n      console.warn('[capacity.debug][time-filter] skipped (no busy map or approx mode)', {\n        input: tables.length,\n        mode,\n      });\n    }\n    return tables;\n  }\n\n  const targetStart = toIsoUtc(window.block.start);\n  const targetEnd = toIsoUtc(window.block.end);\n  let prunedByTime = 0;\n\n  const filtered = tables.filter((table) => {\n    const entry = busy.get(table.id);\n    if (!entry) {\n      return true;\n    }\n    const free = isWindowFree(entry.bitset, targetStart, targetEnd);\n    if (!free) {\n      prunedByTime += 1;\n      return false;\n    }\n    return true;\n  });\n\n  captureStats?.({\n    prunedByTime,\n    candidatesAfterTimePrune: filtered.length,\n    pruned_by_time: prunedByTime,\n    candidates_after_time_prune: filtered.length,\n  });\n\n  if (DEBUG) {\n    console.warn('[capacity.debug][time-filter] applied', {\n      input: tables.length,\n      prunedByTime,\n      remaining: filtered.length,\n      start: toIsoUtc(window.block.start),\n      end: toIsoUtc(window.block.end),\n    });\n  }\n\n  return filtered;\n}\n\nexport function filterAvailableTables(\n  tables: Table[],\n  partySize: number,\n  window: BookingWindow,\n  adjacency: Map<string, Set<string>>,\n  avoidTables?: Set<string>,\n  zoneId?: string | null,\n  options?: { \n    allowInsufficientCapacity?: boolean; \n    allowMaxPartySizeViolation?: boolean;  // NEW: allow tables that violate maxPartySize (for combinations)\n    timeFilter?: TimeFilterOptions \n  },\n): Table[] {\n  const DEBUG = process.env.CAPACITY_DEBUG === '1' || process.env.CAPACITY_DEBUG === 'true';\n  const allowPartial = options?.allowInsufficientCapacity ?? false;\n  const allowMaxPartySizeViolation = options?.allowMaxPartySizeViolation ?? false;\n  const avoid = avoidTables ?? new Set<string>();\n\n  if (DEBUG) {\n    console.warn('[capacity.debug][filter] input', {\n      tables: tables.length,\n      partySize,\n      windowStart: toIsoUtc(window.block.start),\n      windowEnd: toIsoUtc(window.block.end),\n      allowPartial,\n      allowMaxPartySizeViolation,\n      zoneId: zoneId ?? null,\n      avoidCount: avoid.size,\n    });\n  }\n\n  const filtered = tables.filter((table) => {\n    if (!table) return false;\n    if (avoid.has(table.id)) return false;\n    if (zoneId && table.zoneId !== zoneId) return false;\n    if (table.active === false) return false;\n    if (typeof table.status === \"string\" && table.status.toLowerCase() === \"out_of_service\") return false;\n    const capacity = table.capacity ?? 0;\n    if (!Number.isFinite(capacity) || capacity <= 0) return false;\n    if (!allowPartial && capacity < partySize) return false;\n    \n    // FIX: Only enforce maxPartySize if not allowing violations (for combinations)\n    if (!allowMaxPartySizeViolation && typeof table.maxPartySize === \"number\" && table.maxPartySize > 0 && partySize > table.maxPartySize) {\n      return false;\n    }\n    \n    if (typeof table.minPartySize === \"number\" && table.minPartySize > 0 && partySize < table.minPartySize) {\n      return false;\n    }\n    // Require explicit adjacency info when enforcement is on; missing entry means we cannot validate.\n    if (partiesRequireAdjacency(partySize) && !adjacency.has(table.id)) {\n      return false;\n    }\n    return true;\n  });\n\n  if (DEBUG) {\n    console.warn('[capacity.debug][filter] after basic', { remaining: filtered.length });\n  }\n\n  const timeFiltered =\n    options?.timeFilter && window\n      ? filterTimeAvailableTables(filtered, window, options.timeFilter.busy, options.timeFilter.mode ?? \"strict\", (stats) =>\n          options.timeFilter?.captureStats?.(stats),\n        )\n      : filtered;\n\n  if (DEBUG) {\n    console.warn('[capacity.debug][filter] after time', { remaining: timeFiltered.length });\n  }\n\n  return timeFiltered.sort((a, b) => {\n    const capacityDiff = (a.capacity ?? 0) - (b.capacity ?? 0);\n    if (capacityDiff !== 0) return capacityDiff;\n    return a.tableNumber.localeCompare(b.tableNumber);\n  });\n}\n\nexport function partiesRequireAdjacency(partySize: number): boolean {\n  if (!isAllocatorAdjacencyRequired()) {\n    return false;\n  }\n  const minPartySize = getAllocatorAdjacencyMinPartySize();\n  if (typeof minPartySize === \"number\") {\n    return partySize >= minPartySize;\n  }\n  return true;\n}\n\nexport function resolveRequireAdjacency(partySize: number, override?: boolean): boolean {\n  if (typeof override === \"boolean\") {\n   return override;\n  }\n  return partiesRequireAdjacency(partySize);\n}\n\nexport type LookaheadConfig = {\n  enabled: boolean;\n  windowMinutes: number;\n  penaltyWeight: number;\n  blockThreshold: number;\n};\n\ntype FutureBookingCandidate = {\n  bookingId: string;\n  partySize: number;\n  window: BookingWindow;\n  busy: AvailabilityMap;\n  usedFallback: boolean;\n  fallbackService: ServiceKey | null;\n};\n\nfunction prepareLookaheadBookings(params: {\n  bookingId: string;\n  currentWindow: BookingWindow;\n  lookahead: LookaheadConfig;\n  policy: VenuePolicy;\n  contextBookings: ContextBookingRow[];\n  holds: TableHold[];\n}): FutureBookingCandidate[] {\n  const { bookingId, currentWindow, lookahead, policy, contextBookings, holds } = params;\n  if (!lookahead.enabled || lookahead.windowMinutes <= 0) {\n    return [];\n  }\n\n  const cutoff = currentWindow.block.start.plus({ minutes: lookahead.windowMinutes });\n  const candidates: FutureBookingCandidate[] = [];\n\n  for (const booking of contextBookings) {\n    if (!booking || booking.id === bookingId) {\n      continue;\n    }\n\n    const partySize = booking.party_size ?? 0;\n    if (!Number.isFinite(partySize) || partySize <= 0) {\n      continue;\n    }\n\n    const assignments = booking.booking_table_assignments ?? [];\n    if (assignments.length > 0) {\n      continue;\n    }\n\n    let computed: BookingWindowWithFallback;\n    try {\n      computed = computeBookingWindowWithFallback({\n        startISO: booking.start_at,\n        bookingDate: booking.booking_date,\n        startTime: booking.start_time,\n        partySize,\n        policy,\n      });\n    } catch {\n      continue;\n    }\n\n    const { window } = computed;\n    if (window.block.start <= currentWindow.block.start) {\n      continue;\n    }\n\n    if (window.block.start > cutoff) {\n      continue;\n    }\n\n    const busy = buildBusyMaps({\n      targetBookingId: booking.id,\n      bookings: contextBookings,\n      holds,\n      policy,\n      targetWindow: window,\n    });\n\n    candidates.push({\n      bookingId: booking.id,\n      partySize,\n      window,\n      busy,\n      usedFallback: computed.usedFallback,\n      fallbackService: computed.fallbackService,\n    });\n  }\n\n  return candidates;\n}\n\nfunction applyLookaheadPenalties(params: {\n  plans: RankedTablePlan[];\n  bookingWindow: BookingWindow;\n  tables: Table[];\n  adjacency: Map<string, Set<string>>;\n  zoneId: string | null;\n  futureBookings: FutureBookingCandidate[];\n  config: SelectorScoringConfig;\n  combinationEnabled: boolean;\n  combinationLimit: number;\n  selectorLimits: ReturnType<typeof getSelectorPlannerLimits>;\n  penaltyWeight: number;\n  blockThreshold: number;\n}): {\n  penalizedPlans: number;\n  totalPenalty: number;\n  evaluationMs: number;\n  conflicts: Array<{ bookingId: string; planKey: string }>;\n  blockedPlans: string[];\n  timeBudgetHit: boolean;\n  precheckedConflicts: number;\n} {\n  const {\n    plans,\n    bookingWindow,\n    tables,\n    adjacency,\n    zoneId,\n    futureBookings,\n    config,\n    combinationEnabled,\n    combinationLimit,\n    selectorLimits,\n    penaltyWeight,\n    blockThreshold,\n  } = params;\n  const start = performance.now();\n  const MAX_LOOKAHEAD_PLANS = Math.min(20, plans.length);\n  const LOOKAHEAD_TIME_BUDGET_MS = Math.max(15, Math.min(100, selectorLimits.enumerationTimeoutMs ?? 50));\n\n  if (futureBookings.length === 0 || plans.length === 0 || penaltyWeight <= 0) {\n    return {\n      penalizedPlans: 0,\n      totalPenalty: 0,\n      evaluationMs: performance.now() - start,\n      conflicts: [],\n      blockedPlans: [],\n      timeBudgetHit: false,\n      precheckedConflicts: 0,\n    };\n  }\n\n  let penalizedPlans = 0;\n  let totalPenalty = 0;\n  const conflicts: Array<{ bookingId: string; planKey: string }> = [];\n  const blockedPlanKeys = new Set<string>();\n  let timeBudgetHit = false;\n  let precheckedConflicts = 0;\n\n  const quickCapacityFeasible = (\n    candidateTables: Table[],\n    required: number,\n    kLimit: number,\n    baseZone: string | null,\n  ): boolean => {\n    if (kLimit <= 0 || candidateTables.length === 0) {\n      return false;\n    }\n    const caps: number[] = [];\n    for (const table of candidateTables) {\n      if (baseZone && table.zoneId && table.zoneId !== baseZone) {\n        continue;\n      }\n      const capacity = table.capacity ?? 0;\n      if (capacity > 0) {\n        caps.push(capacity);\n      }\n    }\n    if (caps.length === 0) {\n      return false;\n    }\n    caps.sort((a, b) => b - a);\n    const upperBound = caps.slice(0, Math.min(kLimit, caps.length)).reduce((sum, value) => sum + value, 0);\n    return upperBound >= required;\n  };\n\n  for (const plan of plans.slice(0, MAX_LOOKAHEAD_PLANS)) {\n    if (performance.now() - start > LOOKAHEAD_TIME_BUDGET_MS) {\n      timeBudgetHit = true;\n      break;\n    }\n\n    let planPenalty = 0;\n    const avoidTables = new Set(plan.tables.map((table) => table.id));\n\n    for (const future of futureBookings) {\n      if (!windowsOverlap(bookingWindow.block, future.window.block)) {\n        continue;\n      }\n\n      const requireAdjacencyForFuture = resolveRequireAdjacency(future.partySize);\n      const availableTables = filterAvailableTables(\n        tables,\n        future.partySize,\n        future.window,\n        adjacency,\n        avoidTables,\n        zoneId ?? null,\n        {\n          allowInsufficientCapacity: true,\n          allowMaxPartySizeViolation: combinationEnabled,\n          timeFilter: {\n            busy: future.busy,\n            mode: \"strict\",\n          },\n        },\n      );\n\n      if (availableTables.length === 0) {\n        planPenalty += penaltyWeight;\n        conflicts.push({ bookingId: future.bookingId, planKey: plan.tableKey });\n        continue;\n      }\n\n      if (!quickCapacityFeasible(availableTables, future.partySize, combinationLimit, zoneId ?? null)) {\n        planPenalty += penaltyWeight;\n        conflicts.push({ bookingId: future.bookingId, planKey: plan.tableKey });\n        precheckedConflicts += 1;\n        continue;\n      }\n\n      const futurePlans = buildScoredTablePlans({\n        tables: availableTables,\n        partySize: future.partySize,\n        adjacency,\n        config,\n        enableCombinations: combinationEnabled,\n        kMax: combinationLimit,\n        maxPlansPerSlack: selectorLimits.maxPlansPerSlack,\n        maxCombinationEvaluations: selectorLimits.maxCombinationEvaluations,\n        enumerationTimeoutMs: selectorLimits.enumerationTimeoutMs,\n        requireAdjacency: requireAdjacencyForFuture,\n        demandMultiplier: 1,\n      });\n\n      if (futurePlans.plans.length === 0) {\n        planPenalty += penaltyWeight;\n        conflicts.push({ bookingId: future.bookingId, planKey: plan.tableKey });\n      }\n    }\n\n    if (planPenalty > 0) {\n      penalizedPlans += 1;\n      totalPenalty += planPenalty;\n      plan.score += planPenalty;\n      plan.scoreBreakdown.futureConflictPenalty =\n        (plan.scoreBreakdown.futureConflictPenalty ?? 0) + planPenalty;\n      plan.scoreBreakdown.total += planPenalty;\n    }\n\n    if (blockThreshold > 0 && planPenalty >= blockThreshold) {\n      blockedPlanKeys.add(plan.tableKey);\n    }\n  }\n\n  if (blockedPlanKeys.size > 0) {\n    for (let index = plans.length - 1; index >= 0; index -= 1) {\n      if (blockedPlanKeys.has(plans[index].tableKey)) {\n        plans.splice(index, 1);\n      }\n    }\n  }\n\n  const evaluationMs = performance.now() - start;\n  return {\n    penalizedPlans,\n    totalPenalty,\n    evaluationMs,\n    conflicts,\n    blockedPlans: Array.from(blockedPlanKeys),\n    timeBudgetHit,\n    precheckedConflicts,\n  };\n}\n\nexport function evaluateLookahead(params: {\n  lookahead: LookaheadConfig;\n  bookingId: string;\n  bookingWindow: BookingWindow;\n  plansResult: BuildCandidatesResult;\n  tables: Table[];\n  adjacency: Map<string, Set<string>>;\n  zoneId: string | null;\n  policy: VenuePolicy;\n  contextBookings: ContextBookingRow[];\n  holds: TableHold[];\n  combinationEnabled: boolean;\n  combinationLimit: number;\n  selectorLimits: ReturnType<typeof getSelectorPlannerLimits>;\n  scoringConfig: SelectorScoringConfig;\n}): CandidateDiagnostics[\"lookahead\"] {\n  const {\n    lookahead,\n    bookingId,\n    bookingWindow,\n    plansResult,\n    tables,\n    adjacency,\n    zoneId,\n    policy,\n    contextBookings,\n    holds,\n    combinationEnabled,\n    combinationLimit,\n    selectorLimits,\n    scoringConfig,\n  } = params;\n\n  if (!lookahead.enabled) {\n    return {\n      enabled: false,\n      evaluationMs: 0,\n      futureBookingsConsidered: 0,\n      penalizedPlans: 0,\n      totalPenalty: 0,\n      windowMinutes: lookahead.windowMinutes,\n      conflicts: [],\n      blockedPlans: [],\n      hardBlockTriggered: false,\n      plansConsidered: 0,\n      plansEvaluated: 0,\n      timeBudgetHit: false,\n      precheckedConflicts: 0,\n    };\n  }\n\n  const futureBookings = prepareLookaheadBookings({\n    bookingId,\n    currentWindow: bookingWindow,\n    lookahead,\n    policy,\n    contextBookings,\n    holds,\n  });\n\n  if (futureBookings.length === 0 || plansResult.plans.length === 0) {\n    return {\n      enabled: true,\n      evaluationMs: 0,\n      futureBookingsConsidered: futureBookings.length,\n      penalizedPlans: 0,\n      totalPenalty: 0,\n      windowMinutes: lookahead.windowMinutes,\n      conflicts: [],\n      blockedPlans: [],\n      hardBlockTriggered: false,\n      plansConsidered: 0,\n      plansEvaluated: 0,\n      timeBudgetHit: false,\n      precheckedConflicts: 0,\n    };\n  }\n\n  const { penalizedPlans, totalPenalty, evaluationMs, conflicts, blockedPlans, timeBudgetHit, precheckedConflicts } = applyLookaheadPenalties({\n    plans: plansResult.plans,\n    bookingWindow,\n    tables,\n    adjacency,\n    zoneId,\n    futureBookings,\n    config: scoringConfig,\n    combinationEnabled,\n    combinationLimit,\n    selectorLimits,\n    penaltyWeight: lookahead.penaltyWeight,\n    blockThreshold: lookahead.blockThreshold,\n  });\n\n  if (plansResult.plans.length === 0) {\n    return {\n      enabled: true,\n      evaluationMs,\n      futureBookingsConsidered: futureBookings.length,\n      penalizedPlans,\n      totalPenalty,\n      windowMinutes: lookahead.windowMinutes,\n      conflicts,\n      blockedPlans,\n      hardBlockTriggered: blockedPlans.length > 0,\n      plansConsidered: Math.min(20, plansResult.plans.length),\n      plansEvaluated: Math.min(20, plansResult.plans.length),\n      timeBudgetHit,\n      precheckedConflicts,\n    };\n  }\n\n  if (penalizedPlans > 0) {\n    sortPlansByScore(plansResult.plans);\n  }\n\n  return {\n    enabled: true,\n    evaluationMs,\n    futureBookingsConsidered: futureBookings.length,\n    penalizedPlans,\n    totalPenalty,\n    windowMinutes: lookahead.windowMinutes,\n    conflicts,\n    blockedPlans,\n    hardBlockTriggered: blockedPlans.length > 0,\n    // Best-effort estimates; exact counts are cheap to compute here\n    plansConsidered: Math.min(20, plansResult.plans.length),\n    plansEvaluated: Math.min(20, plansResult.plans.length),\n    timeBudgetHit,\n    precheckedConflicts,\n  };\n}\n\nfunction sortPlansByScore(plans: RankedTablePlan[]): void {\n  plans.sort((a, b) => {\n    if (a.score !== b.score) {\n      return a.score - b.score;\n    }\n    if (a.metrics.overage !== b.metrics.overage) {\n      return a.metrics.overage - b.metrics.overage;\n    }\n    if (a.metrics.tableCount !== b.metrics.tableCount) {\n      return a.metrics.tableCount - b.metrics.tableCount;\n    }\n    if (a.totalCapacity !== b.totalCapacity) {\n      return a.totalCapacity - b.totalCapacity;\n    }\n    if (a.metrics.fragmentation !== b.metrics.fragmentation) {\n      return a.metrics.fragmentation - b.metrics.fragmentation;\n    }\n    if (a.metrics.adjacencyCost !== b.metrics.adjacencyCost) {\n      return a.metrics.adjacencyCost - b.metrics.adjacencyCost;\n    }\n    return a.tableKey.localeCompare(b.tableKey, \"en\");\n  });\n}\n\nfunction registerBusyWindow(\n  map: AvailabilityMap,\n  tableId: string,\n  window: { startAt: string; endAt: string; bookingId: string | null; source: \"booking\" | \"hold\" },\n): void {\n  if (!map.has(tableId)) {\n    map.set(tableId, {\n      bitset: createAvailabilityBitset(),\n      windows: [],\n    });\n  }\n  const entry = map.get(tableId)!;\n  markWindow(entry.bitset, window.startAt, window.endAt);\n  entry.windows.push({\n    tableId,\n    ...window,\n  });\n}\n\nexport function buildBusyMaps(params: {\n  targetBookingId: string;\n  bookings: ContextBookingRow[];\n  holds: TableHold[];\n  excludeHoldId?: string | null;\n  policy: VenuePolicy;\n  targetWindow?: BookingWindow | null;\n}): AvailabilityMap {\n  const { targetBookingId, bookings, holds, excludeHoldId, policy, targetWindow } = params;\n  const map: AvailabilityMap = new Map();\n  const pruneToTargetWindow = isPlannerTimePruningEnabled();\n  const targetInterval =\n    pruneToTargetWindow && targetWindow\n      ? {\n          start: toIsoUtc(targetWindow.block.start),\n          end: toIsoUtc(targetWindow.block.end),\n        }\n      : null;\n\n  for (const booking of bookings) {\n    if (booking.id === targetBookingId) continue;\n    const assignments = booking.booking_table_assignments ?? [];\n    if (assignments.length === 0) continue;\n\n    const { window } = computeBookingWindowWithFallback({\n      startISO: booking.start_at,\n      bookingDate: booking.booking_date,\n      startTime: booking.start_time,\n      partySize: booking.party_size,\n      policy,\n    });\n\n    const bookingInterval = {\n      start: toIsoUtc(window.block.start),\n      end: toIsoUtc(window.block.end),\n    };\n\n    if (targetInterval && !windowsOverlap(bookingInterval, targetInterval)) {\n      continue;\n    }\n\n    for (const assignment of assignments) {\n      if (!assignment?.table_id) continue;\n      registerBusyWindow(map, assignment.table_id, {\n        startAt: bookingInterval.start,\n        endAt: bookingInterval.end,\n        bookingId: booking.id,\n        source: \"booking\",\n      });\n    }\n  }\n\n  for (const hold of holds) {\n    if (excludeHoldId && hold.id === excludeHoldId) continue;\n    if (\n      targetInterval &&\n      !windowsOverlap(\n        { start: hold.startAt, end: hold.endAt },\n        targetInterval,\n      )\n    ) {\n      continue;\n    }\n    for (const tableId of hold.tableIds) {\n      registerBusyWindow(map, tableId, {\n        startAt: hold.startAt,\n        endAt: hold.endAt,\n        bookingId: hold.bookingId,\n        source: \"hold\",\n      });\n    }\n  }\n\n  return map;\n}\n\nexport function extractConflictsForTables(\n  busy: AvailabilityMap,\n  tableIds: string[],\n  window: BookingWindow,\n): ManualAssignmentConflict[] {\n  const conflicts: ManualAssignmentConflict[] = [];\n  const targetStart = toIsoUtc(window.block.start);\n  const targetEnd = toIsoUtc(window.block.end);\n\n  for (const tableId of tableIds) {\n    const entry = busy.get(tableId);\n    if (!entry) continue;\n    if (isWindowFree(entry.bitset, targetStart, targetEnd)) continue;\n    for (const other of entry.windows) {\n      if (windowsOverlap({ start: targetStart, end: targetEnd }, { start: other.startAt, end: other.endAt })) {\n        conflicts.push({\n          tableId,\n          bookingId: other.bookingId,\n          startAt: other.startAt,\n          endAt: other.endAt,\n          source: other.source,\n        });\n      }\n    }\n  }\n\n  return conflicts;\n}\n\ntype AssignmentAvailabilityRow = {\n  table_id: string | null;\n  start_at: string | null;\n  end_at: string | null;\n  bookings: Pick<Tables<\"bookings\">, \"id\" | \"status\" | \"start_at\" | \"end_at\"> | null;\n};\n\nasync function legacyTableAvailabilityCheck(params: {\n  supabase: DbClient;\n  tableId: string;\n  startAt: string;\n  endAt: string;\n  excludeBookingId?: string | null;\n}): Promise<boolean> {\n  const { supabase, tableId, startAt, endAt, excludeBookingId } = params;\n\n  const { data, error } = await supabase\n    .from(\"booking_table_assignments\")\n    .select(\"table_id, start_at, end_at, bookings(id, status, start_at, end_at)\")\n    .eq(\"table_id\", tableId);\n\n  if (error || !data) {\n    throw new AssignTablesRpcError({\n      message: error?.message ?? \"Failed to query table availability\",\n      code: \"TABLE_AVAILABILITY_QUERY_FAILED\",\n      details: serializeDetails({\n        code: (error as { code?: string })?.code ?? null,\n        details: error?.details ?? null,\n        hint: error?.hint ?? null,\n      }),\n      hint: null,\n    });\n  }\n\n  const rows = data as AssignmentAvailabilityRow[];\n  for (const row of rows) {\n    const booking = row.bookings;\n    if (excludeBookingId && booking?.id === excludeBookingId) {\n      continue;\n    }\n    if (booking && ![\"pending\", \"confirmed\", \"seated\"].includes(booking.status ?? \"\")) {\n      continue;\n    }\n    const otherStart = row.start_at ?? booking?.start_at;\n    const otherEnd = row.end_at ?? booking?.end_at;\n    if (!otherStart || !otherEnd) {\n      continue;\n    }\n    if (windowsOverlap({ start: startAt, end: endAt }, { start: otherStart, end: otherEnd })) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport async function isTableAvailableV2(\n  tableId: string,\n  startISO: string,\n  partySize: number,\n  options?: {\n    excludeBookingId?: string;\n    policy?: VenuePolicy;\n    client?: DbClient;\n  },\n): Promise<boolean> {\n  const supabase = ensureClient(options?.client);\n  const policy = options?.policy ?? getVenuePolicy();\n  const { window } = computeBookingWindowWithFallback({\n    startISO,\n    partySize,\n    policy,\n  });\n\n  const startAt = toIsoUtc(window.block.start);\n  const endAt = toIsoUtc(window.block.end);\n\n  try {\n    const { data, error } = await (supabase as unknown as {\n      rpc: (\n        fn: string,\n        args: {\n          p_table_id: string;\n          p_start_at: string;\n          p_end_at: string;\n          p_exclude_booking_id: string | null;\n        },\n      ) => Promise<{ data: boolean | null; error: { message?: string; details?: string | null; hint?: string | null; code?: string | null } | null }>;\n    }).rpc(\"is_table_available_v2\", {\n      p_table_id: tableId,\n      p_start_at: startAt,\n      p_end_at: endAt,\n      p_exclude_booking_id: options?.excludeBookingId ?? null,\n    });\n\n    if (error) {\n      const code = extractErrorCode(error);\n      if (code === \"42883\" || code === \"42P01\") {\n        return await legacyTableAvailabilityCheck({\n          supabase,\n          tableId,\n          startAt,\n          endAt,\n          excludeBookingId: options?.excludeBookingId ?? null,\n        });\n      }\n      throw new AssignTablesRpcError({\n        message: error.message ?? \"Failed to query table availability\",\n        code: \"TABLE_AVAILABILITY_QUERY_FAILED\",\n        details: serializeDetails({\n          code: code ?? null,\n          details: error.details ?? null,\n          hint: error.hint ?? null,\n        }),\n        hint: null,\n      });\n    }\n\n    if (typeof data === \"boolean\") {\n      return data;\n    }\n  } catch (error) {\n    const code = extractErrorCode(error);\n    if (code !== \"42883\" && code !== \"42P01\") {\n      throw new AssignTablesRpcError({\n        message: error instanceof Error ? error.message : \"Failed to verify table availability\",\n        code: \"TABLE_AVAILABILITY_QUERY_FAILED\",\n        details: error instanceof Error ? error.stack ?? null : null,\n        hint: null,\n      });\n    }\n    return await legacyTableAvailabilityCheck({\n      supabase,\n      tableId,\n      startAt,\n      endAt,\n      excludeBookingId: options?.excludeBookingId ?? null,\n    });\n  }\n\n  return await legacyTableAvailabilityCheck({\n    supabase,\n    tableId,\n    startAt,\n    endAt,\n    excludeBookingId: options?.excludeBookingId ?? null,\n  });\n}\n\nexport async function isTableAvailable(\n  tableId: string,\n  startISO: string,\n  partySize: number,\n  options?: {\n    excludeBookingId?: string;\n    policy?: VenuePolicy;\n    client?: DbClient;\n  },\n): Promise<boolean> {\n  try {\n    return await isTableAvailableV2(tableId, startISO, partySize, options);\n  } catch (error) {\n    if (error instanceof AssignTablesRpcError) {\n      throw new AssignTablesRpcError({\n        message: \"Failed to verify table availability\",\n        code: error.code ?? \"TABLE_AVAILABILITY_QUERY_FAILED\",\n        details: error.details,\n        hint: error.hint ?? null,\n      });\n    }\n    throw error;\n  }\n}\n",
  "server/capacity/table-assignment/booking-window.ts": "import { DateTime } from \"luxon\";\n\nimport {\n  bandDuration,\n  getBufferConfig,\n  getVenuePolicy,\n  serviceEnd,\n  whichService,\n  ServiceNotFoundError,\n  ServiceOverrunError,\n  type ServiceKey,\n  type VenuePolicy,\n} from \"@/server/capacity/policy\";\nimport { isAllocatorServiceFailHard } from \"@/server/feature-flags\";\n\nimport { ManualSelectionInputError, type BookingWindow } from \"./types\";\n\nexport type ComputeWindowArgs = {\n  startISO?: string | null;\n  bookingDate?: string | null;\n  startTime?: string | null;\n  partySize: number;\n  policy?: VenuePolicy;\n  serviceHint?: ServiceKey | null;\n};\n\nexport type BookingWindowWithFallback = {\n  window: BookingWindow;\n  usedFallback: boolean;\n  fallbackService: ServiceKey | null;\n};\n\nexport function computeBookingWindow(args: ComputeWindowArgs): BookingWindow {\n  const policy = args.policy ?? getVenuePolicy();\n  const baseStart = resolveStartDateTime(args, policy);\n  const service = resolveService(baseStart, args.serviceHint ?? null, policy);\n  const serviceConfig = policy.services[service];\n  const allowOverrun = Boolean(serviceConfig?.allowOverrun);\n\n  const diningMinutes = bandDuration(service, args.partySize, policy);\n  const buffer = getBufferConfig(service, policy);\n  const diningStart = baseStart;\n  let diningEnd = diningStart.plus({ minutes: diningMinutes });\n  const blockStart = diningStart.minus({ minutes: buffer.pre ?? 0 });\n  let blockEnd = diningEnd.plus({ minutes: buffer.post ?? 0 });\n  let clampedToServiceEnd = false;\n\n  const serviceEndBoundary = serviceEnd(service, diningStart, policy);\n  if (!allowOverrun) {\n    if (blockEnd > serviceEndBoundary) {\n      blockEnd = serviceEndBoundary;\n      diningEnd = blockEnd.minus({ minutes: buffer.post ?? 0 });\n      if (diningEnd <= diningStart) {\n        throw new ServiceOverrunError(service, blockEnd, serviceEndBoundary);\n      }\n      clampedToServiceEnd = true;\n    }\n  }\n\n  return {\n    service,\n    durationMinutes: Math.max(1, Math.round(diningEnd.diff(diningStart, \"minutes\").minutes)),\n    dining: {\n      start: diningStart,\n      end: diningEnd,\n    },\n    block: {\n      start: blockStart,\n      end: blockEnd,\n    },\n    clampedToServiceEnd,\n  };\n}\n\nexport function computeBookingWindowWithFallback(args: ComputeWindowArgs): BookingWindowWithFallback {\n  const policy = args.policy ?? getVenuePolicy();\n  try {\n    const window = computeBookingWindow({ ...args, policy });\n    return {\n      window,\n      usedFallback: false,\n      fallbackService: null,\n    };\n  } catch (error) {\n    if (error instanceof ServiceNotFoundError) {\n      const serviceOrderCandidates = policy.serviceOrder.filter((key) => Boolean(policy.services[key]));\n      const servicesFallback = (Object.keys(policy.services) as ServiceKey[]).filter((key) => Boolean(policy.services[key]));\n      const fallbackService =\n        args.serviceHint && policy.services[args.serviceHint]\n          ? args.serviceHint\n          : serviceOrderCandidates[0] ?? servicesFallback[0];\n\n      if (!fallbackService || !policy.services[fallbackService]) {\n        throw error;\n      }\n\n      if (isAllocatorServiceFailHard()) {\n        throw error;\n      }\n\n      const fallbackWindow = computeBookingWindow({\n        ...args,\n        policy,\n        serviceHint: fallbackService,\n      });\n\n      console.warn(\"[capacity][window][fallback] service not found, using fallback service\", {\n        start: fallbackWindow.dining.start.toISO(),\n        fallbackService,\n        clamped: fallbackWindow.clampedToServiceEnd,\n      });\n\n      return {\n        window: fallbackWindow,\n        usedFallback: true,\n        fallbackService,\n      };\n    }\n\n    throw error;\n  }\n}\n\nfunction resolveStartDateTime(\n  args: {\n    startISO?: string | null;\n    bookingDate?: string | null;\n    startTime?: string | null;\n  },\n  policy: VenuePolicy,\n): DateTime {\n  if (args.startISO) {\n    const parsed = DateTime.fromISO(args.startISO);\n    if (!parsed.isValid) {\n      throw new ManualSelectionInputError(\"Invalid start ISO timestamp provided\", \"INVALID_START\");\n    }\n    return parsed.setZone(policy.timezone, { keepLocalTime: false });\n  }\n\n  const { bookingDate, startTime } = args;\n  if (!bookingDate || !startTime) {\n    throw new ManualSelectionInputError(\"Booking date and start time are required\", \"START_TIME_REQUIRED\");\n  }\n\n  const composed = DateTime.fromISO(`${bookingDate}T${startTime}`, { zone: policy.timezone });\n  if (!composed.isValid) {\n    throw new ManualSelectionInputError(\"Invalid booking date/time\", \"INVALID_START\");\n  }\n  return composed;\n}\n\nfunction resolveService(start: DateTime, hint: ServiceKey | null, policy: VenuePolicy): ServiceKey {\n  if (hint) {\n    return hint;\n  }\n  const found = whichService(start, policy);\n  if (!found) {\n    throw new ServiceNotFoundError(start);\n  }\n  return found;\n}\n",
  "server/capacity/table-assignment/constants.ts": "export const DEFAULT_HOLD_TTL_SECONDS = 180;\n\nexport const TABLE_RESOURCE_TYPE = \"table\";\n",
  "server/capacity/table-assignment/index.ts": "export * from \"./types\";\n\nexport { computeBookingWindow, computeBookingWindowWithFallback } from \"./booking-window\";\n\nexport {\n  filterAvailableTables,\n  filterTimeAvailableTables,\n  evaluateLookahead,\n  buildBusyMaps,\n  extractConflictsForTables,\n  isTableAvailableV2,\n  isTableAvailable,\n} from \"./availability\";\n\nexport {\n  evaluateManualSelection,\n  createManualHold,\n  getManualAssignmentContext,\n} from \"./manual\";\n\nexport {\n  confirmHoldAssignment,\n  atomicConfirmAndTransition,\n  assignTableToBooking,\n  unassignTableFromBooking,\n  getBookingTableAssignments,\n} from \"./assignment\";\n\nexport { quoteTablesForBooking, findSuitableTables } from \"./quote\";\n\nexport type { AvailabilityMap, TimeFilterStats, LookaheadConfig } from \"./availability\";\n\nexport { DEFAULT_HOLD_TTL_SECONDS, TABLE_RESOURCE_TYPE } from \"./constants\";\n",
  "server/capacity/table-assignment/manual.ts": "import { DateTime } from \"luxon\";\n\nimport { listActiveHoldsForBooking, createTableHold, findHoldConflicts, type HoldConflictInfo, type TableHold, type CreateTableHoldInput } from \"@/server/capacity/holds\";\nimport { getVenuePolicy, ServiceOverrunError } from \"@/server/capacity/policy\";\nimport { computePayloadChecksum, hashPolicyVersion } from \"@/server/capacity/v2\";\nimport { isHoldsEnabled, isHoldStrictConflictsEnabled, isAllocatorAdjacencyRequired, isAdjacencyQueryUndirected } from \"@/server/feature-flags\";\n\nimport { buildBusyMaps, extractConflictsForTables, resolveRequireAdjacency } from \"./availability\";\nimport { computeBookingWindowWithFallback } from \"./booking-window\";\nimport { DEFAULT_HOLD_TTL_SECONDS } from \"./constants\";\nimport { ensureClient, loadBooking, loadTablesByIds, loadTablesForRestaurant, loadAdjacency, loadContextBookings, fetchHoldsForWindow, loadTableAssignmentsForTables, loadRestaurantTimezone, releaseHoldWithRetry, extractErrorCode, type DbClient } from \"./supabase\";\nimport { ManualSelectionInputError, type ManualSelectionOptions, type ManualValidationResult, type ManualHoldOptions, type ManualHoldResult, type ManualSelectionSummary, type ManualSelectionCheck, type ManualAssignmentConflict, type ManualAssignmentContext, type ManualAssignmentContextHold, type Table, type BookingWindow } from \"./types\";\nimport { toIsoUtc, summarizeSelection } from \"./utils\";\n\n\nfunction evaluateAdjacency(\n  tableIds: string[],\n  adjacency: Map<string, Set<string>>,\n): { connected: boolean } {\n  if (tableIds.length <= 1) {\n    return { connected: true };\n  }\n  const queue = [tableIds[0]!];\n  const visited = new Set<string>([tableIds[0]!]);\n  while (queue.length > 0) {\n    const current = queue.shift();\n    if (!current) continue;\n    const neighbors = adjacency.get(current);\n    if (!neighbors) continue;\n    for (const neighbor of neighbors) {\n      if (!tableIds.includes(neighbor)) continue;\n      if (visited.has(neighbor)) continue;\n      visited.add(neighbor);\n      queue.push(neighbor);\n    }\n  }\n  return { connected: visited.size === tableIds.length };\n}\n\nfunction buildManualChecks(params: {\n  summary: ManualSelectionSummary;\n  tables: Table[];\n  requireAdjacency: boolean;\n  adjacency: Map<string, Set<string>>;\n  conflicts: ManualAssignmentConflict[];\n  holdConflicts: HoldConflictInfo[];\n}): ManualSelectionCheck[] {\n  const checks: ManualSelectionCheck[] = [];\n  const { summary, tables, requireAdjacency, adjacency, conflicts, holdConflicts } = params;\n\n  checks.push({\n    id: \"capacity\",\n    status: summary.totalCapacity >= summary.partySize ? \"ok\" : \"error\",\n    message:\n      summary.totalCapacity >= summary.partySize\n        ? \"Capacity satisfied\"\n        : \"Selected tables do not meet requested party size\",\n    details: {\n      totalCapacity: summary.totalCapacity,\n      partySize: summary.partySize,\n      slack: summary.slack,\n    },\n  });\n\n  if (summary.zoneId === null) {\n    checks.push({\n      id: \"zone\",\n      status: \"error\",\n      message: \"Tables must belong to the same zone for manual assignment\",\n    });\n  } else {\n    checks.push({\n      id: \"zone\",\n      status: \"ok\",\n      message: `Zone ${summary.zoneId} validated`,\n    });\n  }\n\n  if (tables.length > 1) {\n    const allMovable = tables.every((table) => table.mobility === \"movable\");\n    checks.push({\n      id: \"movable\",\n      status: allMovable ? \"ok\" : \"error\",\n      message: allMovable\n        ? \"All tables are movable\"\n        : \"Merged assignments require movable tables\",\n    });\n  } else {\n    checks.push({\n      id: \"movable\",\n      status: \"ok\",\n      message: \"Single table selection\",\n    });\n  }\n\n  if (requireAdjacency && tables.length > 1) {\n    const evaluation = evaluateAdjacency(\n      tables.map((table) => table.id),\n      adjacency,\n    );\n    checks.push({\n      id: \"adjacency\",\n      status: evaluation.connected ? \"ok\" : \"error\",\n      message: evaluation.connected\n        ? \"Tables are connected\"\n        : \"Tables must be adjacent when adjacency enforcement is enabled\",\n    });\n  } else {\n    checks.push({\n      id: \"adjacency\",\n      status: \"ok\",\n      message: \"Adjacency not required\",\n    });\n  }\n\n  checks.push({\n    id: \"conflict\",\n    status: conflicts.length === 0 && holdConflicts.length === 0 ? \"ok\" : \"error\",\n    message:\n      conflicts.length === 0 && holdConflicts.length === 0\n        ? \"No conflicting assignments\"\n        : \"Existing assignments or holds conflict with selection\",\n    details: {\n      conflicts,\n      holdConflicts,\n    },\n  });\n\n  checks.push({\n    id: \"holds\",\n    status: holdConflicts.length === 0 ? \"ok\" : \"error\",\n    message: holdConflicts.length === 0 ? \"No holds blocking selection\" : \"Tables currently on hold\",\n    details: {\n      holds: holdConflicts,\n    },\n  });\n\n  return checks;\n}\n\nexport async function evaluateManualSelection(options: ManualSelectionOptions): Promise<ManualValidationResult> {\n  const { bookingId, tableIds, requireAdjacency: requireAdjacencyOverride, excludeHoldId = null, client } = options;\n\n  if (!Array.isArray(tableIds) || tableIds.length === 0) {\n    throw new ManualSelectionInputError(\"At least one table must be selected\", \"TABLES_REQUIRED\");\n  }\n\n  const supabase = ensureClient(client);\n  const booking = await loadBooking(bookingId, supabase);\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const policyVersion = hashPolicyVersion(policy);\n\n  let window: BookingWindow;\n  try {\n    ({ window } = computeBookingWindowWithFallback({\n      startISO: booking.start_at,\n      bookingDate: booking.booking_date,\n      startTime: booking.start_time,\n      partySize: booking.party_size,\n      policy,\n    }));\n  } catch (error) {\n    if (error instanceof ServiceOverrunError) {\n      // Surface a structured 422 that the API layer can return to the client\n      // rather than bubbling a 500. Keeps math unchanged while avoiding crashes\n      // in manual context fetches for after-hours/overrun bookings.\n      throw new ManualSelectionInputError(error.message, \"SERVICE_OVERRUN\", 422);\n    }\n    throw error;\n  }\n\n  const selectionTables = await loadTablesByIds(booking.restaurant_id, tableIds, supabase);\n  if (selectionTables.length !== tableIds.length) {\n    throw new ManualSelectionInputError(\"One or more selected tables were not found\", \"TABLE_LOOKUP_FAILED\");\n  }\n\n  const adjacency = await loadAdjacency(booking.restaurant_id, tableIds, supabase);\n\n  const contextBookings = await loadContextBookings(\n    booking.restaurant_id,\n    booking.booking_date ?? null,\n    supabase,\n    {\n      startIso: toIsoUtc(window.block.start),\n      endIso: toIsoUtc(window.block.end),\n    },\n  );\n  let holds: TableHold[] = [];\n  if (isHoldsEnabled()) {\n    try {\n      holds = await listActiveHoldsForBooking({ bookingId, client: supabase });\n    } catch {\n      holds = [];\n    }\n  }\n\n  const busy = buildBusyMaps({\n    targetBookingId: bookingId,\n    bookings: contextBookings,\n    holds,\n    excludeHoldId,\n    policy,\n    targetWindow: window,\n  });\n\n  const conflicts = extractConflictsForTables(busy, tableIds, window);\n  let holdConflicts: HoldConflictInfo[] = [];\n  try {\n    holdConflicts = await findHoldConflicts({\n      restaurantId: booking.restaurant_id,\n      tableIds,\n      startAt: toIsoUtc(window.block.start),\n      endAt: toIsoUtc(window.block.end),\n      excludeHoldId,\n      client: supabase,\n    });\n  } catch {\n    holdConflicts = [];\n  }\n\n  const requireAdjacency = resolveRequireAdjacency(booking.party_size, requireAdjacencyOverride);\n  const summary = summarizeSelection(selectionTables, booking.party_size);\n  const checks = buildManualChecks({\n    summary,\n    tables: selectionTables,\n    requireAdjacency,\n    adjacency,\n    conflicts,\n    holdConflicts,\n  });\n\n  const ok = checks.every((check) => check.status !== \"error\");\n\n  return {\n    ok,\n    summary,\n    checks,\n    policyVersion,\n  };\n}\n\nexport async function createManualHold(options: ManualHoldOptions): Promise<ManualHoldResult> {\n  const { bookingId, tableIds, createdBy, holdTtlSeconds = DEFAULT_HOLD_TTL_SECONDS, requireAdjacency, excludeHoldId, client } = options;\n  const supabase = ensureClient(client);\n\n  const validation = await evaluateManualSelection({\n    bookingId,\n    tableIds,\n    requireAdjacency,\n    excludeHoldId,\n    client: supabase,\n  });\n\n  if (!validation.ok || !validation.summary) {\n    return {\n      hold: null,\n      validation,\n    };\n  }\n\n  const booking = await loadBooking(bookingId, supabase);\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const policyVersion = typeof (validation as { policyVersion?: string }).policyVersion === \"string\"\n    ? (validation as { policyVersion?: string }).policyVersion!\n    : hashPolicyVersion(policy);\n\n  let window: BookingWindow;\n  try {\n    ({ window } = computeBookingWindowWithFallback({\n      startISO: booking.start_at,\n      bookingDate: booking.booking_date,\n      startTime: booking.start_time,\n      partySize: booking.party_size,\n      policy,\n    }));\n  } catch (error) {\n    if (error instanceof ServiceOverrunError) {\n      throw new ManualSelectionInputError(error.message, \"SERVICE_OVERRUN\", 422);\n    }\n    throw error;\n  }\n\n  const selectionTables = await loadTablesByIds(booking.restaurant_id, tableIds, supabase);\n  if (selectionTables.length !== tableIds.length) {\n    throw new ManualSelectionInputError(\"Selected tables could not be loaded\", \"TABLE_LOOKUP_FAILED\");\n  }\n\n  const startAtIso = toIsoUtc(window.block.start);\n  const endAtIso = toIsoUtc(window.block.end);\n\n  const expiresAt =\n    options.holdExpiresAt ??\n    toIsoUtc(DateTime.now().plus({ seconds: holdTtlSeconds })) ??\n    toIsoUtc(window.block.start.plus({ minutes: 2 }));\n\n  const zoneIdValue = validation.summary.zoneId ?? selectionTables[0]?.zoneId;\n  if (!zoneIdValue) {\n    throw new ManualSelectionInputError(\"Unable to determine zone for selected tables\", \"ZONE_REQUIRED\");\n  }\n\n  // Compute adjacency/zone snapshot for freeze semantics\n  const adjacency = await loadAdjacency(booking.restaurant_id, tableIds, supabase);\n  const adjacencyUndirected = isAdjacencyQueryUndirected();\n  const zoneIds = Array.from(new Set(selectionTables.map((t) => t.zoneId))).filter(Boolean) as string[];\n  const edgeSet = new Set<string>();\n  for (const a of tableIds) {\n    const neighbors = adjacency.get(a);\n    if (!neighbors) continue;\n    for (const b of neighbors) {\n      if (!tableIds.includes(b)) continue;\n      const key = adjacencyUndirected\n        ? ([a, b].sort((x, y) => x.localeCompare(y)) as [string, string]).join(\"->\")\n        : `${a}->${b}`;\n      edgeSet.add(key);\n    }\n  }\n  const normalizedEdges = Array.from(edgeSet).sort();\n  const adjacencySnapshot = computePayloadChecksum({ undirected: adjacencyUndirected, edges: normalizedEdges });\n\n  const holdPayload: CreateTableHoldInput = {\n    bookingId,\n    restaurantId: booking.restaurant_id,\n    zoneId: zoneIdValue,\n    tableIds,\n    startAt: startAtIso,\n    endAt: endAtIso,\n    expiresAt,\n    createdBy,\n    metadata: {\n      selection: {\n        tableIds,\n        summary: validation.summary,\n        snapshot: {\n          zoneIds,\n          adjacency: {\n            undirected: adjacencyUndirected,\n            edges: normalizedEdges,\n            hash: adjacencySnapshot,\n          },\n        },\n      },\n      policyVersion,\n    },\n    client: supabase,\n  };\n\n  const hold = await createTableHold(holdPayload);\n\n  if (excludeHoldId) {\n    try {\n      await releaseHoldWithRetry({ holdId: excludeHoldId, client: supabase });\n    } catch (error) {\n      console.warn(\"[capacity][manual][holds] failed to release replaced hold\", {\n        bookingId,\n        newHoldId: hold.id,\n        previousHoldId: excludeHoldId,\n        error,\n      });\n    }\n  }\n\n  return {\n    hold,\n    validation,\n  };\n}\n\nexport async function getManualAssignmentContext(options: {\n  bookingId: string;\n  client?: DbClient;\n}): Promise<ManualAssignmentContext> {\n  const { bookingId, client } = options;\n  const supabase = ensureClient(client);\n  const booking = await loadBooking(bookingId, supabase);\n\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n\n  let window: BookingWindow;\n  try {\n    ({ window } = computeBookingWindowWithFallback({\n      startISO: booking.start_at,\n      bookingDate: booking.booking_date,\n      startTime: booking.start_time,\n      partySize: booking.party_size,\n      policy,\n    }));\n  } catch (error) {\n    if (error instanceof ServiceOverrunError) {\n      throw new ManualSelectionInputError(error.message, \"SERVICE_OVERRUN\", 422);\n    }\n    throw error;\n  }\n\n  const tables = await loadTablesForRestaurant(booking.restaurant_id, supabase);\n  const contextBookings = await loadContextBookings(\n    booking.restaurant_id,\n    booking.booking_date ?? null,\n    supabase,\n    {\n      startIso: toIsoUtc(window.block.start),\n      endIso: toIsoUtc(window.block.end),\n    },\n  );\n\n  let holds: ManualAssignmentContextHold[] = [];\n  if (isHoldsEnabled()) {\n    try {\n      const rawHolds = await fetchHoldsForWindow(booking.restaurant_id, window, supabase);\n      holds = await hydrateHoldMetadata(rawHolds, supabase);\n    } catch (error: unknown) {\n      const code = extractErrorCode(error);\n      if (code === \"42P01\") {\n        console.warn(\"[capacity][manual][context] holds table unavailable; skipping hold hydration\", {\n          bookingId,\n        });\n      } else {\n        console.warn(\"[capacity][manual][context] failed to list holds\", { bookingId, error });\n      }\n      holds = [];\n    }\n  }\n\n  const busy = buildBusyMaps({\n    targetBookingId: bookingId,\n    bookings: contextBookings,\n    holds,\n    policy,\n    targetWindow: window,\n  });\n\n  const bookingAssignments = await loadTableAssignmentsForTables(\n    bookingId,\n    tables.map((table) => table.id),\n    supabase,\n  );\n\n  const conflicts = extractConflictsForTables(\n    busy,\n    tables.map((table) => table.id),\n    window,\n  );\n\n  const activeHold = holds.find((hold) => hold.bookingId === bookingId) ?? null;\n\n  // Compute context version from holds + assignments + flags + window\n  const flags = {\n    holdsStrictConflicts: isHoldStrictConflictsEnabled(),\n    adjacencyRequired: isAllocatorAdjacencyRequired(),\n    adjacencyUndirected: isAdjacencyQueryUndirected(),\n  };\n  const contextVersionPayload = {\n    holds: holds.map((h) => ({ id: h.id, tableIds: h.tableIds, startAt: h.startAt, endAt: h.endAt })),\n    assignments: bookingAssignments.map((row) => row.table_id),\n    flags,\n    window: {\n      startAt: toIsoUtc(window.block.start),\n      endAt: toIsoUtc(window.block.end),\n    },\n  };\n  const contextVersion = computePayloadChecksum(contextVersionPayload);\n  const serverNow = toIsoUtc(DateTime.now());\n\n  return {\n    booking,\n    tables,\n    bookingAssignments: bookingAssignments.map((row) => row.table_id),\n    holds,\n    activeHold,\n    conflicts,\n    window: {\n      startAt: toIsoUtc(window.block.start),\n      endAt: toIsoUtc(window.block.end),\n    },\n    flags,\n    contextVersion,\n    serverNow,\n  };\n}\n\nasync function hydrateHoldMetadata(holds: TableHold[], client: DbClient): Promise<ManualAssignmentContextHold[]> {\n  if (holds.length === 0) {\n    return [];\n  }\n  const creatorIds = Array.from(\n    new Set(\n      holds\n        .map((hold) => hold.createdBy)\n        .filter((value): value is string => Boolean(value)),\n    ),\n  );\n\n  let creators: Array<{ id: string; name: string | null; email: string | null }> = [];\n  if (creatorIds.length > 0) {\n    const { data, error } = await client\n      .from(\"profiles\")\n      .select(\"id, name, email\")\n      .in(\"id\", creatorIds);\n\n    if (!error && data) {\n      creators = data as Array<{ id: string; name: string | null; email: string | null }>;\n    }\n  }\n\n  return holds.map((hold) => {\n    const creator = creators.find((profile) => profile.id === hold.createdBy);\n    return {\n      ...hold,\n      createdByName: creator?.name ?? null,\n      createdByEmail: creator?.email ?? null,\n    };\n  });\n}\n",
  "server/capacity/table-assignment/quote.ts": "import { DateTime } from \"luxon\";\n\nimport { resolveDemandMultiplier, type DemandMultiplierResult } from \"@/server/capacity/demand-profiles\";\nimport { createTableHold, releaseTableHold, findHoldConflicts, HoldConflictError, type HoldConflictInfo, type TableHold } from \"@/server/capacity/holds\";\nimport { getVenuePolicy, getSelectorScoringConfig, getYieldManagementScarcityWeight, type SelectorScoringConfig, type ServiceKey } from \"@/server/capacity/policy\";\nimport { loadTableScarcityScores } from \"@/server/capacity/scarcity\";\nimport { buildScoredTablePlans, type RankedTablePlan, type CandidateDiagnostics } from \"@/server/capacity/selector\";\nimport { loadStrategicConfig } from \"@/server/capacity/strategic-config\";\nimport { emitHoldStrictConflict, emitSelectorQuote, emitRpcConflict, summarizeCandidate, type CandidateSummary, type SelectorDecisionEvent } from \"@/server/capacity/telemetry\";\nimport { computePayloadChecksum, hashPolicyVersion } from \"@/server/capacity/v2\";\nimport {\n  getAllocatorKMax as getAllocatorCombinationLimit,\n  getAllocatorAdjacencyMinPartySize,\n  getSelectorPlannerLimits,\n  isAllocatorAdjacencyRequired,\n  isAdjacencyQueryUndirected,\n  isCombinationPlannerEnabled,\n  isPlannerTimePruningEnabled,\n  isSelectorLookaheadEnabled,\n  getSelectorLookaheadWindowMinutes,\n  getSelectorLookaheadPenaltyWeight,\n  getSelectorLookaheadBlockThreshold,\n  isHoldsEnabled,\n  isHoldStrictConflictsEnabled,\n  isSelectorScoringEnabled,\n  isAllocatorServiceFailHard,\n  isOpsMetricsEnabled,\n} from \"@/server/feature-flags\";\n\nimport {\n  buildBusyMaps,\n  filterAvailableTables,\n  evaluateLookahead,\n  resolveRequireAdjacency,\n  partiesRequireAdjacency,\n  type AvailabilityMap,\n  type TimeFilterStats,\n  type LookaheadConfig,\n} from \"./availability\";\nimport { computeBookingWindowWithFallback } from \"./booking-window\";\nimport { DEFAULT_HOLD_TTL_SECONDS } from \"./constants\";\nimport {\n  ensureClient,\n  loadBooking,\n  loadTablesForRestaurant,\n  loadAdjacency,\n  loadContextBookings,\n  loadActiveHoldsForDate,\n  loadRestaurantTimezone,\n  extractErrorCode,\n  type DbClient,\n  type ContextBookingRow,\n} from \"./supabase\";\nimport { type Table, type QuoteTablesOptions, type QuoteTablesResult } from \"./types\";\nimport { highResNow, buildTiming, toIsoUtc, summarizeSelection, roundMilliseconds } from \"./utils\";\n\n\nfunction buildSelectorFeatureFlagsTelemetry(): {\n  selectorScoring: boolean;\n  opsMetrics: boolean;\n  plannerTimePruning: boolean;\n  adjacencyUndirected: boolean;\n  holdsStrictConflicts: boolean;\n  allocatorFailHard: boolean;\n  selectorLookahead: boolean;\n} {\n  return {\n    selectorScoring: isSelectorScoringEnabled(),\n    opsMetrics: isOpsMetricsEnabled(),\n    plannerTimePruning: isPlannerTimePruningEnabled(),\n    adjacencyUndirected: isAdjacencyQueryUndirected(),\n    holdsStrictConflicts: isHoldStrictConflictsEnabled(),\n    allocatorFailHard: isAllocatorServiceFailHard(),\n    selectorLookahead: isSelectorLookaheadEnabled(),\n  };\n}\n\nfunction composePlannerConfig(params: {\n  diagnostics: CandidateDiagnostics;\n  scoringConfig: SelectorScoringConfig;\n  combinationEnabled: boolean;\n  requireAdjacency: boolean;\n  adjacencyRequiredGlobally: boolean;\n  adjacencyMinPartySize: number | null;\n  featureFlags: ReturnType<typeof buildSelectorFeatureFlagsTelemetry>;\n  serviceFallback: {\n    usedFallback: boolean;\n    fallbackService: ServiceKey | null;\n  };\n  demandMultiplier: number;\n  demandRule?: DemandMultiplierResult[\"rule\"];\n  lookahead: Pick<LookaheadConfig, \"enabled\" | \"windowMinutes\" | \"penaltyWeight\" | \"blockThreshold\">;\n}): NonNullable<SelectorDecisionEvent[\"plannerConfig\"]> {\n  const { diagnostics, scoringConfig } = params;\n  const { limits } = diagnostics;\n\n  return {\n    combinationEnabled: params.combinationEnabled,\n    requireAdjacency: params.requireAdjacency,\n    adjacencyRequiredGlobally: params.adjacencyRequiredGlobally,\n    adjacencyMinPartySize: params.adjacencyMinPartySize,\n    kMax: limits.kMax,\n    bucketLimit: limits.maxPlansPerSlack,\n    evaluationLimit: limits.maxCombinationEvaluations,\n    maxOverage: scoringConfig.maxOverage,\n    maxTables: scoringConfig.maxTables,\n    weights: {\n      overage: scoringConfig.weights.overage,\n      tableCount: scoringConfig.weights.tableCount,\n      fragmentation: scoringConfig.weights.fragmentation,\n      zoneBalance: scoringConfig.weights.zoneBalance,\n      adjacencyCost: scoringConfig.weights.adjacencyCost,\n      scarcity: scoringConfig.weights.scarcity,\n    },\n    featureFlags: {\n      plannerTimePruning: params.featureFlags.plannerTimePruning,\n      adjacencyUndirected: params.featureFlags.adjacencyUndirected,\n      holdsStrictConflicts: params.featureFlags.holdsStrictConflicts,\n      allocatorFailHard: params.featureFlags.allocatorFailHard,\n      selectorScoring: params.featureFlags.selectorScoring,\n      opsMetrics: params.featureFlags.opsMetrics,\n      selectorLookahead: params.featureFlags.selectorLookahead,\n    },\n    serviceFallback: {\n      used: params.serviceFallback.usedFallback,\n      service: params.serviceFallback.fallbackService,\n    },\n    demandMultiplier: params.demandMultiplier,\n    demandRule: params.demandRule\n      ? {\n          label: params.demandRule.label ?? null,\n          source: params.demandRule.source,\n          serviceWindow: params.demandRule.serviceWindow ?? null,\n          days: params.demandRule.days,\n          start: params.demandRule.start ?? null,\n          end: params.demandRule.end ?? null,\n          priority: params.demandRule.priority ?? null,\n        }\n      : null,\n    lookahead: {\n      enabled: params.lookahead.enabled,\n      windowMinutes: params.lookahead.windowMinutes,\n      penaltyWeight: params.lookahead.penaltyWeight,\n      blockThreshold: params.lookahead.blockThreshold,\n    },\n  };\n}\n\nfunction formatHoldConflictReason(conflicts: HoldConflictInfo[], plan: RankedTablePlan): string {\n  if (conflicts.length === 0) {\n    return \"Conflicts with existing holds\";\n  }\n\n  const tableLookup = new Map<string, string>();\n  for (const table of plan.tables) {\n    tableLookup.set(table.id, table.tableNumber ?? table.id);\n  }\n\n  const tableLabels = new Set<string>();\n  for (const conflict of conflicts) {\n    for (const tableId of conflict.tableIds) {\n      const label = tableLookup.get(tableId) ?? tableId;\n      tableLabels.add(label);\n    }\n  }\n\n  const sortedLabels = Array.from(tableLabels).sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));\n  let message = sortedLabels.length > 0\n    ? `Conflicts with holds on tables ${sortedLabels.join(\", \")}`\n    : \"Conflicts with existing holds\";\n\n  const latestEnd = conflicts.reduce<string | null>((latest, conflict) => {\n    if (!conflict.endAt) {\n      return latest;\n    }\n    if (!latest) {\n      return conflict.endAt;\n    }\n    return conflict.endAt > latest ? conflict.endAt : latest;\n  }, null);\n\n  if (latestEnd) {\n    const retry = DateTime.fromISO(latestEnd);\n    if (retry.isValid) {\n      message += `; retry after ${retry.toUTC().toISOTime({ suppressSeconds: false, suppressMilliseconds: true })}`;\n    }\n  }\n\n  return message;\n}\n\nfunction buildSelectionSnapshot(params: {\n  planTables: Table[];\n  adjacency: Map<string, Set<string>>;\n  adjacencyUndirected: boolean;\n  fallbackZoneId?: string | null;\n}) {\n  const { planTables, adjacency, adjacencyUndirected, fallbackZoneId } = params;\n  const zoneIds = Array.from(\n    new Set(\n      planTables\n        .map((table) => table.zoneId)\n        .filter((zone): zone is string => typeof zone === \"string\" && zone.trim().length > 0),\n    ),\n  );\n  if (zoneIds.length === 0 && typeof fallbackZoneId === \"string\" && fallbackZoneId.trim().length > 0) {\n    zoneIds.push(fallbackZoneId);\n  }\n\n  const tableIdSet = new Set(planTables.map((table) => table.id));\n  const edgeSet = new Set<string>();\n\n  for (const table of planTables) {\n    const neighbors = adjacency.get(table.id);\n    if (!neighbors) continue;\n    for (const neighbor of neighbors) {\n      if (!tableIdSet.has(neighbor)) continue;\n      const key = adjacencyUndirected\n        ? ([table.id, neighbor].sort((a, b) => a.localeCompare(b)) as [string, string]).join(\"->\")\n        : `${table.id}->${neighbor}`;\n      edgeSet.add(key);\n    }\n  }\n\n  const edges = Array.from(edgeSet).sort();\n  const hash = computePayloadChecksum({ undirected: adjacencyUndirected, edges });\n\n  return {\n    zoneIds,\n    adjacency: {\n      undirected: adjacencyUndirected,\n      edges,\n      hash,\n    },\n  };\n}\n\nexport async function quoteTablesForBooking(options: QuoteTablesOptions): Promise<QuoteTablesResult> {\n  const {\n    bookingId,\n    zoneId,\n    maxTables,\n    requireAdjacency: requireAdjacencyOverride,\n    avoidTables = [],\n    holdTtlSeconds = DEFAULT_HOLD_TTL_SECONDS,\n    createdBy,\n    client,\n    signal,\n  } = options;\n\n  const operationStart = highResNow();\n  const supabase = ensureClient(client);\n  const booking = await loadBooking(bookingId, supabase, signal);\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase, signal)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const policyVersion = hashPolicyVersion(policy);\n  const {\n    window,\n    usedFallback: bookingWindowUsedFallback,\n    fallbackService: bookingWindowFallbackService,\n  } = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n\n  const tables = await loadTablesForRestaurant(booking.restaurant_id, supabase, signal);\n  const adjacency = await loadAdjacency(\n    booking.restaurant_id,\n    tables.map((table) => table.id),\n    supabase,\n    signal,\n  );\n  const requireAdjacency = resolveRequireAdjacency(booking.party_size, requireAdjacencyOverride);\n  const timePruningEnabled = isPlannerTimePruningEnabled();\n  const lookaheadEnabled = isSelectorLookaheadEnabled();\n  let timePruningStats: TimeFilterStats | null = null;\n  let busyForPlanner: AvailabilityMap | undefined;\n  let contextBookings: ContextBookingRow[] = [];\n  let holdsForDay: TableHold[] = [];\n\n  if (timePruningEnabled || lookaheadEnabled) {\n    contextBookings = await loadContextBookings(\n      booking.restaurant_id,\n      booking.booking_date ?? null,\n      supabase,\n      {\n        startIso: toIsoUtc(window.block.start),\n        endIso: toIsoUtc(window.block.end),\n      },\n      signal,\n    );\n    if (isHoldsEnabled()) {\n      try {\n        holdsForDay = await loadActiveHoldsForDate(booking.restaurant_id, booking.booking_date ?? null, policy, supabase, signal);\n      } catch (error: unknown) {\n        const code = extractErrorCode(error);\n        if (code === \"42P01\") {\n          console.warn(\"[capacity.quote] holds table unavailable; skipping hold hydration\", {\n            restaurantId: booking.restaurant_id,\n          });\n        } else {\n          console.warn(\"[capacity.quote] failed to load active holds\", {\n            restaurantId: booking.restaurant_id,\n            error,\n          });\n        }\n        holdsForDay = [];\n      }\n    }\n  }\n\n  if (timePruningEnabled) {\n    busyForPlanner = buildBusyMaps({\n      targetBookingId: booking.id,\n      bookings: contextBookings,\n      holds: holdsForDay,\n      policy,\n      targetWindow: window,\n    });\n  }\n\n  // Load config early so we can use combinationEnabled for filtering\n  const strategicOptions = { restaurantId: booking.restaurant_id ?? null } as const;\n  await loadStrategicConfig({ ...strategicOptions, client: supabase });\n  const combinationEnabled = isCombinationPlannerEnabled();\n  \n  const filtered = filterAvailableTables(\n    tables,\n    booking.party_size,\n    window,\n    adjacency,\n    new Set(avoidTables),\n    zoneId ?? null,\n    {\n      allowInsufficientCapacity: true,\n      allowMaxPartySizeViolation: combinationEnabled,  // Allow maxPartySize violations when combinations enabled\n      timeFilter:\n        busyForPlanner && timePruningEnabled\n          ? {\n              busy: busyForPlanner,\n              mode: \"strict\",\n              captureStats: (stats) => {\n                timePruningStats = stats;\n              },\n            }\n          : undefined,\n    },\n  );\n\n  const baseScoringConfig = getSelectorScoringConfig(strategicOptions);\n  const selectorLimits = getSelectorPlannerLimits();\n  const combinationLimit = maxTables ?? getAllocatorCombinationLimit();\n  const demandMultiplierResult = await resolveDemandMultiplier({\n    restaurantId: booking.restaurant_id,\n    serviceStart: window.block.start,\n    serviceKey: window.service,\n    timezone: policy.timezone,\n    client: supabase,\n  });\n  const demandMultiplier = demandMultiplierResult?.multiplier ?? 1;\n  const demandRule = demandMultiplierResult?.rule;\n  const tableScarcityScores = await loadTableScarcityScores({\n    restaurantId: booking.restaurant_id,\n    tables: filtered,\n    client: supabase,\n  });\n  const scoringConfig: SelectorScoringConfig = {\n    ...baseScoringConfig,\n    weights: {\n      ...baseScoringConfig.weights,\n      scarcity: getYieldManagementScarcityWeight(strategicOptions),\n    },\n  };\n  const plannerStart = highResNow();\n  let plans = buildScoredTablePlans({\n    tables: filtered,\n    partySize: booking.party_size,\n    adjacency,\n    config: scoringConfig,\n    enableCombinations: combinationEnabled,\n    kMax: combinationLimit,\n    maxPlansPerSlack: selectorLimits.maxPlansPerSlack,\n    maxCombinationEvaluations: selectorLimits.maxCombinationEvaluations,\n    enumerationTimeoutMs: selectorLimits.enumerationTimeoutMs,\n    requireAdjacency,\n    demandMultiplier,\n    tableScarcityScores,\n  });\n  // Fallback: if no plans found and adjacency was required, retry without adjacency constraint\n  let requireAdjacencyUsed = requireAdjacency;\n  if (plans.plans.length === 0 && requireAdjacency) {\n    const relaxed = buildScoredTablePlans({\n      tables: filtered,\n      partySize: booking.party_size,\n      adjacency,\n      config: scoringConfig,\n      enableCombinations: combinationEnabled,\n      kMax: combinationLimit,\n      maxPlansPerSlack: selectorLimits.maxPlansPerSlack,\n      maxCombinationEvaluations: selectorLimits.maxCombinationEvaluations,\n      enumerationTimeoutMs: selectorLimits.enumerationTimeoutMs,\n      requireAdjacency: false,\n      demandMultiplier,\n      tableScarcityScores,\n    });\n    if (relaxed.plans.length > 0) {\n      plans = relaxed;\n      requireAdjacencyUsed = false;\n    }\n  }\n  // const topRankedPlan = plans.plans[0] ?? null;\n  const lookaheadConfig: LookaheadConfig = {\n    enabled: lookaheadEnabled,\n    windowMinutes: getSelectorLookaheadWindowMinutes(),\n    penaltyWeight: getSelectorLookaheadPenaltyWeight(),\n    blockThreshold: getSelectorLookaheadBlockThreshold(),\n  };\n  const lookaheadDiagnostics = evaluateLookahead({\n    lookahead: lookaheadConfig,\n    bookingId: booking.id,\n    bookingWindow: window,\n    plansResult: plans,\n    tables,\n    adjacency,\n    zoneId: zoneId ?? null,\n    policy,\n    contextBookings,\n    holds: holdsForDay,\n    combinationEnabled,\n    combinationLimit,\n    selectorLimits,\n    scoringConfig,\n  });\n  plans.diagnostics.lookahead = lookaheadDiagnostics;\n  const plannerDurationMs = highResNow() - plannerStart;\n  const adjacencyRequiredGlobally = adjacency.size > 0 && isAllocatorAdjacencyRequired();\n  const adjacencyMinPartySize = getAllocatorAdjacencyMinPartySize();\n  const featureFlags = buildSelectorFeatureFlagsTelemetry();\n  const plannerConfigTelemetry = composePlannerConfig({\n    diagnostics: plans.diagnostics,\n    scoringConfig,\n    combinationEnabled,\n    requireAdjacency: requireAdjacencyUsed,\n    adjacencyRequiredGlobally,\n    adjacencyMinPartySize: adjacencyMinPartySize ?? null,\n    featureFlags,\n    serviceFallback: {\n      usedFallback: bookingWindowUsedFallback,\n      fallbackService: bookingWindowFallbackService,\n    },\n    demandMultiplier,\n    demandRule,\n    lookahead: lookaheadConfig,\n  });\n  if (!timePruningStats) {\n    timePruningStats = {\n      prunedByTime: 0,\n      candidatesAfterTimePrune: filtered.length,\n      pruned_by_time: 0,\n      candidates_after_time_prune: filtered.length,\n    };\n  }\n  plans.diagnostics.timePruning = {\n    prunedByTime: timePruningStats.prunedByTime,\n    candidatesAfterTimePrune: timePruningStats.candidatesAfterTimePrune,\n    pruned_by_time: timePruningStats.pruned_by_time,\n    candidates_after_time_prune: timePruningStats.candidates_after_time_prune,\n  };\n\n  const alternates: CandidateSummary[] = [];\n  const skippedCandidates: Array<{ candidate: CandidateSummary; reason: string; conflicts: HoldConflictInfo[] }> = [];\n  const holdConflictHoldIds = new Set<string>();\n  let holdConflictSkipCount = 0;\n\n  const applyQuoteSkipDiagnostics = () => {\n    plans.diagnostics.quoteSkips = {\n      holdConflicts: {\n        count: holdConflictSkipCount,\n        holdIds: Array.from(holdConflictHoldIds),\n      },\n    };\n  };\n\n  const recordHoldConflictSkip = (conflicts: HoldConflictInfo[], candidate: CandidateSummary, plan: RankedTablePlan) => {\n    holdConflictSkipCount += 1;\n    for (const conflict of conflicts) {\n      if (conflict.holdId) {\n        holdConflictHoldIds.add(conflict.holdId);\n      }\n    }\n    skippedCandidates.push({\n      candidate,\n      reason: formatHoldConflictReason(conflicts, plan),\n      conflicts,\n    });\n  };\n\n  for (let index = 0; index < plans.plans.length; index += 1) {\n    const plan = plans.plans[index]!;\n    const requestedTableIds = plan.tables.map((table) => table.id);\n    const candidateSummary = summarizeCandidate({\n      tableIds: requestedTableIds,\n      tableNumbers: plan.tables.map((table) => table.tableNumber),\n      totalCapacity: plan.totalCapacity,\n      tableCount: plan.tables.length,\n      slack: plan.slack,\n      score: plan.score,\n      adjacencyStatus: plan.adjacencyStatus,\n      scoreBreakdown: plan.scoreBreakdown,\n    });\n\n    const requestedWindowStart = toIsoUtc(window.block.start);\n    const requestedWindowEnd = toIsoUtc(window.block.end);\n\n    if (!isHoldStrictConflictsEnabled()) {\n      const conflicts = await findHoldConflicts({\n        restaurantId: booking.restaurant_id,\n        tableIds: requestedTableIds,\n        startAt: requestedWindowStart,\n        endAt: requestedWindowEnd,\n        client: supabase,\n      });\n\n      if (conflicts.length > 0) {\n        recordHoldConflictSkip(conflicts, candidateSummary, plan);\n        continue;\n      }\n    }\n\n    if (index > 0) {\n      alternates.push(candidateSummary);\n    }\n\n    try {\n      const summary = summarizeSelection(plan.tables, booking.party_size);\n      const zoneForHold = summary.zoneId ?? plan.tables[0]?.zoneId;\n      if (!zoneForHold) {\n        continue;\n      }\n      const snapshot = buildSelectionSnapshot({\n        planTables: plan.tables,\n        adjacency,\n        adjacencyUndirected: featureFlags.adjacencyUndirected,\n        fallbackZoneId: zoneForHold,\n      });\n\n      const holdStart = highResNow();\n      const hold = await createTableHold({\n        bookingId,\n        restaurantId: booking.restaurant_id,\n        zoneId: zoneForHold,\n        tableIds: requestedTableIds,\n        startAt: requestedWindowStart,\n        endAt: requestedWindowEnd,\n        expiresAt: toIsoUtc(DateTime.now().plus({ seconds: holdTtlSeconds })),\n        createdBy,\n        metadata: {\n          selection: {\n            tableIds: requestedTableIds,\n            summary,\n            snapshot,\n          },\n          policyVersion,\n        },\n        client: supabase,\n      });\n\n      if (isHoldStrictConflictsEnabled()) {\n        try {\n          const conflictsAfterInsert = await findHoldConflicts({\n            restaurantId: booking.restaurant_id,\n            tableIds: requestedTableIds,\n            startAt: requestedWindowStart,\n            endAt: requestedWindowEnd,\n            excludeHoldId: hold.id,\n            client: supabase,\n          });\n\n          if (conflictsAfterInsert.length > 0) {\n            try {\n              await emitHoldStrictConflict({\n                restaurantId: booking.restaurant_id,\n                bookingId,\n                tableIds: requestedTableIds,\n                startAt: requestedWindowStart,\n                endAt: requestedWindowEnd,\n                conflicts: conflictsAfterInsert.map((conflict) => ({\n                  holdId: conflict.holdId,\n                  bookingId: conflict.bookingId,\n                  tableIds: conflict.tableIds,\n                  startAt: conflict.startAt,\n                  endAt: conflict.endAt,\n                  expiresAt: conflict.expiresAt,\n                })),\n              });\n            } catch (telemetryError) {\n              console.error(\"[capacity.quote] failed to emit strict conflict telemetry (post-insert)\", {\n                bookingId,\n                restaurantId: booking.restaurant_id,\n                tableIds: requestedTableIds,\n                error: telemetryError instanceof Error ? telemetryError.message : String(telemetryError),\n              });\n            }\n\n            recordHoldConflictSkip(conflictsAfterInsert, candidateSummary, plan);\n\n            try {\n              await releaseTableHold({ holdId: hold.id, client: supabase });\n            } catch (releaseError) {\n              console.error(\"[capacity.quote] failed to release conflicting hold after validation\", {\n                holdId: hold.id,\n                bookingId,\n                restaurantId: booking.restaurant_id,\n                error: releaseError instanceof Error ? releaseError.message : String(releaseError),\n              });\n            }\n\n            applyQuoteSkipDiagnostics();\n            continue;\n          }\n        } catch (validationError) {\n          console.error(\"[capacity.quote] strict conflict validation errored\", {\n            bookingId,\n            restaurantId: booking.restaurant_id,\n            holdId: hold?.id ?? null,\n            error: validationError instanceof Error ? validationError.message : String(validationError),\n          });\n          if (hold?.id) {\n            try {\n              await releaseTableHold({ holdId: hold.id, client: supabase });\n            } catch (releaseError) {\n              console.error(\"[capacity.quote] failed to release hold after validation error\", {\n                holdId: hold.id,\n                bookingId,\n                restaurantId: booking.restaurant_id,\n                error: releaseError instanceof Error ? releaseError.message : String(releaseError),\n              });\n            }\n          }\n\n          recordHoldConflictSkip(\n            hold\n              ? [\n                  {\n                    holdId: hold.id,\n                    bookingId,\n                    tableIds: requestedTableIds,\n                    startAt: requestedWindowStart,\n                    endAt: requestedWindowEnd,\n                    expiresAt: hold.expiresAt,\n                  },\n                ]\n              : [],\n            candidateSummary,\n            plan,\n          );\n\n          applyQuoteSkipDiagnostics();\n          continue;\n        }\n      }\n\n      const holdDurationMs = highResNow() - holdStart;\n      const totalDurationMs = highResNow() - operationStart;\n\n      applyQuoteSkipDiagnostics();\n      await emitSelectorQuote({\n        restaurantId: booking.restaurant_id,\n        bookingId,\n        partySize: booking.party_size,\n        window: {\n          start: requestedWindowStart,\n          end: requestedWindowEnd,\n        },\n        candidates: [candidateSummary, ...alternates],\n        selected: candidateSummary,\n        durationMs: roundMilliseconds(totalDurationMs),\n        featureFlags,\n        timing: buildTiming({\n          totalMs: totalDurationMs,\n          plannerMs: plannerDurationMs,\n          holdMs: holdDurationMs,\n        }),\n        plannerConfig: plannerConfigTelemetry,\n        diagnostics: plans.diagnostics,\n        holdId: hold.id,\n        expiresAt: hold.expiresAt,\n      });\n\n      return {\n        hold,\n        candidate: candidateSummary,\n        alternates,\n        nextTimes: [],\n        skipped: skippedCandidates,\n        metadata: {\n          usedFallback: bookingWindowUsedFallback,\n          fallbackService: bookingWindowFallbackService,\n        },\n      };\n    } catch (error) {\n      if (error instanceof HoldConflictError) {\n        const refreshedConflicts = await findHoldConflicts({\n          restaurantId: booking.restaurant_id,\n          tableIds: plan.tables.map((table) => table.id),\n          startAt: toIsoUtc(window.block.start),\n          endAt: toIsoUtc(window.block.end),\n          client: supabase,\n        });\n\n        recordHoldConflictSkip(refreshedConflicts, candidateSummary, plan);\n        await emitRpcConflict({\n          source: \"create_hold_conflict\",\n          bookingId,\n          restaurantId: booking.restaurant_id,\n          tableIds: plan.tables.map((table) => table.id),\n          holdId: error.holdId ?? null,\n          error: {\n            code: null,\n            message: error.message,\n            details: JSON.stringify(refreshedConflicts),\n            hint: null,\n          },\n        });\n\n        applyQuoteSkipDiagnostics();\n        continue;\n      }\n      throw error;\n    }\n  }\n  applyQuoteSkipDiagnostics();\n\n  const failureReason =\n    holdConflictSkipCount > 0\n      ? 'Hold conflicts prevented all candidates'\n      : plans.fallbackReason ?? 'No suitable tables available';\n  return {\n    hold: null,\n    candidate: null,\n    alternates,\n    nextTimes: [],\n    reason: failureReason,\n    skipped: skippedCandidates,\n    metadata: {\n      usedFallback: bookingWindowUsedFallback,\n      fallbackService: bookingWindowFallbackService,\n    },\n  };\n}\n\nexport async function findSuitableTables(options: {\n  bookingId: string;\n  client?: DbClient;\n}): Promise<RankedTablePlan[]> {\n  const { bookingId, client } = options;\n  const supabase = ensureClient(client);\n  const booking = await loadBooking(bookingId, supabase);\n  const tables = await loadTablesForRestaurant(booking.restaurant_id, supabase);\n  const adjacency = await loadAdjacency(\n    booking.restaurant_id,\n    tables.map((table) => table.id),\n    supabase,\n  );\n  const defaultPolicy = getVenuePolicy();\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    defaultPolicy.timezone;\n  const policy =\n    restaurantTimezone === defaultPolicy.timezone\n      ? defaultPolicy\n      : getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const { window } = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n\n  const filtered = filterAvailableTables(\n    tables,\n    booking.party_size,\n    window,\n    adjacency,\n    undefined,\n    undefined,\n    { allowInsufficientCapacity: true },\n  );\n  const strategicOptions = { restaurantId: booking.restaurant_id ?? null } as const;\n  await loadStrategicConfig({ ...strategicOptions, client: supabase });\n  const baseScoringConfig = getSelectorScoringConfig(strategicOptions);\n  const requireAdjacency = partiesRequireAdjacency(booking.party_size);\n  const selectorLimits = getSelectorPlannerLimits();\n  const demandMultiplierResult = await resolveDemandMultiplier({\n    restaurantId: booking.restaurant_id,\n    serviceStart: window.block.start,\n    serviceKey: window.service,\n    timezone: policy.timezone,\n    client: supabase,\n  });\n  const demandMultiplier = demandMultiplierResult?.multiplier ?? 1;\n  const tableScarcityScores = await loadTableScarcityScores({\n    restaurantId: booking.restaurant_id,\n    tables: filtered,\n    client: supabase,\n  });\n  const scoringConfig: SelectorScoringConfig = {\n    ...baseScoringConfig,\n    weights: {\n      ...baseScoringConfig.weights,\n      scarcity: getYieldManagementScarcityWeight(strategicOptions),\n    },\n  };\n  const plans = buildScoredTablePlans({\n    tables: filtered,\n    partySize: booking.party_size,\n    adjacency,\n    config: scoringConfig,\n    enableCombinations: isCombinationPlannerEnabled(),\n    kMax: getAllocatorCombinationLimit(),\n    maxPlansPerSlack: selectorLimits.maxPlansPerSlack,\n    maxCombinationEvaluations: selectorLimits.maxCombinationEvaluations,\n    enumerationTimeoutMs: selectorLimits.enumerationTimeoutMs,\n    requireAdjacency,\n    demandMultiplier,\n    tableScarcityScores,\n  });\n\n  return plans.plans;\n}\n",
  "server/capacity/table-assignment/supabase.ts": "import { DateTime } from \"luxon\";\n\nimport { BOOKING_BLOCKING_STATUSES } from \"@/lib/enums\";\nimport { releaseTableHold } from \"@/server/capacity/holds\";\nimport {\n  getContextQueryPaddingMinutes,\n  isAdjacencyQueryUndirected,\n} from \"@/server/feature-flags\";\nimport { getServiceSupabaseClient } from \"@/server/supabase\";\n\n\nimport { ManualSelectionInputError, type DbClient, type Table, type BookingWindow } from \"./types\";\nimport { toIsoUtc } from \"./utils\";\n\nimport type { TableHold } from \"@/server/capacity/holds\";\nimport type { VenuePolicy } from \"@/server/capacity/policy\";\nimport type { Tables } from \"@/types/supabase\";\n\nexport type { DbClient } from \"./types\";\n\nconst TABLE_INVENTORY_SELECT =\n  \"id,table_number,capacity,min_party_size,max_party_size,section,category,seating_type,mobility,zone_id,status,active,position\" as const;\n\nexport type TableInventoryRow = Tables<\"table_inventory\">;\n\nexport type BookingRow = Tables<\"bookings\"> & {\n  restaurants?: { timezone: string | null } | { timezone: string | null }[];\n};\n\nexport type ContextBookingRow = {\n  id: string;\n  party_size: number;\n  status: string;\n  start_time: string | null;\n  end_time: string | null;\n  start_at: string | null;\n  end_at: string | null;\n  booking_date: string | null;\n  seating_preference?: string | null;\n  booking_table_assignments: Array<{ table_id: string | null }> | null;\n};\n\nexport type TableHoldRow = Tables<\"table_holds\"> & {\n  table_hold_members: Array<{ table_id: string | null }> | null;\n};\n\nexport type BookingAssignmentRow = {\n  table_id: string;\n  id: string;\n  start_at: string | null;\n  end_at: string | null;\n  merge_group_id: string | null;\n};\n\nexport function ensureClient(client?: DbClient): DbClient {\n  return client ?? getServiceSupabaseClient();\n}\n\nexport function applyAbortSignal<T extends { abortSignal?: (signal: AbortSignal) => T }>(\n  builder: T,\n  signal?: AbortSignal,\n): T {\n  if (signal && typeof builder.abortSignal === \"function\") {\n    return builder.abortSignal(signal);\n  }\n  return builder;\n}\n\nexport function extractErrorCode(error: unknown): string | undefined {\n  if (typeof error !== \"object\" || error === null) {\n    return undefined;\n  }\n  const code = (error as { code?: unknown }).code;\n  return typeof code === \"string\" ? code : undefined;\n}\n\nfunction normalizeBookingRow(row: BookingRow): BookingRow {\n  if (Array.isArray(row.restaurants) && row.restaurants.length > 0) {\n    return { ...row, restaurants: row.restaurants[0] ?? null };\n  }\n  return row;\n}\n\nexport async function loadBooking(bookingId: string, client: DbClient, signal?: AbortSignal): Promise<BookingRow> {\n  const bookingQuery = applyAbortSignal(\n    client\n      .from(\"bookings\")\n      .select(\n        [\n          \"id\",\n          \"restaurant_id\",\n          \"booking_date\",\n          \"start_time\",\n          \"end_time\",\n          \"start_at\",\n          \"end_at\",\n          \"party_size\",\n          \"status\",\n          \"seating_preference\",\n          \"restaurants(timezone)\",\n        ].join(\",\"),\n      )\n      .eq(\"id\", bookingId),\n    signal,\n  );\n\n  const { data, error } = await bookingQuery.maybeSingle();\n\n  if (error) {\n    throw new ManualSelectionInputError(error.message ?? \"Failed to load booking\", \"BOOKING_LOOKUP_FAILED\", 500);\n  }\n\n  if (!data) {\n    throw new ManualSelectionInputError(\"Booking not found\", \"BOOKING_NOT_FOUND\", 404);\n  }\n\n  return normalizeBookingRow(data as unknown as BookingRow);\n}\n\ntype RestaurantInfo = {\n  timezone: string | null;\n  slug: string | null;\n};\n\nasync function loadRestaurantInfo(restaurantId: string, client: DbClient, signal?: AbortSignal): Promise<RestaurantInfo> {\n  const restaurantQuery = applyAbortSignal(\n    client.from(\"restaurants\").select(\"timezone, slug\").eq(\"id\", restaurantId),\n    signal,\n  );\n\n  const { data, error } = await restaurantQuery.maybeSingle();\n\n  if (error) {\n    throw new ManualSelectionInputError(error.message ?? \"Failed to load restaurant metadata\", \"RESTAURANT_LOOKUP_FAILED\", 500);\n  }\n\n  return {\n    timezone: data?.timezone ?? null,\n    slug: data?.slug ?? null,\n  };\n}\n\nexport async function loadRestaurantTimezone(\n  restaurantId: string,\n  client: DbClient,\n  signal?: AbortSignal,\n): Promise<string | null> {\n  const info = await loadRestaurantInfo(restaurantId, client, signal);\n  return info.timezone;\n}\n\nexport async function loadTablesForRestaurant(\n  restaurantId: string,\n  client: DbClient,\n  signal?: AbortSignal,\n): Promise<Table[]> {\n  try {\n    const { getInventoryCache } = await import(\"@/server/capacity/cache\");\n    const cached = getInventoryCache(restaurantId);\n    if (Array.isArray(cached) && cached.length > 0) {\n      return cached as Table[];\n    }\n  } catch {\n    // ignore cache fetch failures\n  }\n\n  const query = applyAbortSignal(\n    client.from(\"table_inventory\").select(TABLE_INVENTORY_SELECT).eq(\"restaurant_id\", restaurantId),\n    signal,\n  );\n  const { data, error } = await query;\n\n  if (error || !data) {\n    throw new ManualSelectionInputError(error?.message ?? \"Failed to load table inventory\", \"TABLE_INVENTORY_LOOKUP_FAILED\", 500);\n  }\n\n  const rows = data as TableInventoryRow[];\n  const tables = rows.map<Table>((row) => ({\n    id: row.id,\n    tableNumber: row.table_number,\n    capacity: row.capacity ?? 0,\n    minPartySize: row.min_party_size ?? null,\n    maxPartySize: row.max_party_size ?? null,\n    section: row.section,\n    category: row.category,\n    seatingType: row.seating_type,\n    mobility: row.mobility,\n    zoneId: row.zone_id,\n    status: row.status,\n    active: row.active,\n    position: row.position,\n  }));\n\n  try {\n    const { setInventoryCache } = await import(\"@/server/capacity/cache\");\n    setInventoryCache(restaurantId, tables);\n  } catch {\n    // ignore cache set failure\n  }\n\n  return tables;\n}\n\nexport async function loadTablesByIds(\n  restaurantId: string,\n  tableIds: string[],\n  client: DbClient,\n  signal?: AbortSignal,\n): Promise<Table[]> {\n  if (tableIds.length === 0) {\n    return [];\n  }\n\n  const uniqueIds = Array.from(new Set(tableIds));\n  const tableQuery = applyAbortSignal(\n    client\n      .from(\"table_inventory\")\n      .select<typeof TABLE_INVENTORY_SELECT, TableInventoryRow>(TABLE_INVENTORY_SELECT)\n      .eq(\"restaurant_id\", restaurantId)\n      .in(\"id\", uniqueIds),\n    signal,\n  );\n\n  const { data, error } = await tableQuery;\n\n  if (error || !data) {\n    return [];\n  }\n\n  const rows = data as TableInventoryRow[];\n\n  const lookup = new Map(\n    rows.map((row) => [\n      row.id,\n      {\n        id: row.id,\n        tableNumber: row.table_number,\n        capacity: row.capacity ?? 0,\n        minPartySize: row.min_party_size ?? null,\n        maxPartySize: row.max_party_size ?? null,\n        section: row.section,\n        category: row.category,\n        seatingType: row.seating_type,\n        mobility: row.mobility,\n        zoneId: row.zone_id,\n        status: row.status,\n        active: row.active,\n        position: row.position,\n      } satisfies Table,\n    ]),\n  );\n\n  return tableIds.reduce<Table[]>((acc, id) => {\n    const table = lookup.get(id);\n    if (table) {\n      acc.push(table);\n    }\n    return acc;\n  }, []);\n}\n\nexport async function loadAdjacency(\n  restaurantId: string,\n  tableIds: string[],\n  client: DbClient,\n  signal?: AbortSignal,\n): Promise<Map<string, Set<string>>> {\n  const uniqueTableIds = Array.from(\n    new Set(\n      tableIds.filter((value): value is string => typeof value === \"string\" && value.length > 0),\n    ),\n  );\n\n  if (uniqueTableIds.length === 0) {\n    return new Map();\n  }\n\n  let cachedGraph: Map<string, Set<string>> | null = null;\n  try {\n    const { getAdjacencyCache } = await import(\"@/server/capacity/cache\");\n    cachedGraph = getAdjacencyCache(restaurantId);\n  } catch {\n    cachedGraph = null;\n  }\n  const missing: string[] = [];\n  if (cachedGraph) {\n    for (const id of uniqueTableIds) {\n      if (!cachedGraph.has(id)) {\n        missing.push(id);\n      }\n    }\n  }\n  const needFetch = !cachedGraph || missing.length > 0;\n\n  type AdjacencyRow = { table_a: string | null; table_b: string | null };\n  const baseQuery = () => applyAbortSignal(client.from(\"table_adjacencies\").select(\"table_a, table_b\"), signal);\n  const adjacencyUndirected = isAdjacencyQueryUndirected();\n  const targetIds = needFetch && cachedGraph ? missing : uniqueTableIds;\n  const forward = await baseQuery().in(\"table_a\", targetIds);\n  if (forward.error) {\n    return new Map();\n  }\n\n  const reverse = adjacencyUndirected ? await baseQuery().in(\"table_b\", targetIds) : null;\n  if (reverse?.error) {\n    return new Map();\n  }\n\n  const forwardRows = Array.isArray(forward.data) ? (forward.data as AdjacencyRow[]) : [];\n  const reverseRows =\n    adjacencyUndirected && reverse && Array.isArray(reverse.data)\n      ? (reverse.data as AdjacencyRow[])\n      : [];\n\n  const map = cachedGraph ? new Map<string, Set<string>>(cachedGraph) : new Map<string, Set<string>>();\n  if (targetIds.length > 0) {\n    for (const id of targetIds) {\n      map.delete(id);\n    }\n  }\n  const addEdge = (from: string | null, to: string | null) => {\n    if (!from || !to) {\n      return;\n    }\n    if (!map.has(from)) {\n      map.set(from, new Set());\n    }\n    map.get(from)!.add(to);\n  };\n\n  for (const row of forwardRows) {\n    addEdge(row.table_a, row.table_b);\n    if (adjacencyUndirected) {\n      addEdge(row.table_b, row.table_a);\n    }\n  }\n\n  if (adjacencyUndirected && reverseRows) {\n    for (const row of reverseRows) {\n      addEdge(row.table_a, row.table_b);\n      addEdge(row.table_b, row.table_a);\n    }\n  }\n\n  try {\n    const { setAdjacencyCache } = await import(\"@/server/capacity/cache\");\n    setAdjacencyCache(restaurantId, map);\n  } catch {\n    // ignore cache set failures\n  }\n\n  const filtered = new Map<string, Set<string>>();\n  for (const id of uniqueTableIds) {\n    if (map.has(id)) {\n      filtered.set(id, new Set(map.get(id)!));\n    }\n  }\n  return filtered;\n}\n\nexport async function loadContextBookings(\n  restaurantId: string,\n  bookingDate: string | null,\n  client: DbClient,\n  aroundWindow?: { startIso: string; endIso: string; paddingMinutes?: number },\n  signal?: AbortSignal,\n): Promise<ContextBookingRow[]> {\n  if (!bookingDate) {\n    return [];\n  }\n\n  const paddingDefault = Math.max(0, Math.min(getContextQueryPaddingMinutes(), 240));\n  const pad = Math.max(0, Math.min(aroundWindow?.paddingMinutes ?? paddingDefault, 240));\n  const startIso = aroundWindow?.startIso ?? null;\n  const endIso = aroundWindow?.endIso ?? null;\n  const padMs = pad * 60 * 1000;\n  const startPad = startIso ? DateTime.fromISO(startIso, { setZone: true }).minus({ milliseconds: padMs }).toISO() : null;\n  const endPad = endIso ? DateTime.fromISO(endIso, { setZone: true }).plus({ milliseconds: padMs }).toISO() : null;\n\n  let query = client\n    .from(\"bookings\")\n    .select(\n      [\n        \"id\",\n        \"party_size\",\n        \"status\",\n        \"start_time\",\n        \"end_time\",\n        \"start_at\",\n        \"end_at\",\n        \"booking_date\",\n        \"booking_table_assignments(table_id)\",\n      ].join(\",\"),\n    )\n    .eq(\"restaurant_id\", restaurantId)\n    .eq(\"booking_date\", bookingDate)\n    .in(\"status\", [...BOOKING_BLOCKING_STATUSES])\n    .order(\"start_at\", { ascending: true });\n\n  query = applyAbortSignal(query, signal);\n\n  const hasGt = typeof (query as unknown as { gt?: unknown }).gt === \"function\";\n  const hasLt = typeof (query as unknown as { lt?: unknown }).lt === \"function\";\n  if (startPad && hasGt) {\n    (query as unknown as { gt: (col: string, val: string) => unknown }).gt(\"end_at\", startPad);\n  }\n  if (endPad && hasLt) {\n    (query as unknown as { lt: (col: string, val: string) => unknown }).lt(\"start_at\", endPad);\n  }\n\n  const { data, error } = await query;\n\n  if (error || !data) {\n    return [];\n  }\n\n  return data as unknown as ContextBookingRow[];\n}\n\nexport async function loadTableAssignmentsForTables(\n  bookingId: string,\n  tableIds: string[],\n  client: DbClient,\n): Promise<BookingAssignmentRow[]> {\n  if (tableIds.length === 0) {\n    return [];\n  }\n\n  const { data, error } = await client\n    .from(\"booking_table_assignments\")\n    .select(\"table_id, id, start_at, end_at, merge_group_id\")\n    .eq(\"booking_id\", bookingId);\n\n  if (error || !data) {\n    return [];\n  }\n\n  const rows = data as unknown as BookingAssignmentRow[];\n  return rows.filter((row) => tableIds.includes(row.table_id));\n}\n\nexport async function fetchHoldsForWindow(\n  restaurantId: string,\n  window: BookingWindow,\n  client: DbClient,\n): Promise<TableHold[]> {\n  const { data, error } = await client\n    .from(\"table_holds\")\n    .select(\"*, table_hold_members(table_id)\")\n    .eq(\"restaurant_id\", restaurantId)\n    .gt(\"expires_at\", new Date().toISOString())\n    .lt(\"start_at\", toIsoUtc(window.block.end))\n    .gt(\"end_at\", toIsoUtc(window.block.start));\n\n  if (error || !data) {\n    throw error ?? new Error(\"Failed to load holds\");\n  }\n\n  const rows = data as TableHoldRow[];\n\n  return rows.map((row) => {\n    const members = row.table_hold_members ?? [];\n    const tableIds = members\n      .map((member) => member.table_id)\n      .filter((value): value is string => typeof value === \"string\");\n    return {\n      id: row.id,\n      bookingId: row.booking_id,\n      restaurantId: row.restaurant_id,\n      zoneId: row.zone_id,\n      startAt: row.start_at,\n      endAt: row.end_at,\n      expiresAt: row.expires_at,\n      tableIds,\n      createdBy: row.created_by ?? null,\n      metadata: row.metadata ?? null,\n    } satisfies TableHold;\n  });\n}\n\nexport async function loadActiveHoldsForDate(\n  restaurantId: string,\n  bookingDate: string | null,\n  policy: VenuePolicy,\n  client: DbClient,\n  signal?: AbortSignal,\n): Promise<TableHold[]> {\n  if (!bookingDate) {\n    return [];\n  }\n\n  const day = DateTime.fromISO(bookingDate, { zone: policy.timezone ?? \"UTC\" });\n  if (!day.isValid) {\n    return [];\n  }\n\n  const dayStart = toIsoUtc(day.startOf(\"day\"));\n  const dayEnd = toIsoUtc(day.plus({ days: 1 }).startOf(\"day\"));\n  const now = toIsoUtc(DateTime.now());\n\n  const holdsQuery = applyAbortSignal(\n    client\n      .from(\"table_holds\")\n      .select(\"*, table_hold_members(table_id)\")\n      .eq(\"restaurant_id\", restaurantId)\n      .gt(\"expires_at\", now)\n      .lt(\"start_at\", dayEnd)\n      .gt(\"end_at\", dayStart),\n    signal,\n  );\n\n  const { data, error } = await holdsQuery;\n\n  if (error || !data) {\n    throw error ?? new Error(\"Failed to load holds\");\n  }\n\n  const rows = data as TableHoldRow[];\n\n  return rows.map((row) => {\n    const members = row.table_hold_members ?? [];\n    const tableIds = members\n      .map((member) => member.table_id)\n      .filter((value): value is string => typeof value === \"string\");\n    return {\n      id: row.id,\n      bookingId: row.booking_id,\n      restaurantId: row.restaurant_id,\n      zoneId: row.zone_id,\n      startAt: row.start_at,\n      endAt: row.end_at,\n      expiresAt: row.expires_at,\n      tableIds,\n      createdBy: row.created_by ?? null,\n      metadata: row.metadata ?? null,\n    } satisfies TableHold;\n  });\n}\n\nexport async function releaseHoldWithRetry(params: {\n  holdId: string;\n  client: DbClient;\n  attempts?: number;\n  baseDelayMs?: number;\n}): Promise<void> {\n  const { holdId, client, attempts = 3, baseDelayMs = 50 } = params;\n  for (let attempt = 1; attempt <= attempts; attempt += 1) {\n    try {\n      await releaseTableHold({ holdId, client });\n      return;\n    } catch (error) {\n      if (attempt === attempts) {\n        throw error;\n      }\n      const jitter = Math.random() * baseDelayMs;\n      const delay = baseDelayMs * attempt + jitter;\n      await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n  }\n}\n\nexport function findMissingHoldMetadataFields(holdRow: TableHoldRow): string[] {\n  const missing: string[] = [];\n  const rawMetadata = (holdRow as { metadata?: unknown }).metadata;\n\n  if (!rawMetadata || typeof rawMetadata !== \"object\") {\n    return [\"metadata\"];\n  }\n\n  const metadata = rawMetadata as Record<string, unknown>;\n  if (typeof metadata.policyVersion !== \"string\" || metadata.policyVersion.trim().length === 0) {\n    missing.push(\"metadata.policyVersion\");\n  }\n\n  const selection = metadata.selection as Record<string, unknown> | undefined;\n  if (!selection || typeof selection !== \"object\") {\n    missing.push(\"metadata.selection\");\n    return missing;\n  }\n\n  const snapshot = selection.snapshot as Record<string, unknown> | undefined;\n  if (!snapshot || typeof snapshot !== \"object\") {\n    missing.push(\"metadata.selection.snapshot\");\n    return missing;\n  }\n\n  const zoneIds = snapshot.zoneIds;\n  if (!Array.isArray(zoneIds) || zoneIds.length === 0 || zoneIds.some((zone) => typeof zone !== \"string\" || zone.trim().length === 0)) {\n    missing.push(\"metadata.selection.snapshot.zoneIds\");\n  }\n\n  const adjacency = snapshot.adjacency as Record<string, unknown> | undefined;\n  if (!adjacency || typeof adjacency !== \"object\") {\n    missing.push(\"metadata.selection.snapshot.adjacency\");\n    return missing;\n  }\n\n  const edges = adjacency.edges;\n  if (!Array.isArray(edges) || edges.some((edge) => typeof edge !== \"string\")) {\n    missing.push(\"metadata.selection.snapshot.adjacency.edges\");\n  }\n\n  const hash = adjacency.hash;\n  if (typeof hash !== \"string\" || hash.trim().length === 0) {\n    missing.push(\"metadata.selection.snapshot.adjacency.hash\");\n  }\n\n  return missing;\n}\n",
  "server/capacity/table-assignment/types.ts": "import type { TableHold, HoldConflictInfo } from \"@/server/capacity/holds\";\nimport type { ServiceKey } from \"@/server/capacity/policy\";\nimport type { CandidateSummary } from \"@/server/capacity/telemetry\";\nimport type { Tables, Database } from \"@/types/supabase\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\nimport type { DateTime } from \"luxon\";\n\nexport type DbClient = SupabaseClient<Database, \"public\">;\n\nexport type Table = {\n  id: string;\n  tableNumber: string;\n  capacity: number;\n  minPartySize?: number | null;\n  maxPartySize?: number | null;\n  section?: string | null;\n  category?: Tables<\"table_inventory\">[\"category\"] | string | null;\n  seatingType?: Tables<\"table_inventory\">[\"seating_type\"] | string | null;\n  mobility?: Tables<\"table_inventory\">[\"mobility\"] | string | null;\n  zoneId: string;\n  status?: Tables<\"table_inventory\">[\"status\"] | string | null;\n  active?: boolean | null;\n  position?: Tables<\"table_inventory\">[\"position\"] | null;\n};\n\nexport type TableMatchParams = {\n  partySize: number;\n  requireAdjacency?: boolean;\n  avoidTableIds?: string[];\n  zoneId?: string | null;\n};\n\nexport type TableAssignmentMember = {\n  tableId: string;\n  assignmentId: string;\n  startAt: string;\n  endAt: string;\n  mergeGroupId?: string | null;\n};\n\nexport type TableAssignmentGroup = {\n  bookingId: string;\n  tableIds: string[];\n  assignments: TableAssignmentMember[];\n};\n\nexport type ManualSelectionCheck = {\n  id: \"capacity\" | \"zone\" | \"movable\" | \"adjacency\" | \"conflict\" | \"holds\";\n  status: \"ok\" | \"warning\" | \"error\";\n  message: string;\n  details?: Record<string, unknown>;\n};\n\nexport type ManualSelectionSummary = {\n  tableCount: number;\n  totalCapacity: number;\n  slack: number;\n  zoneId: string | null;\n  tableNumbers: string[];\n  partySize: number;\n};\n\nexport type ManualValidationResult = {\n  ok: boolean;\n  summary: ManualSelectionSummary;\n  checks: ManualSelectionCheck[];\n  policyVersion?: string;\n};\n\nexport type ManualSelectionOptions = {\n  bookingId: string;\n  tableIds: string[];\n  requireAdjacency?: boolean;\n  excludeHoldId?: string | null;\n  client?: DbClient;\n};\n\nexport type ManualHoldOptions = ManualSelectionOptions & {\n  createdBy: string;\n  holdTtlSeconds?: number;\n  holdExpiresAt?: string;\n};\n\nexport type ManualHoldResult = {\n  hold: TableHold | null;\n  validation: ManualValidationResult;\n};\n\nexport type QuoteTablesOptions = {\n  bookingId: string;\n  zoneId?: string | null;\n  maxTables?: number;\n  requireAdjacency?: boolean;\n  avoidTables?: string[];\n  holdTtlSeconds?: number;\n  createdBy: string;\n  client?: DbClient;\n  signal?: AbortSignal;\n};\n\nexport type QuoteTablesResult = {\n  hold: TableHold | null;\n  candidate: CandidateSummary | null;\n  alternates: CandidateSummary[];\n  nextTimes: string[];\n  reason?: string;\n  skipped?: Array<{ candidate: CandidateSummary; reason: string; conflicts: HoldConflictInfo[] }>;\n  metadata?: {\n    usedFallback: boolean;\n    fallbackService: ServiceKey | null;\n  };\n};\n\nexport type ManualAssignmentConflict = {\n  tableId: string;\n  bookingId: string | null;\n  startAt: string;\n  endAt: string;\n  source: \"booking\" | \"hold\";\n};\n\nexport type ManualAssignmentContextHold = TableHold & {\n  createdByName?: string | null;\n  createdByEmail?: string | null;\n  summary?: ManualSelectionSummary;\n};\n\nexport type ManualAssignmentContext = {\n  booking: Tables<\"bookings\">;\n  tables: Table[];\n  bookingAssignments: string[];\n  holds: ManualAssignmentContextHold[];\n  activeHold: ManualAssignmentContextHold | null;\n  conflicts: ManualAssignmentConflict[];\n  window: {\n    startAt: string | null;\n    endAt: string | null;\n  };\n  flags?: {\n    holdsStrictConflicts: boolean;\n    adjacencyRequired: boolean;\n    adjacencyUndirected: boolean;\n  };\n  contextVersion?: string;\n  serverNow?: string;\n};\n\nexport type BookingWindow = {\n  service: ServiceKey;\n  durationMinutes: number;\n  dining: {\n    start: DateTime;\n    end: DateTime;\n  };\n  block: {\n    start: DateTime;\n    end: DateTime;\n  };\n  clampedToServiceEnd: boolean;\n};\n\nexport class ManualSelectionInputError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string = \"MANUAL_SELECTION_INPUT_INVALID\",\n    public readonly status = 400,\n  ) {\n    super(message);\n    this.name = \"ManualSelectionInputError\";\n  }\n}\n",
  "server/capacity/table-assignment/utils.ts": "import { DateTime } from \"luxon\";\n\nimport type { ManualSelectionSummary, Table } from \"./types\";\nimport type { SelectorDecisionEvent } from \"@/server/capacity/telemetry\";\n\nexport function toIsoUtc(dateTime: DateTime): string {\n  return dateTime.setZone(\"UTC\").toISO({\n    suppressMilliseconds: true,\n    suppressSeconds: false,\n    includeOffset: false,\n  })!;\n}\n\nexport function normalizeIsoString(value: string | null | undefined): string | null {\n  if (!value) {\n    return null;\n  }\n  const parsed = DateTime.fromISO(value, { setZone: true });\n  if (!parsed.isValid) {\n    return null;\n  }\n  return toIsoUtc(parsed);\n}\n\nexport function highResNow(): number {\n  return typeof performance !== \"undefined\" ? performance.now() : Date.now();\n}\n\nexport function roundMilliseconds(value: number): number {\n  return Math.round(value * 100) / 100;\n}\n\nexport function buildTiming(params: {\n  totalMs: number;\n  plannerMs?: number;\n  assignmentMs?: number;\n  holdMs?: number;\n}): SelectorDecisionEvent[\"timing\"] {\n  const timing: SelectorDecisionEvent[\"timing\"] = {\n    totalMs: roundMilliseconds(params.totalMs),\n  };\n\n  if (typeof params.plannerMs === \"number\" && params.plannerMs > 0) {\n    timing.plannerMs = roundMilliseconds(params.plannerMs);\n  }\n  if (typeof params.assignmentMs === \"number\" && params.assignmentMs > 0) {\n    timing.assignmentMs = roundMilliseconds(params.assignmentMs);\n  }\n  if (typeof params.holdMs === \"number\" && params.holdMs > 0) {\n    timing.holdMs = roundMilliseconds(params.holdMs);\n  }\n\n  return timing;\n}\n\nexport function serializeDetails(value: unknown): string | null {\n  if (value === undefined || value === null) {\n    return null;\n  }\n  try {\n    return JSON.stringify(value);\n  } catch {\n    return null;\n  }\n}\n\nexport function summarizeSelection(tables: Table[], partySize: number): ManualSelectionSummary {\n  const totalCapacity = tables.reduce((sum, table) => sum + (table.capacity ?? 0), 0);\n  const zoneIds = new Set(tables.map((table) => table.zoneId));\n  return {\n    tableCount: tables.length,\n    totalCapacity,\n    slack: Math.max(0, totalCapacity - partySize),\n    zoneId: zoneIds.size === 1 ? tables[0]?.zoneId ?? null : null,\n    tableNumbers: tables.map((table) => table.tableNumber),\n    partySize,\n  };\n}\n",
  "server/capacity/tables.ts": "import {\n  computeBookingWindow as computeBookingWindowInternal,\n  filterAvailableTables as filterAvailableTablesInternal,\n  filterTimeAvailableTables as filterTimeAvailableTablesInternal,\n  extractConflictsForTables as extractConflictsForTablesInternal,\n} from \"./table-assignment\";\nimport { windowsOverlap } from \"./time-windows\";\n\nexport type {\n  Table,\n  TableMatchParams,\n  TableAssignmentMember,\n  TableAssignmentGroup,\n  ManualSelectionCheck,\n  ManualSelectionSummary,\n  ManualValidationResult,\n  ManualSelectionOptions,\n  ManualHoldOptions,\n  ManualHoldResult,\n  ManualAssignmentConflict,\n  ManualAssignmentContextHold,\n  ManualAssignmentContext,\n  BookingWindow,\n  QuoteTablesOptions,\n  QuoteTablesResult,\n} from \"./table-assignment\";\n\nexport { ManualSelectionInputError } from \"./table-assignment\";\n\nexport {\n  computeBookingWindow,\n  filterAvailableTables,\n  evaluateLookahead,\n  evaluateManualSelection,\n  createManualHold,\n  getManualAssignmentContext,\n  confirmHoldAssignment,\n  atomicConfirmAndTransition,\n  assignTableToBooking,\n  unassignTableFromBooking,\n  getBookingTableAssignments,\n  quoteTablesForBooking,\n  findSuitableTables,\n  isTableAvailableV2,\n  isTableAvailable,\n} from \"./table-assignment\";\n\nexport type { IntervalLike } from \"./time-windows\";\n\nexport const __internal = {\n  computeBookingWindow: computeBookingWindowInternal,\n  windowsOverlap,\n  filterAvailableTables: filterAvailableTablesInternal,\n  filterTimeAvailableTables: filterTimeAvailableTablesInternal,\n  extractConflictsForTables: extractConflictsForTablesInternal,\n};\n"
}
