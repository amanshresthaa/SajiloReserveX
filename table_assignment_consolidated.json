{
  "files": [
    {
      "path": "server/capacity/tables.ts",
      "content": "import { DateTime } from \"luxon\";\nimport { randomUUID } from \"node:crypto\";\nimport { performance } from \"node:perf_hooks\";\n\nimport {\n  getAllocatorAdjacencyMinPartySize,\n  getAllocatorKMax as getAllocatorCombinationLimit,\n  getSelectorPlannerLimits,\n  isAllocatorAdjacencyRequired,\n  isAllocatorMergesEnabled,\n  isAllocatorV2Enabled,\n  isCombinationPlannerEnabled,\n  isHoldsEnabled,\n  isOpsMetricsEnabled,\n  isSelectorScoringEnabled,\n} from \"@/server/feature-flags\";\nimport { getServiceSupabaseClient } from \"@/server/supabase\";\n\nimport {\n  AssignTablesRpcError,\n  HoldConflictError,\n  HoldNotFoundError,\n  createTableHold,\n  findHoldConflicts,\n  listActiveHoldsForBooking,\n  releaseTableHold,\n  type CreateTableHoldInput,\n  type HoldConflictInfo,\n  type TableHold,\n} from \"./holds\";\nimport { createAvailabilityBitset, markWindow, isWindowFree } from \"./planner/bitset\";\nimport {\n  bandDuration,\n  getBufferConfig,\n  getSelectorScoringConfig,\n  getVenuePolicy,\n  serviceEnd,\n  whichService,\n  type SelectorScoringConfig,\n  type ServiceKey,\n  type VenuePolicy,\n  ServiceNotFoundError,\n  ServiceOverrunError,\n} from \"./policy\";\nimport { buildScoredTablePlans, type RankedTablePlan, type CandidateDiagnostics } from \"./selector\";\nimport {\n  emitHoldConfirmed,\n  emitRpcConflict,\n  emitSelectorDecision,\n  emitSelectorQuote,\n  summarizeCandidate,\n  type CandidateSummary,\n  type SelectorDecisionEvent,\n} from \"./telemetry\";\nimport {\n  AssignmentConflictError,\n  AssignmentOrchestrator,\n  AssignmentRepositoryError,\n  AssignmentValidationError,\n  SupabaseAssignmentRepository,\n  createPlanSignature,\n  normalizeTableIds,\n} from \"./v2\";\n\nimport type { Database, Tables } from \"@/types/supabase\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\n\ntype DbClient = SupabaseClient<Database, \"public\">;\n\ntype TableInventoryRow = Tables<\"table_inventory\">;\n\nconst TABLE_INVENTORY_SELECT =\n  \"id,table_number,capacity,min_party_size,max_party_size,section,category,seating_type,mobility,zone_id,status,active,position\" as const;\n\ntype TableHoldRow = Tables<\"table_holds\"> & {\n  table_hold_members: Array<{ table_id: string | null }> | null;\n};\n\ntype AssignmentAvailabilityRow = {\n  table_id: string | null;\n  start_at: string | null;\n  end_at: string | null;\n  bookings: Pick<Tables<\"bookings\">, \"id\" | \"status\" | \"start_at\" | \"end_at\"> | null;\n};\n\nconst DEFAULT_HOLD_TTL_SECONDS = 180;\nconst TABLE_RESOURCE_TYPE = \"table\";\n\nexport type Table = {\n  id: string;\n  tableNumber: string;\n  capacity: number;\n  minPartySize?: number | null;\n  maxPartySize?: number | null;\n  section?: string | null;\n  category?: Tables<\"table_inventory\">[\"category\"] | string | null;\n  seatingType?: Tables<\"table_inventory\">[\"seating_type\"] | string | null;\n  mobility?: Tables<\"table_inventory\">[\"mobility\"] | string | null;\n  zoneId: string;\n  status?: Tables<\"table_inventory\">[\"status\"] | string | null;\n  active?: boolean | null;\n  position?: Tables<\"table_inventory\">[\"position\"] | null;\n};\n\nexport type TableMatchParams = {\n  partySize: number;\n  requireAdjacency?: boolean;\n  avoidTableIds?: string[];\n  zoneId?: string | null;\n};\n\nexport type TableAssignmentMember = {\n  tableId: string;\n  assignmentId: string;\n  startAt: string;\n  endAt: string;\n  mergeGroupId?: string | null;\n};\n\nexport type TableAssignmentGroup = {\n  bookingId: string;\n  tableIds: string[];\n  assignments: TableAssignmentMember[];\n};\n\nexport type ManualSelectionCheck = {\n  id: \"capacity\" | \"zone\" | \"movable\" | \"adjacency\" | \"conflict\" | \"holds\";\n  status: \"ok\" | \"warning\" | \"error\";\n  message: string;\n  details?: Record<string, unknown>;\n};\n\nexport type ManualSelectionSummary = {\n  tableCount: number;\n  totalCapacity: number;\n  slack: number;\n  zoneId: string | null;\n  tableNumbers: string[];\n  partySize: number;\n};\n\nexport type ManualValidationResult = {\n  ok: boolean;\n  summary: ManualSelectionSummary;\n  checks: ManualSelectionCheck[];\n};\n\nexport type ManualSelectionOptions = {\n  bookingId: string;\n  tableIds: string[];\n  requireAdjacency?: boolean;\n  excludeHoldId?: string | null;\n  client?: DbClient;\n};\n\nexport type ManualHoldOptions = ManualSelectionOptions & {\n  createdBy: string;\n  holdTtlSeconds?: number;\n  holdExpiresAt?: string;\n};\n\nexport type ManualHoldResult = {\n  hold: TableHold | null;\n  validation: ManualValidationResult;\n};\n\nexport type AutoAssignResult = {\n  assigned: Array<{ bookingId: string; tableIds: string[] }>;\n  skipped: Array<{ bookingId: string; reason: string }>;\n};\n\nexport type QuoteTablesOptions = {\n  bookingId: string;\n  zoneId?: string | null;\n  maxTables?: number;\n  requireAdjacency?: boolean;\n  avoidTables?: string[];\n  holdTtlSeconds?: number;\n  createdBy: string;\n  client?: DbClient;\n};\n\nexport type QuoteTablesResult = {\n  hold: TableHold | null;\n  candidate: CandidateSummary | null;\n  alternates: CandidateSummary[];\n  nextTimes: string[];\n  reason?: string;\n};\n\nexport type ManualAssignmentConflict = {\n  tableId: string;\n  bookingId: string | null;\n  startAt: string;\n  endAt: string;\n  source: \"booking\" | \"hold\";\n};\n\nexport type ManualAssignmentContextHold = TableHold & {\n  createdByName?: string | null;\n  createdByEmail?: string | null;\n  summary?: ManualSelectionSummary;\n};\n\nexport type ManualAssignmentContext = {\n  booking: Tables<\"bookings\">;\n  tables: Table[];\n  bookingAssignments: string[];\n  holds: ManualAssignmentContextHold[];\n  activeHold: ManualAssignmentContextHold | null;\n  conflicts: ManualAssignmentConflict[];\n  window: {\n    startAt: string | null;\n    endAt: string | null;\n  };\n};\n\ntype BookingRow = Tables<\"bookings\"> & {\n  restaurants?: { timezone: string | null } | { timezone: string | null }[];\n};\n\ntype ContextBookingRow = {\n  id: string;\n  party_size: number;\n  status: string;\n  start_time: string | null;\n  end_time: string | null;\n  start_at: string | null;\n  end_at: string | null;\n  booking_date: string | null;\n  seating_preference?: string | null;\n  booking_table_assignments: Array<{ table_id: string | null }> | null;\n};\n\ntype BusyWindow = {\n  tableId: string;\n  startAt: string;\n  endAt: string;\n  bookingId: string | null;\n  source: \"booking\" | \"hold\";\n};\n\ntype AvailabilityMap = Map<\n  string,\n  {\n    bitset: ReturnType<typeof createAvailabilityBitset>;\n    windows: BusyWindow[];\n  }\n>;\n\nexport class ManualSelectionInputError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string = \"MANUAL_SELECTION_INPUT_INVALID\",\n    public readonly status = 400,\n  ) {\n    super(message);\n    this.name = \"ManualSelectionInputError\";\n  }\n}\n\nfunction ensureClient(client?: DbClient): DbClient {\n  return client ?? getServiceSupabaseClient();\n}\n\nfunction extractErrorCode(error: unknown): string | undefined {\n  if (typeof error !== \"object\" || error === null) {\n    return undefined;\n  }\n  const code = (error as { code?: unknown }).code;\n  return typeof code === \"string\" ? code : undefined;\n}\n\nfunction normalizeBookingRow(row: BookingRow): BookingRow {\n  if (Array.isArray(row.restaurants) && row.restaurants.length > 0) {\n    return { ...row, restaurants: row.restaurants[0] ?? null };\n  }\n  return row;\n}\n\nexport type BookingWindow = ReturnType<typeof computeBookingWindow>;\n\nexport function computeBookingWindow(args: {\n  startISO?: string | null;\n  bookingDate?: string | null;\n  startTime?: string | null;\n  partySize: number;\n  policy?: VenuePolicy;\n  serviceHint?: ServiceKey | null;\n}): {\n  service: ServiceKey;\n  durationMinutes: number;\n  dining: {\n    start: DateTime;\n    end: DateTime;\n  };\n  block: {\n    start: DateTime;\n    end: DateTime;\n  };\n} {\n  const policy = args.policy ?? getVenuePolicy();\n  const baseStart = resolveStartDateTime(args, policy);\n  const service = resolveService(baseStart, args.serviceHint ?? null, policy);\n\n  const diningMinutes = bandDuration(service, args.partySize, policy);\n  const buffer = getBufferConfig(service, policy);\n  const diningStart = baseStart;\n  const diningEnd = diningStart.plus({ minutes: diningMinutes });\n  const blockStart = diningStart.minus({ minutes: buffer.pre ?? 0 });\n  const blockEnd = diningEnd.plus({ minutes: buffer.post ?? 0 });\n\n  const serviceEndBoundary = serviceEnd(service, diningStart, policy);\n  if (blockEnd > serviceEndBoundary) {\n    throw new ServiceOverrunError(service, blockEnd, serviceEndBoundary);\n  }\n\n  return {\n    service,\n    durationMinutes: diningMinutes,\n    dining: {\n      start: diningStart,\n      end: diningEnd,\n    },\n    block: {\n      start: blockStart,\n      end: blockEnd,\n    },\n  };\n}\n\ntype ComputeWindowArgs = {\n  startISO?: string | null;\n  bookingDate?: string | null;\n  startTime?: string | null;\n  partySize: number;\n  policy?: VenuePolicy;\n  serviceHint?: ServiceKey | null;\n};\n\nfunction computeBookingWindowWithFallback(args: ComputeWindowArgs): BookingWindow {\n  const policy = args.policy ?? getVenuePolicy();\n  try {\n    return computeBookingWindow({ ...args, policy });\n  } catch (error) {\n    if (error instanceof ServiceNotFoundError) {\n      const serviceOrderCandidates = policy.serviceOrder.filter((key) => Boolean(policy.services[key]));\n      const servicesFallback = (Object.keys(policy.services) as ServiceKey[]).filter((key) =>\n        Boolean(policy.services[key]),\n      );\n      const fallbackService =\n        args.serviceHint && policy.services[args.serviceHint]\n          ? args.serviceHint\n          : serviceOrderCandidates[0] ?? servicesFallback[0];\n\n      if (!fallbackService || !policy.services[fallbackService]) {\n        throw error;\n      }\n\n      const baseStart = resolveStartDateTime(args, policy);\n      const durationMinutes = bandDuration(fallbackService, args.partySize, policy);\n      const buffer = getBufferConfig(fallbackService, policy);\n      const diningStart = baseStart;\n      const diningEnd = diningStart.plus({ minutes: durationMinutes });\n      const blockStart = diningStart.minus({ minutes: buffer.pre ?? 0 });\n      const blockEnd = diningEnd.plus({ minutes: buffer.post ?? 0 });\n      const serviceEndBoundary = serviceEnd(fallbackService, diningStart, policy);\n      if (blockEnd > serviceEndBoundary) {\n        throw new ServiceOverrunError(fallbackService, blockEnd, serviceEndBoundary);\n      }\n\n      console.warn(\"[capacity][window][fallback] service not found, using fallback service\", {\n        start: baseStart.toISO(),\n        fallbackService,\n      });\n\n      return {\n        service: fallbackService,\n        durationMinutes,\n        dining: {\n          start: diningStart,\n          end: diningEnd,\n        },\n        block: {\n          start: blockStart,\n          end: blockEnd,\n        },\n      };\n    }\n\n    throw error;\n  }\n}\n\nfunction resolveStartDateTime(\n  args: {\n    startISO?: string | null;\n    bookingDate?: string | null;\n    startTime?: string | null;\n  },\n  policy: VenuePolicy,\n): DateTime {\n  if (args.startISO) {\n    const parsed = DateTime.fromISO(args.startISO);\n    if (!parsed.isValid) {\n      throw new ManualSelectionInputError(\"Invalid start ISO timestamp provided\", \"INVALID_START\");\n    }\n    return parsed.setZone(policy.timezone, { keepLocalTime: false });\n  }\n\n  const { bookingDate, startTime } = args;\n  if (!bookingDate || !startTime) {\n    throw new ManualSelectionInputError(\"Booking date and start time are required\", \"START_TIME_REQUIRED\");\n  }\n\n  const composed = DateTime.fromISO(`${bookingDate}T${startTime}`, { zone: policy.timezone });\n  if (!composed.isValid) {\n    throw new ManualSelectionInputError(\"Invalid booking date/time\", \"INVALID_START\");\n  }\n  return composed;\n}\n\nfunction resolveService(start: DateTime, hint: ServiceKey | null, policy: VenuePolicy): ServiceKey {\n  if (hint) {\n    return hint;\n  }\n  const found = whichService(start, policy);\n  if (!found) {\n    throw new ServiceNotFoundError(start);\n  }\n  return found;\n}\n\ntype IntervalPoint = DateTime | string | number;\ntype IntervalLike = {\n  start: IntervalPoint;\n  end: IntervalPoint;\n};\n\nfunction intervalPointToMillis(point: IntervalPoint): number | null {\n  if (DateTime.isDateTime(point)) {\n    const value = point.toMillis();\n    return Number.isFinite(value) ? value : null;\n  }\n\n  if (typeof point === \"number\") {\n    return Number.isFinite(point) ? point : null;\n  }\n\n  if (typeof point === \"string\") {\n    const parsed = DateTime.fromISO(point, { setZone: true });\n    if (!parsed.isValid) {\n      return null;\n    }\n    const value = parsed.toMillis();\n    return Number.isFinite(value) ? value : null;\n  }\n\n  return null;\n}\n\nfunction normalizeInterval(interval: IntervalLike): { start: number; end: number } | null {\n  const start = intervalPointToMillis(interval.start);\n  const end = intervalPointToMillis(interval.end);\n  if (start === null || end === null) {\n    return null;\n  }\n  if (!(start < end)) {\n    return null;\n  }\n  return { start, end };\n}\n\nfunction highResNow(): number {\n  return typeof performance !== \"undefined\" ? performance.now() : Date.now();\n}\n\nfunction roundMilliseconds(value: number): number {\n  return Math.round(value * 100) / 100;\n}\n\nfunction buildTiming(params: {\n  totalMs: number;\n  plannerMs?: number;\n  assignmentMs?: number;\n  holdMs?: number;\n}): SelectorDecisionEvent[\"timing\"] {\n  const timing: SelectorDecisionEvent[\"timing\"] = {\n    totalMs: roundMilliseconds(params.totalMs),\n  };\n\n  if (typeof params.plannerMs === \"number\" && params.plannerMs > 0) {\n    timing.plannerMs = roundMilliseconds(params.plannerMs);\n  }\n  if (typeof params.assignmentMs === \"number\" && params.assignmentMs > 0) {\n    timing.assignmentMs = roundMilliseconds(params.assignmentMs);\n  }\n  if (typeof params.holdMs === \"number\" && params.holdMs > 0) {\n    timing.holdMs = roundMilliseconds(params.holdMs);\n  }\n\n  return timing;\n}\n\n/**\n * Normalizes planner configuration details so telemetry consumers receive a\n * consistent view of the limits and feature toggles that influenced a search.\n */\nfunction composePlannerConfig(params: {\n  diagnostics: CandidateDiagnostics;\n  scoringConfig: SelectorScoringConfig;\n  combinationEnabled: boolean;\n  requireAdjacency: boolean;\n  adjacencyRequiredGlobally: boolean;\n  adjacencyMinPartySize: number | null;\n}): NonNullable<SelectorDecisionEvent[\"plannerConfig\"]> {\n  const { diagnostics, scoringConfig } = params;\n  const { limits } = diagnostics;\n\n  return {\n    combinationEnabled: params.combinationEnabled,\n    requireAdjacency: params.requireAdjacency,\n    adjacencyRequiredGlobally: params.adjacencyRequiredGlobally,\n    adjacencyMinPartySize: params.adjacencyMinPartySize,\n    kMax: limits.kMax,\n    bucketLimit: limits.maxPlansPerSlack,\n    evaluationLimit: limits.maxCombinationEvaluations,\n    maxOverage: scoringConfig.maxOverage,\n    maxTables: scoringConfig.maxTables,\n  };\n}\n\n/**\n * Returns whether the half-open interval `[a.start, a.end)` intersects with `[b.start, b.end)`.\n *\n * Accepts ISO strings, Luxon {@link DateTime} instances, or epoch millisecond numbers.\n * Values are normalized to UTC and invalid intervals are treated as non-overlapping.\n */\nexport function windowsOverlap(a: IntervalLike, b: IntervalLike): boolean {\n  const first = normalizeInterval(a);\n  const second = normalizeInterval(b);\n  if (!first || !second) {\n    return false;\n  }\n\n  return first.start < second.end && second.start < first.end;\n}\n\nfunction toIsoUtc(dateTime: DateTime): string {\n  return (\n    dateTime.toUTC().toISO({ suppressMilliseconds: true }) ??\n    dateTime.toUTC().toISO() ??\n    dateTime.toUTC().toString()\n  );\n}\n\nfunction normalizeIsoString(value: string | null | undefined): string | null {\n  if (!value) {\n    return null;\n  }\n  const parsed = DateTime.fromISO(value);\n  if (!parsed.isValid) {\n    return null;\n  }\n  return toIsoUtc(parsed);\n}\n\nexport function filterAvailableTables(\n  tables: Table[],\n  partySize: number,\n  window: ReturnType<typeof computeBookingWindow>,\n  adjacency: Map<string, Set<string>>,\n  avoidTables?: Set<string>,\n  zoneId?: string | null,\n  options?: { allowInsufficientCapacity?: boolean },\n): Table[] {\n  const allowPartial = options?.allowInsufficientCapacity ?? false;\n  const avoid = avoidTables ?? new Set<string>();\n\n  const filtered = tables.filter((table) => {\n    if (!table) return false;\n    if (avoid.has(table.id)) return false;\n    if (zoneId && table.zoneId !== zoneId) return false;\n    if (table.active === false) return false;\n    if (typeof table.status === \"string\" && table.status.toLowerCase() === \"out_of_service\") return false;\n    const capacity = table.capacity ?? 0;\n    if (!Number.isFinite(capacity) || capacity <= 0) return false;\n    if (!allowPartial && capacity < partySize) return false;\n    if (typeof table.maxPartySize === \"number\" && table.maxPartySize > 0 && partySize > table.maxPartySize) {\n      return false;\n    }\n    if (typeof table.minPartySize === \"number\" && table.minPartySize > 0 && partySize < table.minPartySize) {\n      return false;\n    }\n    // If adjacency map is supplied and requires zone-level adjacency, ensure entry exists.\n    if (partiesRequireAdjacency(partySize) && adjacency.size > 0 && !adjacency.has(table.id)) {\n      adjacency.set(table.id, new Set());\n    }\n    return true;\n  });\n\n  return filtered.sort((a, b) => {\n    const capacityDiff = (a.capacity ?? 0) - (b.capacity ?? 0);\n    if (capacityDiff !== 0) return capacityDiff;\n    return a.tableNumber.localeCompare(b.tableNumber);\n  });\n}\n\n/**\n * Determines whether adjacency must be enforced for a given party size.\n *\n * The allocator-level `requireAdjacency` flag acts as a global gate, while\n * `allocator.adjacencyMinPartySize` (when provided) raises the threshold so\n * that only large parties mandate adjacency.\n */\nfunction partiesRequireAdjacency(partySize: number): boolean {\n  if (!isAllocatorAdjacencyRequired()) {\n    return false;\n  }\n  const minPartySize = getAllocatorAdjacencyMinPartySize();\n  if (typeof minPartySize === \"number\") {\n    return partySize >= minPartySize;\n  }\n  return true;\n}\n\n/**\n * Resolves the adjacency requirement for interactive flows, preferring the\n * explicit override supplied by the caller but falling back to the allocator\n * policy when no override is present.\n */\nfunction resolveRequireAdjacency(partySize: number, override?: boolean): boolean {\n  if (typeof override === \"boolean\") {\n    return override;\n  }\n  return partiesRequireAdjacency(partySize);\n}\n\nasync function loadBooking(bookingId: string, client: DbClient): Promise<BookingRow> {\n  const { data, error } = await client\n    .from(\"bookings\")\n    .select(\n      [\n        \"id\",\n        \"restaurant_id\",\n        \"booking_date\",\n        \"start_time\",\n        \"end_time\",\n        \"start_at\",\n        \"end_at\",\n        \"party_size\",\n        \"status\",\n        \"seating_preference\",\n        \"restaurants(timezone)\",\n      ].join(\",\"),\n    )\n    .eq(\"id\", bookingId)\n    .maybeSingle();\n\n  if (error) {\n    throw new ManualSelectionInputError(error.message ?? \"Failed to load booking\", \"BOOKING_LOOKUP_FAILED\", 500);\n  }\n\n  if (!data) {\n    throw new ManualSelectionInputError(\"Booking not found\", \"BOOKING_NOT_FOUND\", 404);\n  }\n\n  return normalizeBookingRow(data as unknown as BookingRow);\n}\n\nasync function loadRestaurantTimezone(restaurantId: string, client: DbClient): Promise<string | null> {\n  const { data, error } = await client\n    .from(\"restaurants\")\n    .select(\"timezone\")\n    .eq(\"id\", restaurantId)\n    .maybeSingle();\n\n  if (error) {\n    throw new ManualSelectionInputError(error.message ?? \"Failed to load restaurant timezone\", \"RESTAURANT_LOOKUP_FAILED\", 500);\n  }\n\n  return data?.timezone ?? null;\n}\n\nasync function loadTablesForRestaurant(restaurantId: string, client: DbClient): Promise<Table[]> {\n  const { data, error } = await client\n    .from(\"table_inventory\")\n    .select<typeof TABLE_INVENTORY_SELECT, TableInventoryRow>(TABLE_INVENTORY_SELECT)\n    .eq(\"restaurant_id\", restaurantId)\n    .order(\"table_number\", { ascending: true });\n\n  if (error || !data) {\n    return [];\n  }\n\n  const rows = data as unknown as Tables<\"table_inventory\">[];\n\n  return rows.map((row) => ({\n    id: row.id,\n    tableNumber: row.table_number,\n    capacity: row.capacity ?? 0,\n    minPartySize: row.min_party_size ?? null,\n    maxPartySize: row.max_party_size ?? null,\n    section: row.section,\n    category: row.category,\n    seatingType: row.seating_type,\n    mobility: row.mobility,\n    zoneId: row.zone_id,\n    status: row.status,\n    active: row.active,\n    position: row.position,\n  }));\n}\n\nasync function loadTablesByIds(\n  restaurantId: string,\n  tableIds: string[],\n  client: DbClient,\n): Promise<Table[]> {\n  if (tableIds.length === 0) {\n    return [];\n  }\n\n  const uniqueIds = Array.from(new Set(tableIds));\n  const { data, error } = await client\n    .from(\"table_inventory\")\n    .select<typeof TABLE_INVENTORY_SELECT, TableInventoryRow>(TABLE_INVENTORY_SELECT)\n    .eq(\"restaurant_id\", restaurantId)\n    .in(\"id\", uniqueIds);\n\n  if (error || !data) {\n    return [];\n  }\n\n  const rows = data as unknown as TableInventoryRow[];\n\n  const lookup = new Map(\n    rows.map((row) => [\n      row.id,\n      {\n        id: row.id,\n        tableNumber: row.table_number,\n        capacity: row.capacity ?? 0,\n        minPartySize: row.min_party_size ?? null,\n        maxPartySize: row.max_party_size ?? null,\n        section: row.section,\n        category: row.category,\n        seatingType: row.seating_type,\n        mobility: row.mobility,\n        zoneId: row.zone_id,\n        status: row.status,\n        active: row.active,\n        position: row.position,\n      } satisfies Table,\n    ]),\n  );\n\n  return tableIds.reduce<Table[]>((acc, id) => {\n    const table = lookup.get(id);\n    if (table) {\n      acc.push(table);\n    }\n    return acc;\n  }, []);\n}\n\nasync function loadAdjacency(tableIds: string[], client: DbClient): Promise<Map<string, Set<string>>> {\n  if (tableIds.length === 0) {\n    return new Map();\n  }\n\n  const { data, error } = await client\n    .from(\"table_adjacencies\")\n    .select(\"table_a, table_b\")\n    .in(\"table_a\", tableIds);\n\n  if (error || !data) {\n    return new Map();\n  }\n\n  const map = new Map<string, Set<string>>();\n  for (const row of data) {\n    if (!map.has(row.table_a)) {\n      map.set(row.table_a, new Set());\n    }\n    map.get(row.table_a)!.add(row.table_b);\n    if (!map.has(row.table_b)) {\n      map.set(row.table_b, new Set());\n    }\n    map.get(row.table_b)!.add(row.table_a);\n  }\n  return map;\n}\n\nasync function loadContextBookings(\n  restaurantId: string,\n  bookingDate: string | null,\n  client: DbClient,\n): Promise<ContextBookingRow[]> {\n  if (!bookingDate) {\n    return [];\n  }\n\n  const { data, error } = await client\n    .from(\"bookings\")\n    .select(\n      [\n        \"id\",\n        \"party_size\",\n        \"status\",\n        \"start_time\",\n        \"end_time\",\n        \"start_at\",\n        \"end_at\",\n        \"booking_date\",\n        \"booking_table_assignments(table_id)\",\n      ].join(\",\"),\n    )\n    .eq(\"restaurant_id\", restaurantId)\n    .eq(\"booking_date\", bookingDate)\n    .order(\"start_at\", { ascending: true });\n\n  if (error || !data) {\n    return [];\n  }\n\n  return data as unknown as ContextBookingRow[];\n}\n\ntype BookingAssignmentRow = {\n  table_id: string;\n  id: string;\n  start_at: string | null;\n  end_at: string | null;\n  merge_group_id: string | null;\n};\n\nasync function loadTableAssignmentsForTables(\n  bookingId: string,\n  tableIds: string[],\n  client: DbClient,\n): Promise<BookingAssignmentRow[]> {\n  if (tableIds.length === 0) {\n    return [];\n  }\n\n  const { data, error } = await client\n    .from(\"booking_table_assignments\")\n    .select(\"table_id, id, start_at, end_at, merge_group_id\")\n    .eq(\"booking_id\", bookingId)\n    .in(\"table_id\", Array.from(new Set(tableIds)));\n\n  if (error || !data) {\n    return [];\n  }\n\n  const rows = data as unknown as BookingAssignmentRow[];\n  return rows.filter((row) => tableIds.includes(row.table_id));\n}\n\nfunction registerBusyWindow(\n  map: AvailabilityMap,\n  tableId: string,\n  window: { startAt: string; endAt: string; bookingId: string | null; source: \"booking\" | \"hold\" },\n): void {\n  if (!map.has(tableId)) {\n    map.set(tableId, {\n      bitset: createAvailabilityBitset(),\n      windows: [],\n    });\n  }\n  const entry = map.get(tableId)!;\n  markWindow(entry.bitset, window.startAt, window.endAt);\n  entry.windows.push({\n    tableId,\n    ...window,\n  });\n}\n\nfunction buildBusyMaps(params: {\n  targetBookingId: string;\n  bookings: ContextBookingRow[];\n  holds: TableHold[];\n  excludeHoldId?: string | null;\n  policy: VenuePolicy;\n}): AvailabilityMap {\n  const { targetBookingId, bookings, holds, excludeHoldId, policy } = params;\n  const map: AvailabilityMap = new Map();\n\n  for (const booking of bookings) {\n    if (booking.id === targetBookingId) continue;\n    const assignments = booking.booking_table_assignments ?? [];\n    if (assignments.length === 0) continue;\n\n    const window = computeBookingWindowWithFallback({\n      startISO: booking.start_at,\n      bookingDate: booking.booking_date,\n      startTime: booking.start_time,\n      partySize: booking.party_size,\n      policy,\n    });\n\n    for (const assignment of assignments) {\n      if (!assignment?.table_id) continue;\n      registerBusyWindow(map, assignment.table_id, {\n        startAt: toIsoUtc(window.block.start),\n        endAt: toIsoUtc(window.block.end),\n        bookingId: booking.id,\n        source: \"booking\",\n      });\n    }\n  }\n\n  for (const hold of holds) {\n    if (excludeHoldId && hold.id === excludeHoldId) continue;\n    for (const tableId of hold.tableIds) {\n      registerBusyWindow(map, tableId, {\n        startAt: hold.startAt,\n        endAt: hold.endAt,\n        bookingId: hold.bookingId,\n        source: \"hold\",\n      });\n    }\n  }\n\n  return map;\n}\n\nfunction extractConflictsForTables(\n  busy: AvailabilityMap,\n  tableIds: string[],\n  window: ReturnType<typeof computeBookingWindow>,\n): ManualAssignmentConflict[] {\n  const conflicts: ManualAssignmentConflict[] = [];\n  const targetStart = toIsoUtc(window.block.start);\n  const targetEnd = toIsoUtc(window.block.end);\n\n  for (const tableId of tableIds) {\n    const entry = busy.get(tableId);\n    if (!entry) continue;\n    if (isWindowFree(entry.bitset, targetStart, targetEnd)) continue;\n    for (const other of entry.windows) {\n      if (windowsOverlap({ start: targetStart, end: targetEnd }, { start: other.startAt, end: other.endAt })) {\n        conflicts.push({\n          tableId,\n          bookingId: other.bookingId,\n          startAt: other.startAt,\n          endAt: other.endAt,\n          source: other.source,\n        });\n      }\n    }\n  }\n\n  return conflicts;\n}\n\nfunction formatConflictSummary(conflicts: ManualAssignmentConflict[]): string {\n  if (conflicts.length === 0) {\n    return \"conflicts\";\n  }\n\n  const sources = new Set(conflicts.map((conflict) => conflict.source));\n  const tableIds = Array.from(new Set(conflicts.map((conflict) => conflict.tableId))).join(\", \");\n  if (sources.size === 0) {\n    return tableIds ? `conflicts on tables ${tableIds}` : \"conflicts\";\n  }\n\n  if (sources.size > 1) {\n    return tableIds ? `holds and bookings on tables ${tableIds}` : \"holds and bookings\";\n  }\n\n  const [source] = sources;\n  const label = source === \"hold\" ? \"holds\" : \"bookings\";\n  return tableIds ? `${label} on tables ${tableIds}` : label;\n}\n\nfunction evaluateAdjacency(\n  tableIds: string[],\n  adjacency: Map<string, Set<string>>,\n): { connected: boolean } {\n  if (tableIds.length <= 1) {\n    return { connected: true };\n  }\n  const queue = [tableIds[0]!];\n  const visited = new Set<string>([tableIds[0]!]);\n  while (queue.length > 0) {\n    const current = queue.shift();\n    if (!current) continue;\n    const neighbors = adjacency.get(current);\n    if (!neighbors) continue;\n    for (const neighbor of neighbors) {\n      if (!tableIds.includes(neighbor)) continue;\n      if (visited.has(neighbor)) continue;\n      visited.add(neighbor);\n      queue.push(neighbor);\n    }\n  }\n  return { connected: visited.size === tableIds.length };\n}\n\nfunction summarizeSelection(tables: Table[], partySize: number): ManualSelectionSummary {\n  const totalCapacity = tables.reduce((sum, table) => sum + (table.capacity ?? 0), 0);\n  const zoneIds = new Set(tables.map((table) => table.zoneId));\n  return {\n    tableCount: tables.length,\n    totalCapacity,\n    slack: Math.max(0, totalCapacity - partySize),\n    zoneId: zoneIds.size === 1 ? tables[0]?.zoneId ?? null : null,\n    tableNumbers: tables.map((table) => table.tableNumber),\n    partySize,\n  };\n}\n\nfunction buildManualChecks(params: {\n  summary: ManualSelectionSummary;\n  tables: Table[];\n  requireAdjacency: boolean;\n  adjacency: Map<string, Set<string>>;\n  conflicts: ManualAssignmentConflict[];\n  holdConflicts: HoldConflictInfo[];\n}): ManualSelectionCheck[] {\n  const checks: ManualSelectionCheck[] = [];\n  const { summary, tables, requireAdjacency, adjacency, conflicts, holdConflicts } = params;\n\n  checks.push({\n    id: \"capacity\",\n    status: summary.totalCapacity >= summary.partySize ? \"ok\" : \"error\",\n    message:\n      summary.totalCapacity >= summary.partySize\n        ? \"Capacity satisfied\"\n        : \"Selected tables do not meet requested party size\",\n    details: {\n      totalCapacity: summary.totalCapacity,\n      partySize: summary.partySize,\n      slack: summary.slack,\n    },\n  });\n\n  if (summary.zoneId === null) {\n    checks.push({\n      id: \"zone\",\n      status: \"error\",\n      message: \"Tables must belong to the same zone for manual assignment\",\n    });\n  } else {\n    checks.push({\n      id: \"zone\",\n      status: \"ok\",\n      message: `Zone ${summary.zoneId} validated`,\n    });\n  }\n\n  if (tables.length > 1) {\n    const allMovable = tables.every((table) => table.mobility === \"movable\");\n    checks.push({\n      id: \"movable\",\n      status: allMovable ? \"ok\" : \"error\",\n      message: allMovable\n        ? \"All tables are movable\"\n        : \"Merged assignments require movable tables\",\n    });\n  } else {\n    checks.push({\n      id: \"movable\",\n      status: \"ok\",\n      message: \"Single table selection\",\n    });\n  }\n\n  if (requireAdjacency && tables.length > 1) {\n    const evaluation = evaluateAdjacency(\n      tables.map((table) => table.id),\n      adjacency,\n    );\n    checks.push({\n      id: \"adjacency\",\n      status: evaluation.connected ? \"ok\" : \"error\",\n      message: evaluation.connected\n        ? \"Tables are connected\"\n        : \"Tables must be adjacent when adjacency enforcement is enabled\",\n    });\n  } else {\n    checks.push({\n      id: \"adjacency\",\n      status: \"ok\",\n      message: \"Adjacency not required\",\n    });\n  }\n\n  checks.push({\n    id: \"conflict\",\n    status: conflicts.length === 0 && holdConflicts.length === 0 ? \"ok\" : \"error\",\n    message:\n      conflicts.length === 0 && holdConflicts.length === 0\n        ? \"No conflicting assignments\"\n        : \"Existing assignments or holds conflict with selection\",\n    details: {\n      conflicts,\n      holdConflicts,\n    },\n  });\n\n  checks.push({\n    id: \"holds\",\n    status: holdConflicts.length === 0 ? \"ok\" : \"error\",\n    message: holdConflicts.length === 0 ? \"No holds blocking selection\" : \"Tables currently on hold\",\n    details: {\n      holds: holdConflicts,\n    },\n  });\n\n  return checks;\n}\n\nexport async function evaluateManualSelection(options: ManualSelectionOptions): Promise<ManualValidationResult> {\n  const { bookingId, tableIds, requireAdjacency: requireAdjacencyOverride, excludeHoldId = null, client } = options;\n\n  if (!Array.isArray(tableIds) || tableIds.length === 0) {\n    throw new ManualSelectionInputError(\"At least one table must be selected\", \"TABLES_REQUIRED\");\n  }\n\n  const supabase = ensureClient(client);\n  const booking = await loadBooking(bookingId, supabase);\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n\n  const window = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n\n  const selectionTables = await loadTablesByIds(booking.restaurant_id, tableIds, supabase);\n  if (selectionTables.length !== tableIds.length) {\n    throw new ManualSelectionInputError(\"One or more selected tables were not found\", \"TABLE_LOOKUP_FAILED\");\n  }\n\n  const adjacency = await loadAdjacency(tableIds, supabase);\n\n  const contextBookings = await loadContextBookings(booking.restaurant_id, booking.booking_date ?? null, supabase);\n  let holds: TableHold[] = [];\n  if (isHoldsEnabled()) {\n    try {\n      holds = await listActiveHoldsForBooking({ bookingId, client: supabase });\n    } catch {\n      holds = [];\n    }\n  }\n\n  const busy = buildBusyMaps({\n    targetBookingId: bookingId,\n    bookings: contextBookings,\n    holds,\n    excludeHoldId,\n    policy,\n  });\n\n  const conflicts = extractConflictsForTables(busy, tableIds, window);\n  let holdConflicts: HoldConflictInfo[] = [];\n  try {\n    holdConflicts = await findHoldConflicts({\n      restaurantId: booking.restaurant_id,\n      tableIds,\n      startAt: toIsoUtc(window.block.start),\n      endAt: toIsoUtc(window.block.end),\n      excludeHoldId,\n      client: supabase,\n    });\n  } catch {\n    holdConflicts = [];\n  }\n\n  const requireAdjacency = resolveRequireAdjacency(booking.party_size, requireAdjacencyOverride);\n  const summary = summarizeSelection(selectionTables, booking.party_size);\n  const checks = buildManualChecks({\n    summary,\n    tables: selectionTables,\n    requireAdjacency,\n    adjacency,\n    conflicts,\n    holdConflicts,\n  });\n\n  const ok = checks.every((check) => check.status !== \"error\");\n\n  return {\n    ok,\n    summary,\n    checks,\n  };\n}\n\nexport async function createManualHold(options: ManualHoldOptions): Promise<ManualHoldResult> {\n  const { bookingId, tableIds, createdBy, holdTtlSeconds = DEFAULT_HOLD_TTL_SECONDS, requireAdjacency, excludeHoldId, client } = options;\n  const supabase = ensureClient(client);\n\n  const validation = await evaluateManualSelection({\n    bookingId,\n    tableIds,\n    requireAdjacency,\n    excludeHoldId,\n    client: supabase,\n  });\n\n  if (!validation.ok || !validation.summary) {\n    return {\n      hold: null,\n      validation,\n    };\n  }\n\n  const booking = await loadBooking(bookingId, supabase);\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n\n  const window = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n\n  const selectionTables = await loadTablesByIds(booking.restaurant_id, tableIds, supabase);\n  if (selectionTables.length !== tableIds.length) {\n    throw new ManualSelectionInputError(\"Selected tables could not be loaded\", \"TABLE_LOOKUP_FAILED\");\n  }\n\n  const startAtIso = toIsoUtc(window.block.start);\n  const endAtIso = toIsoUtc(window.block.end);\n\n  const expiresAt =\n    options.holdExpiresAt ??\n    toIsoUtc(DateTime.now().plus({ seconds: holdTtlSeconds })) ??\n    toIsoUtc(window.block.start.plus({ minutes: 2 }));\n\n  const zoneIdValue = validation.summary.zoneId ?? selectionTables[0]?.zoneId;\n  if (!zoneIdValue) {\n    throw new ManualSelectionInputError(\"Unable to determine zone for selected tables\", \"ZONE_REQUIRED\");\n  }\n\n  const holdPayload: CreateTableHoldInput = {\n    bookingId,\n    restaurantId: booking.restaurant_id,\n    zoneId: zoneIdValue,\n    tableIds,\n    startAt: startAtIso,\n    endAt: endAtIso,\n    expiresAt,\n    createdBy,\n    metadata: {\n      selection: {\n        tableIds,\n        summary: validation.summary,\n      },\n    },\n    client: supabase,\n  };\n\n  const hold = await createTableHold(holdPayload);\n\n  if (excludeHoldId) {\n    try {\n      await releaseTableHold({ holdId: excludeHoldId, client: supabase });\n    } catch (error) {\n      console.warn(\"[capacity][manual][holds] failed to release replaced hold\", {\n        bookingId,\n        newHoldId: hold.id,\n        previousHoldId: excludeHoldId,\n        error,\n      });\n    }\n  }\n\n  return {\n    hold,\n    validation,\n  };\n}\n\nexport async function getManualAssignmentContext(options: {\n  bookingId: string;\n  client?: DbClient;\n}): Promise<ManualAssignmentContext> {\n  const { bookingId, client } = options;\n  const supabase = ensureClient(client);\n  const booking = await loadBooking(bookingId, supabase);\n\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n\n  const window = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n\n  const tables = await loadTablesForRestaurant(booking.restaurant_id, supabase);\n  const contextBookings = await loadContextBookings(booking.restaurant_id, booking.booking_date ?? null, supabase);\n\n  let holds: ManualAssignmentContextHold[] = [];\n  if (isHoldsEnabled()) {\n    try {\n      const rawHolds = await fetchHoldsForWindow(booking.restaurant_id, window, supabase);\n      holds = await hydrateHoldMetadata(rawHolds, supabase);\n    } catch (error: unknown) {\n      const code = extractErrorCode(error);\n      if (code === \"42P01\") {\n        console.warn(\"[capacity][manual][context] holds table unavailable; skipping hold hydration\", {\n          bookingId,\n        });\n      } else {\n        console.warn(\"[capacity][manual][context] failed to list holds\", { bookingId, error });\n      }\n      holds = [];\n    }\n  }\n\n  const busy = buildBusyMaps({\n    targetBookingId: bookingId,\n    bookings: contextBookings,\n    holds,\n    policy,\n  });\n\n  const bookingAssignments = await loadTableAssignmentsForTables(\n    bookingId,\n    tables.map((table) => table.id),\n    supabase,\n  );\n\n  const conflicts = extractConflictsForTables(\n    busy,\n    tables.map((table) => table.id),\n    window,\n  );\n\n  const activeHold = holds.find((hold) => hold.bookingId === bookingId) ?? null;\n\n  return {\n    booking,\n    tables,\n    bookingAssignments: bookingAssignments.map((row) => row.table_id),\n    holds,\n    activeHold,\n    conflicts,\n    window: {\n      startAt: toIsoUtc(window.block.start),\n      endAt: toIsoUtc(window.block.end),\n    },\n  };\n}\n\nasync function hydrateHoldMetadata(holds: TableHold[], client: DbClient): Promise<ManualAssignmentContextHold[]> {\n  if (holds.length === 0) {\n    return [];\n  }\n  const creatorIds = Array.from(\n    new Set(\n      holds\n        .map((hold) => hold.createdBy)\n        .filter((value): value is string => Boolean(value)),\n    ),\n  );\n\n  let creators: Array<{ id: string; name: string | null; email: string | null }> = [];\n  if (creatorIds.length > 0) {\n    const { data, error } = await client\n      .from(\"profiles\")\n      .select(\"id, name, email\")\n      .in(\"id\", creatorIds);\n\n    if (!error && data) {\n      creators = data as Array<{ id: string; name: string | null; email: string | null }>;\n    }\n  }\n\n  return holds.map((hold) => {\n    const creator = creators.find((profile) => profile.id === hold.createdBy);\n    return {\n      ...hold,\n      createdByName: creator?.name ?? null,\n      createdByEmail: creator?.email ?? null,\n    };\n  });\n}\n\nasync function fetchHoldsForWindow(\n  restaurantId: string,\n  window: ReturnType<typeof computeBookingWindow>,\n  client: DbClient,\n): Promise<TableHold[]> {\n  const { data, error } = await client\n    .from(\"table_holds\")\n    .select(\"*, table_hold_members(table_id)\")\n    .eq(\"restaurant_id\", restaurantId)\n    .gt(\"expires_at\", new Date().toISOString())\n    .lt(\"start_at\", toIsoUtc(window.block.end))\n    .gt(\"end_at\", toIsoUtc(window.block.start));\n\n  if (error || !data) {\n    throw error ?? new Error(\"Failed to load holds\");\n  }\n\n  const rows = data as TableHoldRow[];\n\n  return rows.map((row) => {\n    const members = row.table_hold_members ?? [];\n    const tableIds = members\n      .map((member) => member.table_id)\n      .filter((value): value is string => typeof value === \"string\");\n    return {\n      id: row.id,\n      bookingId: row.booking_id,\n      restaurantId: row.restaurant_id,\n      zoneId: row.zone_id,\n      startAt: row.start_at,\n      endAt: row.end_at,\n      expiresAt: row.expires_at,\n      tableIds,\n      createdBy: row.created_by ?? null,\n      metadata: row.metadata ?? null,\n    } satisfies TableHold;\n  });\n}\n\nasync function loadActiveHoldsForDate(\n  restaurantId: string,\n  bookingDate: string | null,\n  policy: VenuePolicy,\n  client: DbClient,\n): Promise<TableHold[]> {\n  if (!bookingDate) {\n    return [];\n  }\n\n  const day = DateTime.fromISO(bookingDate, { zone: policy.timezone ?? \"UTC\" });\n  if (!day.isValid) {\n    return [];\n  }\n\n  const dayStart = toIsoUtc(day.startOf(\"day\"));\n  const dayEnd = toIsoUtc(day.plus({ days: 1 }).startOf(\"day\"));\n  const now = toIsoUtc(DateTime.now());\n\n  const { data, error } = await client\n    .from(\"table_holds\")\n    .select(\"*, table_hold_members(table_id)\")\n    .eq(\"restaurant_id\", restaurantId)\n    .gt(\"expires_at\", now)\n    .lt(\"start_at\", dayEnd)\n    .gt(\"end_at\", dayStart);\n\n  if (error || !data) {\n    throw error ?? new Error(\"Failed to load holds\");\n  }\n\n  const rows = data as TableHoldRow[];\n\n  return rows.map((row) => {\n    const members = row.table_hold_members ?? [];\n    const tableIds = members\n      .map((member) => member.table_id)\n      .filter((value): value is string => typeof value === \"string\");\n    return {\n      id: row.id,\n      bookingId: row.booking_id,\n      restaurantId: row.restaurant_id,\n      zoneId: row.zone_id,\n      startAt: row.start_at,\n      endAt: row.end_at,\n      expiresAt: row.expires_at,\n      tableIds,\n      createdBy: row.created_by ?? null,\n      metadata: row.metadata ?? null,\n    } satisfies TableHold;\n  });\n}\n\ntype RawAssignmentRecord = {\n  tableId: string;\n  startAt?: string | null;\n  endAt?: string | null;\n  mergeGroupId?: string | null;\n};\n\ntype AssignmentSyncParams = {\n  supabase: DbClient;\n  booking: BookingRow;\n  tableIds: string[];\n  idempotencyKey: string | null;\n  assignments: RawAssignmentRecord[];\n  startIso: string;\n  endIso: string;\n  actorId?: string | null;\n  mergeGroupId?: string | null;\n  holdContext?: {\n    holdId: string;\n    zoneId?: string | null;\n  };\n};\n\nfunction serializeDetails(value: unknown): string | null {\n  if (value === null || value === undefined) {\n    return null;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  try {\n    return JSON.stringify(value);\n  } catch {\n    return null;\n  }\n}\n\nasync function synchronizeAssignments(params: AssignmentSyncParams): Promise<TableAssignmentMember[]> {\n  const { supabase, booking, tableIds, idempotencyKey, assignments, startIso, endIso, actorId, mergeGroupId, holdContext } = params;\n  const uniqueTableIds = Array.from(new Set(tableIds));\n  const assignmentRows = await loadTableAssignmentsForTables(booking.id, uniqueTableIds, supabase);\n  const windowRange = `[${startIso},${endIso})`;\n\n  const needsUpdate = assignments.some((assignment) => {\n    const normalizedStart = normalizeIsoString(assignment.startAt ?? null);\n    const normalizedEnd = normalizeIsoString(assignment.endAt ?? null);\n    return normalizedStart !== startIso || normalizedEnd !== endIso;\n  });\n\n  if (needsUpdate) {\n    try {\n      await supabase\n        .from(\"booking_table_assignments\")\n        .update({ start_at: startIso, end_at: endIso })\n        .eq(\"booking_id\", booking.id)\n        .in(\"table_id\", uniqueTableIds);\n    } catch {\n      // Ignore in mocked environments.\n    }\n\n    try {\n      await supabase\n        .from(\"allocations\")\n        .update({ window: windowRange })\n        .eq(\"booking_id\", booking.id)\n        .eq(\"resource_type\", TABLE_RESOURCE_TYPE)\n        .in(\"resource_id\", uniqueTableIds);\n    } catch {\n      // Ignore missing allocation support in mocked environments.\n    }\n\n    if (idempotencyKey) {\n      try {\n        await supabase\n          .from(\"booking_assignment_idempotency\")\n          .update({\n            assignment_window: windowRange,\n            merge_group_allocation_id: mergeGroupId ?? null,\n          })\n          .eq(\"booking_id\", booking.id)\n          .eq(\"idempotency_key\", idempotencyKey);\n      } catch {\n        // Ignore ledger updates in mocked environments.\n      }\n    }\n  }\n\n  const assignmentLookup = new Map<string, RawAssignmentRecord>();\n  for (const assignment of assignments) {\n    assignmentLookup.set(assignment.tableId, assignment);\n  }\n\n  const tableRowLookup = new Map(assignmentRows.map((row) => [row.table_id, row]));\n\n  const result: TableAssignmentMember[] = uniqueTableIds.map((tableId) => {\n    const row = tableRowLookup.get(tableId);\n    const assignment = assignmentLookup.get(tableId);\n    return {\n      tableId,\n      assignmentId: row?.id ?? randomUUID(),\n      startAt: startIso,\n      endAt: endIso,\n      mergeGroupId: assignment?.mergeGroupId ?? mergeGroupId ?? null,\n    };\n  });\n\n  if (holdContext) {\n    const zoneId = holdContext.zoneId ?? \"\";\n    const telemetryMetadata = holdContext.zoneId ? undefined : { unknownZone: true };\n    await emitHoldConfirmed({\n      holdId: holdContext.holdId,\n      bookingId: booking.id,\n      restaurantId: booking.restaurant_id,\n      zoneId,\n      tableIds: result.map((assignment) => assignment.tableId),\n      startAt: startIso,\n      endAt: endIso,\n      expiresAt: endIso,\n      actorId: actorId ?? null,\n      metadata: telemetryMetadata,\n    });\n  }\n\n  return result;\n}\n\nexport async function confirmHoldAssignment(options: {\n  holdId: string;\n  bookingId: string;\n  idempotencyKey: string;\n  requireAdjacency?: boolean;\n  assignedBy?: string | null;\n  client?: DbClient;\n}): Promise<TableAssignmentMember[]> {\n  if (!isAllocatorV2Enabled()) {\n    throw new AssignTablesRpcError({\n      message: \"Allocator v2 must be enabled to confirm holds\",\n      code: \"ALLOCATOR_V2_DISABLED\",\n      details: null,\n      hint: \"Enable allocator.v2.enabled to use confirmHoldAssignment\",\n    });\n  }\n\n  const { holdId, bookingId, idempotencyKey, requireAdjacency: requireAdjacencyOverride, assignedBy = null, client } = options;\n  const supabase = ensureClient(client);\n\n  const {\n    data: holdRow,\n    error: holdError,\n  } = await supabase\n    .from(\"table_holds\")\n    .select(\"restaurant_id, zone_id, booking_id, table_hold_members(table_id)\")\n    .eq(\"id\", holdId)\n    .maybeSingle();\n\n  if (holdError) {\n    throw new HoldNotFoundError(holdError.message ?? \"Failed to load table hold\");\n  }\n\n  if (!holdRow) {\n    throw new HoldNotFoundError();\n  }\n\n  const tableIds = Array.isArray(holdRow.table_hold_members)\n    ? (holdRow.table_hold_members as Array<{ table_id: string }>).map((member) => member.table_id)\n    : [];\n\n  const holdBookingId = (holdRow as { booking_id?: string | null }).booking_id ?? null;\n  if (holdBookingId && holdBookingId !== bookingId) {\n    await emitRpcConflict({\n      source: \"confirm_hold_booking_mismatch\",\n      bookingId,\n      restaurantId: holdRow.restaurant_id,\n      tableIds,\n      holdId,\n      error: {\n        code: \"HOLD_BOOKING_MISMATCH\",\n        message: \"Hold is already linked to a different booking\",\n        details: serializeDetails({ holdBookingId }),\n        hint: null,\n      },\n    });\n\n    throw new AssignTablesRpcError({\n      message: \"Hold is already linked to a different booking\",\n      code: \"HOLD_BOOKING_MISMATCH\",\n      details: serializeDetails({ holdBookingId }),\n      hint: null,\n    });\n  }\n\n  if (tableIds.length === 0) {\n    throw new AssignTablesRpcError({\n      message: \"Hold has no tables\",\n      code: \"HOLD_EMPTY\",\n      details: null,\n      hint: null,\n    });\n  }\n\n  const booking = await loadBooking(bookingId, supabase);\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const window = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n  const requireAdjacency = resolveRequireAdjacency(booking.party_size, requireAdjacencyOverride);\n\n  const startIso = toIsoUtc(window.block.start);\n  const endIso = toIsoUtc(window.block.end);\n  const normalizedTableIds = normalizeTableIds(tableIds);\n  const planSignature = createPlanSignature({\n    bookingId,\n    tableIds: normalizedTableIds,\n    startAt: startIso,\n    endAt: endIso,\n  });\n\n  const orchestrator = new AssignmentOrchestrator(new SupabaseAssignmentRepository(supabase));\n  let response;\n  try {\n    response = await orchestrator.commitPlan(\n      {\n        bookingId,\n        restaurantId: booking.restaurant_id,\n        partySize: booking.party_size,\n        zoneId: holdRow.zone_id,\n        serviceDate: booking.booking_date ?? null,\n        window: {\n          startAt: startIso,\n          endAt: endIso,\n        },\n        holdId,\n      },\n      {\n        signature: planSignature,\n        tableIds: normalizedTableIds,\n        startAt: startIso,\n        endAt: endIso,\n        metadata: {\n          holdId,\n        },\n      },\n      {\n        source: \"manual\",\n        idempotencyKey,\n        actorId: assignedBy,\n        metadata: {\n          requireAdjacency,\n          holdId,\n        },\n        requireAdjacency,\n      },\n    );\n  } catch (error) {\n    if (error instanceof AssignmentConflictError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_CONFLICT\",\n        details: serializeDetails(error.details),\n        hint: error.details?.hint ?? null,\n      });\n    }\n\n    if (error instanceof AssignmentValidationError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_VALIDATION\",\n        details: serializeDetails(error.details),\n        hint: null,\n      });\n    }\n\n    if (error instanceof AssignmentRepositoryError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_REPOSITORY_ERROR\",\n        details: serializeDetails(error.cause ?? null),\n        hint: null,\n      });\n    }\n\n    throw error;\n  }\n\n  try {\n    await supabase.from(\"table_holds\").delete().eq(\"id\", holdId);\n  } catch {\n    // Best-effort cleanup.\n  }\n\n  return synchronizeAssignments({\n    supabase,\n    booking,\n    tableIds: normalizedTableIds,\n    idempotencyKey,\n    assignments: response.assignments.map((assignment) => ({\n      tableId: assignment.tableId,\n      startAt: assignment.startAt,\n      endAt: assignment.endAt,\n      mergeGroupId: assignment.mergeGroupId ?? response.mergeGroupId ?? null,\n    })),\n    startIso,\n    endIso,\n    actorId: assignedBy,\n    mergeGroupId: response.mergeGroupId ?? null,\n    holdContext: {\n      holdId,\n      zoneId: holdRow.zone_id ?? null,\n    },\n  });\n}\n\nexport async function assignTableToBooking(\n  bookingId: string,\n  tableIdOrIds: string | string[],\n  assignedBy: string | null,\n  client?: DbClient,\n  options?: { idempotencyKey?: string | null; requireAdjacency?: boolean; booking?: BookingRow },\n): Promise<string> {\n  if (!isAllocatorV2Enabled()) {\n    throw new AssignTablesRpcError({\n      message: \"Allocator v2 must be enabled to assign tables\",\n      code: \"ALLOCATOR_V2_DISABLED\",\n      details: null,\n      hint: \"Enable allocator.v2.enabled to call assignTableToBooking\",\n    });\n  }\n\n  const supabase = ensureClient(client);\n  const tableIds = Array.isArray(tableIdOrIds) ? tableIdOrIds : [tableIdOrIds];\n  if (tableIds.length === 0) {\n    throw new ManualSelectionInputError(\"Must provide at least one table id\", \"TABLES_REQUIRED\");\n  }\n\n  const booking = options?.booking ?? (await loadBooking(bookingId, supabase));\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const window = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n  const startIso = toIsoUtc(window.block.start);\n  const endIso = toIsoUtc(window.block.end);\n  const normalizedTableIds = normalizeTableIds(tableIds);\n  const planSignature = createPlanSignature({\n    bookingId,\n    tableIds: normalizedTableIds,\n    startAt: startIso,\n    endAt: endIso,\n    salt: options?.idempotencyKey ?? undefined,\n  });\n  const idempotencyKey = options?.idempotencyKey ?? planSignature;\n  const requireAdjacency = options?.requireAdjacency ?? false;\n\n  const orchestrator = new AssignmentOrchestrator(new SupabaseAssignmentRepository(supabase));\n  let response;\n  try {\n    response = await orchestrator.commitPlan(\n      {\n        bookingId,\n        restaurantId: booking.restaurant_id,\n        partySize: booking.party_size,\n        serviceDate: booking.booking_date ?? null,\n        window: {\n          startAt: startIso,\n          endAt: endIso,\n        },\n      },\n      {\n        signature: planSignature,\n        tableIds: normalizedTableIds,\n        startAt: startIso,\n        endAt: endIso,\n        metadata: {\n          requestSource: \"assignTableToBooking\",\n        },\n      },\n      {\n        source: \"manual\",\n        idempotencyKey,\n        actorId: assignedBy,\n        metadata: {\n          requireAdjacency,\n        },\n        requireAdjacency,\n      },\n    );\n  } catch (error) {\n    if (error instanceof AssignmentConflictError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_CONFLICT\",\n        details: serializeDetails(error.details),\n        hint: error.details?.hint ?? null,\n      });\n    }\n\n    if (error instanceof AssignmentValidationError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_VALIDATION\",\n        details: serializeDetails(error.details),\n        hint: null,\n      });\n    }\n\n    if (error instanceof AssignmentRepositoryError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_REPOSITORY_ERROR\",\n        details: serializeDetails(error.cause ?? null),\n        hint: null,\n      });\n    }\n\n    throw error;\n  }\n\n  const synchronized = await synchronizeAssignments({\n    supabase,\n    booking,\n    tableIds: normalizedTableIds,\n    idempotencyKey,\n    assignments: response.assignments.map((assignment) => ({\n      tableId: assignment.tableId,\n      startAt: assignment.startAt,\n      endAt: assignment.endAt,\n      mergeGroupId: assignment.mergeGroupId ?? response.mergeGroupId ?? null,\n    })),\n    startIso,\n    endIso,\n    actorId: assignedBy,\n    mergeGroupId: response.mergeGroupId ?? null,\n  });\n\n  const firstAssignment = synchronized[0];\n  if (!firstAssignment) {\n    throw new AssignTablesRpcError({\n      message: \"Assignment failed with no records returned\",\n      code: \"ASSIGNMENT_EMPTY\",\n      details: null,\n      hint: null,\n    });\n  }\n\n  return firstAssignment.assignmentId;\n}\n\nexport async function unassignTableFromBooking(\n  bookingId: string,\n  tableId: string,\n  client?: DbClient,\n): Promise<boolean> {\n  const supabase = ensureClient(client);\n  const { data, error } = await supabase.rpc(\"unassign_tables_atomic\", {\n    p_booking_id: bookingId,\n    p_table_ids: [tableId],\n  });\n  if (error) {\n    return false;\n  }\n  return Array.isArray(data) && data.length > 0;\n}\n\nexport async function getBookingTableAssignments(\n  bookingId: string,\n  client?: DbClient,\n): Promise<TableAssignmentMember[]> {\n  const supabase = ensureClient(client);\n  const { data, error } = await supabase\n    .from(\"booking_table_assignments\")\n    .select(\"table_id, id, assigned_at\")\n    .eq(\"booking_id\", bookingId);\n\n  if (error || !data) {\n    return [];\n  }\n\n  return data.map((row) => ({\n    tableId: row.table_id,\n    assignmentId: row.id,\n    startAt: row.assigned_at ?? \"\",\n    endAt: row.assigned_at ?? \"\",\n    mergeGroupId: null,\n  }));\n}\n\nexport async function quoteTablesForBooking(options: QuoteTablesOptions): Promise<QuoteTablesResult> {\n  const {\n    bookingId,\n    zoneId,\n    maxTables,\n    requireAdjacency: requireAdjacencyOverride,\n    avoidTables = [],\n    holdTtlSeconds = DEFAULT_HOLD_TTL_SECONDS,\n    createdBy,\n    client,\n  } = options;\n\n  const operationStart = highResNow();\n  const supabase = ensureClient(client);\n  const booking = await loadBooking(bookingId, supabase);\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const window = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n\n  const tables = await loadTablesForRestaurant(booking.restaurant_id, supabase);\n  const adjacency = await loadAdjacency(\n    tables.map((table) => table.id),\n    supabase,\n  );\n  const requireAdjacency = resolveRequireAdjacency(booking.party_size, requireAdjacencyOverride);\n\n  const filtered = filterAvailableTables(\n    tables,\n    booking.party_size,\n    window,\n    adjacency,\n    new Set(avoidTables),\n    zoneId ?? null,\n    { allowInsufficientCapacity: true },\n  );\n\n  const scoringConfig = getSelectorScoringConfig();\n  const selectorLimits = getSelectorPlannerLimits();\n  const combinationEnabled = isCombinationPlannerEnabled();\n  const combinationLimit = maxTables ?? getAllocatorCombinationLimit();\n  const plannerStart = highResNow();\n  const plans = buildScoredTablePlans({\n    tables: filtered,\n    partySize: booking.party_size,\n    adjacency,\n    config: scoringConfig,\n    enableCombinations: combinationEnabled,\n    kMax: combinationLimit,\n    maxPlansPerSlack: selectorLimits.maxPlansPerSlack,\n    maxCombinationEvaluations: selectorLimits.maxCombinationEvaluations,\n    requireAdjacency,\n  });\n  const plannerDurationMs = highResNow() - plannerStart;\n  const adjacencyRequiredGlobally = adjacency.size > 0 && isAllocatorAdjacencyRequired();\n  const adjacencyMinPartySize = getAllocatorAdjacencyMinPartySize();\n  const plannerConfigTelemetry = composePlannerConfig({\n    diagnostics: plans.diagnostics,\n    scoringConfig,\n    combinationEnabled,\n    requireAdjacency,\n    adjacencyRequiredGlobally,\n    adjacencyMinPartySize: adjacencyMinPartySize ?? null,\n  });\n\n  const alternates: CandidateSummary[] = [];\n\n  for (let index = 0; index < plans.plans.length; index += 1) {\n    const plan = plans.plans[index]!;\n    const candidateSummary = summarizeCandidate({\n      tableIds: plan.tables.map((table) => table.id),\n      tableNumbers: plan.tables.map((table) => table.tableNumber),\n      totalCapacity: plan.totalCapacity,\n      tableCount: plan.tables.length,\n      slack: plan.slack,\n      score: plan.score,\n      adjacencyStatus: plan.adjacencyStatus,\n    });\n\n    if (index > 0) {\n      alternates.push(candidateSummary);\n    }\n\n    try {\n      const summary = summarizeSelection(plan.tables, booking.party_size);\n      const zoneForHold = summary.zoneId ?? plan.tables[0]?.zoneId;\n      if (!zoneForHold) {\n        continue;\n      }\n\n      const holdStart = highResNow();\n      const hold = await createTableHold({\n        bookingId,\n        restaurantId: booking.restaurant_id,\n        zoneId: zoneForHold,\n        tableIds: plan.tables.map((table) => table.id),\n        startAt: toIsoUtc(window.block.start),\n        endAt: toIsoUtc(window.block.end),\n        expiresAt: toIsoUtc(DateTime.now().plus({ seconds: holdTtlSeconds })),\n        createdBy,\n        metadata: {\n          selection: {\n            tableIds: plan.tables.map((table) => table.id),\n            summary,\n          },\n        },\n        client: supabase,\n      });\n      const holdDurationMs = highResNow() - holdStart;\n      const totalDurationMs = highResNow() - operationStart;\n\n      await emitSelectorQuote({\n        restaurantId: booking.restaurant_id,\n        bookingId,\n        partySize: booking.party_size,\n        window: {\n          start: toIsoUtc(window.block.start),\n          end: toIsoUtc(window.block.end),\n        },\n        candidates: [candidateSummary, ...alternates],\n        selected: candidateSummary,\n        durationMs: roundMilliseconds(totalDurationMs),\n        featureFlags: {\n          selectorScoring: isSelectorScoringEnabled(),\n          opsMetrics: isOpsMetricsEnabled(),\n        },\n        timing: buildTiming({\n          totalMs: totalDurationMs,\n          plannerMs: plannerDurationMs,\n          holdMs: holdDurationMs,\n        }),\n        plannerConfig: plannerConfigTelemetry,\n        diagnostics: plans.diagnostics,\n        holdId: hold.id,\n        expiresAt: hold.expiresAt,\n      });\n\n      return {\n        hold,\n        candidate: candidateSummary,\n        alternates,\n        nextTimes: [],\n      };\n    } catch (error) {\n      if (error instanceof HoldConflictError) {\n        const conflicts = await findHoldConflicts({\n          restaurantId: booking.restaurant_id,\n          tableIds: plan.tables.map((table) => table.id),\n          startAt: toIsoUtc(window.block.start),\n          endAt: toIsoUtc(window.block.end),\n          client: supabase,\n        });\n\n        await emitRpcConflict({\n          source: \"create_hold_conflict\",\n          bookingId,\n          restaurantId: booking.restaurant_id,\n          tableIds: plan.tables.map((table) => table.id),\n          holdId: error.holdId ?? null,\n          error: {\n            code: null,\n            message: error.message,\n            details: JSON.stringify(conflicts),\n            hint: null,\n          },\n        });\n\n        continue;\n      }\n      throw error;\n    }\n  }\n\n  return {\n    hold: null,\n    candidate: null,\n    alternates,\n    nextTimes: [],\n    reason: plans.fallbackReason ?? \"No suitable tables available\",\n  };\n}\n\nexport async function autoAssignTablesForDate(options: {\n  restaurantId: string;\n  date: string;\n  client?: DbClient;\n  assignedBy?: string | null;\n}): Promise<AutoAssignResult> {\n  const { restaurantId, date, client, assignedBy = null } = options;\n  const supabase = ensureClient(client);\n  const [bookings, tables, restaurantTimezone] = await Promise.all([\n    loadContextBookings(restaurantId, date, supabase),\n    loadTablesForRestaurant(restaurantId, supabase),\n    loadRestaurantTimezone(restaurantId, supabase),\n  ]);\n  const adjacency = await loadAdjacency(\n    tables.map((table) => table.id),\n    supabase,\n  );\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const adjacencyEdgeCount = Array.from(adjacency.values()).reduce((sum, neighbors) => sum + neighbors.size, 0);\n  const adjacencyEnforced = adjacencyEdgeCount > 0 && isAllocatorAdjacencyRequired();\n  const combinationPlannerEnabled = isCombinationPlannerEnabled();\n  const mergesEnabled = isAllocatorMergesEnabled();\n  const selectorLimits = getSelectorPlannerLimits();\n  let activeHolds: TableHold[] = [];\n  if (isHoldsEnabled()) {\n    try {\n      activeHolds = await loadActiveHoldsForDate(restaurantId, date, policy, supabase);\n    } catch (error: unknown) {\n      const code = extractErrorCode(error);\n      if (code === \"42P01\") {\n        console.warn(\"[ops][auto-assign] holds table unavailable; skipping hold hydration\", {\n          restaurantId,\n        });\n      } else {\n        console.warn(\"[ops][auto-assign] failed to load active holds\", {\n          restaurantId,\n          error,\n        });\n      }\n      activeHolds = [];\n    }\n  }\n\n  const result: AutoAssignResult = {\n    assigned: [],\n    skipped: [],\n  };\n\n  const adjacencyMinPartySizeFlag = getAllocatorAdjacencyMinPartySize();\n\n  for (const booking of bookings) {\n    const alreadyAssigned = (booking.booking_table_assignments ?? []).some((row) => Boolean(row.table_id));\n    if (alreadyAssigned) {\n      continue;\n    }\n\n    const featureFlags = {\n      selectorScoring: isSelectorScoringEnabled(),\n      opsMetrics: isOpsMetricsEnabled(),\n    };\n\n    const operationStart = highResNow();\n    let plannerDurationMs = 0;\n    let assignmentDurationMs = 0;\n    let combinationModeForTelemetry = combinationPlannerEnabled;\n\n    let window: BookingWindow | null = null;\n    let overrunReason: string | null = null;\n    try {\n      window = computeBookingWindowWithFallback({\n        startISO: booking.start_at,\n        bookingDate: booking.booking_date,\n        startTime: booking.start_time,\n        partySize: booking.party_size,\n        policy,\n      });\n    } catch (error) {\n      if (error instanceof ServiceOverrunError) {\n        overrunReason = error.message ?? \"Reservation window exceeds service boundary\";\n      } else {\n        throw error;\n      }\n    }\n    if (!window) {\n      const reason = overrunReason ?? \"Reservation window exceeds service boundary\";\n      const totalDurationMs = highResNow() - operationStart;\n      result.skipped.push({ bookingId: booking.id, reason });\n      await emitSelectorDecision({\n        restaurantId,\n        bookingId: booking.id,\n        partySize: booking.party_size,\n        window: undefined,\n        candidates: [],\n        selected: null,\n        skipReason: reason,\n        durationMs: roundMilliseconds(totalDurationMs),\n        featureFlags,\n        timing: buildTiming({ totalMs: totalDurationMs }),\n        plannerConfig: undefined,\n        diagnostics: undefined,\n      });\n      continue;\n    }\n\n    const requireAdjacency = adjacencyEnforced && partiesRequireAdjacency(booking.party_size);\n\n    const availableTables = filterAvailableTables(\n      tables,\n      booking.party_size,\n      window,\n      adjacency,\n      undefined,\n      undefined,\n      { allowInsufficientCapacity: true },\n    );\n    const scoringConfig = getSelectorScoringConfig();\n    const combinationLimit = getAllocatorCombinationLimit();\n    const runPlanner = (enableCombinations: boolean) => {\n      const plannerStart = highResNow();\n      const result = buildScoredTablePlans({\n        tables: availableTables,\n        partySize: booking.party_size,\n        adjacency,\n        config: scoringConfig,\n        enableCombinations,\n        kMax: combinationLimit,\n        maxPlansPerSlack: selectorLimits.maxPlansPerSlack,\n        maxCombinationEvaluations: selectorLimits.maxCombinationEvaluations,\n        requireAdjacency,\n      });\n      plannerDurationMs += highResNow() - plannerStart;\n      return result;\n    };\n    let plans = runPlanner(combinationPlannerEnabled);\n\n    if (plans.plans.length === 0 && !combinationPlannerEnabled) {\n      if (mergesEnabled) {\n        combinationModeForTelemetry = true;\n        const mergeFallback = runPlanner(true);\n        if (mergeFallback.plans.length > 0) {\n          plans = mergeFallback;\n        } else {\n          plans = {\n            ...mergeFallback,\n            fallbackReason: mergeFallback.fallbackReason ?? \"Combination planner disabled (requires merges)\",\n          };\n        }\n      } else if (!plans.fallbackReason) {\n        plans = {\n          ...plans,\n          fallbackReason: \"Combination planner disabled (requires merges)\",\n        };\n      }\n    }\n\n    const plannerConfigTelemetry = composePlannerConfig({\n      diagnostics: plans.diagnostics,\n      scoringConfig,\n      combinationEnabled: combinationModeForTelemetry,\n      requireAdjacency,\n      adjacencyRequiredGlobally: adjacencyEnforced,\n      adjacencyMinPartySize: adjacencyMinPartySizeFlag ?? null,\n    });\n\n    if (plans.plans.length === 0) {\n      const fallback = plans.fallbackReason ?? \"No suitable tables available\";\n      const skipReason = `No suitable tables available (${fallback})`;\n      const totalDurationMs = highResNow() - operationStart;\n      result.skipped.push({ bookingId: booking.id, reason: skipReason });\n      await emitSelectorDecision({\n        restaurantId,\n        bookingId: booking.id,\n        partySize: booking.party_size,\n        window: {\n          start: toIsoUtc(window.block.start),\n          end: toIsoUtc(window.block.end),\n        },\n        candidates: [],\n        selected: null,\n        skipReason,\n        durationMs: roundMilliseconds(totalDurationMs),\n        featureFlags,\n        timing: buildTiming({ totalMs: totalDurationMs, plannerMs: plannerDurationMs }),\n        plannerConfig: plannerConfigTelemetry,\n        diagnostics: plans.diagnostics,\n      });\n      continue;\n    }\n\n    const busy = buildBusyMaps({\n      targetBookingId: booking.id,\n      bookings,\n      holds: activeHolds,\n      policy,\n    });\n\n    const planEvaluations = plans.plans.map((plan) => ({\n      plan,\n      conflicts: extractConflictsForTables(\n        busy,\n        plan.tables.map((table) => table.id),\n        window,\n      ),\n    }));\n\n    const candidateSummariesAll: CandidateSummary[] = planEvaluations.map(({ plan }) =>\n      summarizeCandidate({\n        tableIds: plan.tables.map((table) => table.id),\n        tableNumbers: plan.tables.map((table) => table.tableNumber),\n        totalCapacity: plan.totalCapacity,\n        tableCount: plan.tables.length,\n        slack: plan.slack,\n        score: plan.score,\n        adjacencyStatus: plan.adjacencyStatus,\n      }),\n    );\n\n    const conflictFreeEntries = planEvaluations.filter(({ conflicts }) => conflicts.length === 0);\n    if (conflictFreeEntries.length === 0) {\n      const conflictEntry = planEvaluations.find(({ conflicts }) => conflicts.length > 0);\n      const conflictSummary = conflictEntry ? formatConflictSummary(conflictEntry.conflicts) : \"conflicts\";\n      const skipReason = `Conflicts with existing ${conflictSummary}`;\n\n      if (conflictEntry) {\n        await emitRpcConflict({\n          source: \"auto_assign_conflict\",\n          bookingId: booking.id,\n          restaurantId,\n          tableIds: conflictEntry.plan.tables.map((table) => table.id),\n          error: {\n            code: null,\n            message: skipReason,\n            details: JSON.stringify(conflictEntry.conflicts),\n            hint: null,\n          },\n        });\n      }\n\n      result.skipped.push({ bookingId: booking.id, reason: skipReason });\n      const totalDurationMs = highResNow() - operationStart;\n      await emitSelectorDecision({\n        restaurantId,\n        bookingId: booking.id,\n        partySize: booking.party_size,\n        window: {\n          start: toIsoUtc(window.block.start),\n          end: toIsoUtc(window.block.end),\n        },\n        candidates: candidateSummariesAll,\n        selected: null,\n        skipReason,\n        durationMs: roundMilliseconds(totalDurationMs),\n        featureFlags,\n        timing: buildTiming({ totalMs: totalDurationMs, plannerMs: plannerDurationMs }),\n        plannerConfig: plannerConfigTelemetry,\n        diagnostics: plans.diagnostics,\n      });\n      continue;\n    }\n\n    const topEntry = conflictFreeEntries[0]!;\n    const topPlan = topEntry.plan;\n    const candidateSummaries: CandidateSummary[] = conflictFreeEntries.map(({ plan }) =>\n      summarizeCandidate({\n        tableIds: plan.tables.map((table) => table.id),\n        tableNumbers: plan.tables.map((table) => table.tableNumber),\n        totalCapacity: plan.totalCapacity,\n        tableCount: plan.tables.length,\n        slack: plan.slack,\n        score: plan.score,\n        adjacencyStatus: plan.adjacencyStatus,\n      }),\n    );\n    const candidate = candidateSummaries[0]!;\n\n    const assignmentStart = highResNow();\n    try {\n      await assignTableToBooking(\n        booking.id,\n        topPlan.tables.map((table) => table.id),\n        assignedBy,\n        supabase,\n        {\n          idempotencyKey: randomUUID(),\n          requireAdjacency,\n          booking: {\n            ...(booking as Partial<BookingRow>),\n            id: booking.id,\n            restaurant_id: restaurantId,\n            booking_date: booking.booking_date,\n            start_time: booking.start_time,\n            end_time: booking.end_time,\n            start_at: booking.start_at,\n            end_at: booking.end_at,\n            party_size: booking.party_size,\n            status: booking.status,\n            seating_preference: booking.seating_preference ?? null,\n            restaurants: { timezone: policy.timezone },\n          } as BookingRow,\n        },\n      );\n      assignmentDurationMs = highResNow() - assignmentStart;\n    } catch (error: unknown) {\n      assignmentDurationMs = highResNow() - assignmentStart;\n      const message = error instanceof Error ? error.message : String(error);\n      const normalized = message.toLowerCase();\n      const overlap =\n        normalized.includes(\"assignment overlap\") || normalized.includes(\"allocations_no_overlap\");\n\n      if (!overlap) {\n        throw error;\n      }\n\n      await emitRpcConflict({\n        source: \"auto_assign_overlap\",\n        bookingId: booking.id,\n        restaurantId,\n        tableIds: topPlan.tables.map((table) => table.id),\n        error: {\n          code: null,\n          message,\n          details: null,\n          hint: null,\n        },\n      });\n\n      const skipReason = \"Auto assign skipped: Supabase reported an overlapping assignment\";\n      result.skipped.push({ bookingId: booking.id, reason: skipReason });\n      const totalDurationMs = highResNow() - operationStart;\n      await emitSelectorDecision({\n        restaurantId,\n        bookingId: booking.id,\n        partySize: booking.party_size,\n        window: {\n          start: toIsoUtc(window.block.start),\n          end: toIsoUtc(window.block.end),\n        },\n        candidates: candidateSummariesAll,\n        selected: null,\n        skipReason,\n        durationMs: roundMilliseconds(totalDurationMs),\n        featureFlags,\n        timing: buildTiming({\n          totalMs: totalDurationMs,\n          plannerMs: plannerDurationMs,\n          assignmentMs: assignmentDurationMs,\n        }),\n        plannerConfig: plannerConfigTelemetry,\n        diagnostics: plans.diagnostics,\n      });\n      continue;\n    }\n\n    if (!booking.booking_table_assignments) {\n      booking.booking_table_assignments = [];\n    }\n    for (const table of topPlan.tables) {\n      if (!booking.booking_table_assignments.some((assignment) => assignment?.table_id === table.id)) {\n        booking.booking_table_assignments.push({ table_id: table.id });\n      }\n    }\n\n    result.assigned.push({\n      bookingId: booking.id,\n      tableIds: topPlan.tables.map((table) => table.id),\n    });\n\n    const totalDurationMs = highResNow() - operationStart;\n    await emitSelectorDecision({\n      restaurantId,\n      bookingId: booking.id,\n      partySize: booking.party_size,\n      window: {\n        start: toIsoUtc(window.block.start),\n        end: toIsoUtc(window.block.end),\n      },\n      candidates: candidateSummaries,\n      selected: candidate,\n      skipReason: null,\n      durationMs: roundMilliseconds(totalDurationMs),\n      featureFlags,\n      timing: buildTiming({\n        totalMs: totalDurationMs,\n        plannerMs: plannerDurationMs,\n        assignmentMs: assignmentDurationMs,\n      }),\n      plannerConfig: plannerConfigTelemetry,\n      diagnostics: plans.diagnostics,\n    });\n  }\n\n  return result;\n}\n\nexport async function autoAssignTables(options: {\n  restaurantId: string;\n  date: string;\n  client?: DbClient;\n  assignedBy?: string | null;\n}): Promise<AutoAssignResult> {\n  return autoAssignTablesForDate(options);\n}\n\nexport async function findSuitableTables(options: {\n  bookingId: string;\n  client?: DbClient;\n}): Promise<RankedTablePlan[]> {\n  const { bookingId, client } = options;\n  const supabase = ensureClient(client);\n  const booking = await loadBooking(bookingId, supabase);\n  const tables = await loadTablesForRestaurant(booking.restaurant_id, supabase);\n  const adjacency = await loadAdjacency(\n    tables.map((table) => table.id),\n    supabase,\n  );\n  const defaultPolicy = getVenuePolicy();\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    defaultPolicy.timezone;\n  const policy =\n    restaurantTimezone === defaultPolicy.timezone\n      ? defaultPolicy\n      : getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const window = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n\n  const filtered = filterAvailableTables(\n    tables,\n    booking.party_size,\n    window,\n    adjacency,\n    undefined,\n    undefined,\n    { allowInsufficientCapacity: true },\n  );\n  const scoringConfig = getSelectorScoringConfig();\n  const requireAdjacency = partiesRequireAdjacency(booking.party_size);\n  const selectorLimits = getSelectorPlannerLimits();\n  const plans = buildScoredTablePlans({\n    tables: filtered,\n    partySize: booking.party_size,\n    adjacency,\n    config: scoringConfig,\n    enableCombinations: isCombinationPlannerEnabled(),\n    kMax: getAllocatorCombinationLimit(),\n    maxPlansPerSlack: selectorLimits.maxPlansPerSlack,\n    maxCombinationEvaluations: selectorLimits.maxCombinationEvaluations,\n    requireAdjacency,\n  });\n\n  return plans.plans;\n}\n\nexport async function isTableAvailableV2(\n  tableId: string,\n  startISO: string,\n  partySize: number,\n  options?: {\n    excludeBookingId?: string;\n    policy?: VenuePolicy;\n    client?: DbClient;\n  },\n): Promise<boolean> {\n  const supabase = ensureClient(options?.client);\n  const policy = options?.policy ?? getVenuePolicy();\n  const window = computeBookingWindowWithFallback({\n    startISO,\n    partySize,\n    policy,\n  });\n\n  const { data, error } = await supabase\n    .from(\"booking_table_assignments\")\n    .select(\"table_id, start_at, end_at, bookings(id, status, start_at, end_at)\")\n    .eq(\"table_id\", tableId);\n\n  if (error) {\n    throw new AssignTablesRpcError({\n      message: error.message ?? \"Failed to query table availability\",\n      code: \"TABLE_AVAILABILITY_QUERY_FAILED\",\n      details: serializeDetails({\n        code: (error as { code?: string }).code ?? null,\n        details: error.details ?? null,\n        hint: error.hint ?? null,\n      }),\n      hint: null,\n    });\n  }\n\n  if (!data) {\n    throw new AssignTablesRpcError({\n      message: \"No table assignment data returned for availability check\",\n      code: \"TABLE_AVAILABILITY_QUERY_FAILED\",\n      details: null,\n      hint: null,\n    });\n  }\n\n  const rows = data as AssignmentAvailabilityRow[];\n\n  for (const row of rows) {\n    const booking = row.bookings;\n    if (options?.excludeBookingId && booking?.id === options.excludeBookingId) {\n      continue;\n    }\n\n    const otherStart = row.start_at ?? booking?.start_at;\n    const otherEnd = row.end_at ?? booking?.end_at;\n    if (!otherStart || !otherEnd) {\n      continue;\n    }\n\n    if (\n      windowsOverlap(\n        { start: toIsoUtc(window.block.start), end: toIsoUtc(window.block.end) },\n        { start: otherStart, end: otherEnd },\n      )\n    ) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport async function isTableAvailable(\n  tableId: string,\n  startISO: string,\n  partySize: number,\n  options?: {\n    excludeBookingId?: string;\n    policy?: VenuePolicy;\n    client?: DbClient;\n  },\n): Promise<boolean> {\n  try {\n    return await isTableAvailableV2(tableId, startISO, partySize, options);\n  } catch (error) {\n    if (error instanceof AssignTablesRpcError) {\n      throw new AssignTablesRpcError({\n        message: \"Failed to verify table availability\",\n        code: error.code ?? \"TABLE_AVAILABILITY_QUERY_FAILED\",\n        details: error.details,\n        hint: error.hint ?? null,\n      });\n    }\n    throw error;\n  }\n}\n\nexport const __internal = {\n  computeBookingWindow,\n  windowsOverlap,\n  filterAvailableTables,\n  extractConflictsForTables,\n};\n"
    },
    {
      "path": "server/capacity/selector.ts",
      "content": "import type { SelectorScoringConfig, SelectorScoringWeights } from \"./policy\";\nimport type { Table } from \"./tables\";\n\nconst DIAGNOSTIC_SKIP_KEYS = [\"capacity\", \"overage\", \"adjacency\", \"kmax\", \"zone\", \"limit\", \"bucket\"] as const;\n\ntype DiagnosticSkipKey = (typeof DIAGNOSTIC_SKIP_KEYS)[number];\n\ntype DiagnosticSkipCounts = Record<DiagnosticSkipKey, number> & Record<string, number>;\n\nexport type CandidateMetrics = {\n  overage: number;\n  tableCount: number;\n  fragmentation: number;\n  zoneBalance: number;\n  adjacencyCost: number;\n};\n\nexport type RankedTablePlan = {\n  tables: Table[];\n  totalCapacity: number;\n  slack: number;\n  metrics: CandidateMetrics;\n  score: number;\n  tableKey: string;\n  adjacencyStatus: \"single\" | \"connected\" | \"disconnected\";\n};\n\nexport type CandidateDiagnostics = {\n  singlesConsidered: number;\n  combinationsEnumerated: number;\n  combinationsAccepted: number;\n  skipped: DiagnosticSkipCounts;\n  limits: {\n    kMax: number;\n    maxPlansPerSlack: number;\n    maxCombinationEvaluations: number;\n  };\n  totals: {\n    enumerated: number;\n    accepted: number;\n  };\n};\n\nexport type BuildCandidatesOptions = {\n  tables: Table[];\n  partySize: number;\n  adjacency: Map<string, Set<string>>;\n  config: SelectorScoringConfig;\n  enableCombinations?: boolean;\n  kMax?: number;\n  maxPlansPerSlack?: number;\n  maxCombinationEvaluations?: number;\n  requireAdjacency?: boolean;\n};\n\nexport type BuildCandidatesResult = {\n  plans: RankedTablePlan[];\n  fallbackReason?: string;\n  diagnostics: CandidateDiagnostics;\n};\n\nconst FALLBACK_NO_TABLES = \"No tables meet the capacity requirements for this party size.\";\nconst DEFAULT_MAX_PLANS_PER_SLACK = 50;\nconst DEFAULT_MAX_COMBINATION_EVALUATIONS = 500;\n\nfunction createSkipCounts(): DiagnosticSkipCounts {\n  return DIAGNOSTIC_SKIP_KEYS.reduce((accumulator, key) => {\n    accumulator[key] = 0;\n    return accumulator;\n  }, Object.create(null) as DiagnosticSkipCounts);\n}\n\nfunction incrementCounter(target: Record<string, number>, key: string, amount = 1): void {\n  const current = target[key] ?? 0;\n  target[key] = current + amount;\n}\n\nexport function buildScoredTablePlans(options: BuildCandidatesOptions): BuildCandidatesResult {\n  const {\n    tables,\n    partySize,\n    adjacency,\n    config,\n    enableCombinations = false,\n    kMax,\n    maxPlansPerSlack,\n    maxCombinationEvaluations,\n    requireAdjacency = true,\n  } = options;\n  const { maxOverage, weights } = config;\n\n  const maxAllowedCapacity = partySize + Math.max(maxOverage, 0);\n  const combinationCap = Math.max(1, Math.min(kMax ?? config.maxTables ?? 1, tables.length || 1));\n  const perSlackLimit = Math.max(1, maxPlansPerSlack ?? DEFAULT_MAX_PLANS_PER_SLACK);\n  const combinationEvaluationLimit = Math.max(1, maxCombinationEvaluations ?? DEFAULT_MAX_COMBINATION_EVALUATIONS);\n\n  const diagnostics: CandidateDiagnostics = {\n    singlesConsidered: 0,\n    combinationsEnumerated: 0,\n    combinationsAccepted: 0,\n    skipped: createSkipCounts(),\n    limits: {\n      kMax: combinationCap,\n      maxPlansPerSlack: perSlackLimit,\n      maxCombinationEvaluations: combinationEvaluationLimit,\n    },\n    totals: {\n      enumerated: 0,\n      accepted: 0,\n    },\n  };\n\n  const validTables: Table[] = [];\n  const singleTableCandidates: Table[] = [];\n\n  for (const table of tables) {\n    const capacity = table.capacity ?? 0;\n    if (!Number.isFinite(capacity) || capacity <= 0) {\n      incrementCounter(diagnostics.skipped, \"capacity\");\n      continue;\n    }\n\n    if (typeof table.minPartySize === \"number\" && table.minPartySize > 0 && partySize < table.minPartySize) {\n      incrementCounter(diagnostics.skipped, \"capacity\");\n      continue;\n    }\n\n    if (typeof table.maxPartySize === \"number\" && table.maxPartySize > 0 && partySize > table.maxPartySize) {\n      incrementCounter(diagnostics.skipped, \"capacity\");\n      continue;\n    }\n\n    if (capacity > maxAllowedCapacity) {\n      incrementCounter(diagnostics.skipped, \"overage\");\n      continue;\n    }\n\n    validTables.push(table);\n\n    if (capacity >= partySize) {\n      singleTableCandidates.push(table);\n    }\n  }\n\n  diagnostics.singlesConsidered = singleTableCandidates.length;\n\n  const plans: RankedTablePlan[] = [];\n\n  for (const table of singleTableCandidates) {\n    const adjacencyDepths = new Map<string, number>([[table.id, 0]]);\n    const metrics = computeMetrics([table], partySize, adjacencyDepths);\n    const score = computeScore(metrics, weights);\n    const totalCapacity = metrics.overage + partySize;\n    const tableKey = buildTableKey([table]);\n\n    plans.push({\n      tables: [table],\n      totalCapacity,\n      slack: metrics.overage,\n      metrics,\n      score,\n      tableKey,\n      adjacencyStatus: \"single\",\n    });\n  }\n\n  if (enableCombinations && combinationCap > 1 && validTables.length > 1) {\n    const combinationPlans = enumerateCombinationPlans({\n      candidates: validTables,\n      partySize,\n      weights,\n      adjacency,\n      maxAllowedCapacity,\n      kMax: combinationCap,\n      bucketLimit: perSlackLimit,\n      evaluationLimit: combinationEvaluationLimit,\n      diagnostics,\n      requireAdjacency,\n    });\n\n    plans.push(...combinationPlans);\n  }\n\n  plans.sort((a, b) => comparePlans(a, b, weights));\n\n  const fallbackReason = plans.length > 0 ? undefined : FALLBACK_NO_TABLES;\n\n  diagnostics.totals.enumerated = diagnostics.combinationsEnumerated + diagnostics.singlesConsidered;\n  diagnostics.totals.accepted = plans.length;\n\n  return { plans, fallbackReason, diagnostics };\n}\n\nfunction computeMetrics(tables: Table[], partySize: number, adjacencyDepths: Map<string, number>): CandidateMetrics {\n  const capacities = tables.map((table) => table.capacity ?? 0);\n  const totalCapacity = capacities.reduce((sum, capacity) => sum + capacity, 0);\n  const maxCapacity = capacities.length > 0 ? Math.max(...capacities) : 0;\n  const overage = Math.max(totalCapacity - partySize, 0);\n  const fragmentation = Math.max(totalCapacity - maxCapacity, 0);\n  const zoneIds = new Set(tables.map((table) => table.zoneId ?? null));\n  const zoneBalance = Math.max(zoneIds.size - 1, 0);\n  const depthValues = adjacencyDepths.size > 0 ? [...adjacencyDepths.values()] : [0];\n  let adjacencyCost = Math.max(...depthValues);\n  if (adjacencyDepths.size < tables.length) {\n    adjacencyCost = Math.max(adjacencyCost, tables.length);\n  }\n\n  return {\n    overage,\n    tableCount: tables.length,\n    fragmentation,\n    zoneBalance,\n    adjacencyCost,\n  };\n}\n\nfunction computeScore(metrics: CandidateMetrics, weights: SelectorScoringWeights): number {\n  return (\n    metrics.overage * weights.overage +\n    (metrics.tableCount - 1) * weights.tableCount +\n    metrics.fragmentation * weights.fragmentation +\n    metrics.zoneBalance * weights.zoneBalance +\n    metrics.adjacencyCost * weights.adjacencyCost\n  );\n}\n\nfunction comparePlans(a: RankedTablePlan, b: RankedTablePlan, _weights: SelectorScoringWeights): number {\n  if (a.score !== b.score) {\n    return a.score - b.score;\n  }\n\n  if (a.metrics.overage !== b.metrics.overage) {\n    return a.metrics.overage - b.metrics.overage;\n  }\n\n  if (a.metrics.tableCount !== b.metrics.tableCount) {\n    return a.metrics.tableCount - b.metrics.tableCount;\n  }\n\n  if (a.totalCapacity !== b.totalCapacity) {\n    return a.totalCapacity - b.totalCapacity;\n  }\n\n  if (a.metrics.fragmentation !== b.metrics.fragmentation) {\n    return a.metrics.fragmentation - b.metrics.fragmentation;\n  }\n\n  if (a.metrics.adjacencyCost !== b.metrics.adjacencyCost) {\n    return a.metrics.adjacencyCost - b.metrics.adjacencyCost;\n  }\n\n  return a.tableKey.localeCompare(b.tableKey, \"en\");\n}\n\nfunction buildTableKey(tables: Table[]): string {\n  return tables\n    .map((table) => table.tableNumber ?? table.id)\n    .sort((a, b) => a.localeCompare(b))\n    .join(\"+\");\n}\n\ntype CombinationPlannerArgs = {\n  candidates: Table[];\n  partySize: number;\n  weights: SelectorScoringWeights;\n  adjacency: Map<string, Set<string>>;\n  maxAllowedCapacity: number;\n  kMax: number;\n  bucketLimit: number;\n  evaluationLimit: number;\n  diagnostics: CandidateDiagnostics;\n  requireAdjacency: boolean;\n};\n\n/**\n * Enumerates multi-table plans honoring adjacency, kMax, zone-locking, and per-slack limits.\n *\n * Tables are grouped by slack buckets and trimmed to the configured per-slack cap.\n * The search short-circuits when either the evaluation limit, zone guard, or\n * adjacency requirements disqualify further combinations, ensuring consistent\n * diagnostics for skipped plans.\n */\nfunction enumerateCombinationPlans(args: CombinationPlannerArgs): RankedTablePlan[] {\n  const {\n    candidates,\n    partySize,\n    weights,\n    adjacency,\n    maxAllowedCapacity,\n    kMax,\n    bucketLimit,\n    evaluationLimit,\n    diagnostics,\n    requireAdjacency,\n  } = args;\n\n  if (kMax <= 1) {\n    return [];\n  }\n\n  const seenKeys = new Set<string>();\n  const buckets = new Map<number, RankedTablePlan[]>();\n  const sortedCandidates = [...candidates].sort((a, b) => {\n    const capacityDiff = (a.capacity ?? 0) - (b.capacity ?? 0);\n    if (capacityDiff !== 0) {\n      return capacityDiff;\n    }\n    const nameA = a.tableNumber ?? a.id;\n    const nameB = b.tableNumber ?? b.id;\n    return nameA.localeCompare(nameB);\n  });\n\n  let evaluations = 0;\n  let enumerated = diagnostics.combinationsEnumerated ?? 0;\n  let accepted = diagnostics.combinationsAccepted ?? 0;\n  let limitRecorded = false;\n  let stopSearch = false;\n\n  const registerPlan = (plan: RankedTablePlan) => {\n    const bucket = buckets.get(plan.slack) ?? [];\n    bucket.push(plan);\n    bucket.sort((a, b) => comparePlans(a, b, weights));\n    if (bucket.length > bucketLimit) {\n      bucket.length = bucketLimit;\n      incrementCounter(diagnostics.skipped, \"bucket\");\n    }\n    buckets.set(plan.slack, bucket);\n    accepted += 1;\n    diagnostics.combinationsAccepted = accepted;\n  };\n\n  const dfs = (startIndex: number, selection: Table[], runningCapacity: number, baseZoneId: string | null) => {\n    if (stopSearch) {\n      return;\n    }\n\n    if (selection.length >= 2 && runningCapacity >= partySize) {\n      enumerated += 1;\n      diagnostics.combinationsEnumerated = enumerated;\n\n      const key = buildTableKey(selection);\n      if (!seenKeys.has(key)) {\n        seenKeys.add(key);\n        const adjacencyEvaluation = evaluateAdjacency(selection, adjacency);\n        if (!adjacencyEvaluation.connected && requireAdjacency) {\n          incrementCounter(diagnostics.skipped, \"adjacency\");\n        } else {\n          const metrics = computeMetrics(selection, partySize, adjacencyEvaluation.depths);\n          const score = computeScore(metrics, weights);\n          const totalCapacity = metrics.overage + partySize;\n          const adjacencyStatus: RankedTablePlan[\"adjacencyStatus\"] =\n            selection.length <= 1\n              ? \"single\"\n              : adjacencyEvaluation.connected\n                ? \"connected\"\n                : \"disconnected\";\n          const plan: RankedTablePlan = {\n            tables: [...selection],\n            totalCapacity,\n            slack: metrics.overage,\n            metrics,\n            score,\n            tableKey: key,\n            adjacencyStatus,\n          };\n          registerPlan(plan);\n        }\n      }\n\n      evaluations += 1;\n      if (evaluations >= evaluationLimit) {\n        stopSearch = true;\n        if (!limitRecorded) {\n          incrementCounter(diagnostics.skipped, \"limit\");\n          limitRecorded = true;\n        }\n        return;\n      }\n    }\n\n    if (selection.length >= kMax) {\n      if (runningCapacity < partySize) {\n        incrementCounter(diagnostics.skipped, \"capacity\");\n      }\n      incrementCounter(diagnostics.skipped, \"kmax\");\n      return;\n    }\n\n    for (let index = startIndex; index < sortedCandidates.length; index += 1) {\n      if (stopSearch) {\n        break;\n      }\n\n      const candidate = sortedCandidates[index];\n\n      if (selection.some((existing) => existing.id === candidate.id)) {\n        continue;\n      }\n\n      if (selection.length > 0 && baseZoneId && candidate.zoneId && candidate.zoneId !== baseZoneId) {\n        incrementCounter(diagnostics.skipped, \"zone\");\n        continue;\n      }\n\n      if (selection.length + 1 > kMax) {\n        incrementCounter(diagnostics.skipped, \"kmax\");\n        continue;\n      }\n\n      const nextCapacity = runningCapacity + (candidate.capacity ?? 0);\n\n      if (nextCapacity > maxAllowedCapacity) {\n        incrementCounter(diagnostics.skipped, \"overage\");\n        // Capacities sorted ascending; further entries will exceed as well for this path.\n        break;\n      }\n\n      if (requireAdjacency && selection.length > 0 && !isAdjacentToSelection(candidate, selection, adjacency)) {\n        incrementCounter(diagnostics.skipped, \"adjacency\");\n        continue;\n      }\n\n      const nextZoneId = baseZoneId ?? candidate.zoneId ?? null;\n\n      dfs(index + 1, [...selection, candidate], nextCapacity, nextZoneId);\n    }\n  };\n\n  for (let i = 0; i < sortedCandidates.length && !stopSearch; i += 1) {\n    const base = sortedCandidates[i];\n    dfs(i + 1, [base], base.capacity ?? 0, base.zoneId ?? null);\n  }\n\n  return Array.from(buckets.values())\n    .flat()\n    .sort((a, b) => comparePlans(a, b, weights));\n}\n\nfunction isAdjacentToSelection(candidate: Table, selection: Table[], adjacency: Map<string, Set<string>>): boolean {\n  for (const table of selection) {\n    const forward = adjacency.get(table.id);\n    if (forward && forward.has(candidate.id)) {\n      return true;\n    }\n    const backward = adjacency.get(candidate.id);\n    if (backward && backward.has(table.id)) {\n      return true;\n    }\n  }\n  return false;\n}\n\nfunction evaluateAdjacency(\n  tables: Table[],\n  adjacency: Map<string, Set<string>>,\n): { connected: boolean; depths: Map<string, number> } {\n  if (tables.length === 0) {\n    return { connected: true, depths: new Map() };\n  }\n\n  if (tables.length === 1) {\n    return { connected: true, depths: new Map([[tables[0].id, 0]]) };\n  }\n\n  const tableIds = tables.map((table) => table.id);\n  const selection = new Set(tableIds);\n  const depths = new Map<string, number>();\n  const queue: string[] = [];\n\n  const [firstId] = tableIds;\n  queue.push(firstId);\n  depths.set(firstId, 0);\n\n  while (queue.length > 0) {\n    const current = queue.shift();\n    if (!current) {\n      continue;\n    }\n    const neighbors = adjacency.get(current);\n    if (!neighbors) {\n      continue;\n    }\n    for (const neighbor of neighbors) {\n      if (!selection.has(neighbor) || depths.has(neighbor)) {\n        continue;\n      }\n      const depth = (depths.get(current) ?? 0) + 1;\n      depths.set(neighbor, depth);\n      queue.push(neighbor);\n    }\n  }\n\n  const connected = depths.size === selection.size;\n  return { connected, depths };\n}\n"
    },
    {
      "path": "server/capacity/planner/bitset.ts",
      "content": "import { DateTime } from \"luxon\";\n\ntype Dateish = DateTime | string | number | Date;\n\nconst SLOT_MINUTES = 5;\nconst SLOT_DURATION_MS = SLOT_MINUTES * 60 * 1000;\n\nexport type AvailabilityBitset = {\n  /**\n   * Set of slot indices that are occupied. The index is derived from\n   * `Math.floor(epochMillis / SLOT_DURATION_MS)`.\n   */\n  occupied: Set<number>;\n};\n\nfunction toDateTime(value: Dateish): DateTime {\n  if (value instanceof DateTime) {\n    return value;\n  }\n  if (value instanceof Date) {\n    return DateTime.fromJSDate(value, { zone: \"utc\" });\n  }\n  if (typeof value === \"number\") {\n    return DateTime.fromMillis(value, { zone: \"utc\" });\n  }\n  return DateTime.fromISO(value, { zone: \"utc\" });\n}\n\nfunction toSlotIndex(date: Dateish, round: \"floor\" | \"ceil\" = \"floor\"): number {\n  const millis = toDateTime(date).toMillis();\n  const quotient = millis / SLOT_DURATION_MS;\n  return round === \"floor\" ? Math.floor(quotient) : Math.ceil(quotient);\n}\n\nexport function createAvailabilityBitset(\n  windows?: Array<{ start: Dateish; end: Dateish }>,\n): AvailabilityBitset {\n  const occupied = new Set<number>();\n  if (windows) {\n    for (const window of windows) {\n      markWindow({ occupied }, window.start, window.end);\n    }\n  }\n  return { occupied };\n}\n\nexport function markWindow(bitset: AvailabilityBitset, start: Dateish, end: Dateish): void {\n  const startSlot = toSlotIndex(start, \"floor\");\n  const endSlot = toSlotIndex(end, \"ceil\");\n  for (let slot = startSlot; slot < endSlot; slot += 1) {\n    bitset.occupied.add(slot);\n  }\n}\n\nexport function isWindowFree(bitset: AvailabilityBitset, start: Dateish, end: Dateish): boolean {\n  const startSlot = toSlotIndex(start, \"floor\");\n  const endSlot = toSlotIndex(end, \"ceil\");\n  for (let slot = startSlot; slot < endSlot; slot += 1) {\n    if (bitset.occupied.has(slot)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function mergeBitsets(bitsets: AvailabilityBitset[]): AvailabilityBitset {\n  const merged = createAvailabilityBitset();\n  for (const bitset of bitsets) {\n    for (const slot of bitset.occupied) {\n      merged.occupied.add(slot);\n    }\n  }\n  return merged;\n}\n"
    },
    {
      "path": "server/capacity/v2/planner.ts",
      "content": "import { buildScoredTablePlans, type BuildCandidatesResult } from \"../selector\";\nimport type { Table } from \"../tables\";\nimport type { SelectorScoringConfig } from \"../policy\";\n\nexport type PlannerInput = {\n  tables: Table[];\n  partySize: number;\n  adjacency: Map<string, Set<string>>;\n  config: SelectorScoringConfig;\n  enableCombinations: boolean;\n  kMax: number;\n  requireAdjacency: boolean;\n  maxPlansPerSlack?: number;\n  maxCombinationEvaluations?: number;\n};\n\nexport type PlannerResult = BuildCandidatesResult;\n\nexport function generateCandidatePlans(input: PlannerInput): PlannerResult {\n  return buildScoredTablePlans({\n    tables: input.tables,\n    partySize: input.partySize,\n    adjacency: input.adjacency,\n    config: input.config,\n    enableCombinations: input.enableCombinations,\n    kMax: input.kMax,\n    requireAdjacency: input.requireAdjacency,\n    maxPlansPerSlack: input.maxPlansPerSlack,\n    maxCombinationEvaluations: input.maxCombinationEvaluations,\n  });\n}\n"
    },
    {
      "path": "server/capacity/v2/orchestrator.ts",
      "content": "import { isAllocatorV2Enabled, isAllocatorV2ShadowMode, isAllocatorV2ForceLegacy } from \"@/server/feature-flags\";\n\nimport { AssignmentRepository } from \"./repository\";\nimport {\n  AssignmentConflictError,\n  AssignmentRepositoryError,\n  AssignmentValidationError,\n} from \"./errors\";\nimport { NoopAssignmentRepository } from \"./supabase-repository\";\nimport type {\n  AssignmentCommitRequest,\n  AssignmentCommitResponse,\n  AssignmentContext,\n  AssignmentPlan,\n  AssignmentSource,\n} from \"./types\";\n\nexport type CommitPlanOptions = {\n  source: AssignmentSource;\n  idempotencyKey: string;\n  actorId?: string | null;\n  metadata?: Record<string, unknown>;\n  shadow?: boolean;\n  requireAdjacency?: boolean;\n};\n\nexport class AssignmentOrchestrator {\n  constructor(\n    private readonly repository: AssignmentRepository,\n    private readonly shadowRepository: AssignmentRepository = new NoopAssignmentRepository(),\n  ) {}\n\n  async commitPlan(\n    context: AssignmentContext,\n    plan: AssignmentPlan,\n    options: CommitPlanOptions,\n  ): Promise<AssignmentCommitResponse> {\n    const allocatorDisabled = !isAllocatorV2Enabled();\n    const shadowMode = options.shadow ?? isAllocatorV2ShadowMode();\n\n    if (isAllocatorV2ForceLegacy() && !shadowMode) {\n      throw new AssignmentRepositoryError(\"Allocator v2 force-legacy mode is active; cannot commit plan.\");\n    }\n\n    if (allocatorDisabled && !shadowMode) {\n      throw new AssignmentRepositoryError(\"Allocator v2 is disabled. Enable shadow or commit mode before invoking orchestrator.\");\n    }\n\n    const request: AssignmentCommitRequest = {\n      context,\n      plan,\n      source: options.source,\n      idempotencyKey: options.idempotencyKey,\n      actorId: options.actorId,\n      metadata: options.metadata,\n      shadow: shadowMode,\n      requireAdjacency: options.requireAdjacency,\n    };\n\n    const targetRepository = shadowMode && allocatorDisabled ? this.shadowRepository : this.repository;\n\n    try {\n      return await targetRepository.commitAssignment(request);\n    } catch (error) {\n      if (error instanceof AssignmentConflictError || error instanceof AssignmentValidationError) {\n        throw error;\n      }\n      throw new AssignmentRepositoryError(\"Allocator v2 repository failure\", error);\n    }\n  }\n}\n"
    },
    {
      "path": "server/capacity/v2/supabase-repository.ts",
      "content": "import { getServiceSupabaseClient } from \"@/server/supabase\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\n\nimport type { AssignmentRepository } from \"./repository\";\nimport { AssignmentConflictError, AssignmentRepositoryError, AssignmentValidationError } from \"./errors\";\nimport type {\n  AssignmentCommitRequest,\n  AssignmentCommitResponse,\n  AssignmentRecord,\n} from \"./types\";\n\ntype PostgrestError = {\n  code?: string;\n  message?: string;\n  details?: string | null;\n  hint?: string | null;\n};\n\nfunction extractUuids(value: string | null | undefined): string[] {\n  if (!value) return [];\n  const matches = value.match(/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/gi);\n  return matches ? matches.map((entry) => entry.toLowerCase()) : [];\n}\n\nfunction parseBlockingBookingId(message: string, details: string | null | undefined): string | undefined {\n  const sources = [message, details ?? \"\"];\n  for (const source of sources) {\n    const match = source.match(/booking\\s+([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/i);\n    if (match) {\n      return match[1].toLowerCase();\n    }\n  }\n  return undefined;\n}\n\nfunction buildConflictError(params: {\n  error: PostgrestError;\n  request: AssignmentCommitRequest;\n}): AssignmentConflictError {\n  const { error, request } = params;\n  const conflictTables = new Set<string>();\n  for (const tableId of request.plan.tableIds) {\n    conflictTables.add(tableId.toLowerCase());\n  }\n  for (const uuid of extractUuids(error.message)) {\n    conflictTables.add(uuid);\n  }\n  for (const uuid of extractUuids(error.details)) {\n    conflictTables.add(uuid);\n  }\n\n  const blockingBookingId = parseBlockingBookingId(error.message ?? \"\", error.details);\n\n  return new AssignmentConflictError(error.message ?? \"Assignment conflict\", {\n    tableIds: Array.from(conflictTables),\n    blockingBookingId,\n    window: {\n      start: request.plan.startAt,\n      end: request.plan.endAt,\n    },\n    hint: error.hint ?? undefined,\n    raw: {\n      code: error.code,\n      details: error.details,\n      metadata: request.metadata ?? null,\n    },\n  });\n}\n\nfunction buildValidationError(params: {\n  error: PostgrestError;\n  request: AssignmentCommitRequest;\n}): AssignmentValidationError {\n  const { error, request } = params;\n  return new AssignmentValidationError(error.message ?? \"Assignment validation failed\", {\n    code: error.code,\n    details: error.details,\n    hint: error.hint,\n    plan: {\n      tableIds: request.plan.tableIds,\n      startAt: request.plan.startAt,\n      endAt: request.plan.endAt,\n    },\n    context: {\n      bookingId: request.context.bookingId,\n      restaurantId: request.context.restaurantId,\n    },\n  });\n}\n\nfunction translateSupabaseError(params: {\n  error: PostgrestError;\n  request: AssignmentCommitRequest;\n}): never {\n  const { error, request } = params;\n  const code = (error.code ?? \"\").toUpperCase();\n  const message = error.message ?? \"assign_tables_atomic_v2 failed\";\n  const normalized = message.toLowerCase();\n\n  if (\n    code === \"23505\" ||\n    code === \"P0001\" ||\n    normalized.includes(\"duplicate\") ||\n    normalized.includes(\"overlap\") ||\n    normalized.includes(\"conflict\")\n  ) {\n    throw buildConflictError({ error, request });\n  }\n\n  if (\n    code === \"23514\" ||\n    code === \"23503\" ||\n    code === \"23502\" ||\n    code === \"22023\" ||\n    code === \"22000\" ||\n    code === \"P0002\" ||\n    code === \"P0003\" ||\n    normalized.includes(\"requires at least one\") ||\n    normalized.includes(\"not assigned\") ||\n    normalized.includes(\"missing\") ||\n    normalized.includes(\"invalid\")\n  ) {\n    throw buildValidationError({ error, request });\n  }\n\n  throw new AssignmentRepositoryError(message, error);\n}\n\nexport class SupabaseAssignmentRepository implements AssignmentRepository {\n  constructor(private readonly client: SupabaseClient = getServiceSupabaseClient()) {}\n\n  async commitAssignment(request: AssignmentCommitRequest): Promise<AssignmentCommitResponse> {\n    const { context, plan, idempotencyKey, source, actorId, shadow } = request;\n    const supabase = this.client;\n\n    if (!context.window) {\n      throw new AssignmentValidationError(\"Assignment window not provided in context\", { context });\n    }\n\n    const requireAdjacency = request.requireAdjacency ?? true;\n\n    const payload = {\n      p_booking_id: context.bookingId,\n      p_table_ids: plan.tableIds,\n      p_idempotency_key: idempotencyKey,\n      p_require_adjacency: requireAdjacency,\n      p_assigned_by: actorId ?? null,\n      p_start_at: plan.startAt,\n      p_end_at: plan.endAt,\n    };\n\n    const { data, error } = await supabase.rpc(\"assign_tables_atomic_v2\", payload);\n\n    if (error) {\n      translateSupabaseError({ error, request });\n    }\n\n    const assignments: AssignmentRecord[] = (Array.isArray(data) ? data : []).map((row: any) => ({\n      tableId: row.table_id,\n      startAt: row.start_at,\n      endAt: row.end_at,\n      mergeGroupId: row.merge_group_id ?? null,\n      assignmentId: row.assignment_id ?? undefined,\n    }));\n\n    return {\n      attemptId: `rpc-${plan.signature}`,\n      assignments,\n      mergeGroupId: assignments[0]?.mergeGroupId ?? null,\n      shadow: shadow ?? false,\n    };\n  }\n}\n\nexport class NoopAssignmentRepository implements AssignmentRepository {\n  async commitAssignment(_request: AssignmentCommitRequest): Promise<AssignmentCommitResponse> {\n    return {\n      attemptId: \"noop\",\n      assignments: [],\n      mergeGroupId: null,\n      shadow: true,\n    };\n  }\n}\n"
    },
    {
      "path": "server/capacity/v2/types.ts",
      "content": "import type { CandidateSummary } from \"../telemetry\";\n\nexport type AssignmentSource = \"manual\" | \"auto\";\n\nexport type AssignmentPlan = {\n  /** Deterministic hash representing the candidate plan (tables + window + constraints). */\n  signature: string;\n  tableIds: string[];\n  startAt: string;\n  endAt: string;\n  metadata?: Record<string, unknown>;\n  candidate?: CandidateSummary;\n};\n\nexport type AssignmentContext = {\n  bookingId: string;\n  restaurantId: string;\n  partySize: number;\n  zoneId?: string | null;\n  serviceDate?: string | null;\n  window?: {\n    startAt: string;\n    endAt: string;\n  };\n  holdId?: string | null;\n};\n\nexport type AssignmentRecord = {\n  tableId: string;\n  startAt: string;\n  endAt: string;\n  mergeGroupId: string | null;\n  assignmentId?: string;\n};\n\nexport type AssignmentCommitRequest = {\n  context: AssignmentContext;\n  plan: AssignmentPlan;\n  source: AssignmentSource;\n  idempotencyKey: string;\n  actorId?: string | null;\n  metadata?: Record<string, unknown>;\n  shadow?: boolean;\n  requireAdjacency?: boolean;\n};\n\nexport type AssignmentCommitResponse = {\n  attemptId: string;\n  assignments: AssignmentRecord[];\n  mergeGroupId?: string | null;\n  telemetryId?: string;\n  shadow?: boolean;\n};\n\nexport type AssignmentAttemptDiagnostics = {\n  planSignature: string;\n  candidateCount: number;\n  generatedAt: string;\n  skipped?: number;\n  conflictDetails?: Record<string, unknown>;\n};\n"
    },
    {
      "path": "server/capacity/v2/errors.ts",
      "content": "export type ConflictDetails = {\n  tableIds: string[];\n  blockingBookingId?: string;\n  window?: { start: string; end: string };\n  hint?: string | null;\n  raw?: unknown;\n};\n\nexport class AssignmentConflictError extends Error {\n  constructor(message: string, public readonly details?: ConflictDetails) {\n    super(message);\n    this.name = \"AssignmentConflictError\";\n  }\n}\n\nexport class AssignmentValidationError extends Error {\n  constructor(message: string, public readonly details?: Record<string, unknown>) {\n    super(message);\n    this.name = \"AssignmentValidationError\";\n  }\n}\n\nexport class AssignmentRepositoryError extends Error {\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n    this.name = \"AssignmentRepositoryError\";\n  }\n}\n"
    },
    {
      "path": "server/capacity/holds.ts",
      "content": "import { DateTime } from \"luxon\";\n\nimport { getServiceSupabaseClient } from \"@/server/supabase\";\n\nimport type { Database, Json, Tables, TablesInsert } from \"@/types/supabase\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\n\ntype DbClient = SupabaseClient<Database, \"public\", any>;\n\nexport type TableHold = {\n  id: string;\n  bookingId: string | null;\n  restaurantId: string;\n  zoneId: string;\n  startAt: string;\n  endAt: string;\n  expiresAt: string;\n  tableIds: string[];\n  createdBy: string | null;\n  metadata: Json | null;\n};\n\nexport type HoldConflictInfo = {\n  holdId: string;\n  bookingId: string | null;\n  tableIds: string[];\n  startAt: string;\n  endAt: string;\n  expiresAt: string;\n};\n\nexport type CreateTableHoldInput = {\n  bookingId: string | null;\n  restaurantId: string;\n  zoneId: string;\n  tableIds: string[];\n  startAt: string;\n  endAt: string;\n  expiresAt: string;\n  createdBy?: string | null;\n  metadata?: Json | null;\n  client?: DbClient;\n};\n\nexport type ReleaseTableHoldInput = {\n  holdId: string;\n  client?: DbClient;\n};\n\nexport type ConfirmTableHoldInput = {\n  holdId: string;\n  bookingId: string;\n  idempotencyKey?: string | null;\n  requireAdjacency?: boolean;\n  assignedBy?: string | null;\n  startAt?: string | null;\n  endAt?: string | null;\n  client?: DbClient;\n};\n\nexport type ConfirmedAssignment = {\n  tableId: string;\n  startAt: string;\n  endAt: string;\n  mergeGroupId: string | null;\n};\n\nexport type FindHoldConflictsInput = {\n  restaurantId: string;\n  tableIds: string[];\n  startAt: string;\n  endAt: string;\n  excludeHoldId?: string | null;\n  client?: DbClient;\n};\n\nexport type ListActiveHoldsInput = {\n  bookingId: string;\n  client?: DbClient;\n};\n\nexport type SweepExpiredHoldsInput = {\n  now?: string;\n  limit?: number;\n  client?: DbClient;\n};\n\nexport type SweepExpiredHoldsResult = {\n  total: number;\n  holdIds: string[];\n};\n\nexport class HoldConflictError extends Error {\n  constructor(message: string, public readonly holdId?: string) {\n    super(message);\n    this.name = \"HoldConflictError\";\n  }\n}\n\nexport class HoldNotFoundError extends Error {\n  constructor(message = \"Table hold not found\") {\n    super(message);\n    this.name = \"HoldNotFoundError\";\n  }\n}\n\nexport class AssignTablesRpcError extends Error {\n  public readonly code?: string | null;\n  public readonly details?: string | null;\n  public readonly hint?: string | null;\n\n  constructor(error: { message: string; code?: string | null; details?: string | null; hint?: string | null }) {\n    super(error.message);\n    this.name = \"AssignTablesRpcError\";\n    this.code = error.code ?? null;\n    this.details = error.details ?? null;\n    this.hint = error.hint ?? null;\n  }\n}\n\nfunction ensureClient(client?: DbClient): DbClient {\n  return client ?? getServiceSupabaseClient();\n}\n\nfunction normalizeHold(row: Tables<\"table_holds\">, tableIds: string[]): TableHold {\n  return {\n    id: row.id,\n    bookingId: row.booking_id,\n    restaurantId: row.restaurant_id,\n    zoneId: row.zone_id,\n    startAt: row.start_at,\n    endAt: row.end_at,\n    expiresAt: row.expires_at,\n    tableIds,\n    createdBy: row.created_by,\n    metadata: row.metadata ?? null,\n  };\n}\n\nfunction intervalsOverlap(aStart: string, aEnd: string, bStart: string, bEnd: string): boolean {\n  const startA = DateTime.fromISO(aStart);\n  const endA = DateTime.fromISO(aEnd);\n  const startB = DateTime.fromISO(bStart);\n  const endB = DateTime.fromISO(bEnd);\n  if (!startA.isValid || !endA.isValid || !startB.isValid || !endB.isValid) {\n    return false;\n  }\n  return startA < endB && startB < endA;\n}\n\nexport async function createTableHold(input: CreateTableHoldInput): Promise<TableHold> {\n  const {\n    bookingId,\n    restaurantId,\n    zoneId,\n    tableIds,\n    startAt,\n    endAt,\n    expiresAt,\n    createdBy = null,\n    metadata = null,\n    client,\n  } = input;\n\n  if (!Array.isArray(tableIds) || tableIds.length === 0) {\n    throw new HoldConflictError(\"Cannot create a hold without tables\");\n  }\n\n  const supabase = ensureClient(client);\n\n  const insertPayload: TablesInsert<\"table_holds\"> = {\n    booking_id: bookingId,\n    restaurant_id: restaurantId,\n    zone_id: zoneId,\n    start_at: startAt,\n    end_at: endAt,\n    expires_at: expiresAt,\n    created_by: createdBy,\n    metadata,\n  };\n\n  const { data: holdRow, error: insertError } = await supabase\n    .from(\"table_holds\")\n    .insert(insertPayload)\n    .select(\"id, booking_id, restaurant_id, zone_id, start_at, end_at, expires_at, created_by, metadata\")\n    .maybeSingle();\n\n  if (insertError || !holdRow) {\n    throw new HoldConflictError(insertError?.message ?? \"Failed to create table hold\");\n  }\n\n  const memberRows = tableIds.map((tableId) => ({\n    hold_id: holdRow.id,\n    table_id: tableId,\n  }));\n\n  const { error: memberError } = await supabase.from(\"table_hold_members\").insert(memberRows);\n\n  if (memberError) {\n    await supabase.from(\"table_holds\").delete().eq(\"id\", holdRow.id);\n    throw new HoldConflictError(memberError.message ?? \"Failed to record table hold members\", holdRow.id);\n  }\n\n  const hold = normalizeHold(holdRow as Tables<\"table_holds\">, tableIds);\n\n  const { emitHoldCreated } = await import(\"./telemetry\");\n  await emitHoldCreated({\n    holdId: hold.id,\n    bookingId: hold.bookingId,\n    restaurantId: hold.restaurantId,\n    zoneId: hold.zoneId,\n    tableIds: hold.tableIds,\n    startAt: hold.startAt,\n    endAt: hold.endAt,\n    expiresAt: hold.expiresAt,\n    actorId: createdBy,\n    metadata,\n  });\n\n  return hold;\n}\n\nexport async function releaseTableHold(input: ReleaseTableHoldInput): Promise<void> {\n  const { holdId, client } = input;\n  const supabase = ensureClient(client);\n  await supabase.from(\"table_hold_members\").delete().eq(\"hold_id\", holdId);\n  await supabase.from(\"table_holds\").delete().eq(\"id\", holdId);\n}\n\nexport async function listActiveHoldsForBooking(input: ListActiveHoldsInput): Promise<TableHold[]> {\n  const { bookingId, client } = input;\n  const supabase = ensureClient(client);\n\n  const { data, error } = await supabase\n    .from(\"table_holds\")\n    .select(\"*, table_hold_members(table_id)\")\n    .eq(\"booking_id\", bookingId)\n    .gt(\"expires_at\", new Date().toISOString());\n\n  if (error || !data) {\n    return [];\n  }\n\n  return data.map((row) =>\n    normalizeHold(row as Tables<\"table_holds\">, (row.table_hold_members ?? []).map((member: any) => member.table_id)),\n  );\n}\n\nexport async function findHoldConflicts(input: FindHoldConflictsInput): Promise<HoldConflictInfo[]> {\n  const { restaurantId, tableIds, startAt, endAt, excludeHoldId = null, client } = input;\n\n  if (!Array.isArray(tableIds) || tableIds.length === 0) {\n    return [];\n  }\n\n  const supabase = ensureClient(client);\n\n  const query = supabase\n    .from(\"table_holds\")\n    .select(\"id, booking_id, start_at, end_at, expires_at, table_hold_members(table_id)\")\n    .eq(\"restaurant_id\", restaurantId)\n    .gt(\"expires_at\", new Date().toISOString())\n    .lt(\"start_at\", endAt)\n    .gt(\"end_at\", startAt);\n\n  const { data, error } = await query;\n\n  if (error || !data) {\n    return [];\n  }\n\n  const conflicts: HoldConflictInfo[] = [];\n\n  for (const row of data) {\n    if (excludeHoldId && row.id === excludeHoldId) {\n      continue;\n    }\n\n    const members = (row.table_hold_members ?? []) as Array<{ table_id: string }>;\n    const memberTableIds = members.map((member) => member.table_id);\n\n    const sharesTable = memberTableIds.some((id) => tableIds.includes(id));\n    if (!sharesTable) {\n      continue;\n    }\n\n    if (!intervalsOverlap(row.start_at, row.end_at, startAt, endAt)) {\n      continue;\n    }\n\n    conflicts.push({\n      holdId: row.id,\n      bookingId: row.booking_id,\n      tableIds: memberTableIds,\n      startAt: row.start_at,\n      endAt: row.end_at,\n      expiresAt: row.expires_at,\n    });\n  }\n\n  return conflicts;\n}\n\nexport async function confirmTableHold(input: ConfirmTableHoldInput): Promise<ConfirmedAssignment[]> {\n  const {\n    holdId,\n    bookingId,\n    idempotencyKey = null,\n    requireAdjacency = false,\n    assignedBy = null,\n    startAt = null,\n    endAt = null,\n    client,\n  } = input;\n  const supabase = ensureClient(client);\n\n  const { data: holdRow, error: holdError } = await supabase\n    .from(\"table_holds\")\n    .select(\"*, table_hold_members(table_id)\")\n    .eq(\"id\", holdId)\n    .maybeSingle();\n\n  if (holdError) {\n    throw new HoldNotFoundError(holdError.message ?? \"Failed to load hold\");\n  }\n\n  if (!holdRow) {\n    throw new HoldNotFoundError();\n  }\n\n  if (holdRow.booking_id && holdRow.booking_id !== bookingId) {\n    throw new HoldConflictError(\"Hold is linked to a different booking\", holdId);\n  }\n\n  const tableIds = (holdRow.table_hold_members ?? []).map((member: { table_id: string }) => member.table_id);\n  if (tableIds.length === 0) {\n    throw new HoldConflictError(\"Hold has no tables\", holdId);\n  }\n\n  const effectiveStartAt = startAt ?? holdRow.start_at ?? null;\n  const effectiveEndAt = endAt ?? holdRow.end_at ?? null;\n\n  if (!effectiveStartAt || !effectiveEndAt) {\n    throw new AssignTablesRpcError({\n      message: \"Unable to resolve assignment window for table hold\",\n      details: null,\n      hint: null,\n    });\n  }\n\n  const { data, error } = await supabase.rpc(\"assign_tables_atomic_v2\", {\n    p_booking_id: bookingId,\n    p_table_ids: tableIds,\n    p_idempotency_key: idempotencyKey,\n    p_require_adjacency: requireAdjacency,\n    p_assigned_by: assignedBy,\n    p_start_at: effectiveStartAt,\n    p_end_at: effectiveEndAt,\n  });\n\n  if (error) {\n    const { emitRpcConflict } = await import(\"./telemetry\");\n    await emitRpcConflict({\n      source: \"confirm_table_hold\",\n      bookingId,\n      restaurantId: holdRow.restaurant_id,\n      tableIds,\n      idempotencyKey,\n      holdId,\n      error: {\n        code: error.code ?? null,\n        message: error.message ?? \"assign_tables_atomic_v2 failed\",\n        details: error.details ?? null,\n        hint: error.hint ?? null,\n      },\n    });\n    throw new AssignTablesRpcError({\n      message: error.message ?? \"assign_tables_atomic_v2 failed\",\n      code: error.code,\n      details: error.details,\n      hint: error.hint,\n    });\n  }\n\n  const assignments: ConfirmedAssignment[] = (Array.isArray(data) ? data : []).map((row: any) => ({\n    tableId: row.table_id,\n    startAt: row.start_at,\n    endAt: row.end_at,\n    mergeGroupId: row.merge_group_id ?? null,\n  }));\n\n  await supabase.from(\"table_holds\").delete().eq(\"id\", holdId);\n\n  return assignments;\n}\n\nexport async function sweepExpiredHolds(input?: SweepExpiredHoldsInput): Promise<SweepExpiredHoldsResult> {\n  const { now, limit = 100, client } = input ?? {};\n  const supabase = ensureClient(client);\n  const cutoff = now ?? new Date().toISOString();\n\n  const { data, error } = await supabase\n    .from(\"table_holds\")\n    .select(\"id\")\n    .lte(\"expires_at\", cutoff)\n    .order(\"expires_at\", { ascending: true })\n    .limit(limit);\n\n  if (error || !data || data.length === 0) {\n    return {\n      total: 0,\n      holdIds: [],\n    };\n  }\n\n  const holdIds = data.map((row) => row.id);\n  await supabase.from(\"table_hold_members\").delete().in(\"hold_id\", holdIds);\n  await supabase.from(\"table_holds\").delete().in(\"id\", holdIds);\n\n  return {\n    total: holdIds.length,\n    holdIds,\n  };\n}\n"
    },
    {
      "path": "supabase/migrations/20251021094505_recreate_unassign_tables_atomic.sql",
      "content": "DO $migration$\nBEGIN\n  EXECUTE $create$\n    CREATE FUNCTION public.unassign_tables_atomic(\n      p_booking_id uuid,\n      p_table_ids uuid[] DEFAULT NULL\n    ) RETURNS TABLE(table_id uuid)\n    LANGUAGE plpgsql\n    SECURITY DEFINER\n    AS $function$\n    DECLARE\n      v_target_tables uuid[] := p_table_ids;\n      v_removed RECORD;\n    BEGIN\n      IF v_target_tables IS NOT NULL THEN\n        SELECT array_agg(DISTINCT table_id)\n        INTO v_target_tables\n        FROM unnest(v_target_tables) AS t(table_id);\n      ELSE\n        SELECT array_agg(table_id)\n        INTO v_target_tables\n        FROM public.booking_table_assignments\n        WHERE booking_id = p_booking_id;\n      END IF;\n\n      IF v_target_tables IS NULL OR array_length(v_target_tables, 1) = 0 THEN\n        RETURN;\n      END IF;\n\n      FOR v_removed IN\n        DELETE FROM public.booking_table_assignments\n        WHERE booking_id = p_booking_id\n          AND table_id = ANY (v_target_tables)\n        RETURNING table_id\n      LOOP\n        table_id := v_removed.table_id;\n\n        DELETE FROM public.allocations\n        WHERE booking_id = p_booking_id\n          AND resource_type = 'table'\n          AND resource_id = v_removed.table_id;\n\n        UPDATE public.table_inventory ti\n        SET status = 'available'::public.table_status\n        WHERE ti.id = v_removed.table_id\n          AND NOT EXISTS (\n            SELECT 1\n            FROM public.booking_table_assignments bta\n            WHERE bta.table_id = v_removed.table_id\n          );\n\n        RETURN NEXT;\n      END LOOP;\n\n      RETURN;\n    END;\n    $function$\n  $create$;\n\n  EXECUTE $alter$\n    ALTER FUNCTION public.unassign_tables_atomic(uuid, uuid[]) OWNER TO postgres\n  $alter$;\n\n  EXECUTE $grant$\n    GRANT ALL ON FUNCTION public.unassign_tables_atomic(uuid, uuid[]) TO service_role\n  $grant$;\nEND;\n$migration$;\n"
    },
    {
      "path": "supabase/migrations/20251021094502_drop_unassign_tables_atomic.sql",
      "content": "DROP FUNCTION IF EXISTS public.unassign_tables_atomic(uuid, uuid[], uuid);\n"
    },
    {
      "path": "supabase/migrations/20251021094501_drop_assign_tables_atomic.sql",
      "content": "DROP FUNCTION IF EXISTS public.assign_tables_atomic(uuid, uuid[], tstzrange, uuid, text);\n"
    },
    {
      "path": "supabase/migrations/20251027164000_precise_assign_tables_atomic_v2.sql",
      "content": "-- Ensure table assignments use precise time windows and enforce overlap constraints.\nCREATE EXTENSION IF NOT EXISTS btree_gist;\n\nALTER TABLE public.booking_table_assignments\n  ADD COLUMN IF NOT EXISTS start_at timestamptz,\n  ADD COLUMN IF NOT EXISTS end_at timestamptz;\n\nALTER TABLE public.booking_table_assignments\n  DROP CONSTRAINT IF EXISTS no_overlapping_table_assignments;\n\nALTER TABLE public.booking_table_assignments\n  ADD CONSTRAINT no_overlapping_table_assignments\n  EXCLUDE USING gist (\n    table_id WITH =,\n    tstzrange(start_at, end_at, '[)') WITH &&\n  )\n  WHERE (start_at IS NOT NULL AND end_at IS NOT NULL);\n\n-- Recreate assign_tables_atomic_v2 with precise window handling.\nDO $$\nBEGIN\n  -- Drop and recreate the function with precise window handling\n  CREATE OR REPLACE FUNCTION public.assign_tables_atomic_v2(\n    p_booking_id uuid,\n    p_table_ids uuid[],\n    p_idempotency_key text DEFAULT NULL,\n    p_require_adjacency boolean DEFAULT false,\n    p_assigned_by uuid DEFAULT NULL,\n    p_start_at timestamptz DEFAULT NULL,\n    p_end_at timestamptz DEFAULT NULL\n  ) RETURNS TABLE (\n    table_id uuid,\n    start_at timestamptz,\n    end_at timestamptz,\n    merge_group_id uuid\n  )\n  LANGUAGE plpgsql\n  SECURITY DEFINER\n  SET search_path = public\n  AS $function$\n  DECLARE\n    v_booking RECORD;\n    v_zone_id uuid;\n    v_restaurant_id uuid;\n    v_service_date date;\n    v_lock_zone int4;\n    v_lock_date int4;\n    v_now timestamptz := timezone('utc', now());\n    v_table_ids uuid[];\n    v_table_count integer;\n    v_table RECORD;\n    v_loaded_count integer := 0;\n    v_slot_id uuid := NULL;\n    v_start_at timestamptz;\n    v_end_at timestamptz;\n    v_window tstzrange;\n    v_timezone text := NULL;\n    v_hold_conflict uuid;\n    v_merge_allocation_id uuid := NULL;\n    v_table_assignment_id uuid;\n    v_existing RECORD;\n    v_adjacency_count integer;\n    v_table_id uuid;\n    v_merge_group_supported boolean := false;\n    v_conflict RECORD;\n  BEGIN\n    IF p_table_ids IS NULL OR array_length(p_table_ids, 1) = 0 THEN\n      RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one table id'\n        USING ERRCODE = '23514';\n    END IF;\n\n    SELECT array_agg(DISTINCT t.table_id ORDER BY t.table_id)\n    INTO v_table_ids\n    FROM unnest(p_table_ids) AS t(table_id);\n\n    IF v_table_ids IS NULL OR array_length(v_table_ids, 1) = 0 THEN\n      RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one valid table id'\n        USING ERRCODE = '23514';\n    END IF;\n\n    v_table_count := array_length(v_table_ids, 1);\n\n    SELECT\n      b.*,\n      r.timezone AS restaurant_timezone\n    INTO v_booking\n    FROM public.bookings b\n    LEFT JOIN public.restaurants r ON r.id = b.restaurant_id\n    WHERE b.id = p_booking_id\n    FOR UPDATE OF b;\n\n    IF NOT FOUND THEN\n      RAISE EXCEPTION 'Booking % not found', p_booking_id\n        USING ERRCODE = 'P0002';\n    END IF;\n\n    v_restaurant_id := v_booking.restaurant_id;\n    v_timezone := COALESCE(NULLIF(v_booking.restaurant_timezone, ''), 'UTC');\n\n    SELECT EXISTS (\n      SELECT 1\n      FROM information_schema.columns\n      WHERE table_schema = 'public'\n        AND table_name = 'booking_table_assignments'\n        AND column_name = 'merge_group_id'\n    )\n    INTO v_merge_group_supported;\n\n    IF (p_start_at IS NULL) <> (p_end_at IS NULL) THEN\n      RAISE EXCEPTION 'assign_tables_atomic_v2 requires both start and end when providing custom window'\n        USING ERRCODE = '22023';\n    END IF;\n\n    IF p_start_at IS NOT NULL AND p_end_at IS NOT NULL THEN\n      v_start_at := p_start_at;\n      v_end_at := p_end_at;\n    ELSIF v_booking.start_at IS NOT NULL AND v_booking.end_at IS NOT NULL THEN\n      v_start_at := v_booking.start_at;\n      v_end_at := v_booking.end_at;\n    ELSIF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL AND v_booking.end_time IS NOT NULL THEN\n      v_start_at := make_timestamptz(\n        EXTRACT(YEAR FROM v_booking.booking_date)::int,\n        EXTRACT(MONTH FROM v_booking.booking_date)::int,\n        EXTRACT(DAY FROM v_booking.booking_date)::int,\n        EXTRACT(HOUR FROM v_booking.start_time)::int,\n        EXTRACT(MINUTE FROM v_booking.start_time)::int,\n        EXTRACT(SECOND FROM v_booking.start_time),\n        v_timezone\n      );\n      v_end_at := make_timestamptz(\n        EXTRACT(YEAR FROM v_booking.booking_date)::int,\n        EXTRACT(MONTH FROM v_booking.booking_date)::int,\n        EXTRACT(DAY FROM v_booking.booking_date)::int,\n        EXTRACT(HOUR FROM v_booking.end_time)::int,\n        EXTRACT(MINUTE FROM v_booking.end_time)::int,\n        EXTRACT(SECOND FROM v_booking.end_time),\n        v_timezone\n      );\n    ELSE\n      RAISE EXCEPTION 'Booking % missing start/end window', p_booking_id\n        USING ERRCODE = '22000';\n    END IF;\n\n    IF v_start_at >= v_end_at THEN\n      RAISE EXCEPTION 'Booking % has invalid time window', p_booking_id\n        USING ERRCODE = '22000';\n    END IF;\n\n    v_window := tstzrange(v_start_at, v_end_at, '[)');\n\n    FOR v_table IN\n      SELECT id, restaurant_id, zone_id, active, status, mobility\n      FROM public.table_inventory\n      WHERE id = ANY (v_table_ids)\n      ORDER BY id\n      FOR UPDATE\n    LOOP\n      IF v_table.restaurant_id <> v_restaurant_id THEN\n        RAISE EXCEPTION 'Table % belongs to a different restaurant', v_table.id\n          USING ERRCODE = '23503';\n      END IF;\n\n      IF v_table.zone_id IS NULL THEN\n        RAISE EXCEPTION 'Table % is not assigned to a zone', v_table.id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_table.active IS NOT TRUE THEN\n        RAISE EXCEPTION 'Table % is inactive', v_table.id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_zone_id IS NULL THEN\n        v_zone_id := v_table.zone_id;\n      ELSIF v_zone_id <> v_table.zone_id THEN\n        RAISE EXCEPTION 'All tables must belong to the same zone (found %, expected %)', v_table.zone_id, v_zone_id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_table_count > 1 AND v_table.mobility <> 'movable'::public.table_mobility THEN\n        RAISE EXCEPTION 'Merged assignments require movable tables (% is %)', v_table.id, v_table.mobility\n          USING ERRCODE = '23514';\n      END IF;\n\n      v_loaded_count := v_loaded_count + 1;\n    END LOOP;\n\n    IF v_loaded_count <> v_table_count THEN\n      RAISE EXCEPTION 'Unable to load all requested tables for booking %', p_booking_id\n        USING ERRCODE = 'P0002';\n    END IF;\n\n    IF p_require_adjacency AND v_table_count > 1 THEN\n      FOR v_table IN\n        SELECT id FROM unnest(v_table_ids) AS t(id)\n      LOOP\n        SELECT COUNT(*)\n        INTO v_adjacency_count\n        FROM public.table_adjacencies\n        WHERE table_a = v_table.id\n          AND table_b = ANY (v_table_ids)\n          AND table_b <> v_table.id;\n\n        IF COALESCE(v_adjacency_count, 0) = 0 THEN\n          RAISE EXCEPTION 'Table % is not adjacent to the selected set', v_table.id\n            USING ERRCODE = '23514';\n        END IF;\n      END LOOP;\n    END IF;\n\n    v_service_date := (v_start_at AT TIME ZONE v_timezone)::date;\n\n    v_lock_zone := hashtext(COALESCE(v_zone_id::text, ''));\n    v_lock_date := COALESCE((v_service_date - DATE '2000-01-01')::int, 0);\n    PERFORM pg_advisory_xact_lock(v_lock_zone, v_lock_date);\n\n    IF p_idempotency_key IS NOT NULL THEN\n      SELECT *\n      INTO v_existing\n      FROM public.booking_assignment_idempotency\n      WHERE booking_id = p_booking_id\n        AND idempotency_key = p_idempotency_key;\n\n      IF FOUND THEN\n        IF v_existing.table_ids IS NULL OR array_length(v_existing.table_ids, 1) <> v_table_count\n           OR (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_existing.table_ids) AS e(elem))\n              <> (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_table_ids) AS e(elem)) THEN\n          RAISE EXCEPTION 'assign_tables_atomic_v2 idempotency mismatch for booking %', p_booking_id\n            USING ERRCODE = 'P0003',\n                  DETAIL = 'Idempotency key reuse detected with a different table set';\n        END IF;\n\n        RETURN QUERY\n          SELECT\n            bta.table_id,\n            COALESCE(bta.start_at, lower(v_existing.assignment_window)) AS start_at,\n            COALESCE(bta.end_at, upper(v_existing.assignment_window)) AS end_at,\n            v_existing.merge_group_allocation_id\n          FROM public.booking_table_assignments bta\n          WHERE bta.booking_id = p_booking_id\n            AND bta.idempotency_key = p_idempotency_key\n            AND bta.table_id = ANY (v_table_ids)\n          ORDER BY bta.table_id;\n\n        RETURN;\n      END IF;\n    END IF;\n\n    SELECT th.id\n    INTO v_hold_conflict\n    FROM public.table_holds th\n    JOIN public.table_hold_members thm ON thm.hold_id = th.id\n    WHERE thm.table_id = ANY (v_table_ids)\n      AND th.expires_at > v_now\n      AND (th.booking_id IS NULL OR th.booking_id <> p_booking_id)\n      AND tstzrange(th.start_at, th.end_at, '[)') && v_window\n    LIMIT 1;\n\n    IF FOUND THEN\n      RAISE EXCEPTION 'Hold conflict prevents assignment for booking %', p_booking_id\n        USING ERRCODE = 'P0001',\n              DETAIL = format('Hold % overlaps requested window', v_hold_conflict),\n              HINT = 'Retry after hold expiration or confirm existing hold.';\n    END IF;\n\n    IF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL THEN\n      SELECT id\n      INTO v_slot_id\n      FROM public.booking_slots\n      WHERE restaurant_id = v_restaurant_id\n        AND slot_date = v_booking.booking_date\n        AND slot_time = v_booking.start_time\n      LIMIT 1;\n\n      IF v_slot_id IS NULL THEN\n        SELECT public.get_or_create_booking_slot(v_restaurant_id, v_booking.booking_date, v_booking.start_time, 999)\n        INTO v_slot_id;\n      END IF;\n    END IF;\n\n    IF v_merge_group_supported AND v_table_count > 1 THEN\n      v_merge_allocation_id := gen_random_uuid();\n\n      BEGIN\n        INSERT INTO public.allocations (\n          id,\n          booking_id,\n          restaurant_id,\n          resource_type,\n          resource_id,\n          \"window\",\n          created_by,\n          shadow,\n          created_at,\n          updated_at\n        ) VALUES (\n          v_merge_allocation_id,\n          p_booking_id,\n          v_restaurant_id,\n          'merge_group',\n          v_merge_allocation_id,\n          v_window,\n          p_assigned_by,\n          false,\n          v_now,\n          v_now\n        )\n        ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n        SET \"window\" = EXCLUDED.\"window\",\n            created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n            updated_at = v_now;\n      EXCEPTION\n        WHEN unique_violation OR exclusion_violation THEN\n          RAISE EXCEPTION 'allocations_no_overlap'\n            USING ERRCODE = 'P0001',\n                  DETAIL = format('Merge group overlaps requested window for booking %s', p_booking_id);\n      END;\n    END IF;\n\n    FOREACH v_table_id IN ARRAY v_table_ids LOOP\n      SELECT\n        existing.booking_id,\n        existing.start_at,\n        existing.end_at\n      INTO v_conflict\n      FROM public.booking_table_assignments existing\n      WHERE existing.table_id = v_table_id\n        AND existing.booking_id <> p_booking_id\n        AND existing.start_at IS NOT NULL\n        AND existing.end_at IS NOT NULL\n        AND tstzrange(existing.start_at, existing.end_at, '[)') && v_window\n      LIMIT 1;\n\n      IF FOUND THEN\n        RAISE EXCEPTION 'assign_tables_atomic_v2 assignment overlap for table %', v_table_id\n          USING ERRCODE = 'P0001',\n                DETAIL = format('Existing booking %s occupies %s from %s to %s', v_conflict.booking_id, v_table_id, v_conflict.start_at, v_conflict.end_at),\n                HINT = 'Adjust assignment window or release the conflicting table.';\n      END IF;\n\n      v_conflict := NULL;\n\n      IF v_merge_group_supported THEN\n        BEGIN\n          INSERT INTO public.booking_table_assignments (\n            booking_id,\n            table_id,\n            slot_id,\n            assigned_by,\n            idempotency_key,\n            merge_group_id,\n            start_at,\n            end_at\n          ) VALUES (\n            p_booking_id,\n            v_table_id,\n            v_slot_id,\n            p_assigned_by,\n            p_idempotency_key,\n            v_merge_allocation_id,\n            v_start_at,\n            v_end_at\n          )\n          ON CONFLICT ON CONSTRAINT booking_table_assignments_booking_table_key DO UPDATE\n          SET assigned_at = v_now,\n              assigned_by = COALESCE(EXCLUDED.assigned_by, public.booking_table_assignments.assigned_by),\n              idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n              merge_group_id = COALESCE(EXCLUDED.merge_group_id, public.booking_table_assignments.merge_group_id),\n              slot_id = COALESCE(EXCLUDED.slot_id, public.booking_table_assignments.slot_id),\n              start_at = EXCLUDED.start_at,\n              end_at = EXCLUDED.end_at,\n              updated_at = v_now\n          RETURNING id INTO v_table_assignment_id;\n        EXCEPTION\n          WHEN unique_violation THEN\n            RAISE EXCEPTION 'assign_tables_atomic_v2 assignment duplicate for table %', v_table_id\n              USING ERRCODE = 'P0001';\n        END;\n      ELSE\n        BEGIN\n          INSERT INTO public.booking_table_assignments (\n            booking_id,\n            table_id,\n            slot_id,\n            assigned_by,\n            idempotency_key,\n            start_at,\n            end_at\n          ) VALUES (\n            p_booking_id,\n            v_table_id,\n            v_slot_id,\n            p_assigned_by,\n            p_idempotency_key,\n            v_start_at,\n            v_end_at\n          )\n          ON CONFLICT ON CONSTRAINT booking_table_assignments_booking_table_key DO UPDATE\n          SET assigned_at = v_now,\n              assigned_by = COALESCE(EXCLUDED.assigned_by, public.booking_table_assignments.assigned_by),\n              idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n              slot_id = COALESCE(EXCLUDED.slot_id, public.booking_table_assignments.slot_id),\n              start_at = EXCLUDED.start_at,\n              end_at = EXCLUDED.end_at,\n              updated_at = v_now\n          RETURNING id INTO v_table_assignment_id;\n        EXCEPTION\n          WHEN unique_violation THEN\n            RAISE EXCEPTION 'assign_tables_atomic_v2 assignment duplicate for table %', v_table_id\n              USING ERRCODE = 'P0001';\n        END;\n      END IF;\n\n      BEGIN\n        INSERT INTO public.allocations (\n          booking_id,\n          restaurant_id,\n          resource_type,\n          resource_id,\n          \"window\",\n          created_by,\n          shadow,\n          created_at,\n          updated_at\n        ) VALUES (\n          p_booking_id,\n          v_restaurant_id,\n          'table',\n          v_table_id,\n          v_window,\n          p_assigned_by,\n          false,\n          v_now,\n          v_now\n        )\n        ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n        SET \"window\" = EXCLUDED.\"window\",\n            created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n            updated_at = v_now;\n      EXCEPTION\n        WHEN unique_violation OR exclusion_violation THEN\n          RAISE EXCEPTION 'allocations_no_overlap'\n            USING ERRCODE = 'P0001',\n                  DETAIL = format('Resource %s overlaps requested window for booking %s', v_table_id, p_booking_id);\n      END;\n\n      PERFORM public.refresh_table_status(v_table_id);\n\n      table_id := v_table_id;\n      start_at := v_start_at;\n      end_at := v_end_at;\n      merge_group_id := CASE WHEN v_merge_group_supported THEN v_merge_allocation_id ELSE NULL END;\n      RETURN NEXT;\n    END LOOP;\n\n    IF p_idempotency_key IS NOT NULL THEN\n      INSERT INTO public.booking_assignment_idempotency (\n        booking_id,\n        idempotency_key,\n        table_ids,\n        assignment_window,\n        merge_group_allocation_id,\n        created_at\n      ) VALUES (\n        p_booking_id,\n        p_idempotency_key,\n        v_table_ids,\n        v_window,\n        v_merge_allocation_id,\n        v_now\n      )\n      ON CONFLICT (booking_id, idempotency_key) DO NOTHING;\n    END IF;\n  END;\n  $function$;\n\n  ALTER FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid, timestamptz, timestamptz) OWNER TO postgres;\n  GRANT ALL ON FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid, timestamptz, timestamptz) TO service_role;\n\nEND;\n$$;\n"
    },
    {
      "path": "supabase/migrations/20251027211000_assign_tables_atomic_v2_undirected.sql",
      "content": "-- Ensure table assignments use precise time windows and treat adjacency edges as undirected.\nCREATE EXTENSION IF NOT EXISTS btree_gist;\n\nALTER TABLE public.booking_table_assignments\n  ADD COLUMN IF NOT EXISTS start_at timestamptz,\n  ADD COLUMN IF NOT EXISTS end_at timestamptz;\n\nALTER TABLE public.booking_table_assignments\n  DROP CONSTRAINT IF EXISTS no_overlapping_table_assignments;\n\nALTER TABLE public.booking_table_assignments\n  ADD CONSTRAINT no_overlapping_table_assignments\n  EXCLUDE USING gist (\n    table_id WITH =,\n    tstzrange(start_at, end_at, '[)') WITH &&\n  )\n  WHERE (start_at IS NOT NULL AND end_at IS NOT NULL);\n\n-- Recreate assign_tables_atomic_v2 with precise window handling.\nDO $$\nBEGIN\n  -- Drop and recreate the function with precise window handling\n  CREATE OR REPLACE FUNCTION public.assign_tables_atomic_v2(\n    p_booking_id uuid,\n    p_table_ids uuid[],\n    p_idempotency_key text DEFAULT NULL,\n    p_require_adjacency boolean DEFAULT false,\n    p_assigned_by uuid DEFAULT NULL,\n    p_start_at timestamptz DEFAULT NULL,\n    p_end_at timestamptz DEFAULT NULL\n  ) RETURNS TABLE (\n    table_id uuid,\n    start_at timestamptz,\n    end_at timestamptz,\n    merge_group_id uuid\n  )\n  LANGUAGE plpgsql\n  SECURITY DEFINER\n  SET search_path = public\n  AS $function$\n  DECLARE\n    v_booking RECORD;\n    v_zone_id uuid;\n    v_restaurant_id uuid;\n    v_service_date date;\n    v_lock_zone int4;\n    v_lock_date int4;\n    v_now timestamptz := timezone('utc', now());\n    v_table_ids uuid[];\n    v_table_count integer;\n    v_table RECORD;\n    v_loaded_count integer := 0;\n    v_slot_id uuid := NULL;\n    v_start_at timestamptz;\n    v_end_at timestamptz;\n    v_window tstzrange;\n    v_timezone text := NULL;\n    v_hold_conflict uuid;\n    v_merge_allocation_id uuid := NULL;\n    v_table_assignment_id uuid;\n    v_existing RECORD;\n    v_adjacency_count integer;\n    v_table_id uuid;\n    v_merge_group_supported boolean := false;\n    v_conflict RECORD;\n  BEGIN\n    IF p_table_ids IS NULL OR array_length(p_table_ids, 1) = 0 THEN\n      RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one table id'\n        USING ERRCODE = '23514';\n    END IF;\n\n    SELECT array_agg(DISTINCT t.table_id ORDER BY t.table_id)\n    INTO v_table_ids\n    FROM unnest(p_table_ids) AS t(table_id);\n\n    IF v_table_ids IS NULL OR array_length(v_table_ids, 1) = 0 THEN\n      RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one valid table id'\n        USING ERRCODE = '23514';\n    END IF;\n\n    v_table_count := array_length(v_table_ids, 1);\n\n    SELECT\n      b.*,\n      r.timezone AS restaurant_timezone\n    INTO v_booking\n    FROM public.bookings b\n    LEFT JOIN public.restaurants r ON r.id = b.restaurant_id\n    WHERE b.id = p_booking_id\n    FOR UPDATE OF b;\n\n    IF NOT FOUND THEN\n      RAISE EXCEPTION 'Booking % not found', p_booking_id\n        USING ERRCODE = 'P0002';\n    END IF;\n\n    v_restaurant_id := v_booking.restaurant_id;\n    v_timezone := COALESCE(NULLIF(v_booking.restaurant_timezone, ''), 'UTC');\n\n    SELECT EXISTS (\n      SELECT 1\n      FROM information_schema.columns\n      WHERE table_schema = 'public'\n        AND table_name = 'booking_table_assignments'\n        AND column_name = 'merge_group_id'\n    )\n    INTO v_merge_group_supported;\n\n    IF (p_start_at IS NULL) <> (p_end_at IS NULL) THEN\n      RAISE EXCEPTION 'assign_tables_atomic_v2 requires both start and end when providing custom window'\n        USING ERRCODE = '22023';\n    END IF;\n\n    IF p_start_at IS NOT NULL AND p_end_at IS NOT NULL THEN\n      v_start_at := p_start_at;\n      v_end_at := p_end_at;\n    ELSIF v_booking.start_at IS NOT NULL AND v_booking.end_at IS NOT NULL THEN\n      v_start_at := v_booking.start_at;\n      v_end_at := v_booking.end_at;\n    ELSIF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL AND v_booking.end_time IS NOT NULL THEN\n      v_start_at := make_timestamptz(\n        EXTRACT(YEAR FROM v_booking.booking_date)::int,\n        EXTRACT(MONTH FROM v_booking.booking_date)::int,\n        EXTRACT(DAY FROM v_booking.booking_date)::int,\n        EXTRACT(HOUR FROM v_booking.start_time)::int,\n        EXTRACT(MINUTE FROM v_booking.start_time)::int,\n        EXTRACT(SECOND FROM v_booking.start_time),\n        v_timezone\n      );\n      v_end_at := make_timestamptz(\n        EXTRACT(YEAR FROM v_booking.booking_date)::int,\n        EXTRACT(MONTH FROM v_booking.booking_date)::int,\n        EXTRACT(DAY FROM v_booking.booking_date)::int,\n        EXTRACT(HOUR FROM v_booking.end_time)::int,\n        EXTRACT(MINUTE FROM v_booking.end_time)::int,\n        EXTRACT(SECOND FROM v_booking.end_time),\n        v_timezone\n      );\n    ELSE\n      RAISE EXCEPTION 'Booking % missing start/end window', p_booking_id\n        USING ERRCODE = '22000';\n    END IF;\n\n    IF v_start_at >= v_end_at THEN\n      RAISE EXCEPTION 'Booking % has invalid time window', p_booking_id\n        USING ERRCODE = '22000';\n    END IF;\n\n    v_window := tstzrange(v_start_at, v_end_at, '[)');\n\n    FOR v_table IN\n      SELECT id, restaurant_id, zone_id, active, status, mobility\n      FROM public.table_inventory\n      WHERE id = ANY (v_table_ids)\n      ORDER BY id\n      FOR UPDATE\n    LOOP\n      IF v_table.restaurant_id <> v_restaurant_id THEN\n        RAISE EXCEPTION 'Table % belongs to a different restaurant', v_table.id\n          USING ERRCODE = '23503';\n      END IF;\n\n      IF v_table.zone_id IS NULL THEN\n        RAISE EXCEPTION 'Table % is not assigned to a zone', v_table.id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_table.active IS NOT TRUE THEN\n        RAISE EXCEPTION 'Table % is inactive', v_table.id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_zone_id IS NULL THEN\n        v_zone_id := v_table.zone_id;\n      ELSIF v_zone_id <> v_table.zone_id THEN\n        RAISE EXCEPTION 'All tables must belong to the same zone (found %, expected %)', v_table.zone_id, v_zone_id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_table_count > 1 AND v_table.mobility <> 'movable'::public.table_mobility THEN\n        RAISE EXCEPTION 'Merged assignments require movable tables (% is %)', v_table.id, v_table.mobility\n          USING ERRCODE = '23514';\n      END IF;\n\n      v_loaded_count := v_loaded_count + 1;\n    END LOOP;\n\n    IF v_loaded_count <> v_table_count THEN\n      RAISE EXCEPTION 'Unable to load all requested tables for booking %', p_booking_id\n        USING ERRCODE = 'P0002';\n    END IF;\n\n    IF p_require_adjacency AND v_table_count > 1 THEN\n      FOR v_table IN\n        SELECT id FROM unnest(v_table_ids) AS t(id)\n      LOOP\n        SELECT COUNT(*)\n        INTO v_adjacency_count\n        FROM public.table_adjacencies\n        WHERE (\n            table_a = v_table.id\n            AND table_b = ANY (v_table_ids)\n            AND table_b <> v_table.id\n          )\n          OR (\n            table_b = v_table.id\n            AND table_a = ANY (v_table_ids)\n            AND table_a <> v_table.id\n          );\n\n        IF COALESCE(v_adjacency_count, 0) = 0 THEN\n          RAISE EXCEPTION 'Table % is not adjacent to the selected set', v_table.id\n            USING ERRCODE = '23514';\n        END IF;\n      END LOOP;\n    END IF;\n\n    v_service_date := (v_start_at AT TIME ZONE v_timezone)::date;\n\n    v_lock_zone := hashtext(COALESCE(v_zone_id::text, ''));\n    v_lock_date := COALESCE((v_service_date - DATE '2000-01-01')::int, 0);\n    PERFORM pg_advisory_xact_lock(v_lock_zone, v_lock_date);\n\n    IF p_idempotency_key IS NOT NULL THEN\n      SELECT *\n      INTO v_existing\n      FROM public.booking_assignment_idempotency\n      WHERE booking_id = p_booking_id\n        AND idempotency_key = p_idempotency_key;\n\n      IF FOUND THEN\n        IF v_existing.table_ids IS NULL OR array_length(v_existing.table_ids, 1) <> v_table_count\n           OR (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_existing.table_ids) AS e(elem))\n              <> (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_table_ids) AS e(elem)) THEN\n          RAISE EXCEPTION 'assign_tables_atomic_v2 idempotency mismatch for booking %', p_booking_id\n            USING ERRCODE = 'P0003',\n                  DETAIL = 'Idempotency key reuse detected with a different table set';\n        END IF;\n\n        RETURN QUERY\n          SELECT\n            bta.table_id,\n            COALESCE(bta.start_at, lower(v_existing.assignment_window)) AS start_at,\n            COALESCE(bta.end_at, upper(v_existing.assignment_window)) AS end_at,\n            v_existing.merge_group_allocation_id\n          FROM public.booking_table_assignments bta\n          WHERE bta.booking_id = p_booking_id\n            AND bta.idempotency_key = p_idempotency_key\n            AND bta.table_id = ANY (v_table_ids)\n          ORDER BY bta.table_id;\n\n        RETURN;\n      END IF;\n    END IF;\n\n    SELECT th.id\n    INTO v_hold_conflict\n    FROM public.table_holds th\n    JOIN public.table_hold_members thm ON thm.hold_id = th.id\n    WHERE thm.table_id = ANY (v_table_ids)\n      AND th.expires_at > v_now\n      AND (th.booking_id IS NULL OR th.booking_id <> p_booking_id)\n      AND tstzrange(th.start_at, th.end_at, '[)') && v_window\n    LIMIT 1;\n\n    IF FOUND THEN\n      RAISE EXCEPTION 'Hold conflict prevents assignment for booking %', p_booking_id\n        USING ERRCODE = 'P0001',\n              DETAIL = format('Hold % overlaps requested window', v_hold_conflict),\n              HINT = 'Retry after hold expiration or confirm existing hold.';\n    END IF;\n\n    IF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL THEN\n      SELECT id\n      INTO v_slot_id\n      FROM public.booking_slots\n      WHERE restaurant_id = v_restaurant_id\n        AND slot_date = v_booking.booking_date\n        AND slot_time = v_booking.start_time\n      LIMIT 1;\n\n      IF v_slot_id IS NULL THEN\n        SELECT public.get_or_create_booking_slot(v_restaurant_id, v_booking.booking_date, v_booking.start_time, 999)\n        INTO v_slot_id;\n      END IF;\n    END IF;\n\n    IF v_merge_group_supported AND v_table_count > 1 THEN\n      v_merge_allocation_id := gen_random_uuid();\n\n      BEGIN\n        INSERT INTO public.allocations (\n          id,\n          booking_id,\n          restaurant_id,\n          resource_type,\n          resource_id,\n          \"window\",\n          created_by,\n          shadow,\n          created_at,\n          updated_at\n        ) VALUES (\n          v_merge_allocation_id,\n          p_booking_id,\n          v_restaurant_id,\n          'merge_group',\n          v_merge_allocation_id,\n          v_window,\n          p_assigned_by,\n          false,\n          v_now,\n          v_now\n        )\n        ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n        SET \"window\" = EXCLUDED.\"window\",\n            created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n            updated_at = v_now;\n      EXCEPTION\n        WHEN unique_violation OR exclusion_violation THEN\n          RAISE EXCEPTION 'allocations_no_overlap'\n            USING ERRCODE = 'P0001',\n                  DETAIL = format('Merge group overlaps requested window for booking %s', p_booking_id);\n      END;\n    END IF;\n\n    FOREACH v_table_id IN ARRAY v_table_ids LOOP\n      SELECT\n        existing.booking_id,\n        existing.start_at,\n        existing.end_at\n      INTO v_conflict\n      FROM public.booking_table_assignments existing\n      WHERE existing.table_id = v_table_id\n        AND existing.booking_id <> p_booking_id\n        AND existing.start_at IS NOT NULL\n        AND existing.end_at IS NOT NULL\n        AND tstzrange(existing.start_at, existing.end_at, '[)') && v_window\n      LIMIT 1;\n\n      IF FOUND THEN\n        RAISE EXCEPTION 'assign_tables_atomic_v2 assignment overlap for table %', v_table_id\n          USING ERRCODE = 'P0001',\n                DETAIL = format('Existing booking %s occupies %s from %s to %s', v_conflict.booking_id, v_table_id, v_conflict.start_at, v_conflict.end_at),\n                HINT = 'Adjust assignment window or release the conflicting table.';\n      END IF;\n\n      v_conflict := NULL;\n\n      IF v_merge_group_supported THEN\n        BEGIN\n          INSERT INTO public.booking_table_assignments (\n            booking_id,\n            table_id,\n            slot_id,\n            assigned_by,\n            idempotency_key,\n            merge_group_id,\n            start_at,\n            end_at\n          ) VALUES (\n            p_booking_id,\n            v_table_id,\n            v_slot_id,\n            p_assigned_by,\n            p_idempotency_key,\n            v_merge_allocation_id,\n            v_start_at,\n            v_end_at\n          )\n        ON CONFLICT ON CONSTRAINT booking_table_assignments_booking_table_key DO UPDATE\n          SET assigned_at = v_now,\n              assigned_by = COALESCE(EXCLUDED.assigned_by, public.booking_table_assignments.assigned_by),\n              idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n              merge_group_id = COALESCE(EXCLUDED.merge_group_id, public.booking_table_assignments.merge_group_id),\n              slot_id = COALESCE(EXCLUDED.slot_id, public.booking_table_assignments.slot_id),\n              start_at = EXCLUDED.start_at,\n              end_at = EXCLUDED.end_at,\n              updated_at = v_now\n          RETURNING id INTO v_table_assignment_id;\n        EXCEPTION\n          WHEN unique_violation THEN\n            UPDATE public.booking_table_assignments AS bta\n              SET assigned_at = v_now,\n                  assigned_by = COALESCE(p_assigned_by, bta.assigned_by),\n                  idempotency_key = COALESCE(p_idempotency_key, bta.idempotency_key),\n                  merge_group_id = COALESCE(v_merge_allocation_id, bta.merge_group_id),\n                  slot_id = COALESCE(v_slot_id, bta.slot_id),\n                  start_at = v_start_at,\n                  end_at = v_end_at,\n                  updated_at = v_now\n            WHERE bta.booking_id = p_booking_id\n              AND bta.table_id = v_table_id\n            RETURNING bta.id INTO v_table_assignment_id;\n\n            IF NOT FOUND THEN\n              RAISE EXCEPTION 'assign_tables_atomic_v2 assignment duplicate for table %', v_table_id\n                USING ERRCODE = 'P0001';\n            END IF;\n        END;\n      ELSE\n        BEGIN\n          INSERT INTO public.booking_table_assignments (\n            booking_id,\n            table_id,\n            slot_id,\n            assigned_by,\n            idempotency_key,\n            start_at,\n            end_at\n          ) VALUES (\n            p_booking_id,\n            v_table_id,\n            v_slot_id,\n            p_assigned_by,\n            p_idempotency_key,\n            v_start_at,\n            v_end_at\n          )\n          ON CONFLICT ON CONSTRAINT booking_table_assignments_booking_table_key DO UPDATE\n          SET assigned_at = v_now,\n              assigned_by = COALESCE(EXCLUDED.assigned_by, public.booking_table_assignments.assigned_by),\n              idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n              slot_id = COALESCE(EXCLUDED.slot_id, public.booking_table_assignments.slot_id),\n              start_at = EXCLUDED.start_at,\n              end_at = EXCLUDED.end_at,\n              updated_at = v_now\n          RETURNING id INTO v_table_assignment_id;\n        EXCEPTION\n          WHEN unique_violation THEN\n            UPDATE public.booking_table_assignments AS bta\n              SET assigned_at = v_now,\n                  assigned_by = COALESCE(p_assigned_by, bta.assigned_by),\n                  idempotency_key = COALESCE(p_idempotency_key, bta.idempotency_key),\n                  slot_id = COALESCE(v_slot_id, bta.slot_id),\n                  start_at = v_start_at,\n                  end_at = v_end_at,\n                  updated_at = v_now\n            WHERE bta.booking_id = p_booking_id\n              AND bta.table_id = v_table_id\n            RETURNING bta.id INTO v_table_assignment_id;\n\n            IF NOT FOUND THEN\n              RAISE EXCEPTION 'assign_tables_atomic_v2 assignment duplicate for table %', v_table_id\n                USING ERRCODE = 'P0001';\n            END IF;\n        END;\n      END IF;\n\n      BEGIN\n        INSERT INTO public.allocations (\n          booking_id,\n          restaurant_id,\n          resource_type,\n          resource_id,\n          \"window\",\n          created_by,\n          shadow,\n          created_at,\n          updated_at\n        ) VALUES (\n          p_booking_id,\n          v_restaurant_id,\n          'table',\n          v_table_id,\n          v_window,\n          p_assigned_by,\n          false,\n          v_now,\n          v_now\n        )\n        ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n        SET \"window\" = EXCLUDED.\"window\",\n            created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n            updated_at = v_now;\n      EXCEPTION\n        WHEN unique_violation OR exclusion_violation THEN\n          RAISE EXCEPTION 'allocations_no_overlap'\n            USING ERRCODE = 'P0001',\n                  DETAIL = format('Resource %s overlaps requested window for booking %s', v_table_id, p_booking_id);\n      END;\n\n      PERFORM public.refresh_table_status(v_table_id);\n\n      table_id := v_table_id;\n      start_at := v_start_at;\n      end_at := v_end_at;\n      merge_group_id := CASE WHEN v_merge_group_supported THEN v_merge_allocation_id ELSE NULL END;\n      RETURN NEXT;\n    END LOOP;\n\n    IF p_idempotency_key IS NOT NULL THEN\n      INSERT INTO public.booking_assignment_idempotency (\n        booking_id,\n        idempotency_key,\n        table_ids,\n        assignment_window,\n        merge_group_allocation_id,\n        created_at\n      ) VALUES (\n        p_booking_id,\n        p_idempotency_key,\n        v_table_ids,\n        v_window,\n        v_merge_allocation_id,\n        v_now\n      )\n      ON CONFLICT (booking_id, idempotency_key) DO NOTHING;\n    END IF;\n  END;\n  $function$;\n\n  ALTER FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid, timestamptz, timestamptz) OWNER TO postgres;\n  GRANT ALL ON FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid, timestamptz, timestamptz) TO service_role;\n\nEND;\n$$;\n"
    },
    {
      "path": "supabase/migrations/20251021094504_recreate_assign_tables_atomic.sql",
      "content": "DO $migration$\nBEGIN\n  EXECUTE $create$\n    CREATE FUNCTION public.assign_tables_atomic(\n      p_booking_id uuid,\n      p_table_ids uuid[],\n      p_window tstzrange,\n      p_assigned_by uuid DEFAULT NULL,\n      p_idempotency_key text DEFAULT NULL\n    ) RETURNS TABLE(table_id uuid, assignment_id uuid)\n    LANGUAGE plpgsql\n    SECURITY DEFINER\n    AS $function$\n    DECLARE\n      v_booking RECORD;\n      v_restaurant_id uuid;\n      v_target_tables uuid[];\n      v_target_table uuid;\n      v_existing_tables uuid[];\n      v_table RECORD;\n      v_slot_id uuid := NULL;\n      v_now timestamptz := now();\n      v_window tstzrange := p_window;\n      v_assignment_id uuid;\n      v_lock_restaurant int4;\n      v_lock_date int4;\n    BEGIN\n      IF p_table_ids IS NULL OR array_length(p_table_ids, 1) = 0 THEN\n        RAISE EXCEPTION 'assign_tables_atomic requires at least one table id'\n          USING ERRCODE = '23514';\n      END IF;\n\n      SELECT array_agg(DISTINCT table_id ORDER BY table_id)\n      INTO v_target_tables\n      FROM unnest(p_table_ids) AS t(table_id);\n\n      IF v_target_tables IS NULL OR array_length(v_target_tables, 1) = 0 THEN\n        RAISE EXCEPTION 'assign_tables_atomic requires at least one valid table id'\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF array_length(v_target_tables, 1) > 1 THEN\n        RAISE EXCEPTION 'assign_tables_atomic only supports a single table after merge removal'\n          USING ERRCODE = '23514';\n      END IF;\n\n      v_target_table := v_target_tables[1];\n\n      SELECT *\n      INTO v_booking\n      FROM public.bookings\n      WHERE id = p_booking_id\n      FOR UPDATE;\n\n      IF NOT FOUND THEN\n        RAISE EXCEPTION 'Booking % not found', p_booking_id\n          USING ERRCODE = 'P0002';\n      END IF;\n\n      v_restaurant_id := v_booking.restaurant_id;\n\n      v_lock_restaurant := hashtext(v_restaurant_id::text);\n      v_lock_date := COALESCE((v_booking.booking_date - DATE '2000-01-01')::int, 0);\n      PERFORM pg_advisory_xact_lock(v_lock_restaurant, v_lock_date);\n\n      IF v_window IS NULL THEN\n        v_window := tstzrange(v_booking.start_at, v_booking.end_at, '[)');\n      END IF;\n\n      IF v_window IS NULL OR lower(v_window) IS NULL OR upper(v_window) IS NULL OR lower(v_window) >= upper(v_window) THEN\n        RAISE EXCEPTION 'Invalid assignment window for booking %', p_booking_id\n          USING ERRCODE = '22000';\n      END IF;\n\n      IF p_idempotency_key IS NOT NULL THEN\n        SELECT array_agg(bta.table_id ORDER BY bta.table_id)\n        INTO v_existing_tables\n        FROM public.booking_table_assignments bta\n        WHERE bta.booking_id = p_booking_id\n          AND bta.idempotency_key = p_idempotency_key;\n\n        IF v_existing_tables IS NOT NULL THEN\n          IF v_existing_tables <> v_target_tables THEN\n            RAISE EXCEPTION 'assign_tables_atomic idempotency key mismatch'\n              USING ERRCODE = 'P0003',\n                    DETAIL = 'Idempotency key reuse detected with a different table id';\n          END IF;\n\n          RETURN QUERY\n            SELECT\n              bta.table_id,\n              bta.id AS assignment_id\n            FROM public.booking_table_assignments bta\n            WHERE bta.booking_id = p_booking_id\n              AND bta.idempotency_key = p_idempotency_key;\n\n          RETURN;\n        END IF;\n      END IF;\n\n      SELECT id, restaurant_id\n      INTO v_table\n      FROM public.table_inventory\n      WHERE id = v_target_table\n      FOR UPDATE;\n\n      IF NOT FOUND THEN\n        RAISE EXCEPTION 'Table % not found', v_target_table\n          USING ERRCODE = 'P0002';\n      END IF;\n\n      IF v_table.restaurant_id <> v_restaurant_id THEN\n        RAISE EXCEPTION 'Table % belongs to a different restaurant', v_target_table\n          USING ERRCODE = '23503';\n      END IF;\n\n      IF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL THEN\n        SELECT id\n        INTO v_slot_id\n        FROM public.booking_slots\n        WHERE restaurant_id = v_restaurant_id\n          AND slot_date = v_booking.booking_date\n          AND slot_time = v_booking.start_time\n        LIMIT 1;\n\n        IF v_slot_id IS NULL THEN\n          SELECT public.get_or_create_booking_slot(v_restaurant_id, v_booking.booking_date, v_booking.start_time, 999)\n          INTO v_slot_id;\n        END IF;\n      END IF;\n\n      INSERT INTO public.booking_table_assignments (\n        booking_id,\n        table_id,\n        slot_id,\n        assigned_by,\n        idempotency_key\n      ) VALUES (\n        p_booking_id,\n        v_target_table,\n        v_slot_id,\n        p_assigned_by,\n        p_idempotency_key\n      )\n      ON CONFLICT (booking_id, table_id) DO UPDATE\n      SET assigned_by = EXCLUDED.assigned_by,\n          assigned_at = v_now,\n          idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key)\n      RETURNING id INTO v_assignment_id;\n\n      BEGIN\n        INSERT INTO public.allocations (\n          booking_id,\n          restaurant_id,\n          resource_type,\n          resource_id,\n          \"window\",\n          created_by,\n          shadow,\n          created_at,\n          updated_at\n        ) VALUES (\n          p_booking_id,\n          v_restaurant_id,\n          'table',\n          v_target_table,\n          v_window,\n          p_assigned_by,\n          false,\n          v_now,\n          v_now\n        )\n        ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n        SET \"window\" = EXCLUDED.\"window\",\n            created_by = EXCLUDED.created_by,\n            updated_at = v_now;\n      EXCEPTION\n        WHEN unique_violation OR exclusion_violation THEN\n          RAISE EXCEPTION 'allocations_no_overlap'\n            USING ERRCODE = 'P0001',\n                  DETAIL = format('Resource %s overlaps requested window for booking %s', v_target_table, p_booking_id);\n      END;\n\n      UPDATE public.table_inventory\n      SET status = 'reserved'::public.table_status\n      WHERE id = v_target_table;\n\n      table_id := v_target_table;\n      assignment_id := v_assignment_id;\n      RETURN NEXT;\n    END;\n    $function$\n  $create$;\n\n  EXECUTE $alter$\n    ALTER FUNCTION public.assign_tables_atomic(uuid, uuid[], tstzrange, uuid, text) OWNER TO postgres\n  $alter$;\n\n  EXECUTE $grant$\n    GRANT ALL ON FUNCTION public.assign_tables_atomic(uuid, uuid[], tstzrange, uuid, text) TO service_role\n  $grant$;\nEND;\n$migration$;\n"
    },
    {
      "path": "supabase/migrations/20251026105000_assign_tables_atomic_v2.sql",
      "content": "-- Introduce assign_tables_atomic_v2 with per-zone locking, idempotency ledger, and hold awareness.\nDO $migration$\nDECLARE\nBEGIN\n  -- Create idempotency ledger if absent.\n  IF NOT EXISTS (\n    SELECT 1\n    FROM information_schema.tables\n    WHERE table_schema = 'public'\n      AND table_name = 'booking_assignment_idempotency'\n  ) THEN\n    EXECUTE $create_ledger$\n      CREATE TABLE public.booking_assignment_idempotency (\n        booking_id uuid NOT NULL,\n        idempotency_key text NOT NULL,\n        table_ids uuid[] NOT NULL,\n        assignment_window tstzrange NOT NULL,\n        merge_group_allocation_id uuid,\n        created_at timestamptz NOT NULL DEFAULT timezone('utc'::text, now()),\n        PRIMARY KEY (booking_id, idempotency_key)\n      )\n    $create_ledger$;\n\n    EXECUTE $ledger_fk_booking$\n      ALTER TABLE public.booking_assignment_idempotency\n        ADD CONSTRAINT booking_assignment_idempotency_booking_id_fkey\n          FOREIGN KEY (booking_id)\n          REFERENCES public.bookings(id)\n          ON DELETE CASCADE\n    $ledger_fk_booking$;\n\n    EXECUTE $ledger_fk_merge$\n      ALTER TABLE public.booking_assignment_idempotency\n        ADD CONSTRAINT booking_assignment_idempotency_merge_group_fkey\n          FOREIGN KEY (merge_group_allocation_id)\n          REFERENCES public.allocations(id)\n          ON DELETE SET NULL\n    $ledger_fk_merge$;\n\n    CREATE INDEX IF NOT EXISTS booking_assignment_idempotency_created_idx\n      ON public.booking_assignment_idempotency (created_at DESC);\n  END IF;\n\n  -- Replace/define RPC v2.\n  EXECUTE $drop_old$\n    DROP FUNCTION IF EXISTS public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid)\n  $drop_old$;\n\n  EXECUTE $create_rpc$\n    CREATE FUNCTION public.assign_tables_atomic_v2(\n      p_booking_id uuid,\n      p_table_ids uuid[],\n      p_idempotency_key text DEFAULT NULL,\n      p_require_adjacency boolean DEFAULT false,\n      p_assigned_by uuid DEFAULT NULL\n    ) RETURNS TABLE (\n      table_id uuid,\n      start_at timestamptz,\n      end_at timestamptz,\n      merge_group_id uuid\n    )\n    LANGUAGE plpgsql\n    SECURITY DEFINER\n    SET search_path = public\n    AS $function$\n    DECLARE\n      v_booking RECORD;\n      v_zone_id uuid;\n      v_restaurant_id uuid;\n      v_service_date date;\n      v_lock_zone int4;\n      v_lock_date int4;\n      v_now timestamptz := timezone('utc', now());\n      v_table_ids uuid[];\n      v_table_count integer;\n      v_table RECORD;\n      v_loaded_count integer := 0;\n      v_slot_id uuid := NULL;\n      v_start_at timestamptz;\n      v_end_at timestamptz;\n      v_window tstzrange;\n      v_timezone text := NULL;\n      v_hold_conflict uuid;\n      v_merge_allocation_id uuid := NULL;\n      v_table_assignment_id uuid;\n      v_existing RECORD;\n      v_adjacency_count integer;\n      v_table_id uuid;\n    BEGIN\n      IF p_table_ids IS NULL OR array_length(p_table_ids, 1) = 0 THEN\n        RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one table id'\n          USING ERRCODE = '23514';\n      END IF;\n\n      SELECT array_agg(DISTINCT table_id ORDER BY table_id)\n      INTO v_table_ids\n      FROM unnest(p_table_ids) AS t(table_id);\n\n      IF v_table_ids IS NULL OR array_length(v_table_ids, 1) = 0 THEN\n        RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one valid table id'\n          USING ERRCODE = '23514';\n      END IF;\n\n      v_table_count := array_length(v_table_ids, 1);\n\n      SELECT\n        b.*,\n        r.timezone AS restaurant_timezone\n      INTO v_booking\n      FROM public.bookings b\n      LEFT JOIN public.restaurants r ON r.id = b.restaurant_id\n      WHERE b.id = p_booking_id\n      FOR UPDATE;\n\n      IF NOT FOUND THEN\n        RAISE EXCEPTION 'Booking % not found', p_booking_id\n          USING ERRCODE = 'P0002';\n      END IF;\n\n      v_restaurant_id := v_booking.restaurant_id;\n      v_timezone := COALESCE(NULLIF(v_booking.restaurant_timezone, ''), 'UTC');\n\n      IF v_booking.start_at IS NOT NULL AND v_booking.end_at IS NOT NULL THEN\n        v_start_at := v_booking.start_at;\n        v_end_at := v_booking.end_at;\n      ELSIF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL AND v_booking.end_time IS NOT NULL THEN\n        v_start_at := make_timestamptz(\n          EXTRACT(YEAR FROM v_booking.booking_date)::int,\n          EXTRACT(MONTH FROM v_booking.booking_date)::int,\n          EXTRACT(DAY FROM v_booking.booking_date)::int,\n          EXTRACT(HOUR FROM v_booking.start_time)::int,\n          EXTRACT(MINUTE FROM v_booking.start_time)::int,\n          EXTRACT(SECOND FROM v_booking.start_time),\n          v_timezone\n        );\n        v_end_at := make_timestamptz(\n          EXTRACT(YEAR FROM v_booking.booking_date)::int,\n          EXTRACT(MONTH FROM v_booking.booking_date)::int,\n          EXTRACT(DAY FROM v_booking.booking_date)::int,\n          EXTRACT(HOUR FROM v_booking.end_time)::int,\n          EXTRACT(MINUTE FROM v_booking.end_time)::int,\n          EXTRACT(SECOND FROM v_booking.end_time),\n          v_timezone\n        );\n      ELSE\n        RAISE EXCEPTION 'Booking % missing start/end window', p_booking_id\n          USING ERRCODE = '22000';\n      END IF;\n\n      IF v_start_at >= v_end_at THEN\n        RAISE EXCEPTION 'Booking % has invalid time window', p_booking_id\n          USING ERRCODE = '22000';\n      END IF;\n\n      v_window := tstzrange(v_start_at, v_end_at, '[)');\n\n      FOR v_table IN\n        SELECT id, restaurant_id, zone_id, active, status, mobility\n        FROM public.table_inventory\n        WHERE id = ANY (v_table_ids)\n        ORDER BY id\n        FOR UPDATE\n      LOOP\n        IF v_table.restaurant_id <> v_restaurant_id THEN\n          RAISE EXCEPTION 'Table % belongs to a different restaurant', v_table.id\n            USING ERRCODE = '23503';\n        END IF;\n\n        IF v_table.zone_id IS NULL THEN\n          RAISE EXCEPTION 'Table % is not assigned to a zone', v_table.id\n            USING ERRCODE = '23514';\n        END IF;\n\n        IF v_table.active IS NOT TRUE THEN\n          RAISE EXCEPTION 'Table % is inactive', v_table.id\n            USING ERRCODE = '23514';\n        END IF;\n\n        IF v_zone_id IS NULL THEN\n          v_zone_id := v_table.zone_id;\n        ELSIF v_zone_id <> v_table.zone_id THEN\n          RAISE EXCEPTION 'All tables must belong to the same zone (found %, expected %)', v_table.zone_id, v_zone_id\n            USING ERRCODE = '23514';\n        END IF;\n\n        IF v_table_count > 1 AND v_table.mobility <> 'movable'::public.table_mobility THEN\n          RAISE EXCEPTION 'Merged assignments require movable tables (% is %)', v_table.id, v_table.mobility\n            USING ERRCODE = '23514';\n        END IF;\n\n        v_loaded_count := v_loaded_count + 1;\n      END LOOP;\n\n      IF v_loaded_count <> v_table_count THEN\n        RAISE EXCEPTION 'Unable to load all requested tables for booking %', p_booking_id\n          USING ERRCODE = 'P0002';\n      END IF;\n\n      IF p_require_adjacency AND v_table_count > 1 THEN\n        FOR v_table IN\n          SELECT id FROM unnest(v_table_ids) AS t(id)\n        LOOP\n          SELECT COUNT(*)\n          INTO v_adjacency_count\n          FROM public.table_adjacencies\n          WHERE table_a = v_table.id\n            AND table_b = ANY (v_table_ids)\n            AND table_b <> v_table.id;\n\n          IF COALESCE(v_adjacency_count, 0) = 0 THEN\n            RAISE EXCEPTION 'Table % is not adjacent to the selected set', v_table.id\n              USING ERRCODE = '23514';\n          END IF;\n        END LOOP;\n      END IF;\n\n      v_service_date := v_booking.booking_date;\n      IF v_service_date IS NULL THEN\n        v_service_date := (v_start_at AT TIME ZONE v_timezone)::date;\n      END IF;\n\n      v_lock_zone := hashtext(COALESCE(v_zone_id::text, ''));\n      v_lock_date := COALESCE((v_service_date - DATE '2000-01-01')::int, 0);\n      PERFORM pg_advisory_xact_lock(v_lock_zone, v_lock_date);\n\n      IF p_idempotency_key IS NOT NULL THEN\n        SELECT *\n        INTO v_existing\n        FROM public.booking_assignment_idempotency\n        WHERE booking_id = p_booking_id\n          AND idempotency_key = p_idempotency_key;\n\n        IF FOUND THEN\n          IF v_existing.table_ids IS NULL OR array_length(v_existing.table_ids, 1) <> v_table_count\n             OR (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_existing.table_ids) AS e(elem))\n                <> (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_table_ids) AS e(elem)) THEN\n            RAISE EXCEPTION 'assign_tables_atomic_v2 idempotency mismatch for booking %', p_booking_id\n              USING ERRCODE = 'P0003',\n                    DETAIL = 'Idempotency key reuse detected with a different table set';\n          END IF;\n\n          RETURN QUERY\n            SELECT\n              bta.table_id,\n              lower(v_existing.assignment_window) AS start_at,\n              upper(v_existing.assignment_window) AS end_at,\n              v_existing.merge_group_allocation_id\n            FROM public.booking_table_assignments bta\n            WHERE bta.booking_id = p_booking_id\n              AND bta.idempotency_key = p_idempotency_key\n              AND bta.table_id = ANY (v_table_ids)\n            ORDER BY bta.table_id;\n\n          RETURN;\n        END IF;\n      END IF;\n\n      SELECT th.id\n      INTO v_hold_conflict\n      FROM public.table_holds th\n      JOIN public.table_hold_members thm ON thm.hold_id = th.id\n      WHERE thm.table_id = ANY (v_table_ids)\n        AND th.expires_at > v_now\n        AND (th.booking_id IS NULL OR th.booking_id <> p_booking_id)\n        AND tstzrange(th.start_at, th.end_at, '[)') && v_window\n      LIMIT 1;\n\n      IF FOUND THEN\n        RAISE EXCEPTION 'Hold conflict prevents assignment for booking %', p_booking_id\n          USING ERRCODE = 'P0001',\n                DETAIL = format('Hold % overlaps requested window', v_hold_conflict),\n                HINT = 'Retry after hold expiration or confirm existing hold.';\n      END IF;\n\n      IF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL THEN\n        SELECT id\n        INTO v_slot_id\n        FROM public.booking_slots\n        WHERE restaurant_id = v_restaurant_id\n          AND slot_date = v_booking.booking_date\n          AND slot_time = v_booking.start_time\n        LIMIT 1;\n\n        IF v_slot_id IS NULL THEN\n          SELECT public.get_or_create_booking_slot(v_restaurant_id, v_booking.booking_date, v_booking.start_time, 999)\n          INTO v_slot_id;\n        END IF;\n      END IF;\n\n      IF v_table_count > 1 THEN\n        v_merge_allocation_id := gen_random_uuid();\n\n        BEGIN\n          INSERT INTO public.allocations (\n            id,\n            booking_id,\n            restaurant_id,\n            resource_type,\n            resource_id,\n            \"window\",\n            created_by,\n            shadow,\n            created_at,\n            updated_at\n          ) VALUES (\n            v_merge_allocation_id,\n            p_booking_id,\n            v_restaurant_id,\n            'merge_group',\n            v_merge_allocation_id,\n            v_window,\n            p_assigned_by,\n            false,\n            v_now,\n            v_now\n          )\n          ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n          SET \"window\" = EXCLUDED.\"window\",\n              created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n              updated_at = v_now;\n        EXCEPTION\n          WHEN unique_violation OR exclusion_violation THEN\n            RAISE EXCEPTION 'allocations_no_overlap'\n              USING ERRCODE = 'P0001',\n                    DETAIL = format('Merge group overlaps requested window for booking %s', p_booking_id);\n        END;\n      END IF;\n\n      FOREACH v_table_id IN ARRAY v_table_ids LOOP\n        BEGIN\n          INSERT INTO public.booking_table_assignments (\n            booking_id,\n            table_id,\n            slot_id,\n            assigned_by,\n            idempotency_key,\n            merge_group_id\n          ) VALUES (\n            p_booking_id,\n            v_table_id,\n            v_slot_id,\n            p_assigned_by,\n            p_idempotency_key,\n            v_merge_allocation_id\n          )\n          ON CONFLICT (booking_id, table_id) DO UPDATE\n          SET assigned_at = v_now,\n              assigned_by = COALESCE(EXCLUDED.assigned_by, public.booking_table_assignments.assigned_by),\n              idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n              merge_group_id = COALESCE(EXCLUDED.merge_group_id, public.booking_table_assignments.merge_group_id),\n              slot_id = COALESCE(EXCLUDED.slot_id, public.booking_table_assignments.slot_id)\n          RETURNING id INTO v_table_assignment_id;\n        EXCEPTION\n          WHEN unique_violation THEN\n            RAISE EXCEPTION 'assign_tables_atomic_v2 assignment duplicate for table %', v_table_id\n              USING ERRCODE = 'P0001';\n        END;\n\n        BEGIN\n          INSERT INTO public.allocations (\n            booking_id,\n            restaurant_id,\n            resource_type,\n            resource_id,\n            \"window\",\n            created_by,\n            shadow,\n            created_at,\n            updated_at\n          ) VALUES (\n            p_booking_id,\n            v_restaurant_id,\n            'table',\n            v_table_id,\n            v_window,\n            p_assigned_by,\n            false,\n            v_now,\n            v_now\n          )\n          ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n          SET \"window\" = EXCLUDED.\"window\",\n              created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n              updated_at = v_now;\n        EXCEPTION\n          WHEN unique_violation OR exclusion_violation THEN\n            RAISE EXCEPTION 'allocations_no_overlap'\n              USING ERRCODE = 'P0001',\n                    DETAIL = format('Resource %s overlaps requested window for booking %s', v_table_id, p_booking_id);\n        END;\n\n        UPDATE public.table_inventory\n        SET status = 'reserved'::public.table_status\n        WHERE id = v_table_id;\n\n        table_id := v_table_id;\n        start_at := v_start_at;\n        end_at := v_end_at;\n        merge_group_id := v_merge_allocation_id;\n        RETURN NEXT;\n      END LOOP;\n\n      IF p_idempotency_key IS NOT NULL THEN\n        INSERT INTO public.booking_assignment_idempotency (\n          booking_id,\n          idempotency_key,\n          table_ids,\n          assignment_window,\n          merge_group_allocation_id,\n          created_at\n        ) VALUES (\n          p_booking_id,\n          p_idempotency_key,\n          v_table_ids,\n          v_window,\n          v_merge_allocation_id,\n          v_now\n        )\n        ON CONFLICT (booking_id, idempotency_key) DO NOTHING;\n      END IF;\n    END;\n    $function$\n  $create_rpc$;\n\n  EXECUTE $alter_rpc$\n    ALTER FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid) OWNER TO postgres\n  $alter_rpc$;\n\n  EXECUTE $grant_rpc$\n    GRANT ALL ON FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid) TO service_role\n  $grant_rpc$;\nEND;\n$migration$;\n"
    },
    {
      "path": "supabase/migrations/20251028034500_assign_tables_atomic_v2_alias_fix.sql",
      "content": "-- Ensure assign_tables_atomic_v2 uses qualified columns to avoid ambiguous references.\nDO $$\nBEGIN\n  CREATE OR REPLACE FUNCTION public.assign_tables_atomic_v2(\n    p_booking_id uuid,\n    p_table_ids uuid[],\n    p_idempotency_key text DEFAULT NULL,\n    p_require_adjacency boolean DEFAULT false,\n    p_assigned_by uuid DEFAULT NULL,\n    p_start_at timestamptz DEFAULT NULL,\n    p_end_at timestamptz DEFAULT NULL\n  ) RETURNS TABLE (\n    table_id uuid,\n    start_at timestamptz,\n    end_at timestamptz,\n    merge_group_id uuid\n  )\n  LANGUAGE plpgsql\n  SECURITY DEFINER\n  SET search_path = public\n  AS $function$\n  DECLARE\n    v_booking RECORD;\n    v_zone_id uuid;\n    v_restaurant_id uuid;\n    v_service_date date;\n    v_lock_zone int4;\n    v_lock_date int4;\n    v_now timestamptz := timezone('utc', now());\n    v_table_ids uuid[];\n    v_table_count integer;\n    v_table RECORD;\n    v_loaded_count integer := 0;\n    v_slot_id uuid := NULL;\n    v_start_at timestamptz;\n    v_end_at timestamptz;\n    v_window tstzrange;\n    v_timezone text := NULL;\n    v_hold_conflict uuid;\n    v_merge_allocation_id uuid := NULL;\n    v_table_assignment_id uuid;\n    v_existing RECORD;\n    v_adjacency_count integer;\n    v_table_id uuid;\n    v_merge_group_supported boolean := false;\n    v_conflict RECORD;\n  BEGIN\n    IF p_table_ids IS NULL OR array_length(p_table_ids, 1) = 0 THEN\n      RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one table id'\n        USING ERRCODE = '23514';\n    END IF;\n\n    SELECT array_agg(DISTINCT t.table_id ORDER BY t.table_id)\n    INTO v_table_ids\n    FROM unnest(p_table_ids) AS t(table_id);\n\n    IF v_table_ids IS NULL OR array_length(v_table_ids, 1) = 0 THEN\n      RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one valid table id'\n        USING ERRCODE = '23514';\n    END IF;\n\n    v_table_count := array_length(v_table_ids, 1);\n\n    SELECT\n      b.*,\n      r.timezone AS restaurant_timezone\n    INTO v_booking\n    FROM public.bookings b\n    LEFT JOIN public.restaurants r ON r.id = b.restaurant_id\n    WHERE b.id = p_booking_id\n    FOR UPDATE OF b;\n\n    IF NOT FOUND THEN\n      RAISE EXCEPTION 'Booking % not found', p_booking_id\n        USING ERRCODE = 'P0002';\n    END IF;\n\n    v_restaurant_id := v_booking.restaurant_id;\n    v_timezone := COALESCE(NULLIF(v_booking.restaurant_timezone, ''), 'UTC');\n\n    SELECT EXISTS (\n      SELECT 1\n      FROM information_schema.columns\n      WHERE table_schema = 'public'\n        AND table_name = 'booking_table_assignments'\n        AND column_name = 'merge_group_id'\n    )\n    INTO v_merge_group_supported;\n\n    IF (p_start_at IS NULL) <> (p_end_at IS NULL) THEN\n      RAISE EXCEPTION 'assign_tables_atomic_v2 requires both start and end when providing custom window'\n        USING ERRCODE = '22023';\n    END IF;\n\n    IF p_start_at IS NOT NULL AND p_end_at IS NOT NULL THEN\n      v_start_at := p_start_at;\n      v_end_at := p_end_at;\n    ELSIF v_booking.start_at IS NOT NULL AND v_booking.end_at IS NOT NULL THEN\n      v_start_at := v_booking.start_at;\n      v_end_at := v_booking.end_at;\n    ELSIF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL AND v_booking.end_time IS NOT NULL THEN\n      v_start_at := make_timestamptz(\n        EXTRACT(YEAR FROM v_booking.booking_date)::int,\n        EXTRACT(MONTH FROM v_booking.booking_date)::int,\n        EXTRACT(DAY FROM v_booking.booking_date)::int,\n        EXTRACT(HOUR FROM v_booking.start_time)::int,\n        EXTRACT(MINUTE FROM v_booking.start_time)::int,\n        EXTRACT(SECOND FROM v_booking.start_time),\n        v_timezone\n      );\n      v_end_at := make_timestamptz(\n        EXTRACT(YEAR FROM v_booking.booking_date)::int,\n        EXTRACT(MONTH FROM v_booking.booking_date)::int,\n        EXTRACT(DAY FROM v_booking.booking_date)::int,\n        EXTRACT(HOUR FROM v_booking.end_time)::int,\n        EXTRACT(MINUTE FROM v_booking.end_time)::int,\n        EXTRACT(SECOND FROM v_booking.end_time),\n        v_timezone\n      );\n    ELSE\n      RAISE EXCEPTION 'Booking % missing start/end window', p_booking_id\n        USING ERRCODE = '22000';\n    END IF;\n\n    IF v_start_at >= v_end_at THEN\n      RAISE EXCEPTION 'Booking % has invalid time window', p_booking_id\n        USING ERRCODE = '22000';\n    END IF;\n\n    v_window := tstzrange(v_start_at, v_end_at, '[)');\n\n    FOR v_table IN\n      SELECT id, restaurant_id, zone_id, active, status, mobility\n      FROM public.table_inventory\n      WHERE id = ANY (v_table_ids)\n      ORDER BY id\n      FOR UPDATE\n    LOOP\n      IF v_table.restaurant_id <> v_restaurant_id THEN\n        RAISE EXCEPTION 'Table % belongs to a different restaurant', v_table.id\n          USING ERRCODE = '23503';\n      END IF;\n\n      IF v_table.zone_id IS NULL THEN\n        RAISE EXCEPTION 'Table % is not assigned to a zone', v_table.id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_table.active IS NOT TRUE THEN\n        RAISE EXCEPTION 'Table % is inactive', v_table.id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_zone_id IS NULL THEN\n        v_zone_id := v_table.zone_id;\n      ELSIF v_zone_id <> v_table.zone_id THEN\n        RAISE EXCEPTION 'All tables must belong to the same zone (found %, expected %)', v_table.zone_id, v_zone_id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_table_count > 1 AND v_table.mobility <> 'movable'::public.table_mobility THEN\n        RAISE EXCEPTION 'Merged assignments require movable tables (% is %)', v_table.id, v_table.mobility\n          USING ERRCODE = '23514';\n      END IF;\n\n      v_loaded_count := v_loaded_count + 1;\n    END LOOP;\n\n    IF v_loaded_count <> v_table_count THEN\n      RAISE EXCEPTION 'Unable to load all requested tables for booking %', p_booking_id\n        USING ERRCODE = 'P0002';\n    END IF;\n\n    IF p_require_adjacency AND v_table_count > 1 THEN\n      FOR v_table IN\n        SELECT id FROM unnest(v_table_ids) AS t(id)\n      LOOP\n        SELECT COUNT(*)\n        INTO v_adjacency_count\n        FROM public.table_adjacencies\n        WHERE (\n            table_a = v_table.id\n            AND table_b = ANY (v_table_ids)\n            AND table_b <> v_table.id\n          )\n          OR (\n            table_b = v_table.id\n            AND table_a = ANY (v_table_ids)\n            AND table_a <> v_table.id\n          );\n\n        IF COALESCE(v_adjacency_count, 0) = 0 THEN\n          RAISE EXCEPTION 'Table % is not adjacent to the selected set', v_table.id\n            USING ERRCODE = '23514';\n        END IF;\n      END LOOP;\n    END IF;\n\n    v_service_date := (v_start_at AT TIME ZONE v_timezone)::date;\n\n    v_lock_zone := hashtext(COALESCE(v_zone_id::text, ''));\n    v_lock_date := COALESCE((v_service_date - DATE '2000-01-01')::int, 0);\n    PERFORM pg_advisory_xact_lock(v_lock_zone, v_lock_date);\n\n    IF p_idempotency_key IS NOT NULL THEN\n      SELECT *\n      INTO v_existing\n      FROM public.booking_assignment_idempotency\n      WHERE booking_id = p_booking_id\n        AND idempotency_key = p_idempotency_key;\n\n      IF FOUND THEN\n        IF v_existing.table_ids IS NULL OR array_length(v_existing.table_ids, 1) <> v_table_count\n           OR (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_existing.table_ids) AS e(elem))\n              <> (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_table_ids) AS e(elem)) THEN\n          RAISE EXCEPTION 'assign_tables_atomic_v2 idempotency mismatch for booking %', p_booking_id\n            USING ERRCODE = 'P0003',\n                  DETAIL = 'Idempotency key reuse detected with a different table set';\n        END IF;\n\n        RETURN QUERY\n          SELECT\n            bta.table_id,\n            COALESCE(bta.start_at, lower(v_existing.assignment_window)) AS start_at,\n            COALESCE(bta.end_at, upper(v_existing.assignment_window)) AS end_at,\n            v_existing.merge_group_allocation_id\n          FROM public.booking_table_assignments bta\n          WHERE bta.booking_id = p_booking_id\n            AND bta.idempotency_key = p_idempotency_key\n            AND bta.table_id = ANY (v_table_ids)\n          ORDER BY bta.table_id;\n\n        RETURN;\n      END IF;\n    END IF;\n\n    SELECT th.id\n    INTO v_hold_conflict\n    FROM public.table_holds th\n    JOIN public.table_hold_members thm ON thm.hold_id = th.id\n    WHERE thm.table_id = ANY (v_table_ids)\n      AND th.expires_at > v_now\n      AND (th.booking_id IS NULL OR th.booking_id <> p_booking_id)\n      AND tstzrange(th.start_at, th.end_at, '[)') && v_window\n    LIMIT 1;\n\n    IF FOUND THEN\n      RAISE EXCEPTION 'Hold conflict prevents assignment for booking %', p_booking_id\n        USING ERRCODE = 'P0001',\n              DETAIL = format('Hold % overlaps requested window', v_hold_conflict),\n              HINT = 'Retry after hold expiration or confirm existing hold.';\n    END IF;\n\n    IF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL THEN\n      SELECT id\n      INTO v_slot_id\n      FROM public.booking_slots\n      WHERE restaurant_id = v_restaurant_id\n        AND slot_date = v_booking.booking_date\n        AND slot_time = v_booking.start_time\n      LIMIT 1;\n\n      IF v_slot_id IS NULL THEN\n        SELECT public.get_or_create_booking_slot(v_restaurant_id, v_booking.booking_date, v_booking.start_time, 999)\n        INTO v_slot_id;\n      END IF;\n    END IF;\n\n    IF v_merge_group_supported AND v_table_count > 1 THEN\n      v_merge_allocation_id := gen_random_uuid();\n\n      BEGIN\n        INSERT INTO public.allocations (\n          id,\n          booking_id,\n          restaurant_id,\n          resource_type,\n          resource_id,\n          \"window\",\n          created_by,\n          shadow,\n          created_at,\n          updated_at\n        ) VALUES (\n          v_merge_allocation_id,\n          p_booking_id,\n          v_restaurant_id,\n          'merge_group',\n          v_merge_allocation_id,\n          v_window,\n          p_assigned_by,\n          false,\n          v_now,\n          v_now\n        )\n        ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n        SET \"window\" = EXCLUDED.\"window\",\n            created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n            updated_at = v_now;\n      EXCEPTION\n        WHEN unique_violation OR exclusion_violation THEN\n          RAISE EXCEPTION 'allocations_no_overlap'\n            USING ERRCODE = 'P0001',\n                  DETAIL = format('Merge group overlaps requested window for booking %s', p_booking_id);\n      END;\n    END IF;\n\n    FOREACH v_table_id IN ARRAY v_table_ids LOOP\n      SELECT\n        existing.booking_id,\n        existing.start_at,\n        existing.end_at\n      INTO v_conflict\n      FROM public.booking_table_assignments existing\n      WHERE existing.table_id = v_table_id\n        AND existing.booking_id <> p_booking_id\n        AND existing.start_at IS NOT NULL\n        AND existing.end_at IS NOT NULL\n        AND tstzrange(existing.start_at, existing.end_at, '[)') && v_window\n      LIMIT 1;\n\n      IF FOUND THEN\n        RAISE EXCEPTION 'assign_tables_atomic_v2 assignment overlap for table %', v_table_id\n          USING ERRCODE = 'P0001',\n                DETAIL = format('Existing booking %s occupies %s from %s to %s', v_conflict.booking_id, v_table_id, v_conflict.start_at, v_conflict.end_at),\n                HINT = 'Adjust assignment window or release the conflicting table.';\n      END IF;\n\n      v_conflict := NULL;\n\n      IF v_merge_group_supported THEN\n        BEGIN\n          INSERT INTO public.booking_table_assignments (\n            booking_id,\n            table_id,\n            slot_id,\n            assigned_by,\n            idempotency_key,\n            merge_group_id,\n            start_at,\n            end_at\n          ) VALUES (\n            p_booking_id,\n            v_table_id,\n            v_slot_id,\n            p_assigned_by,\n            p_idempotency_key,\n            v_merge_allocation_id,\n            v_start_at,\n            v_end_at\n          )\n        ON CONFLICT ON CONSTRAINT booking_table_assignments_booking_table_key DO UPDATE\n          SET assigned_at = v_now,\n              assigned_by = COALESCE(EXCLUDED.assigned_by, public.booking_table_assignments.assigned_by),\n              idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n              merge_group_id = COALESCE(EXCLUDED.merge_group_id, public.booking_table_assignments.merge_group_id),\n              slot_id = COALESCE(EXCLUDED.slot_id, public.booking_table_assignments.slot_id),\n              start_at = EXCLUDED.start_at,\n              end_at = EXCLUDED.end_at,\n              updated_at = v_now\n          RETURNING id INTO v_table_assignment_id;\n        EXCEPTION\n          WHEN unique_violation THEN\n            UPDATE public.booking_table_assignments AS bta\n              SET assigned_at = v_now,\n                  assigned_by = COALESCE(p_assigned_by, bta.assigned_by),\n                  idempotency_key = COALESCE(p_idempotency_key, bta.idempotency_key),\n                  merge_group_id = COALESCE(v_merge_allocation_id, bta.merge_group_id),\n                  slot_id = COALESCE(v_slot_id, bta.slot_id),\n                  start_at = v_start_at,\n                  end_at = v_end_at,\n                  updated_at = v_now\n            WHERE bta.booking_id = p_booking_id\n              AND bta.table_id = v_table_id\n            RETURNING bta.id INTO v_table_assignment_id;\n\n            IF NOT FOUND THEN\n              RAISE EXCEPTION 'assign_tables_atomic_v2 assignment duplicate for table %', v_table_id\n                USING ERRCODE = 'P0001';\n            END IF;\n        END;\n      ELSE\n        BEGIN\n          INSERT INTO public.booking_table_assignments (\n            booking_id,\n            table_id,\n            slot_id,\n            assigned_by,\n            idempotency_key,\n            start_at,\n            end_at\n          ) VALUES (\n            p_booking_id,\n            v_table_id,\n            v_slot_id,\n            p_assigned_by,\n            p_idempotency_key,\n            v_start_at,\n            v_end_at\n          )\n          ON CONFLICT ON CONSTRAINT booking_table_assignments_booking_table_key DO UPDATE\n          SET assigned_at = v_now,\n              assigned_by = COALESCE(EXCLUDED.assigned_by, public.booking_table_assignments.assigned_by),\n              idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n              slot_id = COALESCE(EXCLUDED.slot_id, public.booking_table_assignments.slot_id),\n              start_at = EXCLUDED.start_at,\n              end_at = EXCLUDED.end_at,\n              updated_at = v_now\n          RETURNING id INTO v_table_assignment_id;\n        EXCEPTION\n          WHEN unique_violation THEN\n            UPDATE public.booking_table_assignments AS bta\n              SET assigned_at = v_now,\n                  assigned_by = COALESCE(p_assigned_by, bta.assigned_by),\n                  idempotency_key = COALESCE(p_idempotency_key, bta.idempotency_key),\n                  slot_id = COALESCE(v_slot_id, bta.slot_id),\n                  start_at = v_start_at,\n                  end_at = v_end_at,\n                  updated_at = v_now\n            WHERE bta.booking_id = p_booking_id\n              AND bta.table_id = v_table_id\n            RETURNING bta.id INTO v_table_assignment_id;\n\n            IF NOT FOUND THEN\n              RAISE EXCEPTION 'assign_tables_atomic_v2 assignment duplicate for table %', v_table_id\n                USING ERRCODE = 'P0001';\n            END IF;\n        END;\n      END IF;\n\n      BEGIN\n        INSERT INTO public.allocations (\n          booking_id,\n          restaurant_id,\n          resource_type,\n          resource_id,\n          \"window\",\n          created_by,\n          shadow,\n          created_at,\n          updated_at\n        ) VALUES (\n          p_booking_id,\n          v_restaurant_id,\n          'table',\n          v_table_id,\n          v_window,\n          p_assigned_by,\n          false,\n          v_now,\n          v_now\n        )\n        ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n        SET \"window\" = EXCLUDED.\"window\",\n            created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n            updated_at = v_now;\n      EXCEPTION\n        WHEN unique_violation OR exclusion_violation THEN\n          RAISE EXCEPTION 'allocations_no_overlap'\n            USING ERRCODE = 'P0001',\n                  DETAIL = format('Resource %s overlaps requested window for booking %s', v_table_id, p_booking_id);\n      END;\n\n      PERFORM public.refresh_table_status(v_table_id);\n\n      table_id := v_table_id;\n      start_at := v_start_at;\n      end_at := v_end_at;\n      merge_group_id := CASE WHEN v_merge_group_supported THEN v_merge_allocation_id ELSE NULL END;\n      RETURN NEXT;\n    END LOOP;\n\n    IF p_idempotency_key IS NOT NULL THEN\n      INSERT INTO public.booking_assignment_idempotency (\n        booking_id,\n        idempotency_key,\n        table_ids,\n        assignment_window,\n        merge_group_allocation_id,\n        created_at\n      ) VALUES (\n        p_booking_id,\n        p_idempotency_key,\n        v_table_ids,\n        v_window,\n        v_merge_allocation_id,\n        v_now\n      )\n      ON CONFLICT (booking_id, idempotency_key) DO NOTHING;\n    END IF;\n  END;\n  $function$;\n\n  ALTER FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid, timestamptz, timestamptz) OWNER TO postgres;\n  GRANT ALL ON FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid, timestamptz, timestamptz) TO service_role;\nEND;\n$$;\n"
    },
    {
      "path": "supabase/migrations/20251026180000_fix_assign_tables_atomic_v2_table_id.sql",
      "content": "-- Fix ambiguous table_id reference in assign_tables_atomic_v2\nCREATE OR REPLACE FUNCTION public.assign_tables_atomic_v2(\n      p_booking_id uuid,\n      p_table_ids uuid[],\n      p_idempotency_key text DEFAULT NULL,\n      p_require_adjacency boolean DEFAULT false,\n      p_assigned_by uuid DEFAULT NULL\n    ) RETURNS TABLE (\n      table_id uuid,\n      start_at timestamptz,\n      end_at timestamptz,\n      merge_group_id uuid\n    )\n    LANGUAGE plpgsql\n    SECURITY DEFINER\n    SET search_path = public\n    AS $function$\n    DECLARE\n      v_booking RECORD;\n      v_zone_id uuid;\n      v_restaurant_id uuid;\n      v_service_date date;\n      v_lock_zone int4;\n      v_lock_date int4;\n      v_now timestamptz := timezone('utc', now());\n      v_table_ids uuid[];\n      v_table_count integer;\n      v_table RECORD;\n      v_loaded_count integer := 0;\n      v_slot_id uuid := NULL;\n      v_start_at timestamptz;\n      v_end_at timestamptz;\n      v_window tstzrange;\n      v_timezone text := NULL;\n      v_hold_conflict uuid;\n      v_merge_allocation_id uuid := NULL;\n      v_table_assignment_id uuid;\n      v_existing RECORD;\n      v_adjacency_count integer;\n      v_table_id uuid;\n      v_merge_group_supported boolean := false;\n    BEGIN\n      IF p_table_ids IS NULL OR array_length(p_table_ids, 1) = 0 THEN\n        RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one table id'\n          USING ERRCODE = '23514';\n      END IF;\n\n      SELECT array_agg(DISTINCT t.table_id ORDER BY t.table_id)\n      INTO v_table_ids\n      FROM unnest(p_table_ids) AS t(table_id);\n\n      IF v_table_ids IS NULL OR array_length(v_table_ids, 1) = 0 THEN\n        RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one valid table id'\n          USING ERRCODE = '23514';\n      END IF;\n\n      v_table_count := array_length(v_table_ids, 1);\n\n      SELECT\n        b.*,\n        r.timezone AS restaurant_timezone\n      INTO v_booking\n      FROM public.bookings b\n      LEFT JOIN public.restaurants r ON r.id = b.restaurant_id\n      WHERE b.id = p_booking_id\n      FOR UPDATE OF b;\n\n      IF NOT FOUND THEN\n        RAISE EXCEPTION 'Booking % not found', p_booking_id\n          USING ERRCODE = 'P0002';\n      END IF;\n\n      v_restaurant_id := v_booking.restaurant_id;\n      v_timezone := COALESCE(NULLIF(v_booking.restaurant_timezone, ''), 'UTC');\n\n      SELECT EXISTS (\n        SELECT 1\n        FROM information_schema.columns\n        WHERE table_schema = 'public'\n          AND table_name = 'booking_table_assignments'\n          AND column_name = 'merge_group_id'\n      )\n      INTO v_merge_group_supported;\n\n      IF v_booking.start_at IS NOT NULL AND v_booking.end_at IS NOT NULL THEN\n        v_start_at := v_booking.start_at;\n        v_end_at := v_booking.end_at;\n      ELSIF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL AND v_booking.end_time IS NOT NULL THEN\n        v_start_at := make_timestamptz(\n          EXTRACT(YEAR FROM v_booking.booking_date)::int,\n          EXTRACT(MONTH FROM v_booking.booking_date)::int,\n          EXTRACT(DAY FROM v_booking.booking_date)::int,\n          EXTRACT(HOUR FROM v_booking.start_time)::int,\n          EXTRACT(MINUTE FROM v_booking.start_time)::int,\n          EXTRACT(SECOND FROM v_booking.start_time),\n          v_timezone\n        );\n        v_end_at := make_timestamptz(\n          EXTRACT(YEAR FROM v_booking.booking_date)::int,\n          EXTRACT(MONTH FROM v_booking.booking_date)::int,\n          EXTRACT(DAY FROM v_booking.booking_date)::int,\n          EXTRACT(HOUR FROM v_booking.end_time)::int,\n          EXTRACT(MINUTE FROM v_booking.end_time)::int,\n          EXTRACT(SECOND FROM v_booking.end_time),\n          v_timezone\n        );\n      ELSE\n        RAISE EXCEPTION 'Booking % missing start/end window', p_booking_id\n          USING ERRCODE = '22000';\n      END IF;\n\n      IF v_start_at >= v_end_at THEN\n        RAISE EXCEPTION 'Booking % has invalid time window', p_booking_id\n          USING ERRCODE = '22000';\n      END IF;\n\n      v_window := tstzrange(v_start_at, v_end_at, '[)');\n\n      FOR v_table IN\n        SELECT id, restaurant_id, zone_id, active, status, mobility\n        FROM public.table_inventory\n        WHERE id = ANY (v_table_ids)\n        ORDER BY id\n        FOR UPDATE\n      LOOP\n        IF v_table.restaurant_id <> v_restaurant_id THEN\n          RAISE EXCEPTION 'Table % belongs to a different restaurant', v_table.id\n            USING ERRCODE = '23503';\n        END IF;\n\n        IF v_table.zone_id IS NULL THEN\n          RAISE EXCEPTION 'Table % is not assigned to a zone', v_table.id\n            USING ERRCODE = '23514';\n        END IF;\n\n        IF v_table.active IS NOT TRUE THEN\n          RAISE EXCEPTION 'Table % is inactive', v_table.id\n            USING ERRCODE = '23514';\n        END IF;\n\n        IF v_zone_id IS NULL THEN\n          v_zone_id := v_table.zone_id;\n        ELSIF v_zone_id <> v_table.zone_id THEN\n          RAISE EXCEPTION 'All tables must belong to the same zone (found %, expected %)', v_table.zone_id, v_zone_id\n            USING ERRCODE = '23514';\n        END IF;\n\n        IF v_table_count > 1 AND v_table.mobility <> 'movable'::public.table_mobility THEN\n          RAISE EXCEPTION 'Merged assignments require movable tables (% is %)', v_table.id, v_table.mobility\n            USING ERRCODE = '23514';\n        END IF;\n\n        v_loaded_count := v_loaded_count + 1;\n      END LOOP;\n\n      IF v_loaded_count <> v_table_count THEN\n        RAISE EXCEPTION 'Unable to load all requested tables for booking %', p_booking_id\n          USING ERRCODE = 'P0002';\n      END IF;\n\n      IF p_require_adjacency AND v_table_count > 1 THEN\n        FOR v_table IN\n          SELECT id FROM unnest(v_table_ids) AS t(id)\n        LOOP\n          SELECT COUNT(*)\n          INTO v_adjacency_count\n          FROM public.table_adjacencies\n          WHERE table_a = v_table.id\n            AND table_b = ANY (v_table_ids)\n            AND table_b <> v_table.id;\n\n          IF COALESCE(v_adjacency_count, 0) = 0 THEN\n            RAISE EXCEPTION 'Table % is not adjacent to the selected set', v_table.id\n              USING ERRCODE = '23514';\n          END IF;\n        END LOOP;\n      END IF;\n\n      v_service_date := v_booking.booking_date;\n      IF v_service_date IS NULL THEN\n        v_service_date := (v_start_at AT TIME ZONE v_timezone)::date;\n      END IF;\n\n      v_lock_zone := hashtext(COALESCE(v_zone_id::text, ''));\n      v_lock_date := COALESCE((v_service_date - DATE '2000-01-01')::int, 0);\n      PERFORM pg_advisory_xact_lock(v_lock_zone, v_lock_date);\n\n      IF p_idempotency_key IS NOT NULL THEN\n        SELECT *\n        INTO v_existing\n        FROM public.booking_assignment_idempotency\n        WHERE booking_id = p_booking_id\n          AND idempotency_key = p_idempotency_key;\n\n        IF FOUND THEN\n          IF v_existing.table_ids IS NULL OR array_length(v_existing.table_ids, 1) <> v_table_count\n             OR (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_existing.table_ids) AS e(elem))\n                <> (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_table_ids) AS e(elem)) THEN\n            RAISE EXCEPTION 'assign_tables_atomic_v2 idempotency mismatch for booking %', p_booking_id\n              USING ERRCODE = 'P0003',\n                    DETAIL = 'Idempotency key reuse detected with a different table set';\n          END IF;\n\n          RETURN QUERY\n            SELECT\n              bta.table_id,\n              lower(v_existing.assignment_window) AS start_at,\n              upper(v_existing.assignment_window) AS end_at,\n              v_existing.merge_group_allocation_id\n            FROM public.booking_table_assignments bta\n            WHERE bta.booking_id = p_booking_id\n              AND bta.idempotency_key = p_idempotency_key\n              AND bta.table_id = ANY (v_table_ids)\n            ORDER BY bta.table_id;\n\n          RETURN;\n        END IF;\n      END IF;\n\n      SELECT th.id\n      INTO v_hold_conflict\n      FROM public.table_holds th\n      JOIN public.table_hold_members thm ON thm.hold_id = th.id\n      WHERE thm.table_id = ANY (v_table_ids)\n        AND th.expires_at > v_now\n        AND (th.booking_id IS NULL OR th.booking_id <> p_booking_id)\n        AND tstzrange(th.start_at, th.end_at, '[)') && v_window\n      LIMIT 1;\n\n      IF FOUND THEN\n        RAISE EXCEPTION 'Hold conflict prevents assignment for booking %', p_booking_id\n          USING ERRCODE = 'P0001',\n                DETAIL = format('Hold % overlaps requested window', v_hold_conflict),\n                HINT = 'Retry after hold expiration or confirm existing hold.';\n      END IF;\n\n      IF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL THEN\n        SELECT id\n        INTO v_slot_id\n        FROM public.booking_slots\n        WHERE restaurant_id = v_restaurant_id\n          AND slot_date = v_booking.booking_date\n          AND slot_time = v_booking.start_time\n        LIMIT 1;\n\n        IF v_slot_id IS NULL THEN\n          SELECT public.get_or_create_booking_slot(v_restaurant_id, v_booking.booking_date, v_booking.start_time, 999)\n          INTO v_slot_id;\n        END IF;\n      END IF;\n\n      IF v_merge_group_supported AND v_table_count > 1 THEN\n        v_merge_allocation_id := gen_random_uuid();\n\n        BEGIN\n          INSERT INTO public.allocations (\n            id,\n            booking_id,\n            restaurant_id,\n            resource_type,\n            resource_id,\n            \"window\",\n            created_by,\n            shadow,\n            created_at,\n            updated_at\n          ) VALUES (\n            v_merge_allocation_id,\n            p_booking_id,\n            v_restaurant_id,\n            'merge_group',\n            v_merge_allocation_id,\n            v_window,\n            p_assigned_by,\n            false,\n            v_now,\n            v_now\n          )\n          ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n          SET \"window\" = EXCLUDED.\"window\",\n              created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n              updated_at = v_now;\n        EXCEPTION\n          WHEN unique_violation OR exclusion_violation THEN\n            RAISE EXCEPTION 'allocations_no_overlap'\n              USING ERRCODE = 'P0001',\n                    DETAIL = format('Merge group overlaps requested window for booking %s', p_booking_id);\n        END;\n      END IF;\n\n      FOREACH v_table_id IN ARRAY v_table_ids LOOP\n        IF v_merge_group_supported THEN\n          BEGIN\n            INSERT INTO public.booking_table_assignments (\n              booking_id,\n              table_id,\n              slot_id,\n              assigned_by,\n              idempotency_key,\n              merge_group_id\n            ) VALUES (\n              p_booking_id,\n              v_table_id,\n              v_slot_id,\n              p_assigned_by,\n              p_idempotency_key,\n              v_merge_allocation_id\n            )\n            ON CONFLICT ON CONSTRAINT booking_table_assignments_booking_table_key DO UPDATE\n            SET assigned_at = v_now,\n                assigned_by = COALESCE(EXCLUDED.assigned_by, public.booking_table_assignments.assigned_by),\n                idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n                merge_group_id = COALESCE(EXCLUDED.merge_group_id, public.booking_table_assignments.merge_group_id),\n                slot_id = COALESCE(EXCLUDED.slot_id, public.booking_table_assignments.slot_id)\n            RETURNING id INTO v_table_assignment_id;\n          EXCEPTION\n            WHEN unique_violation THEN\n              RAISE EXCEPTION 'assign_tables_atomic_v2 assignment duplicate for table %', v_table_id\n                USING ERRCODE = 'P0001';\n          END;\n        ELSE\n          BEGIN\n            INSERT INTO public.booking_table_assignments (\n              booking_id,\n              table_id,\n              slot_id,\n              assigned_by,\n              idempotency_key\n            ) VALUES (\n              p_booking_id,\n              v_table_id,\n              v_slot_id,\n              p_assigned_by,\n              p_idempotency_key\n            )\n            ON CONFLICT ON CONSTRAINT booking_table_assignments_booking_table_key DO UPDATE\n            SET assigned_at = v_now,\n                assigned_by = COALESCE(EXCLUDED.assigned_by, public.booking_table_assignments.assigned_by),\n                idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n                slot_id = COALESCE(EXCLUDED.slot_id, public.booking_table_assignments.slot_id)\n            RETURNING id INTO v_table_assignment_id;\n          EXCEPTION\n            WHEN unique_violation THEN\n              RAISE EXCEPTION 'assign_tables_atomic_v2 assignment duplicate for table %', v_table_id\n                USING ERRCODE = 'P0001';\n          END;\n        END IF;\n\n        BEGIN\n          INSERT INTO public.allocations (\n            booking_id,\n            restaurant_id,\n            resource_type,\n            resource_id,\n            \"window\",\n            created_by,\n            shadow,\n            created_at,\n            updated_at\n          ) VALUES (\n            p_booking_id,\n            v_restaurant_id,\n            'table',\n            v_table_id,\n            v_window,\n            p_assigned_by,\n            false,\n            v_now,\n            v_now\n          )\n          ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n          SET \"window\" = EXCLUDED.\"window\",\n              created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n              updated_at = v_now;\n        EXCEPTION\n          WHEN unique_violation OR exclusion_violation THEN\n            RAISE EXCEPTION 'allocations_no_overlap'\n              USING ERRCODE = 'P0001',\n                    DETAIL = format('Resource %s overlaps requested window for booking %s', v_table_id, p_booking_id);\n        END;\n\n        UPDATE public.table_inventory\n        SET status = 'reserved'::public.table_status\n        WHERE id = v_table_id;\n\n        table_id := v_table_id;\n        start_at := v_start_at;\n        end_at := v_end_at;\n        merge_group_id := CASE WHEN v_merge_group_supported THEN v_merge_allocation_id ELSE NULL END;\n        RETURN NEXT;\n      END LOOP;\n\n      IF p_idempotency_key IS NOT NULL THEN\n        INSERT INTO public.booking_assignment_idempotency (\n          booking_id,\n          idempotency_key,\n          table_ids,\n          assignment_window,\n          merge_group_allocation_id,\n          created_at\n        ) VALUES (\n          p_booking_id,\n          p_idempotency_key,\n          v_table_ids,\n          v_window,\n          v_merge_allocation_id,\n          v_now\n        )\n        ON CONFLICT (booking_id, idempotency_key) DO NOTHING;\n      END IF;\n    END;\n$function$;\n\nALTER FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid) OWNER TO postgres;\n\nGRANT ALL ON FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid) TO service_role;\n\n-- Ensure booking slot helper tolerates missing capacity rules table.\n\nCREATE OR REPLACE FUNCTION public.get_or_create_booking_slot(\n  p_restaurant_id uuid,\n  p_slot_date date,\n  p_slot_time time without time zone,\n  p_default_capacity integer DEFAULT 999\n) RETURNS uuid\nLANGUAGE plpgsql\nSECURITY DEFINER\nAS $function$\nDECLARE\n  v_slot_id uuid;\n  v_service_period_id uuid;\n  v_capacity integer;\n  v_rules_exist boolean := to_regclass('public.restaurant_capacity_rules') IS NOT NULL;\nBEGIN\n  SELECT id\n  INTO v_slot_id\n  FROM public.booking_slots\n  WHERE restaurant_id = p_restaurant_id\n    AND slot_date = p_slot_date\n    AND slot_time = p_slot_time;\n\n  IF FOUND THEN\n    RETURN v_slot_id;\n  END IF;\n\n  SELECT id\n  INTO v_service_period_id\n  FROM public.restaurant_service_periods\n  WHERE restaurant_id = p_restaurant_id\n    AND (day_of_week IS NULL OR day_of_week = EXTRACT(DOW FROM p_slot_date)::smallint)\n    AND p_slot_time >= start_time\n    AND p_slot_time < end_time\n  ORDER BY day_of_week DESC NULLS LAST\n  LIMIT 1;\n\n  v_capacity := NULL;\n\n  IF v_rules_exist THEN\n    SELECT COALESCE(max_covers, p_default_capacity)\n    INTO v_capacity\n    FROM public.restaurant_capacity_rules\n    WHERE restaurant_id = p_restaurant_id\n      AND (service_period_id IS NULL OR service_period_id = v_service_period_id)\n      AND (day_of_week IS NULL OR day_of_week = EXTRACT(DOW FROM p_slot_date)::smallint)\n      AND (effective_date IS NULL OR effective_date <= p_slot_date)\n    ORDER BY\n      effective_date DESC NULLS LAST,\n      day_of_week DESC NULLS LAST,\n      service_period_id DESC NULLS LAST\n    LIMIT 1;\n  END IF;\n\n  v_capacity := COALESCE(v_capacity, p_default_capacity);\n\n  INSERT INTO public.booking_slots (\n    restaurant_id,\n    slot_date,\n    slot_time,\n    service_period_id,\n    available_capacity,\n    reserved_count\n  ) VALUES (\n    p_restaurant_id,\n    p_slot_date,\n    p_slot_time,\n    v_service_period_id,\n    v_capacity,\n    0\n  )\n  RETURNING id INTO v_slot_id;\n\n  RETURN v_slot_id;\nEND;\n$function$;\n\nALTER FUNCTION public.get_or_create_booking_slot(uuid, date, time without time zone, integer) OWNER TO postgres;\n\nGRANT ALL ON FUNCTION public.get_or_create_booking_slot(uuid, date, time without time zone, integer) TO service_role;\n\nCOMMENT ON FUNCTION public.get_or_create_booking_slot(uuid, date, time without time zone, integer)\n  IS 'Get existing slot or create new one with capacity override fallback (works even if restaurant_capacity_rules is absent).';\n"
    },
    {
      "path": "supabase/migrations/20251027000001_fix_assign_tables_atomic_v2_table_id_v2.sql",
      "content": "-- Fix ambiguous table_id reference in assign_tables_atomic_v2\nDO $$\nBEGIN\n  -- Drop and recreate the function with proper table_id handling\n  CREATE OR REPLACE FUNCTION public.assign_tables_atomic_v2(\n    p_booking_id uuid,\n    p_table_ids uuid[],\n    p_idempotency_key text DEFAULT NULL,\n    p_require_adjacency boolean DEFAULT false,\n    p_assigned_by uuid DEFAULT NULL\n  ) RETURNS TABLE (\n    table_id uuid,\n    start_at timestamptz,\n    end_at timestamptz,\n    merge_group_id uuid\n  )\n  LANGUAGE plpgsql\n  SECURITY DEFINER\n  SET search_path = public\n  AS $function$\n  DECLARE\n    v_booking RECORD;\n    v_zone_id uuid;\n    v_restaurant_id uuid;\n    v_service_date date;\n    v_lock_zone int4;\n    v_lock_date int4;\n    v_now timestamptz := timezone('utc', now());\n    v_table_ids uuid[];\n    v_table_count integer;\n    v_table RECORD;\n    v_loaded_count integer := 0;\n    v_slot_id uuid := NULL;\n    v_start_at timestamptz;\n    v_end_at timestamptz;\n    v_window tstzrange;\n    v_timezone text := NULL;\n    v_hold_conflict uuid;\n    v_merge_allocation_id uuid := NULL;\n    v_table_assignment_id uuid;\n    v_existing RECORD;\n    v_adjacency_count integer;\n    v_table_id uuid;\n    v_merge_group_supported boolean := false;\n  BEGIN\n    IF p_table_ids IS NULL OR array_length(p_table_ids, 1) = 0 THEN\n      RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one table id'\n        USING ERRCODE = '23514';\n    END IF;\n\n    SELECT array_agg(DISTINCT t.table_id ORDER BY t.table_id)\n    INTO v_table_ids\n    FROM unnest(p_table_ids) AS t(table_id);\n\n    IF v_table_ids IS NULL OR array_length(v_table_ids, 1) = 0 THEN\n      RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one valid table id'\n        USING ERRCODE = '23514';\n    END IF;\n\n    v_table_count := array_length(v_table_ids, 1);\n\n    SELECT\n      b.*,\n      r.timezone AS restaurant_timezone\n    INTO v_booking\n    FROM public.bookings b\n    LEFT JOIN public.restaurants r ON r.id = b.restaurant_id\n    WHERE b.id = p_booking_id\n    FOR UPDATE OF b;\n\n    IF NOT FOUND THEN\n      RAISE EXCEPTION 'Booking % not found', p_booking_id\n        USING ERRCODE = 'P0002';\n    END IF;\n\n    v_restaurant_id := v_booking.restaurant_id;\n    v_timezone := COALESCE(NULLIF(v_booking.restaurant_timezone, ''), 'UTC');\n\n    SELECT EXISTS (\n      SELECT 1\n      FROM information_schema.columns\n      WHERE table_schema = 'public'\n        AND table_name = 'booking_table_assignments'\n        AND column_name = 'merge_group_id'\n    )\n    INTO v_merge_group_supported;\n\n    IF v_booking.start_at IS NOT NULL AND v_booking.end_at IS NOT NULL THEN\n      v_start_at := v_booking.start_at;\n      v_end_at := v_booking.end_at;\n    ELSIF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL AND v_booking.end_time IS NOT NULL THEN\n      v_start_at := make_timestamptz(\n        EXTRACT(YEAR FROM v_booking.booking_date)::int,\n        EXTRACT(MONTH FROM v_booking.booking_date)::int,\n        EXTRACT(DAY FROM v_booking.booking_date)::int,\n        EXTRACT(HOUR FROM v_booking.start_time)::int,\n        EXTRACT(MINUTE FROM v_booking.start_time)::int,\n        EXTRACT(SECOND FROM v_booking.start_time),\n        v_timezone\n      );\n      v_end_at := make_timestamptz(\n        EXTRACT(YEAR FROM v_booking.booking_date)::int,\n        EXTRACT(MONTH FROM v_booking.booking_date)::int,\n        EXTRACT(DAY FROM v_booking.booking_date)::int,\n        EXTRACT(HOUR FROM v_booking.end_time)::int,\n        EXTRACT(MINUTE FROM v_booking.end_time)::int,\n        EXTRACT(SECOND FROM v_booking.end_time),\n        v_timezone\n      );\n    ELSE\n      RAISE EXCEPTION 'Booking % missing start/end window', p_booking_id\n        USING ERRCODE = '22000';\n    END IF;\n\n    IF v_start_at >= v_end_at THEN\n      RAISE EXCEPTION 'Booking % has invalid time window', p_booking_id\n        USING ERRCODE = '22000';\n    END IF;\n\n    v_window := tstzrange(v_start_at, v_end_at, '[)');\n\n    FOR v_table IN\n      SELECT id, restaurant_id, zone_id, active, status, mobility\n      FROM public.table_inventory\n      WHERE id = ANY (v_table_ids)\n      ORDER BY id\n      FOR UPDATE\n    LOOP\n      IF v_table.restaurant_id <> v_restaurant_id THEN\n        RAISE EXCEPTION 'Table % belongs to a different restaurant', v_table.id\n          USING ERRCODE = '23503';\n      END IF;\n\n      IF v_table.zone_id IS NULL THEN\n        RAISE EXCEPTION 'Table % is not assigned to a zone', v_table.id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_table.active IS NOT TRUE THEN\n        RAISE EXCEPTION 'Table % is inactive', v_table.id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_zone_id IS NULL THEN\n        v_zone_id := v_table.zone_id;\n      ELSIF v_zone_id <> v_table.zone_id THEN\n        RAISE EXCEPTION 'All tables must belong to the same zone (found %, expected %)', v_table.zone_id, v_zone_id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_table_count > 1 AND v_table.mobility <> 'movable'::public.table_mobility THEN\n        RAISE EXCEPTION 'Merged assignments require movable tables (% is %)', v_table.id, v_table.mobility\n          USING ERRCODE = '23514';\n      END IF;\n\n      v_loaded_count := v_loaded_count + 1;\n    END LOOP;\n\n    IF v_loaded_count <> v_table_count THEN\n      RAISE EXCEPTION 'Unable to load all requested tables for booking %', p_booking_id\n        USING ERRCODE = 'P0002';\n    END IF;\n\n    IF p_require_adjacency AND v_table_count > 1 THEN\n      FOR v_table IN\n        SELECT id FROM unnest(v_table_ids) AS t(id)\n      LOOP\n        SELECT COUNT(*)\n        INTO v_adjacency_count\n        FROM public.table_adjacencies\n        WHERE table_a = v_table.id\n          AND table_b = ANY (v_table_ids)\n          AND table_b <> v_table.id;\n\n        IF COALESCE(v_adjacency_count, 0) = 0 THEN\n          RAISE EXCEPTION 'Table % is not adjacent to the selected set', v_table.id\n            USING ERRCODE = '23514';\n        END IF;\n      END LOOP;\n    END IF;\n\n    v_service_date := v_booking.booking_date;\n    IF v_service_date IS NULL THEN\n      v_service_date := (v_start_at AT TIME ZONE v_timezone)::date;\n    END IF;\n\n    v_lock_zone := hashtext(COALESCE(v_zone_id::text, ''));\n    v_lock_date := COALESCE((v_service_date - DATE '2000-01-01')::int, 0);\n    PERFORM pg_advisory_xact_lock(v_lock_zone, v_lock_date);\n\n    IF p_idempotency_key IS NOT NULL THEN\n      SELECT *\n      INTO v_existing\n      FROM public.booking_assignment_idempotency\n      WHERE booking_id = p_booking_id\n        AND idempotency_key = p_idempotency_key;\n\n      IF FOUND THEN\n        IF v_existing.table_ids IS NULL OR array_length(v_existing.table_ids, 1) <> v_table_count\n           OR (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_existing.table_ids) AS e(elem))\n              <> (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_table_ids) AS e(elem)) THEN\n          RAISE EXCEPTION 'assign_tables_atomic_v2 idempotency mismatch for booking %', p_booking_id\n            USING ERRCODE = 'P0003',\n                  DETAIL = 'Idempotency key reuse detected with a different table set';\n        END IF;\n\n        RETURN QUERY\n          SELECT\n            bta.table_id,\n            lower(v_existing.assignment_window) AS start_at,\n            upper(v_existing.assignment_window) AS end_at,\n            v_existing.merge_group_allocation_id\n          FROM public.booking_table_assignments bta\n          WHERE bta.booking_id = p_booking_id\n            AND bta.idempotency_key = p_idempotency_key\n            AND bta.table_id = ANY (v_table_ids)\n          ORDER BY bta.table_id;\n\n        RETURN;\n      END IF;\n    END IF;\n\n    SELECT th.id\n    INTO v_hold_conflict\n    FROM public.table_holds th\n    JOIN public.table_hold_members thm ON thm.hold_id = th.id\n    WHERE thm.table_id = ANY (v_table_ids)\n      AND th.expires_at > v_now\n      AND (th.booking_id IS NULL OR th.booking_id <> p_booking_id)\n      AND tstzrange(th.start_at, th.end_at, '[)') && v_window\n    LIMIT 1;\n\n    IF FOUND THEN\n      RAISE EXCEPTION 'Hold conflict prevents assignment for booking %', p_booking_id\n        USING ERRCODE = 'P0001',\n              DETAIL = format('Hold % overlaps requested window', v_hold_conflict),\n              HINT = 'Retry after hold expiration or confirm existing hold.';\n    END IF;\n\n    IF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL THEN\n      SELECT id\n      INTO v_slot_id\n      FROM public.booking_slots\n      WHERE restaurant_id = v_restaurant_id\n        AND slot_date = v_booking.booking_date\n        AND slot_time = v_booking.start_time\n      LIMIT 1;\n\n      IF v_slot_id IS NULL THEN\n        SELECT public.get_or_create_booking_slot(v_restaurant_id, v_booking.booking_date, v_booking.start_time, 999)\n        INTO v_slot_id;\n      END IF;\n    END IF;\n\n    IF v_merge_group_supported AND v_table_count > 1 THEN\n      v_merge_allocation_id := gen_random_uuid();\n\n      BEGIN\n        INSERT INTO public.allocations (\n          id,\n          booking_id,\n          restaurant_id,\n          resource_type,\n          resource_id,\n          \"window\",\n          created_by,\n          shadow,\n          created_at,\n          updated_at\n        ) VALUES (\n          v_merge_allocation_id,\n          p_booking_id,\n          v_restaurant_id,\n          'merge_group',\n          v_merge_allocation_id,\n          v_window,\n          p_assigned_by,\n          false,\n          v_now,\n          v_now\n        )\n        ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n        SET \"window\" = EXCLUDED.\"window\",\n            created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n            updated_at = v_now;\n      EXCEPTION\n        WHEN unique_violation OR exclusion_violation THEN\n          RAISE EXCEPTION 'allocations_no_overlap'\n            USING ERRCODE = 'P0001',\n                  DETAIL = format('Merge group overlaps requested window for booking %s', p_booking_id);\n      END;\n    END IF;\n\n    FOREACH v_table_id IN ARRAY v_table_ids LOOP\n      IF v_merge_group_supported THEN\n        BEGIN\n          INSERT INTO public.booking_table_assignments (\n            booking_id,\n            table_id,\n            slot_id,\n            assigned_by,\n            idempotency_key,\n            merge_group_id\n          ) VALUES (\n            p_booking_id,\n            v_table_id,\n            v_slot_id,\n            p_assigned_by,\n            p_idempotency_key,\n            v_merge_allocation_id\n          )\n          ON CONFLICT ON CONSTRAINT booking_table_assignments_booking_table_key DO UPDATE\n          SET assigned_at = v_now,\n              assigned_by = COALESCE(EXCLUDED.assigned_by, public.booking_table_assignments.assigned_by),\n              idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n              merge_group_id = COALESCE(EXCLUDED.merge_group_id, public.booking_table_assignments.merge_group_id),\n              slot_id = COALESCE(EXCLUDED.slot_id, public.booking_table_assignments.slot_id)\n          RETURNING id INTO v_table_assignment_id;\n        EXCEPTION\n          WHEN unique_violation THEN\n            RAISE EXCEPTION 'assign_tables_atomic_v2 assignment duplicate for table %', v_table_id\n              USING ERRCODE = 'P0001';\n        END;\n      ELSE\n        BEGIN\n          INSERT INTO public.booking_table_assignments (\n            booking_id,\n            table_id,\n            slot_id,\n            assigned_by,\n            idempotency_key\n          ) VALUES (\n            p_booking_id,\n            v_table_id,\n            v_slot_id,\n            p_assigned_by,\n            p_idempotency_key\n          )\n          ON CONFLICT ON CONSTRAINT booking_table_assignments_booking_table_key DO UPDATE\n          SET assigned_at = v_now,\n              assigned_by = COALESCE(EXCLUDED.assigned_by, public.booking_table_assignments.assigned_by),\n              idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n              slot_id = COALESCE(EXCLUDED.slot_id, public.booking_table_assignments.slot_id)\n          RETURNING id INTO v_table_assignment_id;\n        EXCEPTION\n          WHEN unique_violation THEN\n            RAISE EXCEPTION 'assign_tables_atomic_v2 assignment duplicate for table %', v_table_id\n              USING ERRCODE = 'P0001';\n        END;\n      END IF;\n\n      BEGIN\n        INSERT INTO public.allocations (\n          booking_id,\n          restaurant_id,\n          resource_type,\n          resource_id,\n          \"window\",\n          created_by,\n          shadow,\n          created_at,\n          updated_at\n        ) VALUES (\n          p_booking_id,\n          v_restaurant_id,\n          'table',\n          v_table_id,\n          v_window,\n          p_assigned_by,\n          false,\n          v_now,\n          v_now\n        )\n        ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n        SET \"window\" = EXCLUDED.\"window\",\n            created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n            updated_at = v_now;\n      EXCEPTION\n        WHEN unique_violation OR exclusion_violation THEN\n          RAISE EXCEPTION 'allocations_no_overlap'\n            USING ERRCODE = 'P0001',\n                  DETAIL = format('Resource %s overlaps requested window for booking %s', v_table_id, p_booking_id);\n      END;\n\n      PERFORM public.refresh_table_status(v_table_id);\n\n      table_id := v_table_id;\n      start_at := v_start_at;\n      end_at := v_end_at;\n      merge_group_id := CASE WHEN v_merge_group_supported THEN v_merge_allocation_id ELSE NULL END;\n      RETURN NEXT;\n    END LOOP;\n\n    IF p_idempotency_key IS NOT NULL THEN\n      INSERT INTO public.booking_assignment_idempotency (\n        booking_id,\n        idempotency_key,\n        table_ids,\n        assignment_window,\n        merge_group_allocation_id,\n        created_at\n      ) VALUES (\n        p_booking_id,\n        p_idempotency_key,\n        v_table_ids,\n        v_window,\n        v_merge_allocation_id,\n        v_now\n      )\n      ON CONFLICT (booking_id, idempotency_key) DO NOTHING;\n    END IF;\n  END;\n  $function$;\n\n  ALTER FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid) OWNER TO postgres;\n  GRANT ALL ON FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid) TO service_role;\n\n  -- Also update get_or_create_booking_slot\n  CREATE OR REPLACE FUNCTION public.get_or_create_booking_slot(\n    p_restaurant_id uuid,\n    p_slot_date date,\n    p_slot_time time without time zone,\n    p_default_capacity integer DEFAULT 999\n  ) RETURNS uuid\n  LANGUAGE plpgsql\n  SECURITY DEFINER\n  AS $function$\n  DECLARE\n    v_slot_id uuid;\n    v_service_period_id uuid;\n    v_capacity integer;\n    v_rules_exist boolean := to_regclass('public.restaurant_capacity_rules') IS NOT NULL;\n  BEGIN\n    SELECT id\n    INTO v_slot_id\n    FROM public.booking_slots\n    WHERE restaurant_id = p_restaurant_id\n      AND slot_date = p_slot_date\n      AND slot_time = p_slot_time;\n\n    IF FOUND THEN\n      RETURN v_slot_id;\n    END IF;\n\n    SELECT id\n    INTO v_service_period_id\n    FROM public.restaurant_service_periods\n    WHERE restaurant_id = p_restaurant_id\n      AND (day_of_week IS NULL OR day_of_week = EXTRACT(DOW FROM p_slot_date)::smallint)\n      AND p_slot_time >= start_time\n      AND p_slot_time < end_time\n    ORDER BY day_of_week DESC NULLS LAST\n    LIMIT 1;\n\n    v_capacity := NULL;\n\n    IF v_rules_exist THEN\n      SELECT COALESCE(max_covers, p_default_capacity)\n      INTO v_capacity\n      FROM public.restaurant_capacity_rules\n      WHERE restaurant_id = p_restaurant_id\n        AND (service_period_id IS NULL OR service_period_id = v_service_period_id)\n        AND (day_of_week IS NULL OR day_of_week = EXTRACT(DOW FROM p_slot_date)::smallint)\n        AND (effective_date IS NULL OR effective_date <= p_slot_date)\n      ORDER BY\n        effective_date DESC NULLS LAST,\n        day_of_week DESC NULLS LAST,\n        service_period_id DESC NULLS LAST\n      LIMIT 1;\n    END IF;\n\n    v_capacity := COALESCE(v_capacity, p_default_capacity);\n\n    INSERT INTO public.booking_slots (\n      restaurant_id,\n      slot_date,\n      slot_time,\n      service_period_id,\n      available_capacity,\n      reserved_count\n    ) VALUES (\n      p_restaurant_id,\n      p_slot_date,\n      p_slot_time,\n      v_service_period_id,\n      v_capacity,\n      0\n    )\n    RETURNING id INTO v_slot_id;\n\n    RETURN v_slot_id;\n  END;\n  $function$;\n\n  ALTER FUNCTION public.get_or_create_booking_slot(uuid, date, time without time zone, integer) OWNER TO postgres;\n  GRANT ALL ON FUNCTION public.get_or_create_booking_slot(uuid, date, time without time zone, integer) TO service_role;\n  COMMENT ON FUNCTION public.get_or_create_booking_slot(uuid, date, time without time zone, integer)\n    IS 'Get existing slot or create new one with capacity override fallback (works even if restaurant_capacity_rules is absent).';\nEND;\n$$;\n"
    }
  ]
}
