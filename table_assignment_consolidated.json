{
  "generatedAt": "2025-10-31T12:15:53.414Z",
  "files": [
    {
      "path": "server/capacity/index.ts",
      "content": "/**\n * Capacity & Availability Engine - Public API\n * Story 2: Service Layer Exports\n * \n * Import from this file to use the capacity engine:\n * \n * @example\n * ```typescript\n * import {\n *   checkSlotAvailability,\n *   createBookingWithCapacityCheck,\n *   findAlternativeSlots,\n * } from '@/server/capacity';\n * \n * const result = await checkSlotAvailability({\n *   restaurantId: 'uuid',\n *   date: '2025-10-20',\n *   time: '19:00',\n *   partySize: 4\n * });\n * ```\n */\n\n// =====================================================\n// Main Services\n// =====================================================\n\nexport {\n  checkSlotAvailability,\n  findAlternativeSlots,\n  calculateCapacityUtilization,\n  getServicePeriodsWithCapacity,\n} from \"./service\";\n\nexport {\n  createBookingWithCapacityCheck,\n  updateBookingWithCapacityCheck,\n  createBookingOrThrow,\n  retryWithBackoff,\n  isRetryableBookingError,\n  getBookingErrorMessage,\n} from \"./transaction\";\n\nexport {\n  findSuitableTables,\n  assignTableToBooking,\n  unassignTableFromBooking,\n  getBookingTableAssignments,\n  autoAssignTables,\n  autoAssignTablesForDate,\n  isTableAvailable,\n  evaluateManualSelection,\n  createManualHold,\n  ManualSelectionInputError,\n} from \"./tables\";\n\nexport {\n  defaultVenuePolicy,\n  getVenuePolicy,\n  whichService,\n  bandDuration,\n  serviceEnd,\n  ServiceNotFoundError,\n  ServiceOverrunError,\n  PolicyError,\n  getSelectorScoringConfig,\n} from \"./policy\";\n\nexport {\n  calculateRestaurantCapacityByService,\n  calculateCapacityForTables,\n  type ServiceCapacitySummary,\n  type TableRotationDetail,\n} from \"./rotations\";\n\nexport {\n  validateBookingWindow,\n  type BookingValidationInput,\n  type BookingValidationResult,\n} from \"./validation\";\n\n// =====================================================\n// Types\n// =====================================================\n\nexport type {\n  // Availability\n  AvailabilityCheckParams,\n  AvailabilityResult,\n  AlternativeSlotParams,\n  TimeSlot,\n  CapacityMetadata,\n  \n  // Booking Transaction\n  CreateBookingParams,\n  UpdateBookingParams,\n  BookingResult,\n  BookingRecord,\n  BookingErrorCode,\n  BookingErrorDetails,\n  CapacityInfo,\n  \n  // Service Periods\n  ServicePeriodWithCapacity,\n  PeriodUtilization,\n  SelectorScoringConfig,\n  SelectorScoringWeights,\n  \n  // Retry\n  RetryConfig,\n} from \"./types\";\n\nexport type {\n  // Tables (v2)\n  Table,\n  TableMatchParams,\n  TableAssignmentMember,\n  TableAssignmentGroup,\n  AutoAssignResult,\n  SelectorDecisionCapture,\n  ManualSelectionCheck,\n  ManualSelectionSummary,\n  ManualValidationResult,\n  ManualHoldResult,\n  ManualSelectionOptions,\n  ManualHoldOptions,\n} from \"./tables\";\n\nexport {\n  // Error Classes\n  CapacityError,\n  CapacityExceededError,\n  BookingConflictError,\n  \n  // Constants\n  DEFAULT_RETRY_CONFIG,\n} from \"./types\";\n"
    },
    {
      "path": "server/capacity/tables.ts",
      "content": "import { DateTime } from \"luxon\";\nimport { randomUUID } from \"node:crypto\";\nimport { promises as fs } from \"node:fs\";\nimport path from \"node:path\";\nimport { performance } from \"node:perf_hooks\";\n\nimport { BOOKING_BLOCKING_STATUSES } from \"@/lib/enums\";\nimport {\n  getAllocatorAdjacencyMinPartySize,\n  getAllocatorKMax as getAllocatorCombinationLimit,\n  getSelectorPlannerLimits,\n  isAllocatorAdjacencyRequired,\n  isAllocatorMergesEnabled,\n  isAllocatorServiceFailHard,\n  isAllocatorV2Enabled,\n  isCombinationPlannerEnabled,\n  isHoldsEnabled,\n  isHoldStrictConflictsEnabled,\n  isPlannerTimePruningEnabled,\n  isAdjacencyQueryUndirected,\n  isOpsMetricsEnabled,\n  isSelectorScoringEnabled,\n  isSelectorLookaheadEnabled,\n  getSelectorLookaheadWindowMinutes,\n  getSelectorLookaheadPenaltyWeight,\n} from \"@/server/feature-flags\";\nimport { getServiceSupabaseClient } from \"@/server/supabase\";\n\nimport {\n  AssignTablesRpcError,\n  HoldConflictError,\n  HoldNotFoundError,\n  createTableHold,\n  findHoldConflicts,\n  listActiveHoldsForBooking,\n  releaseTableHold,\n  type CreateTableHoldInput,\n  type HoldConflictInfo,\n  type TableHold,\n} from \"./holds\";\nimport { createAvailabilityBitset, markWindow, isWindowFree } from \"./planner/bitset\";\nimport {\n  bandDuration,\n  getBufferConfig,\n  getSelectorScoringConfig,\n  getVenuePolicy,\n  getYieldManagementScarcityWeight,\n  serviceEnd,\n  whichService,\n  type SelectorScoringConfig,\n  type ServiceKey,\n  type VenuePolicy,\n  ServiceNotFoundError,\n  ServiceOverrunError,\n} from \"./policy\";\nimport { loadStrategicConfig } from \"./strategic-config\";\nimport {\n  buildScoredTablePlans,\n  type RankedTablePlan,\n  type CandidateDiagnostics,\n  type BuildCandidatesResult,\n  type ScoreBreakdown,\n} from \"./selector\";\nimport {\n  buildSelectorDecisionPayload,\n  emitHoldConfirmed,\n  emitRpcConflict,\n  emitSelectorDecision,\n  emitSelectorQuote,\n  summarizeCandidate,\n  type CandidateSummary,\n  type SelectorDecisionCapture,\n  type SelectorDecisionEvent,\n  type StrategicPenaltyTelemetry,\n} from \"./telemetry\";\nimport {\n  AssignmentConflictError,\n  AssignmentOrchestrator,\n  AssignmentRepositoryError,\n  AssignmentValidationError,\n  SupabaseAssignmentRepository,\n  createPlanSignature,\n  normalizeTableIds,\n} from \"./v2\";\nimport { resolveDemandMultiplier, type DemandMultiplierResult } from \"./demand-profiles\";\nimport { loadTableScarcityScores } from \"./scarcity\";\n\nimport type { Database, Tables } from \"@/types/supabase\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\n\nexport type { SelectorDecisionCapture } from \"./telemetry\";\n\ntype DbClient = SupabaseClient<Database, \"public\">;\n\ntype TableInventoryRow = Tables<\"table_inventory\">;\n\nconst TABLE_INVENTORY_SELECT =\n  \"id,table_number,capacity,min_party_size,max_party_size,section,category,seating_type,mobility,zone_id,status,active,position\" as const;\n\ntype TableHoldRow = Tables<\"table_holds\"> & {\n  table_hold_members: Array<{ table_id: string | null }> | null;\n};\n\n\ntype AssignmentAvailabilityRow = {\n  table_id: string | null;\n  start_at: string | null;\n  end_at: string | null;\n  bookings: Pick<Tables<\"bookings\">, \"id\" | \"status\" | \"start_at\" | \"end_at\"> | null;\n};\n\nconst DEFAULT_HOLD_TTL_SECONDS = 180;\nconst TABLE_RESOURCE_TYPE = \"table\";\n\nexport type Table = {\n  id: string;\n  tableNumber: string;\n  capacity: number;\n  minPartySize?: number | null;\n  maxPartySize?: number | null;\n  section?: string | null;\n  category?: Tables<\"table_inventory\">[\"category\"] | string | null;\n  seatingType?: Tables<\"table_inventory\">[\"seating_type\"] | string | null;\n  mobility?: Tables<\"table_inventory\">[\"mobility\"] | string | null;\n  zoneId: string;\n  status?: Tables<\"table_inventory\">[\"status\"] | string | null;\n  active?: boolean | null;\n  position?: Tables<\"table_inventory\">[\"position\"] | null;\n};\n\nexport type TableMatchParams = {\n  partySize: number;\n  requireAdjacency?: boolean;\n  avoidTableIds?: string[];\n  zoneId?: string | null;\n};\n\nexport type TableAssignmentMember = {\n  tableId: string;\n  assignmentId: string;\n  startAt: string;\n  endAt: string;\n  mergeGroupId?: string | null;\n};\n\nexport type TableAssignmentGroup = {\n  bookingId: string;\n  tableIds: string[];\n  assignments: TableAssignmentMember[];\n};\n\nexport type ManualSelectionCheck = {\n  id: \"capacity\" | \"zone\" | \"movable\" | \"adjacency\" | \"conflict\" | \"holds\";\n  status: \"ok\" | \"warning\" | \"error\";\n  message: string;\n  details?: Record<string, unknown>;\n};\n\nexport type ManualSelectionSummary = {\n  tableCount: number;\n  totalCapacity: number;\n  slack: number;\n  zoneId: string | null;\n  tableNumbers: string[];\n  partySize: number;\n};\n\nexport type ManualValidationResult = {\n  ok: boolean;\n  summary: ManualSelectionSummary;\n  checks: ManualSelectionCheck[];\n};\n\nexport type ManualSelectionOptions = {\n  bookingId: string;\n  tableIds: string[];\n  requireAdjacency?: boolean;\n  excludeHoldId?: string | null;\n  client?: DbClient;\n};\n\nexport type ManualHoldOptions = ManualSelectionOptions & {\n  createdBy: string;\n  holdTtlSeconds?: number;\n  holdExpiresAt?: string;\n};\n\nexport type ManualHoldResult = {\n  hold: TableHold | null;\n  validation: ManualValidationResult;\n};\n\nfunction buildSelectorFeatureFlagsTelemetry(): {\n  selectorScoring: boolean;\n  opsMetrics: boolean;\n  plannerTimePruning: boolean;\n  adjacencyUndirected: boolean;\n  holdsStrictConflicts: boolean;\n  allocatorFailHard: boolean;\n  selectorLookahead: boolean;\n} {\n  return {\n    selectorScoring: isSelectorScoringEnabled(),\n    opsMetrics: isOpsMetricsEnabled(),\n    plannerTimePruning: isPlannerTimePruningEnabled(),\n    adjacencyUndirected: isAdjacencyQueryUndirected(),\n    holdsStrictConflicts: isHoldStrictConflictsEnabled(),\n    allocatorFailHard: isAllocatorServiceFailHard(),\n    selectorLookahead: isSelectorLookaheadEnabled(),\n  };\n}\n\nexport type AutoAssignResult = {\n  assigned: Array<{ bookingId: string; tableIds: string[] }>;\n  skipped: Array<{ bookingId: string; reason: string }>;\n  serviceFallbacks: Array<{ bookingId: string; usedFallback: boolean; fallbackService: ServiceKey | null }>;\n  decisions?: SelectorDecisionCapture[];\n};\n\nexport type QuoteTablesOptions = {\n  bookingId: string;\n  zoneId?: string | null;\n  maxTables?: number;\n  requireAdjacency?: boolean;\n  avoidTables?: string[];\n  holdTtlSeconds?: number;\n  createdBy: string;\n  client?: DbClient;\n};\n\nexport type QuoteTablesResult = {\n  hold: TableHold | null;\n  candidate: CandidateSummary | null;\n  alternates: CandidateSummary[];\n  nextTimes: string[];\n  reason?: string;\n  skipped?: Array<{ candidate: CandidateSummary; reason: string; conflicts: HoldConflictInfo[] }>;\n  metadata?: {\n    usedFallback: boolean;\n    fallbackService: ServiceKey | null;\n  };\n};\n\nexport type ManualAssignmentConflict = {\n  tableId: string;\n  bookingId: string | null;\n  startAt: string;\n  endAt: string;\n  source: \"booking\" | \"hold\";\n};\n\nexport type ManualAssignmentContextHold = TableHold & {\n  createdByName?: string | null;\n  createdByEmail?: string | null;\n  summary?: ManualSelectionSummary;\n};\n\nexport type ManualAssignmentContext = {\n  booking: Tables<\"bookings\">;\n  tables: Table[];\n  bookingAssignments: string[];\n  holds: ManualAssignmentContextHold[];\n  activeHold: ManualAssignmentContextHold | null;\n  conflicts: ManualAssignmentConflict[];\n  window: {\n    startAt: string | null;\n    endAt: string | null;\n  };\n};\n\ntype BookingRow = Tables<\"bookings\"> & {\n  restaurants?: { timezone: string | null } | { timezone: string | null }[];\n};\n\ntype ContextBookingRow = {\n  id: string;\n  party_size: number;\n  status: string;\n  start_time: string | null;\n  end_time: string | null;\n  start_at: string | null;\n  end_at: string | null;\n  booking_date: string | null;\n  seating_preference?: string | null;\n  booking_table_assignments: Array<{ table_id: string | null }> | null;\n};\n\ntype BusyWindow = {\n  tableId: string;\n  startAt: string;\n  endAt: string;\n  bookingId: string | null;\n  source: \"booking\" | \"hold\";\n};\n\ntype AvailabilityMap = Map<\n  string,\n  {\n    bitset: ReturnType<typeof createAvailabilityBitset>;\n    windows: BusyWindow[];\n  }\n>;\n\nexport class ManualSelectionInputError extends Error {\n  constructor(\n    message: string,\n    public readonly code: string = \"MANUAL_SELECTION_INPUT_INVALID\",\n    public readonly status = 400,\n  ) {\n    super(message);\n    this.name = \"ManualSelectionInputError\";\n  }\n}\n\nfunction ensureClient(client?: DbClient): DbClient {\n  return client ?? getServiceSupabaseClient();\n}\n\nfunction extractErrorCode(error: unknown): string | undefined {\n  if (typeof error !== \"object\" || error === null) {\n    return undefined;\n  }\n  const code = (error as { code?: unknown }).code;\n  return typeof code === \"string\" ? code : undefined;\n}\n\nfunction normalizeBookingRow(row: BookingRow): BookingRow {\n  if (Array.isArray(row.restaurants) && row.restaurants.length > 0) {\n    return { ...row, restaurants: row.restaurants[0] ?? null };\n  }\n  return row;\n}\n\nasync function releaseHoldWithRetry(params: { holdId: string; client: DbClient; attempts?: number; baseDelayMs?: number }): Promise<void> {\n  const { holdId, client, attempts = 3, baseDelayMs = 50 } = params;\n  for (let attempt = 1; attempt <= attempts; attempt += 1) {\n    try {\n      await releaseTableHold({ holdId, client });\n      return;\n    } catch (error) {\n      if (attempt === attempts) {\n        throw error;\n      }\n      const jitter = Math.random() * baseDelayMs;\n      const delay = baseDelayMs * attempt + jitter;\n      await new Promise((resolve) => setTimeout(resolve, delay));\n    }\n  }\n}\n\nexport type BookingWindow = ReturnType<typeof computeBookingWindow>;\n\ntype BookingWindowWithFallback = {\n  window: BookingWindow;\n  usedFallback: boolean;\n  fallbackService: ServiceKey | null;\n};\n\nexport function computeBookingWindow(args: {\n  startISO?: string | null;\n  bookingDate?: string | null;\n  startTime?: string | null;\n  partySize: number;\n  policy?: VenuePolicy;\n  serviceHint?: ServiceKey | null;\n}): {\n  service: ServiceKey;\n  durationMinutes: number;\n  dining: {\n    start: DateTime;\n    end: DateTime;\n  };\n  block: {\n    start: DateTime;\n    end: DateTime;\n  };\n} {\n  const policy = args.policy ?? getVenuePolicy();\n  const baseStart = resolveStartDateTime(args, policy);\n  const service = resolveService(baseStart, args.serviceHint ?? null, policy);\n\n  const diningMinutes = bandDuration(service, args.partySize, policy);\n  const buffer = getBufferConfig(service, policy);\n  const diningStart = baseStart;\n  const diningEnd = diningStart.plus({ minutes: diningMinutes });\n  const blockStart = diningStart.minus({ minutes: buffer.pre ?? 0 });\n  const blockEnd = diningEnd.plus({ minutes: buffer.post ?? 0 });\n\n  const serviceEndBoundary = serviceEnd(service, diningStart, policy);\n  if (blockEnd > serviceEndBoundary) {\n    throw new ServiceOverrunError(service, blockEnd, serviceEndBoundary);\n  }\n\n  return {\n    service,\n    durationMinutes: diningMinutes,\n    dining: {\n      start: diningStart,\n      end: diningEnd,\n    },\n    block: {\n      start: blockStart,\n      end: blockEnd,\n    },\n  };\n}\n\ntype ComputeWindowArgs = {\n  startISO?: string | null;\n  bookingDate?: string | null;\n  startTime?: string | null;\n  partySize: number;\n  policy?: VenuePolicy;\n  serviceHint?: ServiceKey | null;\n};\n\nfunction computeBookingWindowWithFallback(args: ComputeWindowArgs): BookingWindowWithFallback {\n  const policy = args.policy ?? getVenuePolicy();\n  try {\n    const window = computeBookingWindow({ ...args, policy });\n    return {\n      window,\n      usedFallback: false,\n      fallbackService: null,\n    };\n  } catch (error) {\n    if (error instanceof ServiceNotFoundError) {\n      const serviceOrderCandidates = policy.serviceOrder.filter((key) => Boolean(policy.services[key]));\n      const servicesFallback = (Object.keys(policy.services) as ServiceKey[]).filter((key) =>\n        Boolean(policy.services[key]),\n      );\n      const fallbackService =\n        args.serviceHint && policy.services[args.serviceHint]\n          ? args.serviceHint\n          : serviceOrderCandidates[0] ?? servicesFallback[0];\n\n      if (!fallbackService || !policy.services[fallbackService]) {\n        throw error;\n      }\n\n      if (isAllocatorServiceFailHard()) {\n        throw error;\n      }\n\n      const baseStart = resolveStartDateTime(args, policy);\n      const durationMinutes = bandDuration(fallbackService, args.partySize, policy);\n      const buffer = getBufferConfig(fallbackService, policy);\n      const diningStart = baseStart;\n      const diningEnd = diningStart.plus({ minutes: durationMinutes });\n      const blockStart = diningStart.minus({ minutes: buffer.pre ?? 0 });\n      const blockEnd = diningEnd.plus({ minutes: buffer.post ?? 0 });\n      const serviceEndBoundary = serviceEnd(fallbackService, diningStart, policy);\n      if (blockEnd > serviceEndBoundary) {\n        throw new ServiceOverrunError(fallbackService, blockEnd, serviceEndBoundary);\n      }\n\n      console.warn(\"[capacity][window][fallback] service not found, using fallback service\", {\n        start: baseStart.toISO(),\n        fallbackService,\n      });\n\n      const window: BookingWindow = {\n        service: fallbackService,\n        durationMinutes,\n        dining: {\n          start: diningStart,\n          end: diningEnd,\n        },\n        block: {\n          start: blockStart,\n          end: blockEnd,\n        },\n      };\n\n      return {\n        window,\n        usedFallback: true,\n        fallbackService,\n      };\n    }\n\n    throw error;\n  }\n}\n\nfunction resolveStartDateTime(\n  args: {\n    startISO?: string | null;\n    bookingDate?: string | null;\n    startTime?: string | null;\n  },\n  policy: VenuePolicy,\n): DateTime {\n  if (args.startISO) {\n    const parsed = DateTime.fromISO(args.startISO);\n    if (!parsed.isValid) {\n      throw new ManualSelectionInputError(\"Invalid start ISO timestamp provided\", \"INVALID_START\");\n    }\n    return parsed.setZone(policy.timezone, { keepLocalTime: false });\n  }\n\n  const { bookingDate, startTime } = args;\n  if (!bookingDate || !startTime) {\n    throw new ManualSelectionInputError(\"Booking date and start time are required\", \"START_TIME_REQUIRED\");\n  }\n\n  const composed = DateTime.fromISO(`${bookingDate}T${startTime}`, { zone: policy.timezone });\n  if (!composed.isValid) {\n    throw new ManualSelectionInputError(\"Invalid booking date/time\", \"INVALID_START\");\n  }\n  return composed;\n}\n\nfunction resolveService(start: DateTime, hint: ServiceKey | null, policy: VenuePolicy): ServiceKey {\n  if (hint) {\n    return hint;\n  }\n  const found = whichService(start, policy);\n  if (!found) {\n    throw new ServiceNotFoundError(start);\n  }\n  return found;\n}\n\ntype IntervalPoint = DateTime | string | number;\ntype IntervalLike = {\n  start: IntervalPoint;\n  end: IntervalPoint;\n};\n\nfunction intervalPointToMillis(point: IntervalPoint): number | null {\n  if (DateTime.isDateTime(point)) {\n    const value = point.toMillis();\n    return Number.isFinite(value) ? value : null;\n  }\n\n  if (typeof point === \"number\") {\n    return Number.isFinite(point) ? point : null;\n  }\n\n  if (typeof point === \"string\") {\n    const parsed = DateTime.fromISO(point, { setZone: true });\n    if (!parsed.isValid) {\n      return null;\n    }\n    const value = parsed.toMillis();\n    return Number.isFinite(value) ? value : null;\n  }\n\n  return null;\n}\n\nfunction normalizeInterval(interval: IntervalLike): { start: number; end: number } | null {\n  const start = intervalPointToMillis(interval.start);\n  const end = intervalPointToMillis(interval.end);\n  if (start === null || end === null) {\n    return null;\n  }\n  if (!(start < end)) {\n    return null;\n  }\n  return { start, end };\n}\n\nfunction highResNow(): number {\n  return typeof performance !== \"undefined\" ? performance.now() : Date.now();\n}\n\nfunction roundMilliseconds(value: number): number {\n  return Math.round(value * 100) / 100;\n}\n\nconst AUTO_ASSIGN_LOG_ROOT = process.env.AUTO_ASSIGN_LOG_ROOT ?? path.join(process.cwd(), \"logs\");\nconst AUTO_ASSIGN_LOG_DIR =\n  process.env.AUTO_ASSIGN_LOG_DIR ?? path.join(AUTO_ASSIGN_LOG_ROOT, process.env.AUTO_ASSIGN_LOG_SUBDIR ?? \"auto-assign\");\n\nconst STRATEGIC_SKIP_REASON_PATTERNS = [\n  /conflicts with existing/i,\n  /future conflict/i,\n  /lookahead/i,\n  /strategic/i,\n];\n\ntype ScoreBreakdownLike = ScoreBreakdown | CandidateSummary[\"scoreBreakdown\"] | null | undefined;\n\nfunction isCamelCaseBreakdown(breakdown: ScoreBreakdownLike): breakdown is ScoreBreakdown {\n  return Boolean(breakdown && typeof breakdown === \"object\" && \"slackPenalty\" in breakdown);\n}\n\nfunction isSnakeCaseBreakdown(\n  breakdown: ScoreBreakdownLike,\n): breakdown is NonNullable<CandidateSummary[\"scoreBreakdown\"]> {\n  return Boolean(breakdown && typeof breakdown === \"object\" && \"slack_penalty\" in breakdown);\n}\n\nfunction extractStrategicPenalties(breakdown: ScoreBreakdownLike): StrategicPenaltyTelemetry | null {\n  if (!breakdown) {\n    return null;\n  }\n\n  let slack = 0;\n  let scarcity = 0;\n  let futureConflict = 0;\n\n  if (isCamelCaseBreakdown(breakdown)) {\n    slack = Number(breakdown.slackPenalty ?? 0);\n    scarcity = Number(breakdown.scarcityPenalty ?? 0);\n    futureConflict = Number(breakdown.futureConflictPenalty ?? 0);\n  } else if (isSnakeCaseBreakdown(breakdown)) {\n    slack = Number(breakdown.slack_penalty ?? 0);\n    scarcity = Number(breakdown.scarcity_penalty ?? 0);\n    futureConflict = Number(breakdown.future_conflict_penalty ?? 0);\n  } else {\n    return null;\n  }\n\n  const contributions: Array<[StrategicPenaltyTelemetry[\"dominant\"], number]> = [\n    [\"slack\", slack],\n    [\"scarcity\", scarcity],\n    [\"future_conflict\", futureConflict],\n  ];\n\n  let dominant: StrategicPenaltyTelemetry[\"dominant\"] = \"unknown\";\n  let maxContribution = 0;\n\n  for (const [key, value] of contributions) {\n    if (value > maxContribution) {\n      maxContribution = value;\n      dominant = key;\n    }\n  }\n\n  if (maxContribution <= 0) {\n    dominant = \"unknown\";\n  }\n\n  return {\n    dominant,\n    slack,\n    scarcity,\n    futureConflict,\n  };\n}\n\ntype RejectionTelemetry = {\n  classification: \"hard\" | \"strategic\";\n  penalties: StrategicPenaltyTelemetry | null;\n};\n\nfunction determineRejectionTelemetry(\n  skipReason: string | null | undefined,\n  breakdown: ScoreBreakdownLike,\n): RejectionTelemetry | null {\n  const reason = (skipReason ?? \"\").trim();\n  const normalized = reason.toLowerCase();\n  const penalties = extractStrategicPenalties(breakdown);\n  const hasMeaningfulPenalty = Boolean(\n    penalties && (penalties.slack > 0 || penalties.scarcity > 0 || penalties.futureConflict > 0),\n  );\n  const matchesStrategicKeyword =\n    normalized.length > 0 && STRATEGIC_SKIP_REASON_PATTERNS.some((pattern) => pattern.test(normalized));\n\n  if (hasMeaningfulPenalty || matchesStrategicKeyword) {\n    return {\n      classification: \"strategic\",\n      penalties: penalties ?? null,\n    };\n  }\n\n  if (!reason) {\n    return null;\n  }\n\n  return {\n    classification: \"hard\",\n    penalties: null,\n  };\n}\n\nasync function persistDecisionSnapshots(params: {\n  restaurantId: string;\n  slug?: string | null;\n  date: string;\n  decisions: SelectorDecisionCapture[];\n}): Promise<void> {\n  if (params.decisions.length === 0) {\n    return;\n  }\n\n  if (process.env.NODE_ENV === \"test\") {\n    return;\n  }\n\n  try {\n    const timestamp = DateTime.utc().toFormat(\"yyyyLLdd-HHmmss\");\n    const safeSlugSource = (params.slug && params.slug.trim().length > 0 ? params.slug : params.restaurantId) ?? params.restaurantId;\n    const safeSlug = safeSlugSource.replace(/[^a-zA-Z0-9-_]/g, \"_\").toLowerCase();\n    const bookingSegment = params.date.replace(/[^a-zA-Z0-9-_]/g, \"_\");\n    const decisionSegment = `${String(params.decisions.length).padStart(2, \"0\")}dec`;\n    const timestampDir = path.join(AUTO_ASSIGN_LOG_DIR, \"log\", timestamp);\n    await fs.mkdir(timestampDir, { recursive: true });\n    const filePath = path.join(timestampDir, `${safeSlug}-${bookingSegment}-${decisionSegment}.json`);\n    const payload = {\n      generatedAt: new Date().toISOString(),\n      restaurantId: params.restaurantId,\n      restaurantSlug: params.slug ?? null,\n      date: params.date,\n      decisionCount: params.decisions.length,\n      decisions: params.decisions,\n    };\n    await fs.writeFile(filePath, JSON.stringify(payload, null, 2), \"utf8\");\n  } catch (error) {\n    console.error(\"[auto-assign][capture] failed to persist decisions\", {\n      error: error instanceof Error ? error.message : String(error),\n      restaurantId: params.restaurantId,\n      date: params.date,\n    });\n  }\n}\n\nfunction buildTiming(params: {\n  totalMs: number;\n  plannerMs?: number;\n  assignmentMs?: number;\n  holdMs?: number;\n}): SelectorDecisionEvent[\"timing\"] {\n  const timing: SelectorDecisionEvent[\"timing\"] = {\n    totalMs: roundMilliseconds(params.totalMs),\n  };\n\n  if (typeof params.plannerMs === \"number\" && params.plannerMs > 0) {\n    timing.plannerMs = roundMilliseconds(params.plannerMs);\n  }\n  if (typeof params.assignmentMs === \"number\" && params.assignmentMs > 0) {\n    timing.assignmentMs = roundMilliseconds(params.assignmentMs);\n  }\n  if (typeof params.holdMs === \"number\" && params.holdMs > 0) {\n    timing.holdMs = roundMilliseconds(params.holdMs);\n  }\n\n  return timing;\n}\n\n/**\n * Normalizes planner configuration details so telemetry consumers receive a\n * consistent view of the limits and feature toggles that influenced a search.\n */\nfunction composePlannerConfig(params: {\n  diagnostics: CandidateDiagnostics;\n  scoringConfig: SelectorScoringConfig;\n  combinationEnabled: boolean;\n  requireAdjacency: boolean;\n  adjacencyRequiredGlobally: boolean;\n  adjacencyMinPartySize: number | null;\n  featureFlags: ReturnType<typeof buildSelectorFeatureFlagsTelemetry>;\n  serviceFallback: {\n    usedFallback: boolean;\n    fallbackService: ServiceKey | null;\n  };\n  demandMultiplier: number;\n  demandRule?: DemandMultiplierResult[\"rule\"];\n  lookahead: Pick<LookaheadConfig, \"enabled\" | \"windowMinutes\" | \"penaltyWeight\">;\n}): NonNullable<SelectorDecisionEvent[\"plannerConfig\"]> {\n  const { diagnostics, scoringConfig } = params;\n  const { limits } = diagnostics;\n\n  return {\n    combinationEnabled: params.combinationEnabled,\n    requireAdjacency: params.requireAdjacency,\n    adjacencyRequiredGlobally: params.adjacencyRequiredGlobally,\n    adjacencyMinPartySize: params.adjacencyMinPartySize,\n    kMax: limits.kMax,\n   bucketLimit: limits.maxPlansPerSlack,\n   evaluationLimit: limits.maxCombinationEvaluations,\n   maxOverage: scoringConfig.maxOverage,\n   maxTables: scoringConfig.maxTables,\n    weights: {\n      overage: scoringConfig.weights.overage,\n      tableCount: scoringConfig.weights.tableCount,\n      fragmentation: scoringConfig.weights.fragmentation,\n      zoneBalance: scoringConfig.weights.zoneBalance,\n      adjacencyCost: scoringConfig.weights.adjacencyCost,\n      scarcity: scoringConfig.weights.scarcity,\n    },\n    featureFlags: {\n      plannerTimePruning: params.featureFlags.plannerTimePruning,\n      adjacencyUndirected: params.featureFlags.adjacencyUndirected,\n      holdsStrictConflicts: params.featureFlags.holdsStrictConflicts,\n      allocatorFailHard: params.featureFlags.allocatorFailHard,\n      selectorScoring: params.featureFlags.selectorScoring,\n      opsMetrics: params.featureFlags.opsMetrics,\n      selectorLookahead: params.featureFlags.selectorLookahead,\n    },\n    serviceFallback: {\n      used: params.serviceFallback.usedFallback,\n      service: params.serviceFallback.fallbackService,\n    },\n    demandMultiplier: params.demandMultiplier,\n    demandRule: params.demandRule\n      ? {\n          label: params.demandRule.label ?? null,\n          source: params.demandRule.source,\n          serviceWindow: params.demandRule.serviceWindow ?? null,\n          days: params.demandRule.days,\n          start: params.demandRule.start ?? null,\n          end: params.demandRule.end ?? null,\n          priority: params.demandRule.priority ?? null,\n        }\n      : null,\n    lookahead: {\n      enabled: params.lookahead.enabled,\n      windowMinutes: params.lookahead.windowMinutes,\n      penaltyWeight: params.lookahead.penaltyWeight,\n    },\n  };\n}\n\n/**\n * Returns whether the half-open interval `[a.start, a.end)` intersects with `[b.start, b.end)`.\n *\n * Accepts ISO strings, Luxon {@link DateTime} instances, or epoch millisecond numbers.\n * Values are normalized to UTC and invalid intervals are treated as non-overlapping.\n */\nexport function windowsOverlap(a: IntervalLike, b: IntervalLike): boolean {\n  const first = normalizeInterval(a);\n  const second = normalizeInterval(b);\n  if (!first || !second) {\n    return false;\n  }\n\n  return first.start < second.end && second.start < first.end;\n}\n\nfunction toIsoUtc(dateTime: DateTime): string {\n  return (\n    dateTime.toUTC().toISO({ suppressMilliseconds: true }) ??\n    dateTime.toUTC().toISO() ??\n    dateTime.toUTC().toString()\n  );\n}\n\ntype TimeFilterMode = \"strict\" | \"approx\";\n\ntype TimeFilterStats = {\n  prunedByTime: number;\n  candidatesAfterTimePrune: number;\n  pruned_by_time: number;\n  candidates_after_time_prune: number;\n};\n\ntype TimeFilterOptions = {\n  busy: AvailabilityMap;\n  mode?: TimeFilterMode;\n  captureStats?: (stats: TimeFilterStats) => void;\n};\n\nfunction normalizeIsoString(value: string | null | undefined): string | null {\n  if (!value) {\n    return null;\n  }\n  const parsed = DateTime.fromISO(value);\n  if (!parsed.isValid) {\n    return null;\n  }\n  return toIsoUtc(parsed);\n}\n\nfunction filterTimeAvailableTables(\n  tables: Table[],\n  window: BookingWindow,\n  busy: AvailabilityMap | undefined,\n  mode: TimeFilterMode,\n  captureStats?: (stats: TimeFilterStats) => void,\n): Table[] {\n  if (!busy || busy.size === 0 || mode === \"approx\") {\n    captureStats?.({\n      prunedByTime: 0,\n      candidatesAfterTimePrune: tables.length,\n      pruned_by_time: 0,\n      candidates_after_time_prune: tables.length,\n    });\n    return tables;\n  }\n\n  const targetStart = toIsoUtc(window.block.start);\n  const targetEnd = toIsoUtc(window.block.end);\n  let prunedByTime = 0;\n\n  const filtered = tables.filter((table) => {\n    const entry = busy.get(table.id);\n    if (!entry) {\n      return true;\n    }\n    const free = isWindowFree(entry.bitset, targetStart, targetEnd);\n    if (!free) {\n      prunedByTime += 1;\n      return false;\n    }\n    return true;\n  });\n\n  captureStats?.({\n    prunedByTime,\n    candidatesAfterTimePrune: filtered.length,\n    pruned_by_time: prunedByTime,\n    candidates_after_time_prune: filtered.length,\n  });\n\n  return filtered;\n}\n\nexport function filterAvailableTables(\n  tables: Table[],\n  partySize: number,\n  window: ReturnType<typeof computeBookingWindow>,\n  adjacency: Map<string, Set<string>>,\n  avoidTables?: Set<string>,\n  zoneId?: string | null,\n  options?: { allowInsufficientCapacity?: boolean; timeFilter?: TimeFilterOptions },\n): Table[] {\n  const allowPartial = options?.allowInsufficientCapacity ?? false;\n  const avoid = avoidTables ?? new Set<string>();\n\n  const filtered = tables.filter((table) => {\n    if (!table) return false;\n    if (avoid.has(table.id)) return false;\n    if (zoneId && table.zoneId !== zoneId) return false;\n    if (table.active === false) return false;\n    if (typeof table.status === \"string\" && table.status.toLowerCase() === \"out_of_service\") return false;\n    const capacity = table.capacity ?? 0;\n    if (!Number.isFinite(capacity) || capacity <= 0) return false;\n    if (!allowPartial && capacity < partySize) return false;\n    if (typeof table.maxPartySize === \"number\" && table.maxPartySize > 0 && partySize > table.maxPartySize) {\n      return false;\n    }\n    if (typeof table.minPartySize === \"number\" && table.minPartySize > 0 && partySize < table.minPartySize) {\n      return false;\n    }\n    // If adjacency map is supplied and requires zone-level adjacency, ensure entry exists.\n    if (partiesRequireAdjacency(partySize) && adjacency.size > 0 && !adjacency.has(table.id)) {\n      adjacency.set(table.id, new Set());\n    }\n    return true;\n  });\n\n  const timeFiltered =\n    options?.timeFilter && window\n      ? filterTimeAvailableTables(filtered, window, options.timeFilter.busy, options.timeFilter.mode ?? \"strict\", (stats) =>\n          options.timeFilter?.captureStats?.(stats),\n        )\n      : filtered;\n\n  return timeFiltered.sort((a, b) => {\n    const capacityDiff = (a.capacity ?? 0) - (b.capacity ?? 0);\n    if (capacityDiff !== 0) return capacityDiff;\n    return a.tableNumber.localeCompare(b.tableNumber);\n  });\n}\n\n/**\n * Determines whether adjacency must be enforced for a given party size.\n *\n * The allocator-level `requireAdjacency` flag acts as a global gate, while\n * `allocator.adjacencyMinPartySize` (when provided) raises the threshold so\n * that only large parties mandate adjacency.\n */\nfunction partiesRequireAdjacency(partySize: number): boolean {\n  if (!isAllocatorAdjacencyRequired()) {\n    return false;\n  }\n  const minPartySize = getAllocatorAdjacencyMinPartySize();\n  if (typeof minPartySize === \"number\") {\n    return partySize >= minPartySize;\n  }\n  return true;\n}\n\n/**\n * Resolves the adjacency requirement for interactive flows, preferring the\n * explicit override supplied by the caller but falling back to the allocator\n * policy when no override is present.\n */\nfunction resolveRequireAdjacency(partySize: number, override?: boolean): boolean {\n  if (typeof override === \"boolean\") {\n   return override;\n  }\n  return partiesRequireAdjacency(partySize);\n}\n\ntype LookaheadConfig = {\n  enabled: boolean;\n  windowMinutes: number;\n  penaltyWeight: number;\n};\n\ntype FutureBookingCandidate = {\n  bookingId: string;\n  partySize: number;\n  window: BookingWindow;\n  busy: AvailabilityMap;\n  usedFallback: boolean;\n  fallbackService: ServiceKey | null;\n};\n\nfunction prepareLookaheadBookings(params: {\n  bookingId: string;\n  currentWindow: BookingWindow;\n  lookahead: LookaheadConfig;\n  policy: VenuePolicy;\n  contextBookings: ContextBookingRow[];\n  holds: TableHold[];\n}): FutureBookingCandidate[] {\n  const { bookingId, currentWindow, lookahead, policy, contextBookings, holds } = params;\n  if (!lookahead.enabled || lookahead.windowMinutes <= 0) {\n    return [];\n  }\n\n  const cutoff = currentWindow.block.start.plus({ minutes: lookahead.windowMinutes });\n  const candidates: FutureBookingCandidate[] = [];\n\n  for (const booking of contextBookings) {\n    if (!booking || booking.id === bookingId) {\n      continue;\n    }\n\n    const partySize = booking.party_size ?? 0;\n    if (!Number.isFinite(partySize) || partySize <= 0) {\n      continue;\n    }\n\n    const assignments = booking.booking_table_assignments ?? [];\n    if (assignments.length > 0) {\n      continue;\n    }\n\n    let computed: BookingWindowWithFallback;\n    try {\n      computed = computeBookingWindowWithFallback({\n        startISO: booking.start_at,\n        bookingDate: booking.booking_date,\n        startTime: booking.start_time,\n        partySize,\n        policy,\n      });\n    } catch {\n      continue;\n    }\n\n    const { window } = computed;\n    if (window.block.start <= currentWindow.block.start) {\n      continue;\n    }\n\n    if (window.block.start > cutoff) {\n      continue;\n    }\n\n    const busy = buildBusyMaps({\n      targetBookingId: booking.id,\n      bookings: contextBookings,\n      holds,\n      policy,\n      targetWindow: window,\n    });\n\n    candidates.push({\n      bookingId: booking.id,\n      partySize,\n      window,\n      busy,\n      usedFallback: computed.usedFallback,\n      fallbackService: computed.fallbackService,\n    });\n  }\n\n  return candidates;\n}\n\nfunction applyLookaheadPenalties(params: {\n  plans: RankedTablePlan[];\n  bookingWindow: BookingWindow;\n  tables: Table[];\n  adjacency: Map<string, Set<string>>;\n  zoneId: string | null;\n  futureBookings: FutureBookingCandidate[];\n  config: SelectorScoringConfig;\n  combinationEnabled: boolean;\n  combinationLimit: number;\n  selectorLimits: ReturnType<typeof getSelectorPlannerLimits>;\n  penaltyWeight: number;\n}): {\n  penalizedPlans: number;\n  totalPenalty: number;\n  evaluationMs: number;\n  conflicts: Array<{ bookingId: string; planKey: string }>;\n} {\n  const { plans, bookingWindow, tables, adjacency, zoneId, futureBookings, config, combinationEnabled, combinationLimit, selectorLimits, penaltyWeight } = params;\n  const start = performance.now();\n\n  if (futureBookings.length === 0 || plans.length === 0 || penaltyWeight <= 0) {\n    return { penalizedPlans: 0, totalPenalty: 0, evaluationMs: performance.now() - start, conflicts: [] };\n  }\n\n  let penalizedPlans = 0;\n  let totalPenalty = 0;\n  const conflicts: Array<{ bookingId: string; planKey: string }> = [];\n\n  for (const plan of plans) {\n    let planPenalty = 0;\n    const avoidTables = new Set(plan.tables.map((table) => table.id));\n\n    for (const future of futureBookings) {\n      if (!windowsOverlap(bookingWindow.block, future.window.block)) {\n        continue;\n      }\n\n      const requireAdjacencyForFuture = resolveRequireAdjacency(future.partySize);\n      const availableTables = filterAvailableTables(\n        tables,\n        future.partySize,\n        future.window,\n        adjacency,\n        avoidTables,\n        zoneId ?? null,\n        {\n          allowInsufficientCapacity: true,\n          timeFilter: {\n            busy: future.busy,\n            mode: \"strict\",\n          },\n        },\n      );\n\n      if (availableTables.length === 0) {\n        planPenalty += penaltyWeight;\n        conflicts.push({ bookingId: future.bookingId, planKey: plan.tableKey });\n        continue;\n      }\n\n      const futurePlans = buildScoredTablePlans({\n        tables: availableTables,\n        partySize: future.partySize,\n        adjacency,\n        config,\n        enableCombinations: combinationEnabled,\n        kMax: combinationLimit,\n        maxPlansPerSlack: selectorLimits.maxPlansPerSlack,\n        maxCombinationEvaluations: selectorLimits.maxCombinationEvaluations,\n        requireAdjacency: requireAdjacencyForFuture,\n        demandMultiplier: 1,\n      });\n\n      if (futurePlans.plans.length === 0) {\n        planPenalty += penaltyWeight;\n        conflicts.push({ bookingId: future.bookingId, planKey: plan.tableKey });\n      }\n    }\n\n    if (planPenalty > 0) {\n      penalizedPlans += 1;\n      totalPenalty += planPenalty;\n      plan.score += planPenalty;\n      plan.scoreBreakdown.futureConflictPenalty =\n        (plan.scoreBreakdown.futureConflictPenalty ?? 0) + planPenalty;\n      plan.scoreBreakdown.total += planPenalty;\n    }\n  }\n\n  const evaluationMs = performance.now() - start;\n  return { penalizedPlans, totalPenalty, evaluationMs, conflicts };\n}\n\nfunction sortPlansByScore(plans: RankedTablePlan[]): void {\n  plans.sort((a, b) => {\n    if (a.score !== b.score) {\n      return a.score - b.score;\n    }\n    if (a.metrics.overage !== b.metrics.overage) {\n      return a.metrics.overage - b.metrics.overage;\n    }\n    if (a.metrics.tableCount !== b.metrics.tableCount) {\n      return a.metrics.tableCount - b.metrics.tableCount;\n    }\n    if (a.totalCapacity !== b.totalCapacity) {\n      return a.totalCapacity - b.totalCapacity;\n    }\n    if (a.metrics.fragmentation !== b.metrics.fragmentation) {\n      return a.metrics.fragmentation - b.metrics.fragmentation;\n    }\n    if (a.metrics.adjacencyCost !== b.metrics.adjacencyCost) {\n      return a.metrics.adjacencyCost - b.metrics.adjacencyCost;\n    }\n    return a.tableKey.localeCompare(b.tableKey, \"en\");\n  });\n}\n\nexport function evaluateLookahead(params: {\n  lookahead: LookaheadConfig;\n  bookingId: string;\n  bookingWindow: BookingWindow;\n  plansResult: BuildCandidatesResult;\n  tables: Table[];\n  adjacency: Map<string, Set<string>>;\n  zoneId: string | null;\n  policy: VenuePolicy;\n  contextBookings: ContextBookingRow[];\n  holds: TableHold[];\n  combinationEnabled: boolean;\n  combinationLimit: number;\n  selectorLimits: ReturnType<typeof getSelectorPlannerLimits>;\n  scoringConfig: SelectorScoringConfig;\n}): CandidateDiagnostics[\"lookahead\"] {\n  const {\n    lookahead,\n    bookingId,\n    bookingWindow,\n    plansResult,\n    tables,\n    adjacency,\n    zoneId,\n    policy,\n    contextBookings,\n    holds,\n    combinationEnabled,\n    combinationLimit,\n    selectorLimits,\n    scoringConfig,\n  } = params;\n\n  if (!lookahead.enabled) {\n    return {\n      enabled: false,\n      evaluationMs: 0,\n      futureBookingsConsidered: 0,\n      penalizedPlans: 0,\n      totalPenalty: 0,\n      windowMinutes: lookahead.windowMinutes,\n      conflicts: [],\n    };\n  }\n\n  const futureBookings = prepareLookaheadBookings({\n    bookingId,\n    currentWindow: bookingWindow,\n    lookahead,\n    policy,\n    contextBookings,\n    holds,\n  });\n\n  if (futureBookings.length === 0 || plansResult.plans.length === 0) {\n    return {\n      enabled: true,\n      evaluationMs: 0,\n      futureBookingsConsidered: futureBookings.length,\n      penalizedPlans: 0,\n      totalPenalty: 0,\n      windowMinutes: lookahead.windowMinutes,\n      conflicts: [],\n    };\n  }\n\n  const { penalizedPlans, totalPenalty, evaluationMs, conflicts } = applyLookaheadPenalties({\n    plans: plansResult.plans,\n    bookingWindow,\n    tables,\n    adjacency,\n    zoneId,\n    futureBookings,\n    config: scoringConfig,\n    combinationEnabled,\n    combinationLimit,\n    selectorLimits,\n    penaltyWeight: lookahead.penaltyWeight,\n  });\n\n  if (penalizedPlans > 0) {\n    sortPlansByScore(plansResult.plans);\n  }\n\n  return {\n    enabled: true,\n    evaluationMs,\n    futureBookingsConsidered: futureBookings.length,\n    penalizedPlans,\n    totalPenalty,\n    windowMinutes: lookahead.windowMinutes,\n    conflicts,\n  };\n}\n\nasync function loadBooking(bookingId: string, client: DbClient): Promise<BookingRow> {\n  const { data, error } = await client\n    .from(\"bookings\")\n    .select(\n      [\n        \"id\",\n        \"restaurant_id\",\n        \"booking_date\",\n        \"start_time\",\n        \"end_time\",\n        \"start_at\",\n        \"end_at\",\n        \"party_size\",\n        \"status\",\n        \"seating_preference\",\n        \"restaurants(timezone)\",\n      ].join(\",\"),\n    )\n    .eq(\"id\", bookingId)\n    .maybeSingle();\n\n  if (error) {\n    throw new ManualSelectionInputError(error.message ?? \"Failed to load booking\", \"BOOKING_LOOKUP_FAILED\", 500);\n  }\n\n  if (!data) {\n    throw new ManualSelectionInputError(\"Booking not found\", \"BOOKING_NOT_FOUND\", 404);\n  }\n\n  return normalizeBookingRow(data as unknown as BookingRow);\n}\n\ntype RestaurantInfo = {\n  timezone: string | null;\n  slug: string | null;\n};\n\nasync function loadRestaurantInfo(restaurantId: string, client: DbClient): Promise<RestaurantInfo> {\n  const { data, error } = await client\n    .from(\"restaurants\")\n    .select(\"timezone, slug\")\n    .eq(\"id\", restaurantId)\n    .maybeSingle();\n\n  if (error) {\n    throw new ManualSelectionInputError(error.message ?? \"Failed to load restaurant metadata\", \"RESTAURANT_LOOKUP_FAILED\", 500);\n  }\n\n  return {\n    timezone: data?.timezone ?? null,\n    slug: data?.slug ?? null,\n  };\n}\n\nasync function loadRestaurantTimezone(restaurantId: string, client: DbClient): Promise<string | null> {\n  const info = await loadRestaurantInfo(restaurantId, client);\n  return info.timezone;\n}\n\nasync function loadTablesForRestaurant(restaurantId: string, client: DbClient): Promise<Table[]> {\n  const { data, error } = await client\n    .from(\"table_inventory\")\n    .select<typeof TABLE_INVENTORY_SELECT, TableInventoryRow>(TABLE_INVENTORY_SELECT)\n    .eq(\"restaurant_id\", restaurantId)\n    .order(\"table_number\", { ascending: true });\n\n  if (error || !data) {\n    return [];\n  }\n\n  const rows = data as unknown as Tables<\"table_inventory\">[];\n\n  return rows.map((row) => ({\n    id: row.id,\n    tableNumber: row.table_number,\n    capacity: row.capacity ?? 0,\n    minPartySize: row.min_party_size ?? null,\n    maxPartySize: row.max_party_size ?? null,\n    section: row.section,\n    category: row.category,\n    seatingType: row.seating_type,\n    mobility: row.mobility,\n    zoneId: row.zone_id,\n    status: row.status,\n    active: row.active,\n    position: row.position,\n  }));\n}\n\nasync function loadTablesByIds(\n  restaurantId: string,\n  tableIds: string[],\n  client: DbClient,\n): Promise<Table[]> {\n  if (tableIds.length === 0) {\n    return [];\n  }\n\n  const uniqueIds = Array.from(new Set(tableIds));\n  const { data, error } = await client\n    .from(\"table_inventory\")\n    .select<typeof TABLE_INVENTORY_SELECT, TableInventoryRow>(TABLE_INVENTORY_SELECT)\n    .eq(\"restaurant_id\", restaurantId)\n    .in(\"id\", uniqueIds);\n\n  if (error || !data) {\n    return [];\n  }\n\n  const rows = data as unknown as TableInventoryRow[];\n\n  const lookup = new Map(\n    rows.map((row) => [\n      row.id,\n      {\n        id: row.id,\n        tableNumber: row.table_number,\n        capacity: row.capacity ?? 0,\n        minPartySize: row.min_party_size ?? null,\n        maxPartySize: row.max_party_size ?? null,\n        section: row.section,\n        category: row.category,\n        seatingType: row.seating_type,\n        mobility: row.mobility,\n        zoneId: row.zone_id,\n        status: row.status,\n        active: row.active,\n        position: row.position,\n      } satisfies Table,\n    ]),\n  );\n\n  return tableIds.reduce<Table[]>((acc, id) => {\n    const table = lookup.get(id);\n    if (table) {\n      acc.push(table);\n    }\n    return acc;\n  }, []);\n}\n\nasync function loadAdjacency(tableIds: string[], client: DbClient): Promise<Map<string, Set<string>>> {\n  const uniqueTableIds = Array.from(\n    new Set(\n      tableIds.filter((value): value is string => typeof value === \"string\" && value.length > 0),\n    ),\n  );\n\n  if (uniqueTableIds.length === 0) {\n    return new Map();\n  }\n\n  type AdjacencyRow = { table_a: string | null; table_b: string | null };\n  const baseQuery = () => client.from(\"table_adjacencies\").select(\"table_a, table_b\");\n\n  const [forward, reverse] = await Promise.all([\n    baseQuery().in(\"table_a\", uniqueTableIds),\n    baseQuery().in(\"table_b\", uniqueTableIds),\n  ]);\n\n  if (forward.error || reverse.error) {\n    return new Map();\n  }\n\n  const forwardRows = Array.isArray(forward.data) ? (forward.data as AdjacencyRow[]) : [];\n  const reverseRows = Array.isArray(reverse.data) ? (reverse.data as AdjacencyRow[]) : [];\n  const rows: AdjacencyRow[] = [...forwardRows, ...reverseRows];\n\n  if (rows.length === 0) {\n    return new Map();\n  }\n\n  const map = new Map<string, Set<string>>();\n  for (const row of rows) {\n    const tableA = row.table_a;\n    const tableB = row.table_b;\n    if (!tableA || !tableB) {\n      continue;\n    }\n    if (!map.has(tableA)) {\n      map.set(tableA, new Set());\n    }\n    map.get(tableA)!.add(tableB);\n    if (!map.has(tableB)) {\n      map.set(tableB, new Set());\n    }\n    map.get(tableB)!.add(tableA);\n  }\n  return map;\n}\n\nasync function loadContextBookings(\n  restaurantId: string,\n  bookingDate: string | null,\n  client: DbClient,\n): Promise<ContextBookingRow[]> {\n  if (!bookingDate) {\n    return [];\n  }\n\n  const { data, error } = await client\n    .from(\"bookings\")\n    .select(\n      [\n        \"id\",\n        \"party_size\",\n        \"status\",\n        \"start_time\",\n        \"end_time\",\n        \"start_at\",\n        \"end_at\",\n        \"booking_date\",\n        \"booking_table_assignments(table_id)\",\n      ].join(\",\"),\n    )\n    .eq(\"restaurant_id\", restaurantId)\n    .eq(\"booking_date\", bookingDate)\n    .in(\"status\", [...BOOKING_BLOCKING_STATUSES])\n    .order(\"start_at\", { ascending: true });\n\n  if (error || !data) {\n    return [];\n  }\n\n  return data as unknown as ContextBookingRow[];\n}\n\ntype BookingAssignmentRow = {\n  table_id: string;\n  id: string;\n  start_at: string | null;\n  end_at: string | null;\n  merge_group_id: string | null;\n};\n\nasync function loadTableAssignmentsForTables(\n  bookingId: string,\n  tableIds: string[],\n  client: DbClient,\n): Promise<BookingAssignmentRow[]> {\n  if (tableIds.length === 0) {\n    return [];\n  }\n\n  const { data, error } = await client\n    .from(\"booking_table_assignments\")\n    .select(\"table_id, id, start_at, end_at, merge_group_id\")\n    .eq(\"booking_id\", bookingId);\n\n  if (error || !data) {\n    return [];\n  }\n\n  const rows = data as unknown as BookingAssignmentRow[];\n  return rows.filter((row) => tableIds.includes(row.table_id));\n}\n\nfunction registerBusyWindow(\n  map: AvailabilityMap,\n  tableId: string,\n  window: { startAt: string; endAt: string; bookingId: string | null; source: \"booking\" | \"hold\" },\n): void {\n  if (!map.has(tableId)) {\n    map.set(tableId, {\n      bitset: createAvailabilityBitset(),\n      windows: [],\n    });\n  }\n  const entry = map.get(tableId)!;\n  markWindow(entry.bitset, window.startAt, window.endAt);\n  entry.windows.push({\n    tableId,\n    ...window,\n  });\n}\n\nfunction buildBusyMaps(params: {\n  targetBookingId: string;\n  bookings: ContextBookingRow[];\n  holds: TableHold[];\n  excludeHoldId?: string | null;\n  policy: VenuePolicy;\n  targetWindow?: BookingWindow | null;\n}): AvailabilityMap {\n  const { targetBookingId, bookings, holds, excludeHoldId, policy, targetWindow } = params;\n  const map: AvailabilityMap = new Map();\n  const pruneToTargetWindow = isPlannerTimePruningEnabled();\n  const targetInterval =\n    pruneToTargetWindow && targetWindow\n      ? {\n          start: toIsoUtc(targetWindow.block.start),\n          end: toIsoUtc(targetWindow.block.end),\n        }\n      : null;\n\n  for (const booking of bookings) {\n    if (booking.id === targetBookingId) continue;\n    const assignments = booking.booking_table_assignments ?? [];\n    if (assignments.length === 0) continue;\n\n    const { window } = computeBookingWindowWithFallback({\n      startISO: booking.start_at,\n      bookingDate: booking.booking_date,\n      startTime: booking.start_time,\n      partySize: booking.party_size,\n      policy,\n    });\n\n    const bookingInterval = {\n      start: toIsoUtc(window.block.start),\n      end: toIsoUtc(window.block.end),\n    };\n\n    if (targetInterval && !windowsOverlap(bookingInterval, targetInterval)) {\n      continue;\n    }\n\n    for (const assignment of assignments) {\n      if (!assignment?.table_id) continue;\n      registerBusyWindow(map, assignment.table_id, {\n        startAt: bookingInterval.start,\n        endAt: bookingInterval.end,\n        bookingId: booking.id,\n        source: \"booking\",\n      });\n    }\n  }\n\n  for (const hold of holds) {\n    if (excludeHoldId && hold.id === excludeHoldId) continue;\n    if (\n      targetInterval &&\n      !windowsOverlap(\n        { start: hold.startAt, end: hold.endAt },\n        targetInterval,\n      )\n    ) {\n      continue;\n    }\n    for (const tableId of hold.tableIds) {\n      registerBusyWindow(map, tableId, {\n        startAt: hold.startAt,\n        endAt: hold.endAt,\n        bookingId: hold.bookingId,\n        source: \"hold\",\n      });\n    }\n  }\n\n  return map;\n}\n\nfunction extractConflictsForTables(\n  busy: AvailabilityMap,\n  tableIds: string[],\n  window: ReturnType<typeof computeBookingWindow>,\n): ManualAssignmentConflict[] {\n  const conflicts: ManualAssignmentConflict[] = [];\n  const targetStart = toIsoUtc(window.block.start);\n  const targetEnd = toIsoUtc(window.block.end);\n\n  for (const tableId of tableIds) {\n    const entry = busy.get(tableId);\n    if (!entry) continue;\n    if (isWindowFree(entry.bitset, targetStart, targetEnd)) continue;\n    for (const other of entry.windows) {\n      if (windowsOverlap({ start: targetStart, end: targetEnd }, { start: other.startAt, end: other.endAt })) {\n        conflicts.push({\n          tableId,\n          bookingId: other.bookingId,\n          startAt: other.startAt,\n          endAt: other.endAt,\n          source: other.source,\n        });\n      }\n    }\n  }\n\n  return conflicts;\n}\n\nfunction formatConflictSummary(conflicts: ManualAssignmentConflict[]): string {\n  if (conflicts.length === 0) {\n    return \"conflicts\";\n  }\n\n  const sources = new Set(conflicts.map((conflict) => conflict.source));\n  const tableIds = Array.from(new Set(conflicts.map((conflict) => conflict.tableId))).join(\", \");\n  if (sources.size === 0) {\n    return tableIds ? `conflicts on tables ${tableIds}` : \"conflicts\";\n  }\n\n  if (sources.size > 1) {\n    return tableIds ? `holds and bookings on tables ${tableIds}` : \"holds and bookings\";\n  }\n\n  const [source] = sources;\n  const label = source === \"hold\" ? \"holds\" : \"bookings\";\n  return tableIds ? `${label} on tables ${tableIds}` : label;\n}\n\nfunction formatHoldConflictReason(conflicts: HoldConflictInfo[], plan: RankedTablePlan): string {\n  if (conflicts.length === 0) {\n    return \"Conflicts with existing holds\";\n  }\n\n  const tableLookup = new Map<string, string>();\n  for (const table of plan.tables) {\n    tableLookup.set(table.id, table.tableNumber ?? table.id);\n  }\n\n  const tableLabels = new Set<string>();\n  for (const conflict of conflicts) {\n    for (const tableId of conflict.tableIds) {\n      const label = tableLookup.get(tableId) ?? tableId;\n      tableLabels.add(label);\n    }\n  }\n\n  const sortedLabels = Array.from(tableLabels).sort((a, b) => a.localeCompare(b, undefined, { numeric: true }));\n  let message = sortedLabels.length > 0\n    ? `Conflicts with holds on tables ${sortedLabels.join(\", \")}`\n    : \"Conflicts with existing holds\";\n\n  const latestEnd = conflicts.reduce<string | null>((latest, conflict) => {\n    if (!conflict.endAt) {\n      return latest;\n    }\n    if (!latest) {\n      return conflict.endAt;\n    }\n    return conflict.endAt > latest ? conflict.endAt : latest;\n  }, null);\n\n  if (latestEnd) {\n    const retry = DateTime.fromISO(latestEnd);\n    if (retry.isValid) {\n      message += `; retry after ${retry.toUTC().toISOTime({ suppressSeconds: false, suppressMilliseconds: true })}`;\n    }\n  }\n\n  return message;\n}\n\nfunction evaluateAdjacency(\n  tableIds: string[],\n  adjacency: Map<string, Set<string>>,\n): { connected: boolean } {\n  if (tableIds.length <= 1) {\n    return { connected: true };\n  }\n  const queue = [tableIds[0]!];\n  const visited = new Set<string>([tableIds[0]!]);\n  while (queue.length > 0) {\n    const current = queue.shift();\n    if (!current) continue;\n    const neighbors = adjacency.get(current);\n    if (!neighbors) continue;\n    for (const neighbor of neighbors) {\n      if (!tableIds.includes(neighbor)) continue;\n      if (visited.has(neighbor)) continue;\n      visited.add(neighbor);\n      queue.push(neighbor);\n    }\n  }\n  return { connected: visited.size === tableIds.length };\n}\n\nfunction summarizeSelection(tables: Table[], partySize: number): ManualSelectionSummary {\n  const totalCapacity = tables.reduce((sum, table) => sum + (table.capacity ?? 0), 0);\n  const zoneIds = new Set(tables.map((table) => table.zoneId));\n  return {\n    tableCount: tables.length,\n    totalCapacity,\n    slack: Math.max(0, totalCapacity - partySize),\n    zoneId: zoneIds.size === 1 ? tables[0]?.zoneId ?? null : null,\n    tableNumbers: tables.map((table) => table.tableNumber),\n    partySize,\n  };\n}\n\nfunction buildManualChecks(params: {\n  summary: ManualSelectionSummary;\n  tables: Table[];\n  requireAdjacency: boolean;\n  adjacency: Map<string, Set<string>>;\n  conflicts: ManualAssignmentConflict[];\n  holdConflicts: HoldConflictInfo[];\n}): ManualSelectionCheck[] {\n  const checks: ManualSelectionCheck[] = [];\n  const { summary, tables, requireAdjacency, adjacency, conflicts, holdConflicts } = params;\n\n  checks.push({\n    id: \"capacity\",\n    status: summary.totalCapacity >= summary.partySize ? \"ok\" : \"error\",\n    message:\n      summary.totalCapacity >= summary.partySize\n        ? \"Capacity satisfied\"\n        : \"Selected tables do not meet requested party size\",\n    details: {\n      totalCapacity: summary.totalCapacity,\n      partySize: summary.partySize,\n      slack: summary.slack,\n    },\n  });\n\n  if (summary.zoneId === null) {\n    checks.push({\n      id: \"zone\",\n      status: \"error\",\n      message: \"Tables must belong to the same zone for manual assignment\",\n    });\n  } else {\n    checks.push({\n      id: \"zone\",\n      status: \"ok\",\n      message: `Zone ${summary.zoneId} validated`,\n    });\n  }\n\n  if (tables.length > 1) {\n    const allMovable = tables.every((table) => table.mobility === \"movable\");\n    checks.push({\n      id: \"movable\",\n      status: allMovable ? \"ok\" : \"error\",\n      message: allMovable\n        ? \"All tables are movable\"\n        : \"Merged assignments require movable tables\",\n    });\n  } else {\n    checks.push({\n      id: \"movable\",\n      status: \"ok\",\n      message: \"Single table selection\",\n    });\n  }\n\n  if (requireAdjacency && tables.length > 1) {\n    const evaluation = evaluateAdjacency(\n      tables.map((table) => table.id),\n      adjacency,\n    );\n    checks.push({\n      id: \"adjacency\",\n      status: evaluation.connected ? \"ok\" : \"error\",\n      message: evaluation.connected\n        ? \"Tables are connected\"\n        : \"Tables must be adjacent when adjacency enforcement is enabled\",\n    });\n  } else {\n    checks.push({\n      id: \"adjacency\",\n      status: \"ok\",\n      message: \"Adjacency not required\",\n    });\n  }\n\n  checks.push({\n    id: \"conflict\",\n    status: conflicts.length === 0 && holdConflicts.length === 0 ? \"ok\" : \"error\",\n    message:\n      conflicts.length === 0 && holdConflicts.length === 0\n        ? \"No conflicting assignments\"\n        : \"Existing assignments or holds conflict with selection\",\n    details: {\n      conflicts,\n      holdConflicts,\n    },\n  });\n\n  checks.push({\n    id: \"holds\",\n    status: holdConflicts.length === 0 ? \"ok\" : \"error\",\n    message: holdConflicts.length === 0 ? \"No holds blocking selection\" : \"Tables currently on hold\",\n    details: {\n      holds: holdConflicts,\n    },\n  });\n\n  return checks;\n}\n\nexport async function evaluateManualSelection(options: ManualSelectionOptions): Promise<ManualValidationResult> {\n  const { bookingId, tableIds, requireAdjacency: requireAdjacencyOverride, excludeHoldId = null, client } = options;\n\n  if (!Array.isArray(tableIds) || tableIds.length === 0) {\n    throw new ManualSelectionInputError(\"At least one table must be selected\", \"TABLES_REQUIRED\");\n  }\n\n  const supabase = ensureClient(client);\n  const booking = await loadBooking(bookingId, supabase);\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n\n  const { window } = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n\n  const selectionTables = await loadTablesByIds(booking.restaurant_id, tableIds, supabase);\n  if (selectionTables.length !== tableIds.length) {\n    throw new ManualSelectionInputError(\"One or more selected tables were not found\", \"TABLE_LOOKUP_FAILED\");\n  }\n\n  const adjacency = await loadAdjacency(tableIds, supabase);\n\n  const contextBookings = await loadContextBookings(booking.restaurant_id, booking.booking_date ?? null, supabase);\n  let holds: TableHold[] = [];\n  if (isHoldsEnabled()) {\n    try {\n      holds = await listActiveHoldsForBooking({ bookingId, client: supabase });\n    } catch {\n      holds = [];\n    }\n  }\n\n  const busy = buildBusyMaps({\n    targetBookingId: bookingId,\n    bookings: contextBookings,\n    holds,\n    excludeHoldId,\n    policy,\n    targetWindow: window,\n  });\n\n  const conflicts = extractConflictsForTables(busy, tableIds, window);\n  let holdConflicts: HoldConflictInfo[] = [];\n  try {\n    holdConflicts = await findHoldConflicts({\n      restaurantId: booking.restaurant_id,\n      tableIds,\n      startAt: toIsoUtc(window.block.start),\n      endAt: toIsoUtc(window.block.end),\n      excludeHoldId,\n      client: supabase,\n    });\n  } catch {\n    holdConflicts = [];\n  }\n\n  const requireAdjacency = resolveRequireAdjacency(booking.party_size, requireAdjacencyOverride);\n  const summary = summarizeSelection(selectionTables, booking.party_size);\n  const checks = buildManualChecks({\n    summary,\n    tables: selectionTables,\n    requireAdjacency,\n    adjacency,\n    conflicts,\n    holdConflicts,\n  });\n\n  const ok = checks.every((check) => check.status !== \"error\");\n\n  return {\n    ok,\n    summary,\n    checks,\n  };\n}\n\nexport async function createManualHold(options: ManualHoldOptions): Promise<ManualHoldResult> {\n  const { bookingId, tableIds, createdBy, holdTtlSeconds = DEFAULT_HOLD_TTL_SECONDS, requireAdjacency, excludeHoldId, client } = options;\n  const supabase = ensureClient(client);\n\n  const validation = await evaluateManualSelection({\n    bookingId,\n    tableIds,\n    requireAdjacency,\n    excludeHoldId,\n    client: supabase,\n  });\n\n  if (!validation.ok || !validation.summary) {\n    return {\n      hold: null,\n      validation,\n    };\n  }\n\n  const booking = await loadBooking(bookingId, supabase);\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n\n  const { window } = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n\n  const selectionTables = await loadTablesByIds(booking.restaurant_id, tableIds, supabase);\n  if (selectionTables.length !== tableIds.length) {\n    throw new ManualSelectionInputError(\"Selected tables could not be loaded\", \"TABLE_LOOKUP_FAILED\");\n  }\n\n  const startAtIso = toIsoUtc(window.block.start);\n  const endAtIso = toIsoUtc(window.block.end);\n\n  const expiresAt =\n    options.holdExpiresAt ??\n    toIsoUtc(DateTime.now().plus({ seconds: holdTtlSeconds })) ??\n    toIsoUtc(window.block.start.plus({ minutes: 2 }));\n\n  const zoneIdValue = validation.summary.zoneId ?? selectionTables[0]?.zoneId;\n  if (!zoneIdValue) {\n    throw new ManualSelectionInputError(\"Unable to determine zone for selected tables\", \"ZONE_REQUIRED\");\n  }\n\n  const holdPayload: CreateTableHoldInput = {\n    bookingId,\n    restaurantId: booking.restaurant_id,\n    zoneId: zoneIdValue,\n    tableIds,\n    startAt: startAtIso,\n    endAt: endAtIso,\n    expiresAt,\n    createdBy,\n    metadata: {\n      selection: {\n        tableIds,\n        summary: validation.summary,\n      },\n    },\n    client: supabase,\n  };\n\n  const hold = await createTableHold(holdPayload);\n\n  if (excludeHoldId) {\n    try {\n      await releaseHoldWithRetry({ holdId: excludeHoldId, client: supabase });\n    } catch (error) {\n      console.warn(\"[capacity][manual][holds] failed to release replaced hold\", {\n        bookingId,\n        newHoldId: hold.id,\n        previousHoldId: excludeHoldId,\n        error,\n      });\n    }\n  }\n\n  return {\n    hold,\n    validation,\n  };\n}\n\nexport async function getManualAssignmentContext(options: {\n  bookingId: string;\n  client?: DbClient;\n}): Promise<ManualAssignmentContext> {\n  const { bookingId, client } = options;\n  const supabase = ensureClient(client);\n  const booking = await loadBooking(bookingId, supabase);\n\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n\n  const { window } = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n\n  const tables = await loadTablesForRestaurant(booking.restaurant_id, supabase);\n  const contextBookings = await loadContextBookings(booking.restaurant_id, booking.booking_date ?? null, supabase);\n\n  let holds: ManualAssignmentContextHold[] = [];\n  if (isHoldsEnabled()) {\n    try {\n      const rawHolds = await fetchHoldsForWindow(booking.restaurant_id, window, supabase);\n      holds = await hydrateHoldMetadata(rawHolds, supabase);\n    } catch (error: unknown) {\n      const code = extractErrorCode(error);\n      if (code === \"42P01\") {\n        console.warn(\"[capacity][manual][context] holds table unavailable; skipping hold hydration\", {\n          bookingId,\n        });\n      } else {\n        console.warn(\"[capacity][manual][context] failed to list holds\", { bookingId, error });\n      }\n      holds = [];\n    }\n  }\n\n  const busy = buildBusyMaps({\n    targetBookingId: bookingId,\n    bookings: contextBookings,\n    holds,\n    policy,\n    targetWindow: window,\n  });\n\n  const bookingAssignments = await loadTableAssignmentsForTables(\n    bookingId,\n    tables.map((table) => table.id),\n    supabase,\n  );\n\n  const conflicts = extractConflictsForTables(\n    busy,\n    tables.map((table) => table.id),\n    window,\n  );\n\n  const activeHold = holds.find((hold) => hold.bookingId === bookingId) ?? null;\n\n  return {\n    booking,\n    tables,\n    bookingAssignments: bookingAssignments.map((row) => row.table_id),\n    holds,\n    activeHold,\n    conflicts,\n    window: {\n      startAt: toIsoUtc(window.block.start),\n      endAt: toIsoUtc(window.block.end),\n    },\n  };\n}\n\nasync function hydrateHoldMetadata(holds: TableHold[], client: DbClient): Promise<ManualAssignmentContextHold[]> {\n  if (holds.length === 0) {\n    return [];\n  }\n  const creatorIds = Array.from(\n    new Set(\n      holds\n        .map((hold) => hold.createdBy)\n        .filter((value): value is string => Boolean(value)),\n    ),\n  );\n\n  let creators: Array<{ id: string; name: string | null; email: string | null }> = [];\n  if (creatorIds.length > 0) {\n    const { data, error } = await client\n      .from(\"profiles\")\n      .select(\"id, name, email\")\n      .in(\"id\", creatorIds);\n\n    if (!error && data) {\n      creators = data as Array<{ id: string; name: string | null; email: string | null }>;\n    }\n  }\n\n  return holds.map((hold) => {\n    const creator = creators.find((profile) => profile.id === hold.createdBy);\n    return {\n      ...hold,\n      createdByName: creator?.name ?? null,\n      createdByEmail: creator?.email ?? null,\n    };\n  });\n}\n\nasync function fetchHoldsForWindow(\n  restaurantId: string,\n  window: ReturnType<typeof computeBookingWindow>,\n  client: DbClient,\n): Promise<TableHold[]> {\n  const { data, error } = await client\n    .from(\"table_holds\")\n    .select(\"*, table_hold_members(table_id)\")\n    .eq(\"restaurant_id\", restaurantId)\n    .gt(\"expires_at\", new Date().toISOString())\n    .lt(\"start_at\", toIsoUtc(window.block.end))\n    .gt(\"end_at\", toIsoUtc(window.block.start));\n\n  if (error || !data) {\n    throw error ?? new Error(\"Failed to load holds\");\n  }\n\n  const rows = data as TableHoldRow[];\n\n  return rows.map((row) => {\n    const members = row.table_hold_members ?? [];\n    const tableIds = members\n      .map((member) => member.table_id)\n      .filter((value): value is string => typeof value === \"string\");\n    return {\n      id: row.id,\n      bookingId: row.booking_id,\n      restaurantId: row.restaurant_id,\n      zoneId: row.zone_id,\n      startAt: row.start_at,\n      endAt: row.end_at,\n      expiresAt: row.expires_at,\n      tableIds,\n      createdBy: row.created_by ?? null,\n      metadata: row.metadata ?? null,\n    } satisfies TableHold;\n  });\n}\n\nasync function loadActiveHoldsForDate(\n  restaurantId: string,\n  bookingDate: string | null,\n  policy: VenuePolicy,\n  client: DbClient,\n): Promise<TableHold[]> {\n  if (!bookingDate) {\n    return [];\n  }\n\n  const day = DateTime.fromISO(bookingDate, { zone: policy.timezone ?? \"UTC\" });\n  if (!day.isValid) {\n    return [];\n  }\n\n  const dayStart = toIsoUtc(day.startOf(\"day\"));\n  const dayEnd = toIsoUtc(day.plus({ days: 1 }).startOf(\"day\"));\n  const now = toIsoUtc(DateTime.now());\n\n  const { data, error } = await client\n    .from(\"table_holds\")\n    .select(\"*, table_hold_members(table_id)\")\n    .eq(\"restaurant_id\", restaurantId)\n    .gt(\"expires_at\", now)\n    .lt(\"start_at\", dayEnd)\n    .gt(\"end_at\", dayStart);\n\n  if (error || !data) {\n    throw error ?? new Error(\"Failed to load holds\");\n  }\n\n  const rows = data as TableHoldRow[];\n\n  return rows.map((row) => {\n    const members = row.table_hold_members ?? [];\n    const tableIds = members\n      .map((member) => member.table_id)\n      .filter((value): value is string => typeof value === \"string\");\n    return {\n      id: row.id,\n      bookingId: row.booking_id,\n      restaurantId: row.restaurant_id,\n      zoneId: row.zone_id,\n      startAt: row.start_at,\n      endAt: row.end_at,\n      expiresAt: row.expires_at,\n      tableIds,\n      createdBy: row.created_by ?? null,\n      metadata: row.metadata ?? null,\n    } satisfies TableHold;\n  });\n}\n\ntype RawAssignmentRecord = {\n  tableId: string;\n  startAt?: string | null;\n  endAt?: string | null;\n  mergeGroupId?: string | null;\n};\n\ntype AssignmentSyncParams = {\n  supabase: DbClient;\n  booking: BookingRow;\n  tableIds: string[];\n  idempotencyKey: string | null;\n  assignments: RawAssignmentRecord[];\n  startIso: string;\n  endIso: string;\n  actorId?: string | null;\n  mergeGroupId?: string | null;\n  holdContext?: {\n    holdId: string;\n    zoneId?: string | null;\n  };\n};\n\nfunction serializeDetails(value: unknown): string | null {\n  if (value === null || value === undefined) {\n    return null;\n  }\n  if (typeof value === \"string\") {\n    return value;\n  }\n  try {\n    return JSON.stringify(value);\n  } catch {\n    return null;\n  }\n}\n\nasync function synchronizeAssignments(params: AssignmentSyncParams): Promise<TableAssignmentMember[]> {\n  const { supabase, booking, tableIds, idempotencyKey, assignments, startIso, endIso, actorId, mergeGroupId, holdContext } = params;\n  const uniqueTableIds = Array.from(new Set(tableIds));\n  const assignmentRows = await loadTableAssignmentsForTables(booking.id, uniqueTableIds, supabase);\n  const windowRange = `[${startIso},${endIso})`;\n\n  const needsUpdate = assignments.some((assignment) => {\n    const normalizedStart = normalizeIsoString(assignment.startAt ?? null);\n    const normalizedEnd = normalizeIsoString(assignment.endAt ?? null);\n    return normalizedStart !== startIso || normalizedEnd !== endIso;\n  });\n\n  if (needsUpdate) {\n    try {\n      await supabase\n        .from(\"booking_table_assignments\")\n        .update({ start_at: startIso, end_at: endIso })\n        .eq(\"booking_id\", booking.id)\n        .in(\"table_id\", uniqueTableIds);\n    } catch {\n      // Ignore in mocked environments.\n    }\n\n    try {\n      await supabase\n        .from(\"allocations\")\n        .update({ window: windowRange })\n        .eq(\"booking_id\", booking.id)\n        .eq(\"resource_type\", TABLE_RESOURCE_TYPE)\n        .in(\"resource_id\", uniqueTableIds);\n    } catch {\n      // Ignore missing allocation support in mocked environments.\n    }\n\n    if (idempotencyKey) {\n      try {\n        await supabase\n          .from(\"booking_assignment_idempotency\")\n          .update({\n            assignment_window: windowRange,\n            merge_group_allocation_id: mergeGroupId ?? null,\n          })\n          .eq(\"booking_id\", booking.id)\n          .eq(\"idempotency_key\", idempotencyKey);\n      } catch {\n        // Ignore ledger updates in mocked environments.\n      }\n    }\n  }\n\n  const assignmentLookup = new Map<string, RawAssignmentRecord>();\n  for (const assignment of assignments) {\n    assignmentLookup.set(assignment.tableId, assignment);\n  }\n\n  const tableRowLookup = new Map(assignmentRows.map((row) => [row.table_id, row]));\n\n  const result: TableAssignmentMember[] = uniqueTableIds.map((tableId) => {\n    const row = tableRowLookup.get(tableId);\n    const assignment = assignmentLookup.get(tableId);\n    return {\n      tableId,\n      assignmentId: row?.id ?? randomUUID(),\n      startAt: startIso,\n      endAt: endIso,\n      mergeGroupId: assignment?.mergeGroupId ?? mergeGroupId ?? null,\n    };\n  });\n\n  if (holdContext) {\n    const zoneId = holdContext.zoneId ?? \"\";\n    const telemetryMetadata = holdContext.zoneId ? undefined : { unknownZone: true };\n    await emitHoldConfirmed({\n      holdId: holdContext.holdId,\n      bookingId: booking.id,\n      restaurantId: booking.restaurant_id,\n      zoneId,\n      tableIds: result.map((assignment) => assignment.tableId),\n      startAt: startIso,\n      endAt: endIso,\n      expiresAt: endIso,\n      actorId: actorId ?? null,\n      metadata: telemetryMetadata,\n    });\n  }\n\n  return result;\n}\n\nexport async function confirmHoldAssignment(options: {\n  holdId: string;\n  bookingId: string;\n  idempotencyKey: string;\n  requireAdjacency?: boolean;\n  assignedBy?: string | null;\n  client?: DbClient;\n}): Promise<TableAssignmentMember[]> {\n  if (!isAllocatorV2Enabled()) {\n    throw new AssignTablesRpcError({\n      message: \"Allocator v2 must be enabled to confirm holds\",\n      code: \"ALLOCATOR_V2_DISABLED\",\n      details: null,\n      hint: \"Enable allocator.v2.enabled to use confirmHoldAssignment\",\n    });\n  }\n\n  const { holdId, bookingId, idempotencyKey, requireAdjacency: requireAdjacencyOverride, assignedBy = null, client } = options;\n  const supabase = ensureClient(client);\n\n  const {\n    data: holdRow,\n    error: holdError,\n  } = await supabase\n    .from(\"table_holds\")\n    .select(\"restaurant_id, zone_id, booking_id, table_hold_members(table_id)\")\n    .eq(\"id\", holdId)\n    .maybeSingle();\n\n  if (holdError) {\n    throw new HoldNotFoundError(holdError.message ?? \"Failed to load table hold\");\n  }\n\n  if (!holdRow) {\n    throw new HoldNotFoundError();\n  }\n\n  const tableIds = Array.isArray(holdRow.table_hold_members)\n    ? (holdRow.table_hold_members as Array<{ table_id: string }>).map((member) => member.table_id)\n    : [];\n\n  const holdBookingId = (holdRow as { booking_id?: string | null }).booking_id ?? null;\n  if (holdBookingId && holdBookingId !== bookingId) {\n    await emitRpcConflict({\n      source: \"confirm_hold_booking_mismatch\",\n      bookingId,\n      restaurantId: holdRow.restaurant_id,\n      tableIds,\n      holdId,\n      error: {\n        code: \"HOLD_BOOKING_MISMATCH\",\n        message: \"Hold is already linked to a different booking\",\n        details: serializeDetails({ holdBookingId }),\n        hint: null,\n      },\n    });\n\n    throw new AssignTablesRpcError({\n      message: \"Hold is already linked to a different booking\",\n      code: \"HOLD_BOOKING_MISMATCH\",\n      details: serializeDetails({ holdBookingId }),\n      hint: null,\n    });\n  }\n\n  if (tableIds.length === 0) {\n    throw new AssignTablesRpcError({\n      message: \"Hold has no tables\",\n      code: \"HOLD_EMPTY\",\n      details: null,\n      hint: null,\n    });\n  }\n\n  const booking = await loadBooking(bookingId, supabase);\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const { window } = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n  const requireAdjacency = resolveRequireAdjacency(booking.party_size, requireAdjacencyOverride);\n\n  const startIso = toIsoUtc(window.block.start);\n  const endIso = toIsoUtc(window.block.end);\n  const normalizedTableIds = normalizeTableIds(tableIds);\n  const planSignature = createPlanSignature({\n    bookingId,\n    tableIds: normalizedTableIds,\n    startAt: startIso,\n    endAt: endIso,\n  });\n\n  const orchestrator = new AssignmentOrchestrator(new SupabaseAssignmentRepository(supabase));\n  let response;\n  try {\n    response = await orchestrator.commitPlan(\n      {\n        bookingId,\n        restaurantId: booking.restaurant_id,\n        partySize: booking.party_size,\n        zoneId: holdRow.zone_id,\n        serviceDate: booking.booking_date ?? null,\n        window: {\n          startAt: startIso,\n          endAt: endIso,\n        },\n        holdId,\n      },\n      {\n        signature: planSignature,\n        tableIds: normalizedTableIds,\n        startAt: startIso,\n        endAt: endIso,\n        metadata: {\n          holdId,\n        },\n      },\n      {\n        source: \"manual\",\n        idempotencyKey,\n        actorId: assignedBy,\n        metadata: {\n          requireAdjacency,\n          holdId,\n        },\n        requireAdjacency,\n      },\n    );\n  } catch (error) {\n    if (error instanceof AssignmentConflictError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_CONFLICT\",\n        details: serializeDetails(error.details),\n        hint: error.details?.hint ?? null,\n      });\n    }\n\n    if (error instanceof AssignmentValidationError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_VALIDATION\",\n        details: serializeDetails(error.details),\n        hint: null,\n      });\n    }\n\n    if (error instanceof AssignmentRepositoryError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_REPOSITORY_ERROR\",\n        details: serializeDetails(error.cause ?? null),\n        hint: null,\n      });\n    }\n\n    throw error;\n  }\n\n  try {\n    await supabase.from(\"table_holds\").delete().eq(\"id\", holdId);\n  } catch {\n    // Best-effort cleanup.\n  }\n\n  return synchronizeAssignments({\n    supabase,\n    booking,\n    tableIds: normalizedTableIds,\n    idempotencyKey,\n    assignments: response.assignments.map((assignment) => ({\n      tableId: assignment.tableId,\n      startAt: assignment.startAt,\n      endAt: assignment.endAt,\n      mergeGroupId: assignment.mergeGroupId ?? response.mergeGroupId ?? null,\n    })),\n    startIso,\n    endIso,\n    actorId: assignedBy,\n    mergeGroupId: response.mergeGroupId ?? null,\n    holdContext: {\n      holdId,\n      zoneId: holdRow.zone_id ?? null,\n    },\n  });\n}\n\nexport async function assignTableToBooking(\n  bookingId: string,\n  tableIdOrIds: string | string[],\n  assignedBy: string | null,\n  client?: DbClient,\n  options?: { idempotencyKey?: string | null; requireAdjacency?: boolean; booking?: BookingRow },\n): Promise<string> {\n  if (!isAllocatorV2Enabled()) {\n    throw new AssignTablesRpcError({\n      message: \"Allocator v2 must be enabled to assign tables\",\n      code: \"ALLOCATOR_V2_DISABLED\",\n      details: null,\n      hint: \"Enable allocator.v2.enabled to call assignTableToBooking\",\n    });\n  }\n\n  const supabase = ensureClient(client);\n  const tableIds = Array.isArray(tableIdOrIds) ? tableIdOrIds : [tableIdOrIds];\n  if (tableIds.length === 0) {\n    throw new ManualSelectionInputError(\"Must provide at least one table id\", \"TABLES_REQUIRED\");\n  }\n\n  const booking = options?.booking ?? (await loadBooking(bookingId, supabase));\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const { window } = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n  const startIso = toIsoUtc(window.block.start);\n  const endIso = toIsoUtc(window.block.end);\n  const normalizedTableIds = normalizeTableIds(tableIds);\n  const planSignature = createPlanSignature({\n    bookingId,\n    tableIds: normalizedTableIds,\n    startAt: startIso,\n    endAt: endIso,\n    salt: options?.idempotencyKey ?? undefined,\n  });\n  const idempotencyKey = options?.idempotencyKey ?? planSignature;\n  const requireAdjacency = options?.requireAdjacency ?? false;\n\n  const orchestrator = new AssignmentOrchestrator(new SupabaseAssignmentRepository(supabase));\n  let response;\n  try {\n    response = await orchestrator.commitPlan(\n      {\n        bookingId,\n        restaurantId: booking.restaurant_id,\n        partySize: booking.party_size,\n        serviceDate: booking.booking_date ?? null,\n        window: {\n          startAt: startIso,\n          endAt: endIso,\n        },\n      },\n      {\n        signature: planSignature,\n        tableIds: normalizedTableIds,\n        startAt: startIso,\n        endAt: endIso,\n        metadata: {\n          requestSource: \"assignTableToBooking\",\n        },\n      },\n      {\n        source: \"manual\",\n        idempotencyKey,\n        actorId: assignedBy,\n        metadata: {\n          requireAdjacency,\n        },\n        requireAdjacency,\n      },\n    );\n  } catch (error) {\n    if (error instanceof AssignmentConflictError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_CONFLICT\",\n        details: serializeDetails(error.details),\n        hint: error.details?.hint ?? null,\n      });\n    }\n\n    if (error instanceof AssignmentValidationError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_VALIDATION\",\n        details: serializeDetails(error.details),\n        hint: null,\n      });\n    }\n\n    if (error instanceof AssignmentRepositoryError) {\n      throw new AssignTablesRpcError({\n        message: error.message,\n        code: \"ASSIGNMENT_REPOSITORY_ERROR\",\n        details: serializeDetails(error.cause ?? null),\n        hint: null,\n      });\n    }\n\n    throw error;\n  }\n\n  const synchronized = await synchronizeAssignments({\n    supabase,\n    booking,\n    tableIds: normalizedTableIds,\n    idempotencyKey,\n    assignments: response.assignments.map((assignment) => ({\n      tableId: assignment.tableId,\n      startAt: assignment.startAt,\n      endAt: assignment.endAt,\n      mergeGroupId: assignment.mergeGroupId ?? response.mergeGroupId ?? null,\n    })),\n    startIso,\n    endIso,\n    actorId: assignedBy,\n    mergeGroupId: response.mergeGroupId ?? null,\n  });\n\n  const firstAssignment = synchronized[0];\n  if (!firstAssignment) {\n    throw new AssignTablesRpcError({\n      message: \"Assignment failed with no records returned\",\n      code: \"ASSIGNMENT_EMPTY\",\n      details: null,\n      hint: null,\n    });\n  }\n\n  return firstAssignment.assignmentId;\n}\n\nexport async function unassignTableFromBooking(\n  bookingId: string,\n  tableId: string,\n  client?: DbClient,\n): Promise<boolean> {\n  const supabase = ensureClient(client);\n  const { data, error } = await supabase.rpc(\"unassign_tables_atomic\", {\n    p_booking_id: bookingId,\n    p_table_ids: [tableId],\n  });\n  if (error) {\n    return false;\n  }\n  return Array.isArray(data) && data.length > 0;\n}\n\nexport async function getBookingTableAssignments(\n  bookingId: string,\n  client?: DbClient,\n): Promise<TableAssignmentMember[]> {\n  const supabase = ensureClient(client);\n  const { data, error } = await supabase\n    .from(\"booking_table_assignments\")\n    .select(\"table_id, id, assigned_at\")\n    .eq(\"booking_id\", bookingId);\n\n  if (error || !data) {\n    return [];\n  }\n\n  return data.map((row) => ({\n    tableId: row.table_id,\n    assignmentId: row.id,\n    startAt: row.assigned_at ?? \"\",\n    endAt: row.assigned_at ?? \"\",\n    mergeGroupId: null,\n  }));\n}\n\nexport async function quoteTablesForBooking(options: QuoteTablesOptions): Promise<QuoteTablesResult> {\n  const {\n    bookingId,\n    zoneId,\n    maxTables,\n    requireAdjacency: requireAdjacencyOverride,\n    avoidTables = [],\n    holdTtlSeconds = DEFAULT_HOLD_TTL_SECONDS,\n    createdBy,\n    client,\n  } = options;\n\n  const operationStart = highResNow();\n  const supabase = ensureClient(client);\n  const booking = await loadBooking(bookingId, supabase);\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    getVenuePolicy().timezone;\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const {\n    window,\n    usedFallback: bookingWindowUsedFallback,\n    fallbackService: bookingWindowFallbackService,\n  } = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n\n  const tables = await loadTablesForRestaurant(booking.restaurant_id, supabase);\n  const adjacency = await loadAdjacency(\n    tables.map((table) => table.id),\n    supabase,\n  );\n  const requireAdjacency = resolveRequireAdjacency(booking.party_size, requireAdjacencyOverride);\n  const timePruningEnabled = isPlannerTimePruningEnabled();\n  const lookaheadEnabled = isSelectorLookaheadEnabled();\n  let timePruningStats: TimeFilterStats | null = null;\n  let busyForPlanner: AvailabilityMap | undefined;\n  let contextBookings: ContextBookingRow[] = [];\n  let holdsForDay: TableHold[] = [];\n\n  if (timePruningEnabled || lookaheadEnabled) {\n    contextBookings = await loadContextBookings(booking.restaurant_id, booking.booking_date ?? null, supabase);\n    if (isHoldsEnabled()) {\n      try {\n        holdsForDay = await loadActiveHoldsForDate(booking.restaurant_id, booking.booking_date ?? null, policy, supabase);\n      } catch (error: unknown) {\n        const code = extractErrorCode(error);\n        if (code === \"42P01\") {\n          console.warn(\"[capacity.quote] holds table unavailable; skipping hold hydration\", {\n            restaurantId: booking.restaurant_id,\n          });\n        } else {\n          console.warn(\"[capacity.quote] failed to load active holds\", {\n            restaurantId: booking.restaurant_id,\n            error,\n          });\n        }\n        holdsForDay = [];\n      }\n    }\n  }\n\n  if (timePruningEnabled) {\n    busyForPlanner = buildBusyMaps({\n      targetBookingId: booking.id,\n      bookings: contextBookings,\n      holds: holdsForDay,\n      policy,\n      targetWindow: window,\n    });\n  }\n\n  const filtered = filterAvailableTables(\n    tables,\n    booking.party_size,\n    window,\n    adjacency,\n    new Set(avoidTables),\n    zoneId ?? null,\n    {\n      allowInsufficientCapacity: true,\n      timeFilter:\n        busyForPlanner && timePruningEnabled\n          ? {\n              busy: busyForPlanner,\n              mode: \"strict\",\n              captureStats: (stats) => {\n                timePruningStats = stats;\n              },\n            }\n          : undefined,\n    },\n  );\n\n  const strategicOptions = { restaurantId: booking.restaurant_id ?? null } as const;\n  await loadStrategicConfig({ ...strategicOptions, client: supabase });\n  const baseScoringConfig = getSelectorScoringConfig(strategicOptions);\n  const selectorLimits = getSelectorPlannerLimits();\n  const combinationEnabled = isCombinationPlannerEnabled();\n  const combinationLimit = maxTables ?? getAllocatorCombinationLimit();\n  const demandMultiplierResult = await resolveDemandMultiplier({\n    restaurantId: booking.restaurant_id,\n    serviceStart: window.block.start,\n    serviceKey: window.service,\n    timezone: policy.timezone,\n    client: supabase,\n  });\n  const demandMultiplier = demandMultiplierResult?.multiplier ?? 1;\n  const demandRule = demandMultiplierResult?.rule;\n  const tableScarcityScores = await loadTableScarcityScores({\n    restaurantId: booking.restaurant_id,\n    tables: filtered,\n    client: supabase,\n  });\n  const scoringConfig: SelectorScoringConfig = {\n    ...baseScoringConfig,\n    weights: {\n      ...baseScoringConfig.weights,\n      scarcity: getYieldManagementScarcityWeight(strategicOptions),\n    },\n  };\n  const plannerStart = highResNow();\n  const plans = buildScoredTablePlans({\n    tables: filtered,\n    partySize: booking.party_size,\n    adjacency,\n    config: scoringConfig,\n    enableCombinations: combinationEnabled,\n    kMax: combinationLimit,\n    maxPlansPerSlack: selectorLimits.maxPlansPerSlack,\n    maxCombinationEvaluations: selectorLimits.maxCombinationEvaluations,\n    requireAdjacency,\n    demandMultiplier,\n    tableScarcityScores,\n  });\n  const topRankedPlan = plans.plans[0] ?? null;\n  const lookaheadConfig: LookaheadConfig = {\n    enabled: lookaheadEnabled,\n    windowMinutes: getSelectorLookaheadWindowMinutes(),\n    penaltyWeight: getSelectorLookaheadPenaltyWeight(),\n  };\n  const lookaheadDiagnostics = evaluateLookahead({\n    lookahead: lookaheadConfig,\n    bookingId: booking.id,\n    bookingWindow: window,\n    plansResult: plans,\n    tables,\n    adjacency,\n    zoneId: zoneId ?? null,\n    policy,\n    contextBookings,\n    holds: holdsForDay,\n    combinationEnabled,\n    combinationLimit,\n    selectorLimits,\n    scoringConfig,\n  });\n  plans.diagnostics.lookahead = lookaheadDiagnostics;\n  const plannerDurationMs = highResNow() - plannerStart;\n  const adjacencyRequiredGlobally = adjacency.size > 0 && isAllocatorAdjacencyRequired();\n  const adjacencyMinPartySize = getAllocatorAdjacencyMinPartySize();\n  const featureFlags = buildSelectorFeatureFlagsTelemetry();\n  const plannerConfigTelemetry = composePlannerConfig({\n    diagnostics: plans.diagnostics,\n    scoringConfig,\n    combinationEnabled,\n    requireAdjacency,\n    adjacencyRequiredGlobally,\n    adjacencyMinPartySize: adjacencyMinPartySize ?? null,\n    featureFlags,\n    serviceFallback: {\n      usedFallback: bookingWindowUsedFallback,\n      fallbackService: bookingWindowFallbackService,\n    },\n    demandMultiplier,\n    demandRule,\n    lookahead: lookaheadConfig,\n  });\n  if (!timePruningStats) {\n    timePruningStats = {\n      prunedByTime: 0,\n      candidatesAfterTimePrune: filtered.length,\n      pruned_by_time: 0,\n      candidates_after_time_prune: filtered.length,\n    };\n  }\n  plans.diagnostics.timePruning = {\n    prunedByTime: timePruningStats.prunedByTime,\n    candidatesAfterTimePrune: timePruningStats.candidatesAfterTimePrune,\n    pruned_by_time: timePruningStats.pruned_by_time,\n    candidates_after_time_prune: timePruningStats.candidates_after_time_prune,\n  };\n\n  const alternates: CandidateSummary[] = [];\n  const skippedCandidates: Array<{ candidate: CandidateSummary; reason: string; conflicts: HoldConflictInfo[] }> = [];\n  const holdConflictHoldIds = new Set<string>();\n  let holdConflictSkipCount = 0;\n\n  const applyQuoteSkipDiagnostics = () => {\n    plans.diagnostics.quoteSkips = {\n      holdConflicts: {\n        count: holdConflictSkipCount,\n        holdIds: Array.from(holdConflictHoldIds),\n      },\n    };\n  };\n\n  const recordHoldConflictSkip = (conflicts: HoldConflictInfo[], candidate: CandidateSummary, plan: RankedTablePlan) => {\n    holdConflictSkipCount += 1;\n    for (const conflict of conflicts) {\n      if (conflict.holdId) {\n        holdConflictHoldIds.add(conflict.holdId);\n      }\n    }\n    skippedCandidates.push({\n      candidate,\n      reason: formatHoldConflictReason(conflicts, plan),\n      conflicts,\n    });\n  };\n\n  for (let index = 0; index < plans.plans.length; index += 1) {\n    const plan = plans.plans[index]!;\n    const candidateSummary = summarizeCandidate({\n      tableIds: plan.tables.map((table) => table.id),\n      tableNumbers: plan.tables.map((table) => table.tableNumber),\n      totalCapacity: plan.totalCapacity,\n      tableCount: plan.tables.length,\n      slack: plan.slack,\n      score: plan.score,\n      adjacencyStatus: plan.adjacencyStatus,\n      scoreBreakdown: plan.scoreBreakdown,\n    });\n\n    const conflicts = await findHoldConflicts({\n      restaurantId: booking.restaurant_id,\n      tableIds: plan.tables.map((table) => table.id),\n      startAt: toIsoUtc(window.block.start),\n      endAt: toIsoUtc(window.block.end),\n      client: supabase,\n    });\n\n    if (conflicts.length > 0) {\n      recordHoldConflictSkip(conflicts, candidateSummary, plan);\n      continue;\n    }\n\n    if (index > 0) {\n      alternates.push(candidateSummary);\n    }\n\n    try {\n      const summary = summarizeSelection(plan.tables, booking.party_size);\n      const zoneForHold = summary.zoneId ?? plan.tables[0]?.zoneId;\n      if (!zoneForHold) {\n        continue;\n      }\n\n      const holdStart = highResNow();\n      const hold = await createTableHold({\n        bookingId,\n        restaurantId: booking.restaurant_id,\n        zoneId: zoneForHold,\n        tableIds: plan.tables.map((table) => table.id),\n        startAt: toIsoUtc(window.block.start),\n        endAt: toIsoUtc(window.block.end),\n        expiresAt: toIsoUtc(DateTime.now().plus({ seconds: holdTtlSeconds })),\n        createdBy,\n        metadata: {\n          selection: {\n            tableIds: plan.tables.map((table) => table.id),\n            summary,\n          },\n        },\n        client: supabase,\n      });\n      const holdDurationMs = highResNow() - holdStart;\n      const totalDurationMs = highResNow() - operationStart;\n\n      applyQuoteSkipDiagnostics();\n      await emitSelectorQuote({\n        restaurantId: booking.restaurant_id,\n        bookingId,\n        partySize: booking.party_size,\n        window: {\n          start: toIsoUtc(window.block.start),\n          end: toIsoUtc(window.block.end),\n        },\n        candidates: [candidateSummary, ...alternates],\n        selected: candidateSummary,\n        durationMs: roundMilliseconds(totalDurationMs),\n        featureFlags,\n        timing: buildTiming({\n          totalMs: totalDurationMs,\n          plannerMs: plannerDurationMs,\n          holdMs: holdDurationMs,\n        }),\n        plannerConfig: plannerConfigTelemetry,\n        diagnostics: plans.diagnostics,\n        holdId: hold.id,\n        expiresAt: hold.expiresAt,\n      });\n\n      return {\n        hold,\n        candidate: candidateSummary,\n        alternates,\n        nextTimes: [],\n        skipped: skippedCandidates,\n        metadata: {\n          usedFallback: bookingWindowUsedFallback,\n          fallbackService: bookingWindowFallbackService,\n        },\n      };\n    } catch (error) {\n      if (error instanceof HoldConflictError) {\n        const refreshedConflicts = await findHoldConflicts({\n          restaurantId: booking.restaurant_id,\n          tableIds: plan.tables.map((table) => table.id),\n          startAt: toIsoUtc(window.block.start),\n          endAt: toIsoUtc(window.block.end),\n          client: supabase,\n        });\n\n        recordHoldConflictSkip(refreshedConflicts, candidateSummary, plan);\n        await emitRpcConflict({\n          source: \"create_hold_conflict\",\n          bookingId,\n          restaurantId: booking.restaurant_id,\n          tableIds: plan.tables.map((table) => table.id),\n          holdId: error.holdId ?? null,\n          error: {\n            code: null,\n            message: error.message,\n            details: JSON.stringify(refreshedConflicts),\n            hint: null,\n          },\n        });\n\n        applyQuoteSkipDiagnostics();\n        continue;\n      }\n      throw error;\n    }\n  }\n  applyQuoteSkipDiagnostics();\n\n  return {\n    hold: null,\n    candidate: null,\n    alternates,\n    nextTimes: [],\n    reason: plans.fallbackReason ?? \"No suitable tables available\",\n    skipped: skippedCandidates,\n    metadata: {\n      usedFallback: bookingWindowUsedFallback,\n      fallbackService: bookingWindowFallbackService,\n    },\n  };\n}\n\nexport async function autoAssignTablesForDate(options: {\n  restaurantId: string;\n  date: string;\n  client?: DbClient;\n  assignedBy?: string | null;\n  captureDecisions?: boolean;\n}): Promise<AutoAssignResult> {\n  const { restaurantId, date, client, assignedBy = null, captureDecisions = true } = options;\n  const supabase = ensureClient(client);\n  const [bookings, tables, restaurantInfo] = await Promise.all([\n    loadContextBookings(restaurantId, date, supabase),\n    loadTablesForRestaurant(restaurantId, supabase),\n    loadRestaurantInfo(restaurantId, supabase),\n  ]);\n  const restaurantTimezone = restaurantInfo.timezone;\n  const restaurantSlug = restaurantInfo.slug;\n  const adjacency = await loadAdjacency(\n    tables.map((table) => table.id),\n    supabase,\n  );\n  const policy = getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const adjacencyEdgeCount = Array.from(adjacency.values()).reduce((sum, neighbors) => sum + neighbors.size, 0);\n  const adjacencyEnforced = adjacencyEdgeCount > 0 && isAllocatorAdjacencyRequired();\n  const combinationPlannerEnabled = isCombinationPlannerEnabled();\n  const mergesEnabled = isAllocatorMergesEnabled();\n  const selectorLimits = getSelectorPlannerLimits();\n  const lookaheadConfigGlobal: LookaheadConfig = {\n    enabled: isSelectorLookaheadEnabled(),\n    windowMinutes: getSelectorLookaheadWindowMinutes(),\n    penaltyWeight: getSelectorLookaheadPenaltyWeight(),\n  };\n  const plannerTimePruningEnabled = isPlannerTimePruningEnabled();\n  let activeHolds: TableHold[] = [];\n  if (isHoldsEnabled()) {\n    try {\n      activeHolds = await loadActiveHoldsForDate(restaurantId, date, policy, supabase);\n    } catch (error: unknown) {\n      const code = extractErrorCode(error);\n      if (code === \"42P01\") {\n        console.warn(\"[ops][auto-assign] holds table unavailable; skipping hold hydration\", {\n          restaurantId,\n        });\n      } else {\n        console.warn(\"[ops][auto-assign] failed to load active holds\", {\n          restaurantId,\n          error,\n        });\n      }\n      activeHolds = [];\n    }\n  }\n\n  const result: AutoAssignResult = {\n    assigned: [],\n    skipped: [],\n    serviceFallbacks: [],\n  };\n\n  const capturedDecisions: SelectorDecisionCapture[] | undefined = captureDecisions ? [] : undefined;\n\n  const recordDecision = async (event: SelectorDecisionEvent) => {\n    if (capturedDecisions) {\n      capturedDecisions.push(buildSelectorDecisionPayload(event));\n    }\n    await emitSelectorDecision(event);\n  };\n\n  const adjacencyMinPartySizeFlag = getAllocatorAdjacencyMinPartySize();\n\n  for (const booking of bookings) {\n    const alreadyAssigned = (booking.booking_table_assignments ?? []).some((row) => Boolean(row.table_id));\n    if (alreadyAssigned) {\n      continue;\n    }\n\n    const featureFlags = buildSelectorFeatureFlagsTelemetry();\n\n    const operationStart = highResNow();\n    let plannerDurationMs = 0;\n    let assignmentDurationMs = 0;\n    let combinationModeForTelemetry = combinationPlannerEnabled;\n\n    let window: BookingWindow | null = null;\n    let windowUsedFallback = false;\n    let windowFallbackService: ServiceKey | null = null;\n    let overrunReason: string | null = null;\n    try {\n      const computed = computeBookingWindowWithFallback({\n        startISO: booking.start_at,\n        bookingDate: booking.booking_date,\n        startTime: booking.start_time,\n        partySize: booking.party_size,\n        policy,\n      });\n      window = computed.window;\n      windowUsedFallback = computed.usedFallback;\n      windowFallbackService = computed.fallbackService;\n    } catch (error) {\n      if (error instanceof ServiceOverrunError) {\n        overrunReason = error.message ?? \"Reservation window exceeds service boundary\";\n      } else {\n        throw error;\n      }\n    }\n    if (!window) {\n      const reason = overrunReason ?? \"Reservation window exceeds service boundary\";\n      const totalDurationMs = highResNow() - operationStart;\n      const rejectionTelemetry = determineRejectionTelemetry(reason, null);\n      result.skipped.push({ bookingId: booking.id, reason });\n      result.serviceFallbacks.push({\n        bookingId: booking.id,\n        usedFallback: windowUsedFallback,\n        fallbackService: windowFallbackService,\n      });\n      await recordDecision({\n        restaurantId,\n        bookingId: booking.id,\n        partySize: booking.party_size,\n        window: undefined,\n        candidates: [],\n        selected: null,\n        skipReason: reason,\n        durationMs: roundMilliseconds(totalDurationMs),\n        featureFlags,\n        timing: buildTiming({ totalMs: totalDurationMs }),\n        plannerConfig: undefined,\n        diagnostics: undefined,\n        rejectionClassification: rejectionTelemetry?.classification ?? null,\n        strategicPenalties: rejectionTelemetry?.penalties ?? null,\n      });\n      continue;\n    }\n\n    result.serviceFallbacks.push({\n      bookingId: booking.id,\n      usedFallback: windowUsedFallback,\n      fallbackService: windowFallbackService,\n    });\n\n    const requireAdjacency = adjacencyEnforced && partiesRequireAdjacency(booking.party_size);\n    const busy = buildBusyMaps({\n      targetBookingId: booking.id,\n      bookings,\n      holds: activeHolds,\n      policy,\n      targetWindow: window,\n    });\n    let timePruningStats: TimeFilterStats | null = null;\n\n    const availableTables = filterAvailableTables(\n      tables,\n      booking.party_size,\n      window,\n      adjacency,\n      undefined,\n      undefined,\n      {\n        allowInsufficientCapacity: true,\n        timeFilter: plannerTimePruningEnabled\n          ? {\n              busy,\n              mode: \"strict\",\n              captureStats: (stats) => {\n                timePruningStats = stats;\n              },\n            }\n          : undefined,\n      },\n    );\n    const strategicOptions = { restaurantId } as const;\n    await loadStrategicConfig({ ...strategicOptions, client: supabase });\n    const baseScoringConfig = getSelectorScoringConfig(strategicOptions);\n    const combinationLimit = getAllocatorCombinationLimit();\n    const demandMultiplierResult = await resolveDemandMultiplier({\n      restaurantId,\n      serviceStart: window.block.start,\n      serviceKey: window.service,\n      timezone: policy.timezone,\n      client: supabase,\n    });\n    const demandMultiplier = demandMultiplierResult?.multiplier ?? 1;\n    const demandRule = demandMultiplierResult?.rule;\n    const tableScarcityScores = await loadTableScarcityScores({\n      restaurantId,\n      tables: availableTables,\n      client: supabase,\n    });\n    const scoringConfig: SelectorScoringConfig = {\n      ...baseScoringConfig,\n      weights: {\n        ...baseScoringConfig.weights,\n        scarcity: getYieldManagementScarcityWeight(strategicOptions),\n      },\n    };\n    const runPlanner = (enableCombinations: boolean) => {\n      const plannerStart = highResNow();\n      const result = buildScoredTablePlans({\n        tables: availableTables,\n        partySize: booking.party_size,\n        adjacency,\n        config: scoringConfig,\n        enableCombinations,\n        kMax: combinationLimit,\n        maxPlansPerSlack: selectorLimits.maxPlansPerSlack,\n        maxCombinationEvaluations: selectorLimits.maxCombinationEvaluations,\n        requireAdjacency,\n        demandMultiplier,\n        tableScarcityScores,\n      });\n      plannerDurationMs += highResNow() - plannerStart;\n      return result;\n    };\n    let plans = runPlanner(combinationPlannerEnabled);\n\n    if (plans.plans.length === 0 && !combinationPlannerEnabled) {\n      if (mergesEnabled) {\n        combinationModeForTelemetry = true;\n        const mergeFallback = runPlanner(true);\n        if (mergeFallback.plans.length > 0) {\n          plans = mergeFallback;\n        } else {\n          plans = {\n            ...mergeFallback,\n            fallbackReason: mergeFallback.fallbackReason ?? \"Combination planner disabled (requires merges)\",\n          };\n        }\n      } else if (!plans.fallbackReason) {\n        plans = {\n          ...plans,\n          fallbackReason: \"Combination planner disabled (requires merges)\",\n        };\n      }\n    }\n\n    const lookaheadDiagnostics = evaluateLookahead({\n      lookahead: lookaheadConfigGlobal,\n      bookingId: booking.id,\n      bookingWindow: window,\n      plansResult: plans,\n      tables,\n      adjacency,\n      zoneId: null,\n      policy,\n      contextBookings: bookings,\n      holds: activeHolds,\n      combinationEnabled: combinationModeForTelemetry,\n      combinationLimit,\n      selectorLimits,\n      scoringConfig,\n    });\n    plans.diagnostics.lookahead = lookaheadDiagnostics;\n\n    const plannerConfigTelemetry = composePlannerConfig({\n      diagnostics: plans.diagnostics,\n      scoringConfig,\n      combinationEnabled: combinationModeForTelemetry,\n      requireAdjacency,\n      adjacencyRequiredGlobally: adjacencyEnforced,\n      adjacencyMinPartySize: adjacencyMinPartySizeFlag ?? null,\n      featureFlags,\n      serviceFallback: {\n        usedFallback: windowUsedFallback,\n        fallbackService: windowFallbackService,\n      },\n      demandMultiplier,\n      demandRule,\n      lookahead: lookaheadConfigGlobal,\n    });\n    if (!timePruningStats) {\n      timePruningStats = {\n        prunedByTime: 0,\n        candidatesAfterTimePrune: availableTables.length,\n        pruned_by_time: 0,\n        candidates_after_time_prune: availableTables.length,\n      };\n    }\n    plans.diagnostics.timePruning = {\n      prunedByTime: timePruningStats.prunedByTime,\n      candidatesAfterTimePrune: timePruningStats.candidatesAfterTimePrune,\n      pruned_by_time: timePruningStats.pruned_by_time,\n      candidates_after_time_prune: timePruningStats.candidates_after_time_prune,\n    };\n\n    const topRankedPlan = plans.plans[0] ?? null;\n\n    if (plans.plans.length === 0) {\n      const fallback = plans.fallbackReason ?? \"No suitable tables available\";\n      const skipReason = `No suitable tables available (${fallback})`;\n      const totalDurationMs = highResNow() - operationStart;\n      const rejectionTelemetry = determineRejectionTelemetry(skipReason, topRankedPlan?.scoreBreakdown);\n      result.skipped.push({ bookingId: booking.id, reason: skipReason });\n      await recordDecision({\n        restaurantId,\n        bookingId: booking.id,\n        partySize: booking.party_size,\n        window: {\n          start: toIsoUtc(window.block.start),\n          end: toIsoUtc(window.block.end),\n        },\n        candidates: [],\n        selected: null,\n        skipReason,\n        durationMs: roundMilliseconds(totalDurationMs),\n        featureFlags,\n        timing: buildTiming({ totalMs: totalDurationMs, plannerMs: plannerDurationMs }),\n        plannerConfig: plannerConfigTelemetry,\n        diagnostics: plans.diagnostics,\n        rejectionClassification: rejectionTelemetry?.classification ?? null,\n        strategicPenalties: rejectionTelemetry?.penalties ?? null,\n      });\n      continue;\n    }\n\n    const planEvaluations = plans.plans.map((plan) => ({\n      plan,\n      conflicts: extractConflictsForTables(\n        busy,\n        plan.tables.map((table) => table.id),\n        window,\n      ),\n    }));\n    const bestPlanForTelemetry = planEvaluations[0]?.plan ?? null;\n\n    const candidateSummariesAll: CandidateSummary[] = planEvaluations.map(({ plan }) =>\n      summarizeCandidate({\n        tableIds: plan.tables.map((table) => table.id),\n        tableNumbers: plan.tables.map((table) => table.tableNumber),\n        totalCapacity: plan.totalCapacity,\n        tableCount: plan.tables.length,\n        slack: plan.slack,\n        score: plan.score,\n        adjacencyStatus: plan.adjacencyStatus,\n        scoreBreakdown: plan.scoreBreakdown,\n      }),\n    );\n\n    const conflictFreeEntries = planEvaluations.filter(({ conflicts }) => conflicts.length === 0);\n    if (conflictFreeEntries.length === 0) {\n      const conflictEntry = planEvaluations.find(({ conflicts }) => conflicts.length > 0);\n      const conflictSummary = conflictEntry ? formatConflictSummary(conflictEntry.conflicts) : \"conflicts\";\n      const skipReason = `Conflicts with existing ${conflictSummary}`;\n      const rejectionTelemetry = determineRejectionTelemetry(skipReason, bestPlanForTelemetry?.scoreBreakdown);\n\n      if (conflictEntry) {\n        await emitRpcConflict({\n          source: \"auto_assign_conflict\",\n          bookingId: booking.id,\n          restaurantId,\n          tableIds: conflictEntry.plan.tables.map((table) => table.id),\n          error: {\n            code: null,\n            message: skipReason,\n            details: JSON.stringify(conflictEntry.conflicts),\n            hint: null,\n          },\n        });\n      }\n\n      result.skipped.push({ bookingId: booking.id, reason: skipReason });\n      const totalDurationMs = highResNow() - operationStart;\n      await recordDecision({\n        restaurantId,\n        bookingId: booking.id,\n        partySize: booking.party_size,\n        window: {\n          start: toIsoUtc(window.block.start),\n          end: toIsoUtc(window.block.end),\n        },\n        candidates: candidateSummariesAll,\n        selected: null,\n        skipReason,\n        durationMs: roundMilliseconds(totalDurationMs),\n        featureFlags,\n        timing: buildTiming({ totalMs: totalDurationMs, plannerMs: plannerDurationMs }),\n        plannerConfig: plannerConfigTelemetry,\n        diagnostics: plans.diagnostics,\n        rejectionClassification: rejectionTelemetry?.classification ?? null,\n        strategicPenalties: rejectionTelemetry?.penalties ?? null,\n      });\n      continue;\n    }\n\n    const topEntry = conflictFreeEntries[0]!;\n    const topPlan = topEntry.plan;\n    const candidateSummaries: CandidateSummary[] = conflictFreeEntries.map(({ plan }) =>\n      summarizeCandidate({\n        tableIds: plan.tables.map((table) => table.id),\n        tableNumbers: plan.tables.map((table) => table.tableNumber),\n        totalCapacity: plan.totalCapacity,\n        tableCount: plan.tables.length,\n        slack: plan.slack,\n        score: plan.score,\n        adjacencyStatus: plan.adjacencyStatus,\n        scoreBreakdown: plan.scoreBreakdown,\n      }),\n    );\n    const candidate = candidateSummaries[0]!;\n\n    const assignmentStart = highResNow();\n    try {\n      await assignTableToBooking(\n        booking.id,\n        topPlan.tables.map((table) => table.id),\n        assignedBy,\n        supabase,\n        {\n          idempotencyKey: randomUUID(),\n          requireAdjacency,\n          booking: {\n            ...(booking as Partial<BookingRow>),\n            id: booking.id,\n            restaurant_id: restaurantId,\n            booking_date: booking.booking_date,\n            start_time: booking.start_time,\n            end_time: booking.end_time,\n            start_at: booking.start_at,\n            end_at: booking.end_at,\n            party_size: booking.party_size,\n            status: booking.status,\n            seating_preference: booking.seating_preference ?? null,\n            restaurants: { timezone: policy.timezone },\n          } as BookingRow,\n        },\n      );\n      assignmentDurationMs = highResNow() - assignmentStart;\n    } catch (error: unknown) {\n      assignmentDurationMs = highResNow() - assignmentStart;\n      const message = error instanceof Error ? error.message : String(error);\n      const normalized = message.toLowerCase();\n      const overlap =\n        normalized.includes(\"assignment overlap\") || normalized.includes(\"allocations_no_overlap\");\n\n      if (!overlap) {\n        throw error;\n      }\n\n      await emitRpcConflict({\n        source: \"auto_assign_overlap\",\n        bookingId: booking.id,\n        restaurantId,\n        tableIds: topPlan.tables.map((table) => table.id),\n        error: {\n          code: null,\n          message,\n          details: null,\n          hint: null,\n        },\n      });\n\n      const skipReason = \"Auto assign skipped: Supabase reported an overlapping assignment\";\n      const rejectionTelemetry = determineRejectionTelemetry(skipReason, topPlan?.scoreBreakdown);\n      result.skipped.push({ bookingId: booking.id, reason: skipReason });\n      const totalDurationMs = highResNow() - operationStart;\n      await recordDecision({\n        restaurantId,\n        bookingId: booking.id,\n        partySize: booking.party_size,\n        window: {\n          start: toIsoUtc(window.block.start),\n          end: toIsoUtc(window.block.end),\n        },\n        candidates: candidateSummariesAll,\n        selected: null,\n        skipReason,\n        durationMs: roundMilliseconds(totalDurationMs),\n        featureFlags,\n        timing: buildTiming({\n          totalMs: totalDurationMs,\n          plannerMs: plannerDurationMs,\n          assignmentMs: assignmentDurationMs,\n        }),\n        plannerConfig: plannerConfigTelemetry,\n        diagnostics: plans.diagnostics,\n        rejectionClassification: rejectionTelemetry?.classification ?? null,\n        strategicPenalties: rejectionTelemetry?.penalties ?? null,\n      });\n      continue;\n    }\n\n    if (!booking.booking_table_assignments) {\n      booking.booking_table_assignments = [];\n    }\n    for (const table of topPlan.tables) {\n      if (!booking.booking_table_assignments.some((assignment) => assignment?.table_id === table.id)) {\n        booking.booking_table_assignments.push({ table_id: table.id });\n      }\n    }\n\n    result.assigned.push({\n      bookingId: booking.id,\n      tableIds: topPlan.tables.map((table) => table.id),\n    });\n\n    const totalDurationMs = highResNow() - operationStart;\n    await recordDecision({\n      restaurantId,\n      bookingId: booking.id,\n      partySize: booking.party_size,\n      window: {\n        start: toIsoUtc(window.block.start),\n        end: toIsoUtc(window.block.end),\n      },\n      candidates: candidateSummaries,\n      selected: candidate,\n      skipReason: null,\n      durationMs: roundMilliseconds(totalDurationMs),\n      featureFlags,\n      timing: buildTiming({\n        totalMs: totalDurationMs,\n        plannerMs: plannerDurationMs,\n        assignmentMs: assignmentDurationMs,\n      }),\n      plannerConfig: plannerConfigTelemetry,\n      diagnostics: plans.diagnostics,\n    });\n  }\n\n  if (capturedDecisions) {\n    await persistDecisionSnapshots({ restaurantId, date, slug: restaurantSlug, decisions: capturedDecisions });\n    return { ...result, decisions: capturedDecisions };\n  }\n\n  return result;\n}\n\nexport async function autoAssignTables(options: {\n  restaurantId: string;\n  date: string;\n  client?: DbClient;\n  assignedBy?: string | null;\n  captureDecisions?: boolean;\n}): Promise<AutoAssignResult> {\n  return autoAssignTablesForDate(options);\n}\n\nexport async function findSuitableTables(options: {\n  bookingId: string;\n  client?: DbClient;\n}): Promise<RankedTablePlan[]> {\n  const { bookingId, client } = options;\n  const supabase = ensureClient(client);\n  const booking = await loadBooking(bookingId, supabase);\n  const tables = await loadTablesForRestaurant(booking.restaurant_id, supabase);\n  const adjacency = await loadAdjacency(\n    tables.map((table) => table.id),\n    supabase,\n  );\n  const defaultPolicy = getVenuePolicy();\n  const restaurantTimezone =\n    (booking.restaurants && !Array.isArray(booking.restaurants) ? booking.restaurants.timezone : null) ??\n    (await loadRestaurantTimezone(booking.restaurant_id, supabase)) ??\n    defaultPolicy.timezone;\n  const policy =\n    restaurantTimezone === defaultPolicy.timezone\n      ? defaultPolicy\n      : getVenuePolicy({ timezone: restaurantTimezone ?? undefined });\n  const { window } = computeBookingWindowWithFallback({\n    startISO: booking.start_at,\n    bookingDate: booking.booking_date,\n    startTime: booking.start_time,\n    partySize: booking.party_size,\n    policy,\n  });\n\n  const filtered = filterAvailableTables(\n    tables,\n    booking.party_size,\n    window,\n    adjacency,\n    undefined,\n    undefined,\n    { allowInsufficientCapacity: true },\n  );\n  const strategicOptions = { restaurantId: booking.restaurant_id ?? null } as const;\n  await loadStrategicConfig({ ...strategicOptions, client: supabase });\n  const baseScoringConfig = getSelectorScoringConfig(strategicOptions);\n  const requireAdjacency = partiesRequireAdjacency(booking.party_size);\n  const selectorLimits = getSelectorPlannerLimits();\n  const demandMultiplierResult = await resolveDemandMultiplier({\n    restaurantId: booking.restaurant_id,\n    serviceStart: window.block.start,\n    serviceKey: window.service,\n    timezone: policy.timezone,\n    client: supabase,\n  });\n  const demandMultiplier = demandMultiplierResult?.multiplier ?? 1;\n  const tableScarcityScores = await loadTableScarcityScores({\n    restaurantId: booking.restaurant_id,\n    tables: filtered,\n    client: supabase,\n  });\n  const scoringConfig: SelectorScoringConfig = {\n    ...baseScoringConfig,\n    weights: {\n      ...baseScoringConfig.weights,\n      scarcity: getYieldManagementScarcityWeight(strategicOptions),\n    },\n  };\n  const plans = buildScoredTablePlans({\n    tables: filtered,\n    partySize: booking.party_size,\n    adjacency,\n    config: scoringConfig,\n    enableCombinations: isCombinationPlannerEnabled(),\n    kMax: getAllocatorCombinationLimit(),\n    maxPlansPerSlack: selectorLimits.maxPlansPerSlack,\n    maxCombinationEvaluations: selectorLimits.maxCombinationEvaluations,\n    requireAdjacency,\n    demandMultiplier,\n    tableScarcityScores,\n  });\n\n  return plans.plans;\n}\n\nexport async function isTableAvailableV2(\n  tableId: string,\n  startISO: string,\n  partySize: number,\n  options?: {\n    excludeBookingId?: string;\n    policy?: VenuePolicy;\n    client?: DbClient;\n  },\n): Promise<boolean> {\n  const supabase = ensureClient(options?.client);\n  const policy = options?.policy ?? getVenuePolicy();\n  const { window } = computeBookingWindowWithFallback({\n    startISO,\n    partySize,\n    policy,\n  });\n\n  const startAt = toIsoUtc(window.block.start);\n  const endAt = toIsoUtc(window.block.end);\n\n  try {\n    const { data, error } = await (supabase as unknown as {\n      rpc: (\n        fn: string,\n        args: {\n          p_table_id: string;\n          p_start_at: string;\n          p_end_at: string;\n          p_exclude_booking_id: string | null;\n        },\n      ) => Promise<{ data: boolean | null; error: { message?: string; details?: string | null; hint?: string | null; code?: string | null } | null }>;\n    }).rpc(\"is_table_available_v2\", {\n      p_table_id: tableId,\n      p_start_at: startAt,\n      p_end_at: endAt,\n      p_exclude_booking_id: options?.excludeBookingId ?? null,\n    });\n\n    if (error) {\n      const code = extractErrorCode(error);\n      if (code === \"42883\" || code === \"42P01\") {\n        return await legacyTableAvailabilityCheck({\n          supabase,\n          tableId,\n          startAt,\n          endAt,\n          excludeBookingId: options?.excludeBookingId ?? null,\n        });\n      }\n      throw new AssignTablesRpcError({\n        message: error.message ?? \"Failed to query table availability\",\n        code: \"TABLE_AVAILABILITY_QUERY_FAILED\",\n        details: serializeDetails({\n          code: code ?? null,\n          details: error.details ?? null,\n          hint: error.hint ?? null,\n        }),\n        hint: null,\n      });\n    }\n\n    if (typeof data === \"boolean\") {\n      return data;\n    }\n  } catch (error) {\n    const code = extractErrorCode(error);\n    if (code !== \"42883\" && code !== \"42P01\") {\n      throw new AssignTablesRpcError({\n        message: error instanceof Error ? error.message : \"Failed to verify table availability\",\n        code: \"TABLE_AVAILABILITY_QUERY_FAILED\",\n        details: error instanceof Error ? error.stack ?? null : null,\n        hint: null,\n      });\n    }\n    return await legacyTableAvailabilityCheck({\n      supabase,\n      tableId,\n      startAt,\n      endAt,\n      excludeBookingId: options?.excludeBookingId ?? null,\n    });\n  }\n\n  return await legacyTableAvailabilityCheck({\n    supabase,\n    tableId,\n    startAt,\n    endAt,\n    excludeBookingId: options?.excludeBookingId ?? null,\n  });\n}\n\nasync function legacyTableAvailabilityCheck(params: {\n  supabase: DbClient;\n  tableId: string;\n  startAt: string;\n  endAt: string;\n  excludeBookingId?: string | null;\n}): Promise<boolean> {\n  const { supabase, tableId, startAt, endAt, excludeBookingId } = params;\n\n  const { data, error } = await supabase\n    .from(\"booking_table_assignments\")\n    .select(\"table_id, start_at, end_at, bookings(id, status, start_at, end_at)\")\n    .eq(\"table_id\", tableId);\n\n  if (error || !data) {\n    throw new AssignTablesRpcError({\n      message: error?.message ?? \"Failed to query table availability\",\n      code: \"TABLE_AVAILABILITY_QUERY_FAILED\",\n      details: serializeDetails({\n        code: (error as { code?: string })?.code ?? null,\n        details: error?.details ?? null,\n        hint: error?.hint ?? null,\n      }),\n      hint: null,\n    });\n  }\n\n  const rows = data as AssignmentAvailabilityRow[];\n  for (const row of rows) {\n    const booking = row.bookings;\n    if (excludeBookingId && booking?.id === excludeBookingId) {\n      continue;\n    }\n    if (booking && ![\"pending\", \"confirmed\", \"seated\"].includes(booking.status ?? \"\")) {\n      continue;\n    }\n    const otherStart = row.start_at ?? booking?.start_at;\n    const otherEnd = row.end_at ?? booking?.end_at;\n    if (!otherStart || !otherEnd) {\n      continue;\n    }\n    if (windowsOverlap({ start: startAt, end: endAt }, { start: otherStart, end: otherEnd })) {\n      return false;\n    }\n  }\n\n  return true;\n}\n\nexport async function isTableAvailable(\n  tableId: string,\n  startISO: string,\n  partySize: number,\n  options?: {\n    excludeBookingId?: string;\n    policy?: VenuePolicy;\n    client?: DbClient;\n  },\n): Promise<boolean> {\n  try {\n    return await isTableAvailableV2(tableId, startISO, partySize, options);\n  } catch (error) {\n    if (error instanceof AssignTablesRpcError) {\n      throw new AssignTablesRpcError({\n        message: \"Failed to verify table availability\",\n        code: error.code ?? \"TABLE_AVAILABILITY_QUERY_FAILED\",\n        details: error.details,\n        hint: error.hint ?? null,\n      });\n    }\n    throw error;\n  }\n}\n\nexport const __internal = {\n  computeBookingWindow,\n  windowsOverlap,\n  filterAvailableTables,\n  filterTimeAvailableTables,\n  extractConflictsForTables,\n};\n"
    },
    {
      "path": "server/capacity/selector.ts",
      "content": "import type { SelectorScoringConfig, SelectorScoringWeights } from \"./policy\";\nimport type { Table } from \"./tables\";\n\nconst DIAGNOSTIC_SKIP_KEYS = [\n  \"capacity\",\n  \"overage\",\n  \"adjacency\",\n  \"kmax\",\n  \"zone\",\n  \"limit\",\n  \"bucket\",\n  \"adjacency_frontier\",\n  \"capacity_upper_bound\",\n] as const;\n\ntype DiagnosticSkipKey = (typeof DIAGNOSTIC_SKIP_KEYS)[number];\n\ntype DiagnosticSkipCounts = Record<DiagnosticSkipKey, number> & Record<string, number>;\n\nexport type CandidateMetrics = {\n  overage: number;\n  tableCount: number;\n  fragmentation: number;\n  zoneBalance: number;\n  adjacencyCost: number;\n  scarcityScore: number;\n};\n\nexport type ScoreBreakdown = {\n  slackPenalty: number;\n  demandMultiplier: number;\n  scarcityPenalty: number;\n  combinationPenalty: number;\n  structuralPenalty: number;\n  futureConflictPenalty: number;\n  total: number;\n};\n\nexport type RankedTablePlan = {\n  tables: Table[];\n  totalCapacity: number;\n  slack: number;\n  metrics: CandidateMetrics;\n  score: number;\n  tableKey: string;\n  adjacencyStatus: \"single\" | \"connected\" | \"disconnected\";\n  scoreBreakdown: ScoreBreakdown;\n};\n\nexport type CandidateDiagnostics = {\n  singlesConsidered: number;\n  combinationsEnumerated: number;\n  combinationsAccepted: number;\n  skipped: DiagnosticSkipCounts;\n  limits: {\n    kMax: number;\n    maxPlansPerSlack: number;\n    maxCombinationEvaluations: number;\n  };\n  totals: {\n    enumerated: number;\n    accepted: number;\n  };\n  timePruning?: {\n    prunedByTime: number;\n    candidatesAfterTimePrune: number;\n    pruned_by_time: number;\n    candidates_after_time_prune: number;\n  };\n  quoteSkips?: {\n    holdConflicts: {\n      count: number;\n      holdIds: string[];\n    };\n  };\n  performance?: {\n    totalDurationMs: number;\n    buildScoredTablePlansMs: number;\n    enumerateCombinationsMs?: number;\n    sortingMs?: number;\n    inputSize: {\n      tableCount: number;\n      partySize: number;\n      validTablesCount: number;\n      singleTableCandidatesCount: number;\n    };\n    iterations: {\n      totalEvaluations: number;\n      dfsIterations?: number;\n      earlyExit: boolean;\n      earlyExitReason?: string;\n    };\n  };\n  lookahead?: {\n    enabled: boolean;\n    evaluationMs: number;\n    futureBookingsConsidered: number;\n    penalizedPlans: number;\n    totalPenalty: number;\n    windowMinutes: number;\n    conflicts: Array<{ bookingId: string; planKey: string }>;\n  };\n};\n\nexport type BuildCandidatesOptions = {\n  tables: Table[];\n  partySize: number;\n  adjacency: Map<string, Set<string>>;\n  config: SelectorScoringConfig;\n  enableCombinations?: boolean;\n  kMax?: number;\n  maxPlansPerSlack?: number;\n  maxCombinationEvaluations?: number;\n  requireAdjacency?: boolean;\n  demandMultiplier?: number;\n  tableScarcityScores?: Map<string, number>;\n};\n\nexport type BuildCandidatesResult = {\n  plans: RankedTablePlan[];\n  fallbackReason?: string;\n  diagnostics: CandidateDiagnostics;\n};\n\nconst FALLBACK_NO_TABLES = \"No tables meet the capacity requirements for this party size.\";\nconst DEFAULT_MAX_PLANS_PER_SLACK = 50;\nconst DEFAULT_MAX_COMBINATION_EVALUATIONS = 500;\n\nfunction createSkipCounts(): DiagnosticSkipCounts {\n  return DIAGNOSTIC_SKIP_KEYS.reduce((accumulator, key) => {\n    accumulator[key] = 0;\n    return accumulator;\n  }, Object.create(null) as DiagnosticSkipCounts);\n}\n\nfunction incrementCounter(target: Record<string, number>, key: string, amount = 1): void {\n  const current = target[key] ?? 0;\n  target[key] = current + amount;\n}\n\nexport function buildScoredTablePlans(options: BuildCandidatesOptions): BuildCandidatesResult {\n  const startTime = performance.now();\n\n  const {\n    tables,\n    partySize,\n    adjacency,\n    config,\n    enableCombinations = false,\n    kMax,\n    maxPlansPerSlack,\n    maxCombinationEvaluations,\n    requireAdjacency = true,\n    demandMultiplier: inputDemandMultiplier,\n    tableScarcityScores: providedScarcityScores,\n  } = options;\n  const { maxOverage, weights } = config;\n  const demandMultiplier = normalizeDemandMultiplier(inputDemandMultiplier);\n  const tableScarcityScores = providedScarcityScores ?? computeTableScarcityScores(tables);\n\n  const maxAllowedCapacity = partySize + Math.max(maxOverage, 0);\n  const combinationCap = Math.max(1, Math.min(kMax ?? config.maxTables ?? 1, tables.length || 1));\n  const perSlackLimit = Math.max(1, maxPlansPerSlack ?? DEFAULT_MAX_PLANS_PER_SLACK);\n  const combinationEvaluationLimit = Math.max(1, maxCombinationEvaluations ?? DEFAULT_MAX_COMBINATION_EVALUATIONS);\n\n  const diagnostics: CandidateDiagnostics = {\n    singlesConsidered: 0,\n    combinationsEnumerated: 0,\n    combinationsAccepted: 0,\n    skipped: createSkipCounts(),\n    limits: {\n      kMax: combinationCap,\n      maxPlansPerSlack: perSlackLimit,\n      maxCombinationEvaluations: combinationEvaluationLimit,\n    },\n    totals: {\n      enumerated: 0,\n      accepted: 0,\n    },\n  };\n\n  const validTables: Table[] = [];\n  const singleTableCandidates: Table[] = [];\n\n  for (const table of tables) {\n    const capacity = table.capacity ?? 0;\n    if (!Number.isFinite(capacity) || capacity <= 0) {\n      incrementCounter(diagnostics.skipped, \"capacity\");\n      continue;\n    }\n\n    if (typeof table.minPartySize === \"number\" && table.minPartySize > 0 && partySize < table.minPartySize) {\n      incrementCounter(diagnostics.skipped, \"capacity\");\n      continue;\n    }\n\n    if (typeof table.maxPartySize === \"number\" && table.maxPartySize > 0 && partySize > table.maxPartySize) {\n      incrementCounter(diagnostics.skipped, \"capacity\");\n      continue;\n    }\n\n    if (capacity > maxAllowedCapacity) {\n      incrementCounter(diagnostics.skipped, \"overage\");\n      continue;\n    }\n\n    validTables.push(table);\n\n    if (capacity >= partySize) {\n      singleTableCandidates.push(table);\n    }\n  }\n\n  diagnostics.singlesConsidered = singleTableCandidates.length;\n\n  const plans: RankedTablePlan[] = [];\n\n  for (const table of singleTableCandidates) {\n    const adjacencyDepths = new Map<string, number>([[table.id, 0]]);\n    const metrics = computeMetrics([table], partySize, adjacencyDepths, tableScarcityScores);\n    const { score, breakdown } = computeScore(metrics, weights, demandMultiplier);\n    const totalCapacity = metrics.overage + partySize;\n    const tableKey = buildTableKey([table]);\n\n    plans.push({\n      tables: [table],\n      totalCapacity,\n      slack: metrics.overage,\n      metrics,\n      score,\n      tableKey,\n      adjacencyStatus: \"single\",\n      scoreBreakdown: breakdown,\n    });\n  }\n\n  let enumerateCombinationsMs: number | undefined;\n  let dfsIterations: number | undefined;\n  let earlyExit = false;\n  let earlyExitReason: string | undefined;\n\n  if (enableCombinations && combinationCap > 1 && validTables.length > 1) {\n    const combinationStartTime = performance.now();\n    const combinationPlans = enumerateCombinationPlans({\n      candidates: validTables,\n      partySize,\n      weights,\n      adjacency,\n      maxAllowedCapacity,\n      kMax: combinationCap,\n      bucketLimit: perSlackLimit,\n      evaluationLimit: combinationEvaluationLimit,\n      diagnostics,\n      requireAdjacency,\n      tableScarcityScores,\n      demandMultiplier,\n    });\n    enumerateCombinationsMs = performance.now() - combinationStartTime;\n\n    // Check if early exit occurred\n    if (diagnostics.combinationsEnumerated > 0) {\n      dfsIterations = diagnostics.combinationsEnumerated;\n      const limitSkipped = diagnostics.skipped.limit ?? 0;\n      if (limitSkipped > 0) {\n        earlyExit = true;\n        earlyExitReason = `evaluation_limit_reached (${combinationEvaluationLimit})`;\n      }\n    }\n\n    plans.push(...combinationPlans);\n  }\n\n  const sortStartTime = performance.now();\n  plans.sort((a, b) => comparePlans(a, b, weights));\n  const sortingMs = performance.now() - sortStartTime;\n\n  const fallbackReason = plans.length > 0 ? undefined : FALLBACK_NO_TABLES;\n\n  diagnostics.totals.enumerated = diagnostics.combinationsEnumerated + diagnostics.singlesConsidered;\n  diagnostics.totals.accepted = plans.length;\n\n  const totalDurationMs = performance.now() - startTime;\n\n  // Add performance metrics to diagnostics\n  diagnostics.performance = {\n    totalDurationMs,\n    buildScoredTablePlansMs: totalDurationMs,\n    enumerateCombinationsMs,\n    sortingMs,\n    inputSize: {\n      tableCount: tables.length,\n      partySize,\n      validTablesCount: validTables.length,\n      singleTableCandidatesCount: singleTableCandidates.length,\n    },\n    iterations: {\n      totalEvaluations: diagnostics.combinationsEnumerated + diagnostics.singlesConsidered,\n      dfsIterations,\n      earlyExit,\n      earlyExitReason,\n    },\n  };\n\n  // Log performance warning if selector exceeds threshold (Sprint 0 - T0.2)\n  const SELECTOR_PERF_THRESHOLD_MS = 500;\n  if (totalDurationMs > SELECTOR_PERF_THRESHOLD_MS) {\n    console.warn(\"[PERF] buildScoredTablePlans exceeded threshold\", {\n      durationMs: totalDurationMs,\n      threshold: SELECTOR_PERF_THRESHOLD_MS,\n      inputSize: diagnostics.performance.inputSize,\n      iterations: diagnostics.performance.iterations,\n      enumerateCombinationsMs,\n      sortingMs,\n      enableCombinations,\n      kMax: combinationCap,\n      evaluationLimit: combinationEvaluationLimit,\n    });\n  }\n\n  return { plans, fallbackReason, diagnostics };\n}\n\nfunction computeMetrics(\n  tables: Table[],\n  partySize: number,\n  adjacencyDepths: Map<string, number>,\n  tableScarcityScores: Map<string, number>,\n): CandidateMetrics {\n  const capacities = tables.map((table) => table.capacity ?? 0);\n  const totalCapacity = capacities.reduce((sum, capacity) => sum + capacity, 0);\n  const maxCapacity = capacities.length > 0 ? Math.max(...capacities) : 0;\n  const overage = Math.max(totalCapacity - partySize, 0);\n  const fragmentation = Math.max(totalCapacity - maxCapacity, 0);\n  const zoneIds = new Set(tables.map((table) => table.zoneId ?? null));\n  const zoneBalance = Math.max(zoneIds.size - 1, 0);\n  const depthValues = adjacencyDepths.size > 0 ? [...adjacencyDepths.values()] : [0];\n  let adjacencyCost = Math.max(...depthValues);\n  if (adjacencyDepths.size < tables.length) {\n    adjacencyCost = Math.max(adjacencyCost, tables.length);\n  }\n  const scarcityScore = tables.reduce((sum, table) => sum + (tableScarcityScores.get(table.id) ?? 0), 0);\n\n  return {\n    overage,\n    tableCount: tables.length,\n    fragmentation,\n    zoneBalance,\n    adjacencyCost,\n    scarcityScore,\n  };\n}\n\nfunction computeScore(\n  metrics: CandidateMetrics,\n  weights: SelectorScoringWeights,\n  demandMultiplier: number,\n): { score: number; breakdown: ScoreBreakdown } {\n  const normalizedDemandMultiplier = Number.isFinite(demandMultiplier) && demandMultiplier > 0 ? demandMultiplier : 1;\n  const baseSlackPenalty = metrics.overage * weights.overage;\n  const slackPenalty = baseSlackPenalty * normalizedDemandMultiplier;\n\n  const tableCountPenalty = (metrics.tableCount - 1) * weights.tableCount;\n  const fragmentationPenalty = metrics.fragmentation * weights.fragmentation;\n  const zoneBalancePenalty = metrics.zoneBalance * weights.zoneBalance;\n  const adjacencyPenalty = metrics.adjacencyCost * weights.adjacencyCost;\n  const scarcityWeight = Math.max(0, weights.scarcity ?? 0);\n  let combinationPenalty = metrics.tableCount > 1 ? tableCountPenalty + adjacencyPenalty : 0;\n  if (combinationPenalty > 0 && scarcityWeight > 0 && metrics.tableCount > 0) {\n    const averageScarcity = metrics.scarcityScore / metrics.tableCount;\n    if (averageScarcity > 0) {\n      const scarcityFactor = Math.min(3, 1 + averageScarcity);\n      combinationPenalty *= scarcityFactor;\n    }\n  }\n  const structuralPenalty = combinationPenalty + fragmentationPenalty + zoneBalancePenalty;\n\n  const scarcityPenalty = metrics.scarcityScore * scarcityWeight;\n\n  const total = slackPenalty + structuralPenalty + scarcityPenalty;\n\n  return {\n    score: total,\n    breakdown: {\n      slackPenalty,\n      demandMultiplier: normalizedDemandMultiplier,\n      scarcityPenalty,\n      combinationPenalty,\n      structuralPenalty,\n      futureConflictPenalty: 0,\n      total,\n    },\n  };\n}\n\nfunction comparePlans(a: RankedTablePlan, b: RankedTablePlan, _weights: SelectorScoringWeights): number {\n  if (a.score !== b.score) {\n    return a.score - b.score;\n  }\n\n  if (a.metrics.overage !== b.metrics.overage) {\n    return a.metrics.overage - b.metrics.overage;\n  }\n\n  if (a.metrics.tableCount !== b.metrics.tableCount) {\n    return a.metrics.tableCount - b.metrics.tableCount;\n  }\n\n  if (a.totalCapacity !== b.totalCapacity) {\n    return a.totalCapacity - b.totalCapacity;\n  }\n\n  if (a.metrics.fragmentation !== b.metrics.fragmentation) {\n    return a.metrics.fragmentation - b.metrics.fragmentation;\n  }\n\n  if (a.metrics.adjacencyCost !== b.metrics.adjacencyCost) {\n    return a.metrics.adjacencyCost - b.metrics.adjacencyCost;\n  }\n\n  return a.tableKey.localeCompare(b.tableKey, \"en\");\n}\n\nfunction normalizeDemandMultiplier(value?: number): number {\n  if (typeof value !== \"number\" || !Number.isFinite(value)) {\n    return 1;\n  }\n  if (value <= 0) {\n    return 1;\n  }\n  return value;\n}\n\nfunction computeTableScarcityScores(tables: Table[]): Map<string, number> {\n  const capacityCounts = new Map<number, number>();\n  for (const table of tables) {\n    const capacity = table.capacity ?? 0;\n    if (!Number.isFinite(capacity) || capacity <= 0) {\n      continue;\n    }\n    const current = capacityCounts.get(capacity) ?? 0;\n    capacityCounts.set(capacity, current + 1);\n  }\n\n  const scores = new Map<string, number>();\n  for (const table of tables) {\n    const capacity = table.capacity ?? 0;\n    if (!Number.isFinite(capacity) || capacity <= 0) {\n      scores.set(table.id, 0);\n      continue;\n    }\n    const count = capacityCounts.get(capacity) ?? 0;\n    if (count <= 0) {\n      scores.set(table.id, 0);\n      continue;\n    }\n    scores.set(table.id, 1 / count);\n  }\n\n  return scores;\n}\n\nfunction buildTableKey(tables: Table[]): string {\n  return tables\n    .map((table) => table.tableNumber ?? table.id)\n    .sort((a, b) => a.localeCompare(b))\n    .join(\"+\");\n}\n\ntype CombinationPlannerArgs = {\n  candidates: Table[];\n  partySize: number;\n  weights: SelectorScoringWeights;\n  adjacency: Map<string, Set<string>>;\n  maxAllowedCapacity: number;\n  kMax: number;\n  bucketLimit: number;\n  evaluationLimit: number;\n  diagnostics: CandidateDiagnostics;\n  requireAdjacency: boolean;\n  tableScarcityScores: Map<string, number>;\n  demandMultiplier: number;\n};\n\n/**\n * Enumerates multi-table plans honoring adjacency, kMax, zone-locking, and per-slack limits.\n *\n * Tables are grouped by slack buckets and trimmed to the configured per-slack cap.\n * The search short-circuits when either the evaluation limit, zone guard, or\n * adjacency requirements disqualify further combinations, ensuring consistent\n * diagnostics for skipped plans.\n */\nfunction enumerateCombinationPlans(args: CombinationPlannerArgs): RankedTablePlan[] {\n  const {\n    candidates,\n    partySize,\n    weights,\n    adjacency,\n    maxAllowedCapacity,\n    kMax,\n    bucketLimit,\n    evaluationLimit,\n    diagnostics,\n    requireAdjacency,\n    tableScarcityScores,\n    demandMultiplier,\n  } = args;\n\n  if (kMax <= 1) {\n    return [];\n  }\n\n  const seenKeys = new Set<string>();\n  const buckets = new Map<number, RankedTablePlan[]>();\n  const sortedCandidates = [...candidates].sort((a, b) => {\n    const capacityDiff = (a.capacity ?? 0) - (b.capacity ?? 0);\n    if (capacityDiff !== 0) {\n      return capacityDiff;\n    }\n    const nameA = a.tableNumber ?? a.id;\n    const nameB = b.tableNumber ?? b.id;\n    return nameA.localeCompare(nameB);\n  });\n  const candidateLookup = new Map(sortedCandidates.map((table) => [table.id, table]));\n\n  const buildFrontier = (selectionIds: Set<string>): Set<string> => {\n    const frontierIds = new Set<string>();\n    for (const id of selectionIds) {\n      const neighbors = adjacency.get(id);\n      if (!neighbors) {\n        continue;\n      }\n      for (const neighbor of neighbors) {\n        if (!selectionIds.has(neighbor) && candidateLookup.has(neighbor)) {\n          frontierIds.add(neighbor);\n        }\n      }\n    }\n    return frontierIds;\n  };\n\n  const updateFrontierSet = (\n    currentFrontier: Set<string> | null,\n    selectionIds: Set<string>,\n    candidate: Table,\n  ): Set<string> => {\n    const next = new Set<string>();\n    if (currentFrontier) {\n      for (const id of currentFrontier) {\n        if (!selectionIds.has(id)) {\n          next.add(id);\n        }\n      }\n    }\n    const neighbors = adjacency.get(candidate.id);\n    if (neighbors) {\n      for (const neighbor of neighbors) {\n        if (!selectionIds.has(neighbor) && candidateLookup.has(neighbor)) {\n          next.add(neighbor);\n        }\n      }\n    }\n    next.delete(candidate.id);\n    return next;\n  };\n\n  const gatherCandidateIdsFromIndex = (startIndex: number, selectionIds: Set<string>): string[] => {\n    const ids: string[] = [];\n    for (let idx = startIndex; idx < sortedCandidates.length; idx += 1) {\n      const table = sortedCandidates[idx];\n      if (selectionIds.has(table.id)) {\n        continue;\n      }\n      ids.push(table.id);\n    }\n    return ids;\n  };\n\n  const computeCapacityUpperBound = (\n    candidateIds: string[],\n    remainingSlots: number,\n    baseZoneId: string | null,\n    selectionIds: Set<string>,\n  ): number => {\n    if (remainingSlots <= 0) {\n      return 0;\n    }\n    const capacities: number[] = [];\n    for (const id of candidateIds) {\n      if (selectionIds.has(id)) {\n        continue;\n      }\n      const table = candidateLookup.get(id);\n      if (!table) {\n        continue;\n      }\n      if (baseZoneId && table.zoneId && table.zoneId !== baseZoneId) {\n        continue;\n      }\n      capacities.push(table.capacity ?? 0);\n    }\n    capacities.sort((a, b) => b - a);\n    return capacities.slice(0, remainingSlots).reduce((sum, value) => sum + value, 0);\n  };\n\n  let evaluations = 0;\n  let enumerated = diagnostics.combinationsEnumerated ?? 0;\n  let accepted = diagnostics.combinationsAccepted ?? 0;\n  let limitRecorded = false;\n  let stopSearch = false;\n\n  const registerPlan = (plan: RankedTablePlan) => {\n    const bucket = buckets.get(plan.slack) ?? [];\n    bucket.push(plan);\n    bucket.sort((a, b) => comparePlans(a, b, weights));\n    if (bucket.length > bucketLimit) {\n      bucket.length = bucketLimit;\n      incrementCounter(diagnostics.skipped, \"bucket\");\n    }\n    buckets.set(plan.slack, bucket);\n    accepted += 1;\n    diagnostics.combinationsAccepted = accepted;\n  };\n\n  const dfs = (\n    startIndex: number,\n    selection: Table[],\n    selectionIds: Set<string>,\n    runningCapacity: number,\n    baseZoneId: string | null,\n    frontier: Set<string> | null,\n  ) => {\n    if (stopSearch) {\n      return;\n    }\n\n    if (requireAdjacency && frontier && frontier.size === 0 && selection.length < kMax) {\n      incrementCounter(diagnostics.skipped, \"adjacency_frontier\");\n      return;\n    }\n\n    if (selection.length >= 2 && runningCapacity >= partySize) {\n      enumerated += 1;\n      diagnostics.combinationsEnumerated = enumerated;\n\n      const key = buildTableKey(selection);\n      if (!seenKeys.has(key)) {\n        seenKeys.add(key);\n      const adjacencyEvaluation = evaluateAdjacency(selection, adjacency);\n      if (!adjacencyEvaluation.connected && requireAdjacency) {\n        incrementCounter(diagnostics.skipped, \"adjacency\");\n      } else {\n        const metrics = computeMetrics(selection, partySize, adjacencyEvaluation.depths, tableScarcityScores);\n        const { score, breakdown } = computeScore(metrics, weights, demandMultiplier);\n          const totalCapacity = metrics.overage + partySize;\n          const adjacencyStatus: RankedTablePlan[\"adjacencyStatus\"] =\n            selection.length <= 1\n              ? \"single\"\n              : adjacencyEvaluation.connected\n                ? \"connected\"\n                : \"disconnected\";\n          const plan: RankedTablePlan = {\n            tables: [...selection],\n            totalCapacity,\n            slack: metrics.overage,\n            metrics,\n            score,\n            tableKey: key,\n            adjacencyStatus,\n            scoreBreakdown: breakdown,\n          };\n          registerPlan(plan);\n        }\n      }\n\n      evaluations += 1;\n      if (evaluations >= evaluationLimit) {\n        stopSearch = true;\n        if (!limitRecorded) {\n          incrementCounter(diagnostics.skipped, \"limit\");\n          limitRecorded = true;\n        }\n        return;\n      }\n    }\n\n    if (selection.length >= kMax) {\n      if (runningCapacity < partySize) {\n        incrementCounter(diagnostics.skipped, \"capacity\");\n      }\n      incrementCounter(diagnostics.skipped, \"kmax\");\n      return;\n    }\n\n    const remainingSlots = kMax - selection.length;\n    if (remainingSlots > 0) {\n      let candidateIdsForUpperBound: string[] = [];\n      if (requireAdjacency) {\n        candidateIdsForUpperBound = frontier ? Array.from(frontier) : [];\n      } else {\n        candidateIdsForUpperBound = gatherCandidateIdsFromIndex(startIndex, selectionIds);\n      }\n      const capacityUpperBound = computeCapacityUpperBound(candidateIdsForUpperBound, remainingSlots, baseZoneId, selectionIds);\n      if (runningCapacity + capacityUpperBound < partySize) {\n        incrementCounter(diagnostics.skipped, \"capacity_upper_bound\");\n        return;\n      }\n    }\n\n    for (let index = startIndex; index < sortedCandidates.length; index += 1) {\n      if (stopSearch) {\n        break;\n      }\n\n      const candidate = sortedCandidates[index];\n\n      if (selectionIds.has(candidate.id)) {\n        continue;\n      }\n\n      if (requireAdjacency && frontier && !frontier.has(candidate.id)) {\n        continue;\n      }\n\n      if (selection.length > 0 && baseZoneId && candidate.zoneId && candidate.zoneId !== baseZoneId) {\n        incrementCounter(diagnostics.skipped, \"zone\");\n        continue;\n      }\n\n      if (selection.length + 1 > kMax) {\n        incrementCounter(diagnostics.skipped, \"kmax\");\n        continue;\n      }\n\n      const nextCapacity = runningCapacity + (candidate.capacity ?? 0);\n\n      if (nextCapacity > maxAllowedCapacity) {\n        incrementCounter(diagnostics.skipped, \"overage\");\n        // Capacities sorted ascending; further entries will exceed as well for this path.\n        break;\n      }\n\n      const nextZoneId = baseZoneId ?? candidate.zoneId ?? null;\n      const nextSelection = [...selection, candidate];\n      const nextSelectionIds = new Set(selectionIds);\n      nextSelectionIds.add(candidate.id);\n      const nextFrontier = requireAdjacency ? updateFrontierSet(frontier, nextSelectionIds, candidate) : null;\n\n      dfs(index + 1, nextSelection, nextSelectionIds, nextCapacity, nextZoneId, nextFrontier);\n    }\n  };\n\n  for (let i = 0; i < sortedCandidates.length && !stopSearch; i += 1) {\n    const base = sortedCandidates[i];\n    const baseSelection = [base];\n    const baseSelectionIds = new Set<string>([base.id]);\n    const baseFrontier = requireAdjacency ? buildFrontier(baseSelectionIds) : null;\n    dfs(i + 1, baseSelection, baseSelectionIds, base.capacity ?? 0, base.zoneId ?? null, baseFrontier);\n  }\n\n  return Array.from(buckets.values())\n    .flat()\n    .sort((a, b) => comparePlans(a, b, weights));\n}\n\nfunction evaluateAdjacency(\n  tables: Table[],\n  adjacency: Map<string, Set<string>>,\n): { connected: boolean; depths: Map<string, number> } {\n  if (tables.length === 0) {\n    return { connected: true, depths: new Map() };\n  }\n\n  if (tables.length === 1) {\n    return { connected: true, depths: new Map([[tables[0].id, 0]]) };\n  }\n\n  const tableIds = tables.map((table) => table.id);\n  const selection = new Set(tableIds);\n  const depths = new Map<string, number>();\n  const queue: string[] = [];\n\n  const [firstId] = tableIds;\n  queue.push(firstId);\n  depths.set(firstId, 0);\n\n  while (queue.length > 0) {\n    const current = queue.shift();\n    if (!current) {\n      continue;\n    }\n    const neighbors = adjacency.get(current);\n    if (!neighbors) {\n      continue;\n    }\n    for (const neighbor of neighbors) {\n      if (!selection.has(neighbor) || depths.has(neighbor)) {\n        continue;\n      }\n      const depth = (depths.get(current) ?? 0) + 1;\n      depths.set(neighbor, depth);\n      queue.push(neighbor);\n    }\n  }\n\n  const connected = depths.size === selection.size;\n  return { connected, depths };\n}\n"
    },
    {
      "path": "server/capacity/policy.ts",
      "content": "import { DateTime } from \"luxon\";\n\nimport {\n  DEFAULT_SCARCITY_WEIGHT,\n  getStrategicScarcityWeight,\n  type StrategicConfigSnapshotOptions,\n} from \"./strategic-config\";\n\nconst DEFAULT_TIMEZONE = \"Europe/London\";\n\nexport const SERVICE_KEYS = [\"lunch\", \"dinner\", \"drinks\"] as const;\nexport type ServiceKey = (typeof SERVICE_KEYS)[number];\n\nexport type TimeOfDay = {\n  hour: number;\n  minute: number;\n};\n\nexport type BufferConfig = {\n  pre: number;\n  post: number;\n};\n\nexport type TurnBand = {\n  maxPartySize: number;\n  durationMinutes: number;\n};\n\nexport type ServiceDefinition = {\n  key: ServiceKey;\n  label: string;\n  start: TimeOfDay;\n  end: TimeOfDay;\n  buffer: BufferConfig;\n  turnBands: TurnBand[];\n};\n\nexport type VenuePolicy = {\n  timezone: string;\n  services: Partial<Record<ServiceKey, ServiceDefinition>>;\n  serviceOrder: ServiceKey[];\n};\n\nexport type SelectorScoringWeights = {\n  overage: number;\n  tableCount: number;\n  fragmentation: number;\n  zoneBalance: number;\n  adjacencyCost: number;\n  scarcity: number;\n};\n\nexport const YIELD_MANAGEMENT_SCARCITY_WEIGHT = DEFAULT_SCARCITY_WEIGHT;\n\nexport type SelectorScoringConfig = {\n  weights: SelectorScoringWeights;\n  maxOverage: number;\n  maxTables: number;\n};\n\nexport type ServiceWindow = {\n  start: DateTime;\n  end: DateTime;\n};\n\nfunction cloneTurnBands(bands: TurnBand[]): TurnBand[] {\n  return bands.map((band) => ({ ...band }));\n}\n\nfunction cloneService(service: ServiceDefinition): ServiceDefinition {\n  return {\n    ...service,\n    start: { ...service.start },\n    end: { ...service.end },\n    buffer: { ...service.buffer },\n    turnBands: cloneTurnBands(service.turnBands),\n  };\n}\n\nexport const defaultVenuePolicy: VenuePolicy = {\n  timezone: DEFAULT_TIMEZONE,\n  serviceOrder: [\"lunch\", \"dinner\"],\n  services: {\n    lunch: {\n      key: \"lunch\",\n      label: \"Lunch\",\n      start: { hour: 12, minute: 0 },\n      end: { hour: 15, minute: 0 },\n      buffer: { pre: 0, post: 5 },\n      turnBands: [\n        { maxPartySize: 2, durationMinutes: 60 },\n        { maxPartySize: 4, durationMinutes: 75 },\n        { maxPartySize: 6, durationMinutes: 85 },\n        { maxPartySize: 8, durationMinutes: 85 },\n      ],\n    },\n    dinner: {\n      key: \"dinner\",\n      label: \"Dinner\",\n      start: { hour: 17, minute: 0 },\n      end: { hour: 22, minute: 0 },\n      buffer: { pre: 0, post: 5 },\n      turnBands: [\n        { maxPartySize: 2, durationMinutes: 60 },\n        { maxPartySize: 4, durationMinutes: 75 },\n        { maxPartySize: 6, durationMinutes: 85 },\n        { maxPartySize: 8, durationMinutes: 90 },\n      ],\n    },\n  },\n};\n\nconst defaultSelectorScoringConfig: SelectorScoringConfig = {\n  weights: {\n    overage: 5,\n    tableCount: 3,\n    fragmentation: 2,\n    zoneBalance: 4,\n    adjacencyCost: 1,\n    scarcity: DEFAULT_SCARCITY_WEIGHT,\n  },\n  maxOverage: 2,\n  maxTables: 3,\n};\n\nexport function getSelectorScoringConfig(options?: StrategicConfigSnapshotOptions): SelectorScoringConfig {\n  const dynamicScarcityWeight = getStrategicScarcityWeight(options);\n  return {\n    weights: {\n      ...defaultSelectorScoringConfig.weights,\n      scarcity: dynamicScarcityWeight,\n    },\n    maxOverage: defaultSelectorScoringConfig.maxOverage,\n    maxTables: defaultSelectorScoringConfig.maxTables,\n  };\n}\n\nexport function getYieldManagementScarcityWeight(options?: StrategicConfigSnapshotOptions): number {\n  return getStrategicScarcityWeight(options);\n}\n\nexport class PolicyError extends Error {\n  constructor(message: string) {\n    super(message);\n    this.name = \"PolicyError\";\n  }\n}\n\nexport class ServiceNotFoundError extends PolicyError {\n  constructor(public readonly attempted: DateTime, message?: string) {\n    super(message ?? `No service window matches ${attempted.toISO() ?? \"provided time\"}.`);\n    this.name = \"ServiceNotFoundError\";\n  }\n}\n\nexport class ServiceOverrunError extends PolicyError {\n  constructor(\n    public readonly service: ServiceKey,\n    public readonly attemptedEnd: DateTime,\n    public readonly serviceEnd: DateTime,\n    message?: string,\n  ) {\n    super(\n      message ??\n        `Reservation would overrun ${service} service (end ${serviceEnd.toFormat(\"HH:mm\")}).`,\n    );\n    this.name = \"ServiceOverrunError\";\n  }\n}\n\ntype PolicyOptions = {\n  timezone?: string | null;\n};\n\nexport function getVenuePolicy(options?: PolicyOptions): VenuePolicy {\n  if (!options?.timezone || options.timezone === defaultVenuePolicy.timezone) {\n    return {\n      timezone: defaultVenuePolicy.timezone,\n      serviceOrder: [...defaultVenuePolicy.serviceOrder],\n      services: Object.fromEntries(\n        Object.entries(defaultVenuePolicy.services).map(([key, service]) => [\n          key,\n          service ? cloneService(service) : service,\n        ]),\n      ),\n    };\n  }\n\n  return {\n    timezone: options.timezone,\n    serviceOrder: [...defaultVenuePolicy.serviceOrder],\n    services: Object.fromEntries(\n      Object.entries(defaultVenuePolicy.services).map(([key, service]) => [\n        key,\n        service ? cloneService(service) : service,\n      ]),\n    ),\n  };\n}\n\nfunction toZonedBase(dateTime: DateTime, timezone: string): DateTime {\n  const candidate = dateTime.isValid ? dateTime : DateTime.invalid(\"Invalid start time\");\n  const zoned = candidate.setZone(timezone, { keepLocalTime: false });\n  if (!zoned.isValid) {\n    throw new PolicyError(`Invalid DateTime for policy computation: ${candidate.invalidReason ?? \"unknown reason\"}`);\n  }\n  return zoned;\n}\n\nfunction toDateTime(base: DateTime, time: TimeOfDay): DateTime {\n  return base.set({\n    hour: time.hour,\n    minute: time.minute,\n    second: 0,\n    millisecond: 0,\n  });\n}\n\nfunction resolveServiceWindow(base: DateTime, service: ServiceDefinition): ServiceWindow {\n  const start = toDateTime(base, service.start);\n  let end = toDateTime(base, service.end);\n  if (end <= start) {\n    end = end.plus({ days: 1 });\n  }\n  return { start, end };\n}\n\nfunction activeServices(policy: VenuePolicy): ServiceDefinition[] {\n  return policy.serviceOrder\n    .map((key) => policy.services[key])\n    .filter((service): service is ServiceDefinition => Boolean(service));\n}\n\nexport function whichService(dateTime: DateTime, policy: VenuePolicy = defaultVenuePolicy): ServiceKey | null {\n  const zoned = toZonedBase(dateTime, policy.timezone);\n\n  for (const service of activeServices(policy)) {\n    const window = resolveServiceWindow(zoned, service);\n    if (zoned >= window.start && zoned < window.end) {\n      return service.key;\n    }\n  }\n\n  return null;\n}\n\nexport function serviceWindowFor(\n  serviceKey: ServiceKey,\n  dateTime: DateTime,\n  policy: VenuePolicy = defaultVenuePolicy,\n): ServiceWindow {\n  const service = policy.services[serviceKey];\n  if (!service) {\n    throw new PolicyError(`Unknown service \"${serviceKey}\".`);\n  }\n\n  const zoned = toZonedBase(dateTime, policy.timezone);\n  return resolveServiceWindow(zoned, service);\n}\n\nexport function serviceEnd(\n  serviceKey: ServiceKey,\n  dateTime: DateTime,\n  policy: VenuePolicy = defaultVenuePolicy,\n): DateTime {\n  return serviceWindowFor(serviceKey, dateTime, policy).end;\n}\n\nexport function getTurnBand(\n  serviceKey: ServiceKey,\n  partySize: number,\n  policy: VenuePolicy = defaultVenuePolicy,\n): TurnBand {\n  const service = policy.services[serviceKey];\n  if (!service) {\n    throw new PolicyError(`Unknown service \"${serviceKey}\".`);\n  }\n\n  const bands = service.turnBands;\n  if (!bands || bands.length === 0) {\n    throw new PolicyError(`No turn bands configured for service \"${serviceKey}\".`);\n  }\n\n  if (!Number.isFinite(partySize) || partySize <= 0) {\n    return bands[0]!;\n  }\n\n  for (const band of bands) {\n    if (partySize <= band.maxPartySize) {\n      return band;\n    }\n  }\n\n  return bands[bands.length - 1]!;\n}\n\nexport function bandDuration(\n  serviceKey: ServiceKey,\n  partySize: number,\n  policy: VenuePolicy = defaultVenuePolicy,\n): number {\n  return getTurnBand(serviceKey, partySize, policy).durationMinutes;\n}\n\nexport function getBufferConfig(\n  serviceKey: ServiceKey,\n  policy: VenuePolicy = defaultVenuePolicy,\n): BufferConfig {\n  const service = policy.services[serviceKey];\n  if (!service) {\n    throw new PolicyError(`Unknown service \"${serviceKey}\".`);\n  }\n  return { ...service.buffer };\n}\n"
    },
    {
      "path": "server/capacity/holds.ts",
      "content": "import { DateTime } from \"luxon\";\n\nimport { isHoldStrictConflictsEnabled } from \"@/server/feature-flags\";\nimport { getServiceSupabaseClient } from \"@/server/supabase\";\n\nimport type { Database, Json, Tables, TablesInsert } from \"@/types/supabase\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\n\ntype DbClient = SupabaseClient<Database, \"public\">;\n\nexport type TableHold = {\n  id: string;\n  bookingId: string | null;\n  restaurantId: string;\n  zoneId: string;\n  startAt: string;\n  endAt: string;\n  expiresAt: string;\n  tableIds: string[];\n  createdBy: string | null;\n  metadata: Json | null;\n};\n\nexport type HoldConflictInfo = {\n  holdId: string;\n  bookingId: string | null;\n  tableIds: string[];\n  startAt: string;\n  endAt: string;\n  expiresAt: string;\n};\n\nexport type CreateTableHoldInput = {\n  bookingId: string | null;\n  restaurantId: string;\n  zoneId: string;\n  tableIds: string[];\n  startAt: string;\n  endAt: string;\n  expiresAt: string;\n  createdBy?: string | null;\n  metadata?: Json | null;\n  client?: DbClient;\n};\n\ntype TableHoldWindowRow = {\n  hold_id: string;\n  booking_id: string | null;\n  restaurant_id: string;\n  table_id: string;\n  start_at: string;\n  end_at: string;\n  expires_at: string;\n};\n\nexport type ReleaseTableHoldInput = {\n  holdId: string;\n  client?: DbClient;\n};\n\nexport type ConfirmTableHoldInput = {\n  holdId: string;\n  bookingId: string;\n  idempotencyKey?: string | null;\n  requireAdjacency?: boolean;\n  assignedBy?: string | null;\n  startAt?: string | null;\n  endAt?: string | null;\n  client?: DbClient;\n};\n\nexport type ConfirmedAssignment = {\n  tableId: string;\n  startAt: string;\n  endAt: string;\n  mergeGroupId: string | null;\n};\n\nexport type FindHoldConflictsInput = {\n  restaurantId: string;\n  tableIds: string[];\n  startAt: string;\n  endAt: string;\n  excludeHoldId?: string | null;\n  client?: DbClient;\n};\n\nexport type ListActiveHoldsInput = {\n  bookingId: string;\n  client?: DbClient;\n};\n\nexport type SweepExpiredHoldsInput = {\n  now?: string;\n  limit?: number;\n  client?: DbClient;\n};\n\nexport type SweepExpiredHoldsResult = {\n  total: number;\n  holdIds: string[];\n};\n\nexport class HoldConflictError extends Error {\n  constructor(message: string, public readonly holdId?: string) {\n    super(message);\n    this.name = \"HoldConflictError\";\n  }\n}\n\nexport class HoldNotFoundError extends Error {\n  constructor(message = \"Table hold not found\") {\n    super(message);\n    this.name = \"HoldNotFoundError\";\n  }\n}\n\nexport class AssignTablesRpcError extends Error {\n  public readonly code?: string | null;\n  public readonly details?: string | null;\n  public readonly hint?: string | null;\n\n  constructor(error: { message: string; code?: string | null; details?: string | null; hint?: string | null }) {\n    super(error.message);\n    this.name = \"AssignTablesRpcError\";\n    this.code = error.code ?? null;\n    this.details = error.details ?? null;\n    this.hint = error.hint ?? null;\n  }\n}\n\nfunction ensureClient(client?: DbClient): DbClient {\n  return client ?? getServiceSupabaseClient();\n}\n\nasync function configureHoldStrictConflictSession(client: DbClient): Promise<void> {\n  const enabled = isHoldStrictConflictsEnabled();\n  if (typeof client.rpc !== \"function\") {\n    return;\n  }\n  try {\n    const { error } = await client.rpc(\"set_hold_conflict_enforcement\", { enabled });\n    if (error) {\n      console.warn(\"[capacity.hold] failed to configure strict conflict enforcement\", {\n        enabled,\n        error: error.message ?? error,\n      });\n    }\n  } catch (error) {\n    console.warn(\"[capacity.hold] failed to configure strict conflict enforcement\", {\n      enabled,\n      error: error instanceof Error ? error.message : String(error),\n    });\n  }\n}\n\nfunction normalizeHold(row: Tables<\"table_holds\">, tableIds: string[]): TableHold {\n  return {\n    id: row.id,\n    bookingId: row.booking_id,\n    restaurantId: row.restaurant_id,\n    zoneId: row.zone_id,\n    startAt: row.start_at,\n    endAt: row.end_at,\n    expiresAt: row.expires_at,\n    tableIds,\n    createdBy: row.created_by,\n    metadata: row.metadata ?? null,\n  };\n}\n\ntype HoldRowWithMembers = Tables<\"table_holds\"> & {\n  table_hold_members?: unknown;\n};\n\ntype AssignTablesRowPayload = {\n  table_id?: unknown;\n  start_at?: unknown;\n  end_at?: unknown;\n  merge_group_id?: unknown;\n};\n\nfunction extractTableIdsFromMembers(members: unknown): string[] {\n  if (!Array.isArray(members)) {\n    return [];\n  }\n\n  return members\n    .map((member) => {\n      if (!member || typeof member !== \"object\") {\n        return null;\n      }\n\n      const tableId = (member as { table_id?: unknown }).table_id;\n      return typeof tableId === \"string\" ? tableId : null;\n    })\n    .filter((tableId): tableId is string => tableId !== null);\n}\n\nfunction mapAssignments(payload: unknown): ConfirmedAssignment[] {\n  if (!Array.isArray(payload)) {\n    return [];\n  }\n\n  return payload\n    .map((row) => {\n      if (!row || typeof row !== \"object\") {\n        return null;\n      }\n\n      const record = row as AssignTablesRowPayload;\n      if (\n        typeof record.table_id !== \"string\" ||\n        typeof record.start_at !== \"string\" ||\n        typeof record.end_at !== \"string\"\n      ) {\n        return null;\n      }\n\n      const mergeGroupId = record.merge_group_id;\n      return {\n        tableId: record.table_id,\n        startAt: record.start_at,\n        endAt: record.end_at,\n        mergeGroupId: typeof mergeGroupId === \"string\" ? mergeGroupId : null,\n      } satisfies ConfirmedAssignment;\n    })\n    .filter((assignment): assignment is ConfirmedAssignment => assignment !== null);\n}\n\nfunction intervalsOverlap(aStart: string, aEnd: string, bStart: string, bEnd: string): boolean {\n  const startA = DateTime.fromISO(aStart);\n  const endA = DateTime.fromISO(aEnd);\n  const startB = DateTime.fromISO(bStart);\n  const endB = DateTime.fromISO(bEnd);\n  if (!startA.isValid || !endA.isValid || !startB.isValid || !endB.isValid) {\n    return false;\n  }\n  return startA < endB && startB < endA;\n}\n\nexport async function createTableHold(input: CreateTableHoldInput): Promise<TableHold> {\n  const {\n    bookingId,\n    restaurantId,\n    zoneId,\n    tableIds,\n    startAt,\n    endAt,\n    expiresAt,\n    createdBy = null,\n    metadata = null,\n    client,\n  } = input;\n\n  if (!Array.isArray(tableIds) || tableIds.length === 0) {\n    throw new HoldConflictError(\"Cannot create a hold without tables\");\n  }\n\n  const supabase = ensureClient(client);\n  await configureHoldStrictConflictSession(supabase);\n\n  if (isHoldStrictConflictsEnabled()) {\n    try {\n      const conflicts = await findHoldConflicts({\n        restaurantId,\n        tableIds,\n        startAt,\n        endAt,\n        client: supabase,\n      });\n      const blockingConflicts = conflicts.filter((conflict) => conflict.bookingId !== bookingId);\n      if (blockingConflicts.length > 0) {\n        const { emitHoldStrictConflict } = await import(\"./telemetry\");\n        await emitHoldStrictConflict({\n          restaurantId,\n          bookingId,\n          tableIds,\n          startAt,\n          endAt,\n          conflicts: blockingConflicts.map((conflict) => ({\n            holdId: conflict.holdId,\n            bookingId: conflict.bookingId,\n            tableIds: conflict.tableIds,\n            startAt: conflict.startAt,\n            endAt: conflict.endAt,\n            expiresAt: conflict.expiresAt,\n          })),\n        });\n        throw new HoldConflictError(\"Existing holds conflict with requested tables\", blockingConflicts[0]?.holdId);\n      }\n    } catch (error) {\n      if (error instanceof HoldConflictError) {\n        throw error;\n      }\n      console.warn(\"[capacity.hold] strict conflict evaluation failed; proceeding with relaxed checks\", {\n        restaurantId,\n        error,\n      });\n    }\n  }\n\n  const insertPayload: TablesInsert<\"table_holds\"> = {\n    booking_id: bookingId,\n    restaurant_id: restaurantId,\n    zone_id: zoneId,\n    start_at: startAt,\n    end_at: endAt,\n    expires_at: expiresAt,\n    created_by: createdBy,\n    metadata,\n  };\n\n  const { data: holdRow, error: insertError } = await supabase\n    .from(\"table_holds\")\n    .insert(insertPayload)\n    .select(\"id, booking_id, restaurant_id, zone_id, start_at, end_at, expires_at, created_by, metadata\")\n    .maybeSingle();\n\n  if (insertError || !holdRow) {\n    throw new HoldConflictError(insertError?.message ?? \"Failed to create table hold\");\n  }\n\n  const memberRows = tableIds.map((tableId) => ({\n    hold_id: holdRow.id,\n    table_id: tableId,\n  }));\n\n  const { error: memberError } = await supabase.from(\"table_hold_members\").insert(memberRows);\n\n  if (memberError) {\n    await supabase.from(\"table_holds\").delete().eq(\"id\", holdRow.id);\n    throw new HoldConflictError(memberError.message ?? \"Failed to record table hold members\", holdRow.id);\n  }\n\n  const hold = normalizeHold(holdRow as Tables<\"table_holds\">, tableIds);\n\n  const { emitHoldCreated } = await import(\"./telemetry\");\n  await emitHoldCreated({\n    holdId: hold.id,\n    bookingId: hold.bookingId,\n    restaurantId: hold.restaurantId,\n    zoneId: hold.zoneId,\n    tableIds: hold.tableIds,\n    startAt: hold.startAt,\n    endAt: hold.endAt,\n    expiresAt: hold.expiresAt,\n    actorId: createdBy,\n    metadata,\n  });\n\n  return hold;\n}\n\nexport async function releaseTableHold(input: ReleaseTableHoldInput): Promise<void> {\n  const { holdId, client } = input;\n  const supabase = ensureClient(client);\n  await configureHoldStrictConflictSession(supabase);\n  await supabase.from(\"table_hold_members\").delete().eq(\"hold_id\", holdId);\n  await supabase.from(\"table_holds\").delete().eq(\"id\", holdId);\n}\n\nexport async function listActiveHoldsForBooking(input: ListActiveHoldsInput): Promise<TableHold[]> {\n  const { bookingId, client } = input;\n  const supabase = ensureClient(client);\n\n  const { data, error } = await supabase\n    .from(\"table_holds\")\n    .select(\"*, table_hold_members(table_id)\")\n    .eq(\"booking_id\", bookingId)\n    .gt(\"expires_at\", new Date().toISOString());\n\n  if (error || !data) {\n    return [];\n  }\n\n  return data.map((row) => {\n    const holdRow = row as HoldRowWithMembers;\n    const memberTableIds = extractTableIdsFromMembers(holdRow.table_hold_members ?? null);\n    return normalizeHold(holdRow, memberTableIds);\n  });\n}\n\nexport async function findHoldConflicts(input: FindHoldConflictsInput): Promise<HoldConflictInfo[]> {\n  const { restaurantId, tableIds, startAt, endAt, excludeHoldId = null, client } = input;\n\n  if (!Array.isArray(tableIds) || tableIds.length === 0) {\n    return [];\n  }\n\n  const supabase = ensureClient(client);\n  await configureHoldStrictConflictSession(supabase);\n  if (!isHoldStrictConflictsEnabled()) {\n    return await findHoldConflictsLegacy({ restaurantId, tableIds, startAt, endAt, excludeHoldId, client: supabase });\n  }\n  const nowIso = new Date().toISOString();\n  const rangeLiteral = `[${startAt},${endAt})`;\n\n  try {\n    const { data, error } = await supabase\n      .from(\"table_hold_windows\")\n      .select(\"hold_id, booking_id, restaurant_id, table_id, start_at, end_at, expires_at\")\n      .eq(\"restaurant_id\", restaurantId)\n      .gt(\"expires_at\", nowIso)\n      .in(\"table_id\", tableIds)\n      .filter(\"hold_window\", \"ov\", rangeLiteral);\n\n    if (error) {\n      const code = (error as { code?: string }).code;\n      if (code === \"42P01\") {\n        return await findHoldConflictsLegacy({ restaurantId, tableIds, startAt, endAt, excludeHoldId, client: supabase });\n      }\n      console.warn(\"[capacity.hold] hold_window query failed; falling back to legacy conflict detection\", {\n        restaurantId,\n        error,\n      });\n      return await findHoldConflictsLegacy({ restaurantId, tableIds, startAt, endAt, excludeHoldId, client: supabase });\n    }\n\n    const rows = Array.isArray(data) ? (data as TableHoldWindowRow[]) : [];\n    if (rows.length === 0) {\n      return [];\n    }\n\n    const grouped = new Map<string, HoldConflictInfo>();\n\n    for (const row of rows) {\n      if (!row || (excludeHoldId && row.hold_id === excludeHoldId)) {\n        continue;\n      }\n      if (!intervalsOverlap(row.start_at, row.end_at, startAt, endAt)) {\n        continue;\n      }\n      const key = row.hold_id;\n      if (!grouped.has(key)) {\n        grouped.set(key, {\n          holdId: row.hold_id,\n          bookingId: row.booking_id,\n          tableIds: [],\n          startAt: row.start_at,\n          endAt: row.end_at,\n          expiresAt: row.expires_at,\n        });\n      }\n      const entry = grouped.get(key)!;\n      if (!entry.tableIds.includes(row.table_id)) {\n        entry.tableIds.push(row.table_id);\n      }\n    }\n\n    return Array.from(grouped.values());\n  } catch (error) {\n    const code = (error as { code?: string }).code;\n    if (code === \"42P01\") {\n      return await findHoldConflictsLegacy({ restaurantId, tableIds, startAt, endAt, excludeHoldId, client: supabase });\n    }\n    console.warn(\"[capacity.hold] conflict evaluation failed; using legacy fallback\", {\n      restaurantId,\n      error,\n    });\n    return await findHoldConflictsLegacy({ restaurantId, tableIds, startAt, endAt, excludeHoldId, client: supabase });\n  }\n}\n\nasync function findHoldConflictsLegacy(params: {\n  restaurantId: string;\n  tableIds: string[];\n  startAt: string;\n  endAt: string;\n  excludeHoldId?: string | null;\n  client: DbClient;\n}): Promise<HoldConflictInfo[]> {\n  const { restaurantId, tableIds, startAt, endAt, excludeHoldId = null, client } = params;\n\n  const query = client\n    .from(\"table_holds\")\n    .select(\"id, booking_id, start_at, end_at, expires_at, table_hold_members(table_id)\")\n    .eq(\"restaurant_id\", restaurantId)\n    .gt(\"expires_at\", new Date().toISOString())\n    .lt(\"start_at\", endAt)\n    .gt(\"end_at\", startAt);\n\n  const { data, error } = await query;\n\n  if (error || !data) {\n    return [];\n  }\n\n  const conflicts: HoldConflictInfo[] = [];\n\n  for (const row of data) {\n    if (excludeHoldId && row.id === excludeHoldId) {\n      continue;\n    }\n\n    const members = (row.table_hold_members ?? []) as Array<{ table_id: string }>;\n    const memberTableIds = members.map((member) => member.table_id);\n\n    if (!memberTableIds.some((id) => tableIds.includes(id))) {\n      continue;\n    }\n\n    if (!intervalsOverlap(row.start_at, row.end_at, startAt, endAt)) {\n      continue;\n    }\n\n    conflicts.push({\n      holdId: row.id,\n      bookingId: row.booking_id,\n      tableIds: memberTableIds,\n      startAt: row.start_at,\n      endAt: row.end_at,\n      expiresAt: row.expires_at,\n    });\n  }\n\n  return conflicts;\n}\n\nexport async function confirmTableHold(input: ConfirmTableHoldInput): Promise<ConfirmedAssignment[]> {\n  const {\n    holdId,\n    bookingId,\n    idempotencyKey = null,\n    requireAdjacency = false,\n    assignedBy = null,\n    startAt = null,\n    endAt = null,\n    client,\n  } = input;\n  const supabase = ensureClient(client);\n  await configureHoldStrictConflictSession(supabase);\n\n  const { data: holdRow, error: holdError } = await supabase\n    .from(\"table_holds\")\n    .select(\"*, table_hold_members(table_id)\")\n    .eq(\"id\", holdId)\n    .maybeSingle();\n\n  if (holdError) {\n    throw new HoldNotFoundError(holdError.message ?? \"Failed to load hold\");\n  }\n\n  if (!holdRow) {\n    throw new HoldNotFoundError();\n  }\n\n  if (holdRow.booking_id && holdRow.booking_id !== bookingId) {\n    throw new HoldConflictError(\"Hold is linked to a different booking\", holdId);\n  }\n\n  const tableIds = (holdRow.table_hold_members ?? []).map((member: { table_id: string }) => member.table_id);\n  if (tableIds.length === 0) {\n    throw new HoldConflictError(\"Hold has no tables\", holdId);\n  }\n\n  const effectiveStartAt = startAt ?? holdRow.start_at ?? null;\n  const effectiveEndAt = endAt ?? holdRow.end_at ?? null;\n\n  if (!effectiveStartAt || !effectiveEndAt) {\n    throw new AssignTablesRpcError({\n      message: \"Unable to resolve assignment window for table hold\",\n      details: null,\n      hint: null,\n    });\n  }\n\n  const { data, error } = await supabase.rpc(\"assign_tables_atomic_v2\", {\n    p_booking_id: bookingId,\n    p_table_ids: tableIds,\n    p_idempotency_key: idempotencyKey,\n    p_require_adjacency: requireAdjacency,\n    p_assigned_by: assignedBy,\n    p_start_at: effectiveStartAt,\n    p_end_at: effectiveEndAt,\n  });\n\n  if (error) {\n    const { emitRpcConflict } = await import(\"./telemetry\");\n    await emitRpcConflict({\n      source: \"confirm_table_hold\",\n      bookingId,\n      restaurantId: holdRow.restaurant_id,\n      tableIds,\n      idempotencyKey,\n      holdId,\n      error: {\n        code: error.code ?? null,\n        message: error.message ?? \"assign_tables_atomic_v2 failed\",\n        details: error.details ?? null,\n        hint: error.hint ?? null,\n      },\n    });\n    throw new AssignTablesRpcError({\n      message: error.message ?? \"assign_tables_atomic_v2 failed\",\n      code: error.code,\n      details: error.details,\n      hint: error.hint,\n    });\n  }\n\n  const assignments = mapAssignments(data);\n\n  await supabase.from(\"table_holds\").delete().eq(\"id\", holdId);\n\n  return assignments;\n}\n\nexport async function sweepExpiredHolds(input?: SweepExpiredHoldsInput): Promise<SweepExpiredHoldsResult> {\n  const { now, limit = 100, client } = input ?? {};\n  const supabase = ensureClient(client);\n  await configureHoldStrictConflictSession(supabase);\n  const cutoff = now ?? new Date().toISOString();\n\n  const { data, error } = await supabase\n    .from(\"table_holds\")\n    .select(\"id\")\n    .lte(\"expires_at\", cutoff)\n    .order(\"expires_at\", { ascending: true })\n    .limit(limit);\n\n  if (error) {\n    console.warn(\"[capacity.hold] sweepExpiredHolds failed\", {\n      error,\n      cutoff,\n      limit,\n    });\n    return {\n      total: 0,\n      holdIds: [],\n    };\n  }\n\n  if (!data || data.length === 0) {\n    return {\n      total: 0,\n      holdIds: [],\n    };\n  }\n\n  const holdIds = data.map((row) => row.id);\n  await supabase.from(\"table_hold_members\").delete().in(\"hold_id\", holdIds);\n  await supabase.from(\"table_holds\").delete().in(\"id\", holdIds);\n\n  return {\n    total: holdIds.length,\n    holdIds,\n  };\n}\n"
    },
    {
      "path": "server/capacity/telemetry.ts",
      "content": "import { recordObservabilityEvent } from \"@/server/observability\";\n\nimport type { SelectorScoringWeights, ServiceKey } from \"./policy\";\nimport type { CandidateDiagnostics, ScoreBreakdown } from \"./selector\";\nimport type { Json } from \"@/types/supabase\";\n\nconst EMAIL_PATTERN = /[A-Z0-9._%+-]+@[A-Z0-9.-]+\\.[A-Z]{2,}/gi;\n\nconst SENSITIVE_NAME_KEYS = new Set([\n  \"name\",\n  \"guestName\",\n  \"guest_name\",\n  \"customerName\",\n  \"customer_name\",\n  \"primaryGuestName\",\n  \"primary_guest_name\",\n  \"createdByName\",\n  \"created_by_name\",\n  \"assignedToName\",\n  \"assigned_to_name\",\n]);\n\nfunction redactEmails(value: string): string {\n  if (!value) {\n    return value;\n  }\n  return value.replace(EMAIL_PATTERN, \"[redacted-email]\");\n}\n\nfunction sanitizeTelemetryValue(value: unknown, key?: string): Json {\n  if (value === null || value === undefined) {\n    return null;\n  }\n\n  if (typeof value === \"string\") {\n    if (key && SENSITIVE_NAME_KEYS.has(key)) {\n      return \"[redacted]\";\n    }\n    return redactEmails(value) as Json;\n  }\n\n  if (typeof value === \"number\" || typeof value === \"boolean\") {\n    return value;\n  }\n\n  if (Array.isArray(value)) {\n    return value.map((item) => sanitizeTelemetryValue(item)) as Json[];\n  }\n\n  if (typeof value === \"object\") {\n    const result: Record<string, Json> = {};\n    for (const [entryKey, entryValue] of Object.entries(value as Record<string, unknown>)) {\n      if (SENSITIVE_NAME_KEYS.has(entryKey)) {\n        result[entryKey] = \"[redacted]\";\n        continue;\n      }\n      result[entryKey] = sanitizeTelemetryValue(entryValue, entryKey);\n    }\n    return result;\n  }\n\n  return null;\n}\n\nfunction sanitizeTelemetryContext<T extends Json>(input: T): T {\n  return sanitizeTelemetryValue(input) as T;\n}\n\nexport type CandidateSummary = {\n  tableIds: string[];\n  tableNumbers: string[];\n  totalCapacity: number;\n  tableCount: number;\n  slack?: number;\n  score?: number;\n  adjacencyStatus?: \"single\" | \"connected\" | \"disconnected\";\n  scoreBreakdown?: CandidateScoreBreakdown;\n};\n\nexport type CandidateScoreBreakdown = {\n  slack_penalty: number;\n  scarcity_penalty: number;\n  structural_penalty: number;\n  demand_multiplier: number;\n  combination_penalty: number;\n  future_conflict_penalty: number;\n  total_score: number;\n};\n\nexport type StrategicPenaltyTelemetry = {\n  dominant: \"slack\" | \"scarcity\" | \"future_conflict\" | \"structural\" | \"unknown\";\n  slack: number;\n  scarcity: number;\n  futureConflict: number;\n};\n\nexport type SelectorDecisionEvent = {\n  restaurantId: string;\n  bookingId: string;\n  partySize: number;\n  window?: { start: string | null; end: string | null };\n  candidates: CandidateSummary[];\n  selected?: CandidateSummary | null;\n  skipReason?: string | null;\n  rejectionClassification?: \"hard\" | \"strategic\" | null;\n  strategicPenalties?: StrategicPenaltyTelemetry | null;\n  durationMs: number;\n  featureFlags: {\n    selectorScoring: boolean;\n    opsMetrics: boolean;\n    plannerTimePruning: boolean;\n    adjacencyUndirected: boolean;\n    holdsStrictConflicts: boolean;\n    allocatorFailHard: boolean;\n    selectorLookahead: boolean;\n  };\n  timing?: {\n    totalMs: number;\n    plannerMs?: number;\n    assignmentMs?: number;\n    holdMs?: number;\n  };\n  plannerConfig?: {\n    combinationEnabled: boolean;\n    requireAdjacency: boolean;\n    adjacencyRequiredGlobally: boolean;\n    adjacencyMinPartySize: number | null;\n    kMax: number;\n    bucketLimit: number;\n    evaluationLimit: number;\n    maxOverage: number;\n    maxTables: number;\n    weights: SelectorScoringWeights;\n    featureFlags: {\n      selectorScoring: boolean;\n      opsMetrics: boolean;\n      plannerTimePruning: boolean;\n      adjacencyUndirected: boolean;\n      holdsStrictConflicts: boolean;\n      allocatorFailHard: boolean;\n      selectorLookahead: boolean;\n    };\n    serviceFallback: {\n      used: boolean;\n      service: ServiceKey | null;\n    };\n    demandMultiplier: number;\n    demandRule: {\n      label?: string | null;\n      source: string;\n      serviceWindow?: string | null;\n      days?: string[];\n      start?: string | null;\n      end?: string | null;\n      priority?: number | null;\n    } | null;\n    lookahead: {\n      enabled: boolean;\n      windowMinutes: number;\n      penaltyWeight: number;\n    };\n  };\n  diagnostics?: CandidateDiagnostics;\n};\n\nexport type SelectorDecisionCapture = {\n  type: \"capacity.selector\";\n  timestamp: string;\n  restaurantId: string;\n  bookingId: string;\n  partySize: number;\n  window: { start: string | null; end: string | null } | null;\n  selected: CandidateSummary | null;\n  topCandidates: CandidateSummary[];\n  candidates: CandidateSummary[];\n  skipReason: string | null;\n  rejectionClassification: \"hard\" | \"strategic\" | null;\n  strategicPenalties: StrategicPenaltyTelemetry | null;\n  durationMs: number;\n  featureFlags: SelectorDecisionEvent[\"featureFlags\"];\n  timing: SelectorDecisionEvent[\"timing\"] | null;\n  plannerConfig: SelectorDecisionEvent[\"plannerConfig\"] | null;\n  diagnostics: CandidateDiagnostics | null;\n};\n\nexport function buildSelectorDecisionPayload(event: SelectorDecisionEvent): SelectorDecisionCapture {\n  const payload: SelectorDecisionCapture = {\n    type: \"capacity.selector\",\n    timestamp: new Date().toISOString(),\n    restaurantId: event.restaurantId,\n    bookingId: event.bookingId,\n    partySize: event.partySize,\n    window: event.window ?? null,\n    selected: event.selected ?? null,\n    topCandidates: event.candidates,\n    candidates: event.candidates,\n    skipReason: event.skipReason ?? null,\n    rejectionClassification: event.rejectionClassification ?? null,\n    strategicPenalties: event.strategicPenalties ?? null,\n    durationMs: event.durationMs,\n    featureFlags: event.featureFlags,\n    timing: event.timing ?? null,\n    plannerConfig: event.plannerConfig ?? null,\n    diagnostics: event.diagnostics ?? null,\n  };\n\n  return sanitizeTelemetryContext(payload) as SelectorDecisionCapture;\n}\n\nexport async function emitSelectorDecision(event: SelectorDecisionEvent): Promise<void> {\n  const sanitizedPayload = buildSelectorDecisionPayload(event);\n\n  try {\n    console.log(JSON.stringify(sanitizedPayload));\n  } catch (error) {\n    console.error(\"[capacity.selector] failed to serialize log payload\", {\n      error,\n      bookingId: event.bookingId,\n      restaurantId: event.restaurantId,\n    });\n  }\n\n  try {\n    await recordObservabilityEvent({\n      source: \"capacity.selector\",\n      eventType: event.selected ? \"capacity.selector.assignment\" : \"capacity.selector.skipped\",\n      severity: event.skipReason ? \"warning\" : \"info\",\n      context: sanitizedPayload,\n      restaurantId: event.restaurantId,\n      bookingId: event.bookingId,\n    });\n  } catch (error) {\n    console.error(\"[capacity.selector] failed to persist observability event\", {\n      error,\n      bookingId: event.bookingId,\n      restaurantId: event.restaurantId,\n    });\n  }\n}\n\nexport type SelectorQuoteEvent = SelectorDecisionEvent & {\n  holdId?: string;\n  expiresAt?: string;\n};\n\nexport async function emitSelectorQuote(event: SelectorQuoteEvent): Promise<void> {\n  const payload = {\n    ...event,\n    type: \"capacity.selector.quote\",\n  };\n\n  const sanitizedPayload = sanitizeTelemetryContext(payload as Json);\n\n  try {\n    await recordObservabilityEvent({\n      source: \"capacity.selector\",\n      eventType: \"capacity.selector.quote\",\n      severity: event.skipReason ? \"warning\" : \"info\",\n      context: sanitizedPayload,\n      restaurantId: event.restaurantId,\n      bookingId: event.bookingId,\n    });\n  } catch (error) {\n    console.error(\"[capacity.selector.quote] failed to record telemetry\", {\n      error,\n      bookingId: event.bookingId,\n      restaurantId: event.restaurantId,\n    });\n  }\n}\n\nexport type HoldTelemetryEvent = {\n  holdId: string;\n  bookingId: string | null;\n  restaurantId: string;\n  zoneId: string;\n  tableIds: string[];\n  startAt: string;\n  endAt: string;\n  expiresAt?: string;\n  actorId?: string | null;\n  reason?: string | null;\n  metadata?: Json | null;\n};\n\nasync function emitHoldEvent(eventType: string, payload: HoldTelemetryEvent): Promise<void> {\n  const sanitizedPayload = sanitizeTelemetryContext(payload as Json);\n  try {\n    await recordObservabilityEvent({\n      source: \"capacity.hold\",\n      eventType,\n      severity: eventType.endsWith(\"expired\") ? \"warning\" : \"info\",\n      context: sanitizedPayload,\n      restaurantId: payload.restaurantId,\n      bookingId: payload.bookingId ?? undefined,\n    });\n  } catch (error) {\n    console.error(`[capacity.hold] failed to emit ${eventType}`, {\n      error,\n      holdId: payload.holdId,\n      bookingId: payload.bookingId,\n    });\n  }\n}\n\nexport async function emitHoldCreated(event: HoldTelemetryEvent): Promise<void> {\n  await emitHoldEvent(\"capacity.hold.created\", event);\n}\n\nexport async function emitHoldConfirmed(event: HoldTelemetryEvent): Promise<void> {\n  await emitHoldEvent(\"capacity.hold.confirmed\", event);\n}\n\nexport async function emitHoldExpired(event: HoldTelemetryEvent): Promise<void> {\n  await emitHoldEvent(\"capacity.hold.expired\", event);\n}\n\nexport type HoldStrictConflictEvent = {\n  restaurantId: string;\n  bookingId: string | null;\n  tableIds: string[];\n  startAt: string;\n  endAt: string;\n  conflicts: Array<{\n    holdId: string;\n    bookingId: string | null;\n    tableIds: string[];\n    startAt: string;\n    endAt: string;\n    expiresAt: string;\n  }>;\n};\n\nexport async function emitHoldStrictConflict(event: HoldStrictConflictEvent): Promise<void> {\n  const sanitizedPayload = sanitizeTelemetryContext(event as Json);\n  try {\n    await recordObservabilityEvent({\n      source: \"capacity.hold\",\n      eventType: \"capacity.hold.strict_conflict\",\n      severity: \"warning\",\n      context: sanitizedPayload,\n      restaurantId: event.restaurantId,\n      bookingId: event.bookingId ?? undefined,\n    });\n  } catch (error) {\n    console.error(\"[capacity.hold] failed to record strict conflict telemetry\", {\n      error,\n      bookingId: event.bookingId,\n      restaurantId: event.restaurantId,\n    });\n  }\n}\n\nexport type RpcConflictEvent = {\n  source: string;\n  bookingId: string;\n  restaurantId: string;\n  tableIds: string[];\n  idempotencyKey?: string | null;\n  holdId?: string | null;\n  error: {\n    code?: string | null;\n    message: string;\n    details?: string | null;\n    hint?: string | null;\n  };\n};\n\nexport async function emitRpcConflict(event: RpcConflictEvent): Promise<void> {\n  const sanitizedPayload = sanitizeTelemetryContext(event as Json);\n  try {\n    await recordObservabilityEvent({\n      source: \"capacity.rpc\",\n      eventType: \"capacity.rpc.conflict\",\n      severity: \"warning\",\n      context: sanitizedPayload,\n      restaurantId: event.restaurantId,\n      bookingId: event.bookingId,\n    });\n  } catch (error) {\n    console.error(\"[capacity.rpc] failed to record conflict telemetry\", {\n      error,\n      bookingId: event.bookingId,\n      restaurantId: event.restaurantId,\n    });\n  }\n}\n\nexport function summarizeCandidate(input: {\n  tableIds: string[];\n  tableNumbers: (string | null | undefined)[];\n  totalCapacity: number;\n  tableCount: number;\n  slack?: number;\n  score?: number;\n  adjacencyStatus?: \"single\" | \"connected\" | \"disconnected\";\n  scoreBreakdown?: ScoreBreakdown;\n}): CandidateSummary {\n  let scoreBreakdown: CandidateScoreBreakdown | undefined;\n  if (input.scoreBreakdown) {\n    scoreBreakdown = {\n      slack_penalty: input.scoreBreakdown.slackPenalty,\n      scarcity_penalty: input.scoreBreakdown.scarcityPenalty,\n      structural_penalty: input.scoreBreakdown.structuralPenalty,\n      demand_multiplier: input.scoreBreakdown.demandMultiplier,\n      combination_penalty: input.scoreBreakdown.combinationPenalty,\n      future_conflict_penalty: input.scoreBreakdown.futureConflictPenalty,\n      total_score: input.scoreBreakdown.total,\n    };\n  }\n\n  return {\n    tableIds: input.tableIds,\n    tableNumbers: input.tableNumbers.map((value) => value ?? \"\"),\n    totalCapacity: input.totalCapacity,\n    tableCount: input.tableCount,\n    slack: input.slack,\n    score: input.score,\n    adjacencyStatus: input.adjacencyStatus,\n    scoreBreakdown,\n  };\n}\n"
    },
    {
      "path": "server/capacity/planner/bitset.ts",
      "content": "import { DateTime } from \"luxon\";\n\ntype Dateish = DateTime | string | number | Date;\n\nconst SLOT_MINUTES = 5;\nconst SLOT_DURATION_MS = SLOT_MINUTES * 60 * 1000;\n\nexport type AvailabilityBitset = {\n  /**\n   * Set of slot indices that are occupied. The index is derived from\n   * `Math.floor(epochMillis / SLOT_DURATION_MS)`.\n   */\n  occupied: Set<number>;\n};\n\nfunction toDateTime(value: Dateish): DateTime {\n  if (value instanceof DateTime) {\n    return value;\n  }\n  if (value instanceof Date) {\n    return DateTime.fromJSDate(value, { zone: \"utc\" });\n  }\n  if (typeof value === \"number\") {\n    return DateTime.fromMillis(value, { zone: \"utc\" });\n  }\n  return DateTime.fromISO(value, { zone: \"utc\" });\n}\n\nfunction toSlotIndex(date: Dateish, round: \"floor\" | \"ceil\" = \"floor\"): number {\n  const millis = toDateTime(date).toMillis();\n  const quotient = millis / SLOT_DURATION_MS;\n  return round === \"floor\" ? Math.floor(quotient) : Math.ceil(quotient);\n}\n\nexport function createAvailabilityBitset(\n  windows?: Array<{ start: Dateish; end: Dateish }>,\n): AvailabilityBitset {\n  const occupied = new Set<number>();\n  if (windows) {\n    for (const window of windows) {\n      markWindow({ occupied }, window.start, window.end);\n    }\n  }\n  return { occupied };\n}\n\nexport function markWindow(bitset: AvailabilityBitset, start: Dateish, end: Dateish): void {\n  const startSlot = toSlotIndex(start, \"floor\");\n  const endSlot = toSlotIndex(end, \"ceil\");\n  for (let slot = startSlot; slot < endSlot; slot += 1) {\n    bitset.occupied.add(slot);\n  }\n}\n\nexport function isWindowFree(bitset: AvailabilityBitset, start: Dateish, end: Dateish): boolean {\n  const startSlot = toSlotIndex(start, \"floor\");\n  const endSlot = toSlotIndex(end, \"ceil\");\n  for (let slot = startSlot; slot < endSlot; slot += 1) {\n    if (bitset.occupied.has(slot)) {\n      return false;\n    }\n  }\n  return true;\n}\n\nexport function mergeBitsets(bitsets: AvailabilityBitset[]): AvailabilityBitset {\n  const merged = createAvailabilityBitset();\n  for (const bitset of bitsets) {\n    for (const slot of bitset.occupied) {\n      merged.occupied.add(slot);\n    }\n  }\n  return merged;\n}\n"
    },
    {
      "path": "server/capacity/demand-profiles.ts",
      "content": "import fs from \"node:fs\";\n\nimport { DateTime } from \"luxon\";\n\nimport { getServiceSupabaseClient } from \"@/server/supabase\";\nimport { getDemandProfileConfigPath } from \"./strategic-config\";\n\nimport type { Database } from \"@/types/supabase\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\nimport type { ServiceKey } from \"./policy\";\n\nconst DAY_NAME_TO_NUMBER: Record<string, number> = {\n  SUNDAY: 0,\n  MONDAY: 1,\n  TUESDAY: 2,\n  WEDNESDAY: 3,\n  THURSDAY: 4,\n  FRIDAY: 5,\n  SATURDAY: 6,\n};\n\nconst CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes\nconst MINUTES_PER_DAY = 24 * 60;\n\nfunction parseTimeToMinutes(value?: string | null): number | null {\n  if (!value) {\n    return null;\n  }\n  const trimmed = value.trim();\n  if (trimmed.length === 0) {\n    return null;\n  }\n  const match = /^([0-2]?\\d):([0-5]\\d)$/.exec(trimmed);\n  if (!match) {\n    return null;\n  }\n  const hour = Number.parseInt(match[1], 10);\n  const minute = Number.parseInt(match[2], 10);\n  if (!Number.isInteger(hour) || !Number.isInteger(minute)) {\n    return null;\n  }\n  if (hour < 0 || hour > 23 || minute < 0 || minute > 59) {\n    return null;\n  }\n  return hour * 60 + minute;\n}\n\nfunction normalizeWindow(start?: string, end?: string): { startMinute: number; endMinute: number } {\n  const startMinute = parseTimeToMinutes(start) ?? 0;\n  let endMinute = parseTimeToMinutes(end) ?? MINUTES_PER_DAY;\n\n  if (endMinute <= startMinute) {\n    endMinute = startMinute === 0 ? MINUTES_PER_DAY : Math.min(startMinute + MINUTES_PER_DAY, MINUTES_PER_DAY);\n  }\n\n  return { startMinute, endMinute };\n}\n\nfunction isWithinWindow(rule: PreparedFallbackRule, minuteOfDay: number): boolean {\n  if (minuteOfDay < 0 || minuteOfDay >= MINUTES_PER_DAY) {\n    return false;\n  }\n  return minuteOfDay >= rule.startMinute && minuteOfDay < rule.endMinute;\n}\n\nfunction compareRules(a: PreparedFallbackRule, b: PreparedFallbackRule): number {\n  if (a.priority !== b.priority) {\n    return b.priority - a.priority;\n  }\n  const durationA = a.endMinute - a.startMinute;\n  const durationB = b.endMinute - b.startMinute;\n  if (durationA !== durationB) {\n    return durationA - durationB;\n  }\n  if (a.startMinute !== b.startMinute) {\n    return a.startMinute - b.startMinute;\n  }\n  return 0;\n}\n\nfunction minutesToTimeString(minutes: number): string {\n  const bounded = Math.max(0, Math.min(MINUTES_PER_DAY - 1, Math.floor(minutes)));\n  const hours = Math.floor(bounded / 60)\n    .toString()\n    .padStart(2, \"0\");\n  const mins = (bounded % 60)\n    .toString()\n    .padStart(2, \"0\");\n  return `${hours}:${mins}`;\n}\n\ntype DbClient = SupabaseClient<Database, \"public\">;\n\nexport type DemandProfileRule = {\n  label?: string;\n  serviceWindow: string;\n  days: string[];\n  start?: string;\n  end?: string;\n  multiplier: number;\n  priority?: number;\n};\n\nexport type DemandMultiplierResult = {\n  multiplier: number;\n  rule?: {\n    label?: string;\n    source: \"restaurant\" | \"default\" | \"fallback\";\n    serviceWindow?: string;\n    days?: string[];\n    start?: string;\n    end?: string;\n    priority?: number | null;\n  };\n};\n\ntype PreparedFallbackRule = {\n  label?: string;\n  serviceWindow: string;\n  multiplier: number;\n  start?: string;\n  end?: string;\n  startMinute: number;\n  endMinute: number;\n  dayNumbers: number[];\n  source: \"default\" | \"restaurant\";\n  priority: number;\n};\n\ntype PreparedFallbackProfiles = {\n  default: PreparedFallbackRule[];\n  restaurants: Map<string, PreparedFallbackRule[]>;\n};\n\ntype CacheEntry = {\n  result: DemandMultiplierResult;\n  expiresAt: number;\n};\n\nconst demandCache = new Map<string, CacheEntry>();\n\nconst EMBEDDED_DEFAULTS: DemandProfileRule[] = [\n  {\n    label: \"weekday-lunch\",\n    serviceWindow: \"lunch\",\n    days: [\"MONDAY\", \"TUESDAY\", \"WEDNESDAY\", \"THURSDAY\", \"FRIDAY\"],\n    start: \"11:30\",\n    end: \"14:30\",\n    multiplier: 0.85,\n  },\n  {\n    label: \"weekday-dinner\",\n    serviceWindow: \"dinner\",\n    days: [\"MONDAY\", \"TUESDAY\", \"WEDNESDAY\", \"THURSDAY\"],\n    start: \"17:30\",\n    end: \"21:30\",\n    multiplier: 1.15,\n  },\n  {\n    label: \"weekend-dinner-peak\",\n    serviceWindow: \"dinner\",\n    days: [\"FRIDAY\", \"SATURDAY\"],\n    start: \"18:00\",\n    end: \"22:30\",\n    multiplier: 1.35,\n  },\n  {\n    label: \"weekend-brunch\",\n    serviceWindow: \"lunch\",\n    days: [\"SATURDAY\", \"SUNDAY\"],\n    start: \"10:00\",\n    end: \"13:00\",\n    multiplier: 1.1,\n  },\n];\n\ntype FallbackConfig = {\n  default: DemandProfileRule[];\n  restaurants?: Record<string, DemandProfileRule[]>;\n};\n\nlet preparedFallbackProfiles: PreparedFallbackProfiles | null = null;\n\nfunction toDayNumber(day: string): number | null {\n  const normalized = day.trim().toUpperCase();\n  return DAY_NAME_TO_NUMBER[normalized] ?? null;\n}\n\nfunction readFallbackConfig(): FallbackConfig {\n  try {\n    const profilePath = getDemandProfileConfigPath();\n    const raw = fs.readFileSync(profilePath, \"utf8\");\n    return JSON.parse(raw) as FallbackConfig;\n  } catch (error) {\n    console.warn(\"[demand-profiles] failed to load fallback config, using embedded defaults\", {\n      error: error instanceof Error ? error.message : String(error),\n      path: getDemandProfileConfigPath(),\n    });\n    return { default: EMBEDDED_DEFAULTS };\n  }\n}\n\nfunction prepareFallbackProfiles(): PreparedFallbackProfiles {\n  if (preparedFallbackProfiles) {\n    return preparedFallbackProfiles;\n  }\n\n  const config = readFallbackConfig();\n  const defaultRules: PreparedFallbackRule[] = [];\n  const restaurantRules = new Map<string, PreparedFallbackRule[]>();\n\n  const processRuleSet = (rules: DemandProfileRule[] | undefined, source: \"default\" | \"restaurant\"): PreparedFallbackRule[] => {\n    if (!Array.isArray(rules)) {\n      return [];\n    }\n\n    const prepared: PreparedFallbackRule[] = [];\n    for (const rule of rules) {\n      if (!rule) {\n        continue;\n      }\n      const dayNumbers = (rule.days ?? [])\n        .map((day) => toDayNumber(day))\n        .filter((value): value is number => value !== null);\n\n      if (dayNumbers.length === 0) {\n        continue;\n      }\n\n      const serviceWindow = (rule.serviceWindow ?? rule.label ?? \"dinner\").toString().toLowerCase();\n      const { startMinute, endMinute } = normalizeWindow(rule.start, rule.end);\n      const priority = typeof rule.priority === \"number\" ? rule.priority : 0;\n\n      prepared.push({\n        label: rule.label,\n        serviceWindow,\n        multiplier: rule.multiplier,\n        start: rule.start,\n        end: rule.end,\n        startMinute,\n        endMinute,\n        dayNumbers,\n        source,\n        priority,\n      });\n    }\n\n    return prepared;\n  };\n\n  defaultRules.push(...processRuleSet(config.default ?? EMBEDDED_DEFAULTS, \"default\"));\n\n  if (config.restaurants) {\n    for (const [restaurantId, rules] of Object.entries(config.restaurants)) {\n      if (!Array.isArray(rules) || rules.length === 0) {\n        continue;\n      }\n      restaurantRules.set(restaurantId, processRuleSet(rules, \"restaurant\"));\n    }\n  }\n\n  preparedFallbackProfiles = {\n    default: defaultRules,\n    restaurants: restaurantRules,\n  };\n\n  return preparedFallbackProfiles;\n}\n\nfunction getFallbackRule(\n  restaurantId: string | null | undefined,\n  dayOfWeek: number,\n  serviceWindow: string,\n  minuteOfDay: number,\n): PreparedFallbackRule | null {\n  const profiles = prepareFallbackProfiles();\n  const candidates: PreparedFallbackRule[] = [];\n\n  if (restaurantId) {\n    const restaurantSpecific = profiles.restaurants.get(restaurantId);\n    if (restaurantSpecific) {\n      candidates.push(...restaurantSpecific);\n    }\n  }\n\n  candidates.push(...profiles.default);\n  const normalizedWindow = serviceWindow.toLowerCase();\n\n  const matching = candidates\n    .filter(\n      (rule) =>\n        rule.serviceWindow === normalizedWindow &&\n        rule.dayNumbers.includes(dayOfWeek) &&\n        isWithinWindow(rule, minuteOfDay),\n    )\n    .sort(compareRules);\n\n  return matching[0] ?? null;\n}\n\nfunction buildCacheKey(\n  restaurantId: string | null | undefined,\n  dayOfWeek: number,\n  serviceWindow: string,\n  minuteOfDay: number,\n): string {\n  const boundedMinute = Math.max(0, Math.min(MINUTES_PER_DAY - 1, minuteOfDay));\n  return `${restaurantId ?? \"default\"}|${dayOfWeek}|${serviceWindow.toLowerCase()}|${boundedMinute}`;\n}\n\nasync function fetchRestaurantMultiplier(params: {\n  restaurantId: string;\n  dayOfWeek: number;\n  serviceWindow: string;\n  client: DbClient;\n}): Promise<{ multiplier: number; rule: DemandMultiplierResult[\"rule\"] } | null> {\n  const { restaurantId, dayOfWeek, serviceWindow, client } = params;\n\n  const query = client\n    .from(\"demand_profiles\")\n    .select(\"multiplier, service_window, start_minute, end_minute, priority, label\")\n    .eq(\"restaurant_id\", restaurantId)\n    .eq(\"day_of_week\", dayOfWeek)\n    .eq(\"service_window\", serviceWindow)\n    .limit(1);\n\n  const { data, error } = await query.maybeSingle();\n\n  if (error) {\n    if ((error as { code?: string } | null)?.code === \"42703\") {\n      return fetchRestaurantMultiplierLegacy(params);\n    }\n    throw error;\n  }\n\n  if (!data) {\n    return null;\n  }\n\n  const row = data as unknown as {\n    multiplier: number | null;\n    service_window: string | null;\n    start_minute?: number | null;\n    end_minute?: number | null;\n    priority?: number | null;\n    label?: string | null;\n  };\n\n  const multiplier = Number(row.multiplier ?? 1);\n  const startMinuteRaw = typeof row.start_minute === \"number\" ? row.start_minute : null;\n  const endMinuteRaw = typeof row.end_minute === \"number\" ? row.end_minute : null;\n  const normalizedWindow = normalizeWindow(\n    typeof startMinuteRaw === \"number\" ? minutesToTimeString(startMinuteRaw) : undefined,\n    typeof endMinuteRaw === \"number\" ? minutesToTimeString(endMinuteRaw) : undefined,\n  );\n\n  const startLabel = startMinuteRaw !== null ? minutesToTimeString(normalizedWindow.startMinute) : null;\n  const endLabel = endMinuteRaw !== null ? minutesToTimeString(normalizedWindow.endMinute - 1) : null;\n  const priority = typeof row.priority === \"number\" ? row.priority : null;\n\n  return {\n    multiplier,\n    rule: {\n      label: row.label ?? row.service_window ?? serviceWindow,\n      serviceWindow,\n      source: \"restaurant\",\n      start: startLabel ?? undefined,\n      end: endLabel ?? undefined,\n      priority,\n    },\n  };\n}\n\nasync function fetchRestaurantMultiplierLegacy(params: {\n  restaurantId: string;\n  dayOfWeek: number;\n  serviceWindow: string;\n  client: DbClient;\n}): Promise<{ multiplier: number; rule: DemandMultiplierResult[\"rule\"] } | null> {\n  const { restaurantId, dayOfWeek, serviceWindow, client } = params;\n  const { data, error } = await client\n    .from(\"demand_profiles\")\n    .select(\"multiplier, service_window\")\n    .eq(\"restaurant_id\", restaurantId)\n    .eq(\"day_of_week\", dayOfWeek)\n    .eq(\"service_window\", serviceWindow)\n    .maybeSingle();\n\n  if (error || !data) {\n    return null;\n  }\n\n  const multiplier = Number(data.multiplier ?? 1);\n\n  return {\n    multiplier,\n    rule: {\n      label: data.service_window ?? serviceWindow,\n      serviceWindow,\n      source: \"restaurant\",\n    },\n  };\n}\n\nfunction toDemandRuleFromFallback(\n  fallback: PreparedFallbackRule,\n  localized: DateTime,\n): DemandMultiplierResult[\"rule\"] {\n  const dayName = localized.setLocale(\"en\").weekdayLong ?? \"Unknown\";\n\n  return {\n    label: fallback.label,\n    serviceWindow: fallback.serviceWindow,\n    source: fallback.source,\n    days: [dayName],\n    start: fallback.start,\n    end: fallback.end,\n    priority: fallback.priority,\n  };\n}\n\nexport async function resolveDemandMultiplier(params: {\n  restaurantId?: string | null;\n  serviceStart: DateTime;\n  serviceKey?: ServiceKey | string | null;\n  timezone?: string | null;\n  client?: DbClient;\n}): Promise<DemandMultiplierResult> {\n  const client = params.client ?? getServiceSupabaseClient();\n  const targetTimezone = params.timezone ?? params.serviceStart.zoneName ?? \"UTC\";\n  const localized = params.serviceStart.setZone(targetTimezone);\n\n  if (!localized.isValid) {\n    return { multiplier: 1, rule: { source: \"fallback\" } };\n  }\n\n  const dayOfWeek = localized.weekday % 7; // Luxon weekday: 1 (Mon) .. 7 (Sun)\n  const serviceWindow = (params.serviceKey ?? \"dinner\").toString().toLowerCase();\n  const weekdayLabel = localized.setLocale(\"en\").weekdayLong ?? localized.weekdayLong ?? \"Unknown\";\n  const minuteOfDay = localized.hour * 60 + localized.minute;\n  const cacheKey = buildCacheKey(params.restaurantId, dayOfWeek, serviceWindow, minuteOfDay);\n  const now = Date.now();\n  const cached = demandCache.get(cacheKey);\n\n  if (cached && cached.expiresAt > now) {\n    return cached.result;\n  }\n\n  let multiplier = 1;\n  let rule: DemandMultiplierResult[\"rule\"] | undefined;\n\n  if (params.restaurantId) {\n    const restaurantResult = await fetchRestaurantMultiplier({\n      restaurantId: params.restaurantId,\n      dayOfWeek,\n      serviceWindow,\n      client,\n    });\n\n    if (restaurantResult) {\n      multiplier = restaurantResult.multiplier;\n      const normalizedRule = restaurantResult.rule ?? { source: \"restaurant\" as const };\n      rule = {\n        ...normalizedRule,\n        source: normalizedRule.source ?? (\"restaurant\" as const),\n        days: [weekdayLabel],\n        priority: normalizedRule.priority ?? null,\n      };\n\n      demandCache.set(cacheKey, {\n        result: { multiplier, rule },\n        expiresAt: now + CACHE_TTL_MS,\n      });\n\n      return { multiplier, rule };\n    }\n  }\n\n  const fallbackRule = getFallbackRule(params.restaurantId ?? undefined, dayOfWeek, serviceWindow, minuteOfDay);\n  if (fallbackRule) {\n    multiplier = fallbackRule.multiplier;\n    rule = toDemandRuleFromFallback(fallbackRule, localized);\n  } else {\n    rule = {\n      source: \"fallback\",\n      serviceWindow,\n      days: [weekdayLabel],\n      priority: null,\n    };\n  }\n\n  const result: DemandMultiplierResult = { multiplier, rule };\n\n  demandCache.set(cacheKey, {\n    result,\n    expiresAt: now + CACHE_TTL_MS,\n  });\n\n  return result;\n}\n\nexport function clearDemandMultiplierCache(): void {\n  demandCache.clear();\n}\n\nexport function clearDemandProfileFallbackCache(): void {\n  preparedFallbackProfiles = null;\n}\n\nexport function clearAllDemandProfileCaches(): void {\n  clearDemandMultiplierCache();\n  clearDemandProfileFallbackCache();\n}\n"
    },
    {
      "path": "server/capacity/scarcity.ts",
      "content": "import { getServiceSupabaseClient } from \"@/server/supabase\";\n\nimport type { Table } from \"./tables\";\nimport type { Database } from \"@/types/supabase\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\n\nconst CACHE_TTL_MS = 5 * 60 * 1000; // 5 minutes\n\ntype DbClient = SupabaseClient<Database, \"public\">;\n\ntype MetricsCacheEntry = {\n  metrics: Map<string, number>;\n  expiresAt: number;\n};\n\nconst scarcityCache = new Map<string, MetricsCacheEntry>();\n\nfunction sanitizeSegment(value: string | null | undefined, fallback: string): string {\n  if (!value) {\n    return fallback;\n  }\n  return value.toString().trim().toLowerCase() || fallback;\n}\n\nexport function deriveTableType(table: Table): string {\n  const capacity = Number.isFinite(table.capacity) ? Number(table.capacity) : 0;\n  const category = sanitizeSegment(table.category as string | null | undefined, \"uncategorized\");\n  const seating = sanitizeSegment(table.seatingType as string | null | undefined, \"standard\");\n\n  return `capacity:${capacity}|category:${category}|seating:${seating}`;\n}\n\nexport function computeScarcityScore(count: number): number {\n  if (!Number.isFinite(count) || count <= 0) {\n    return 0;\n  }\n  return Number((1 / count).toFixed(4));\n}\n\nasync function fetchRestaurantMetrics(client: DbClient, restaurantId: string): Promise<Map<string, number>> {\n  const cacheEntry = scarcityCache.get(restaurantId);\n  const now = Date.now();\n  if (cacheEntry && cacheEntry.expiresAt > now) {\n    return cacheEntry.metrics;\n  }\n\n  const { data, error } = await client\n    .from(\"table_scarcity_metrics\")\n    .select(\"table_type, scarcity_score\")\n    .eq(\"restaurant_id\", restaurantId);\n\n  if (error) {\n    console.warn(\"[scarcity] failed to load metrics, falling back to heuristic\", {\n      restaurantId,\n      error: error.message,\n    });\n    return new Map();\n  }\n\n  const metrics = new Map<string, number>();\n  for (const row of data ?? []) {\n    if (!row || typeof row.table_type !== \"string\") {\n      continue;\n    }\n    const score = Number(row.scarcity_score);\n    if (Number.isFinite(score)) {\n      metrics.set(row.table_type, score);\n    }\n  }\n\n  scarcityCache.set(restaurantId, {\n    metrics,\n    expiresAt: now + CACHE_TTL_MS,\n  });\n\n  return metrics;\n}\n\nexport async function loadTableScarcityScores(params: {\n  restaurantId: string;\n  tables: Table[];\n  client?: DbClient;\n}): Promise<Map<string, number>> {\n  const { restaurantId, tables, client } = params;\n  const dbClient = client ?? getServiceSupabaseClient();\n  const metrics = await fetchRestaurantMetrics(dbClient, restaurantId);\n\n  const countsByType = new Map<string, number>();\n  for (const table of tables) {\n    const type = deriveTableType(table);\n    countsByType.set(type, (countsByType.get(type) ?? 0) + 1);\n  }\n\n  const scores = new Map<string, number>();\n\n  for (const table of tables) {\n    const type = deriveTableType(table);\n    const metricScore = metrics.get(type);\n    if (typeof metricScore === \"number\" && Number.isFinite(metricScore) && metricScore > 0) {\n      scores.set(table.id, Number(metricScore.toFixed(4)));\n      continue;\n    }\n\n    const fallback = computeScarcityScore(countsByType.get(type) ?? 0);\n    scores.set(table.id, fallback);\n  }\n\n  return scores;\n}\n\nexport function clearScarcityCache(): void {\n  scarcityCache.clear();\n}\n"
    },
    {
      "path": "server/capacity/strategic-config.ts",
      "content": "import path from \"node:path\";\n\nimport { env } from \"@/lib/env\";\nimport { getServiceSupabaseClient } from \"@/server/supabase\";\n\nimport type { Database } from \"@/types/supabase\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\n\nconst DEFAULT_DEMAND_PROFILE_RELATIVE_PATH = \"config/demand-profiles.json\";\nexport const DEFAULT_SCARCITY_WEIGHT = 22;\nconst MIN_SCARCITY_WEIGHT = 0;\nconst MAX_SCARCITY_WEIGHT = 1000;\nconst CACHE_TTL_MS = 30_000;\nconst GLOBAL_CACHE_KEY = \"__global__\";\n\ntype DbClient = SupabaseClient<Database, \"public\">;\n\nexport type StrategicConfigSource = \"env\" | \"db\";\n\nexport type StrategicConfigState = {\n  scarcityWeight: number;\n  demandMultiplierOverride: number | null;\n  futureConflictPenalty: number | null;\n  updatedAt: string | null;\n  source: StrategicConfigSource;\n};\n\ntype StrategicConfigCacheEntry = {\n  state: StrategicConfigState;\n  expiresAt: number;\n};\n\nexport type StrategicConfigSnapshotOptions = {\n  restaurantId?: string | null;\n};\n\nexport type StrategicConfigLoadOptions = StrategicConfigSnapshotOptions & {\n  client?: DbClient;\n  force?: boolean;\n};\n\ntype StrategicConfigOverride = Partial<StrategicConfigState> & StrategicConfigSnapshotOptions & {\n  source?: StrategicConfigSource;\n};\n\ntype StrategicConfigRow = {\n  scarcity_weight: number | null;\n  demand_multiplier_override: number | null;\n  future_conflict_penalty: number | null;\n  updated_at: string | null;\n};\n\nlet testScarcityWeight: number | null = null;\nlet testDemandProfilePath: string | null = null;\nlet testConfigOverride: Partial<StrategicConfigState> | null = null;\n\nconst configCache = new Map<string, StrategicConfigCacheEntry>();\n\nfunction clamp(value: number, min: number, max: number): number {\n  if (!Number.isFinite(value)) {\n    return min;\n  }\n  if (value < min) {\n    return min;\n  }\n  if (value > max) {\n    return max;\n  }\n  return value;\n}\n\nfunction resolveConfigPath(rawPath?: string | null): string {\n  if (!rawPath) {\n    return path.join(process.cwd(), DEFAULT_DEMAND_PROFILE_RELATIVE_PATH);\n  }\n  if (path.isAbsolute(rawPath)) {\n    return rawPath;\n  }\n  return path.join(process.cwd(), rawPath);\n}\n\nfunction computeCacheKey(restaurantId: string | null): string {\n  return restaurantId ?? GLOBAL_CACHE_KEY;\n}\n\nfunction createEnvState(): StrategicConfigState {\n  const scarcityWeight = clamp(\n    env.strategic.scarcityWeight ?? DEFAULT_SCARCITY_WEIGHT,\n    MIN_SCARCITY_WEIGHT,\n    MAX_SCARCITY_WEIGHT,\n  );\n\n  return {\n    scarcityWeight,\n    demandMultiplierOverride: null,\n    futureConflictPenalty: null,\n    updatedAt: null,\n    source: \"env\",\n  } as const;\n}\n\nfunction ensureCacheEntry(key: string): StrategicConfigCacheEntry {\n  const existing = configCache.get(key);\n  if (existing) {\n    return existing;\n  }\n\n  const base = createEnvState();\n  const entry: StrategicConfigCacheEntry = {\n    state: key === GLOBAL_CACHE_KEY ? base : { ...base },\n    expiresAt: 0,\n  };\n  configCache.set(key, entry);\n  return entry;\n}\n\nfunction applyTestOverrides(state: StrategicConfigState): StrategicConfigState {\n  const scarcity =\n    typeof testScarcityWeight === \"number\"\n      ? clamp(testScarcityWeight, MIN_SCARCITY_WEIGHT, MAX_SCARCITY_WEIGHT)\n      : state.scarcityWeight;\n\n  const base: StrategicConfigState = {\n    ...state,\n    scarcityWeight: scarcity,\n  };\n\n  if (!testConfigOverride) {\n    return base;\n  }\n\n  return {\n    ...base,\n    ...testConfigOverride,\n    scarcityWeight:\n      typeof testConfigOverride.scarcityWeight === \"number\"\n        ? clamp(testConfigOverride.scarcityWeight, MIN_SCARCITY_WEIGHT, MAX_SCARCITY_WEIGHT)\n        : base.scarcityWeight,\n    source: testConfigOverride.source ?? base.source,\n  };\n}\n\nfunction mapRowToState(row: StrategicConfigRow): StrategicConfigState {\n  const scarcity = clamp(Number(row.scarcity_weight ?? DEFAULT_SCARCITY_WEIGHT), MIN_SCARCITY_WEIGHT, MAX_SCARCITY_WEIGHT);\n  const demandOverride = row.demand_multiplier_override;\n  const futurePenalty = row.future_conflict_penalty;\n\n  return {\n    scarcityWeight: scarcity,\n    demandMultiplierOverride: demandOverride === null ? null : Number(demandOverride),\n    futureConflictPenalty: futurePenalty === null ? null : Number(futurePenalty),\n    updatedAt: row.updated_at ?? null,\n    source: \"db\",\n  };\n}\n\nasync function fetchStrategicConfigFromDb(\n  client: DbClient,\n  restaurantId: string | null,\n): Promise<StrategicConfigState | null> {\n  const query = client\n    .from(\"strategic_configs\")\n    .select(\"scarcity_weight, demand_multiplier_override, future_conflict_penalty, updated_at\")\n    .order(\"updated_at\", { ascending: false })\n    .limit(1);\n\n  const { data, error } = restaurantId\n    ? await query.eq(\"restaurant_id\", restaurantId).maybeSingle()\n    : await query.is(\"restaurant_id\", null).maybeSingle();\n\n  if (error) {\n    const errorCode = typeof error === \"object\" && error && \"code\" in error ? String((error as { code?: string }).code ?? \"\") : \"\";\n    const message = typeof error === \"object\" && error && \"message\" in error ? String((error as { message?: string }).message ?? \"\") : \"\";\n    const isMissingTable = errorCode === \"42P01\" || /unexpected table\\s+strategic_configs/i.test(message) || /relation .*strategic_configs.* does not exist/i.test(message);\n    const isMissingColumns = errorCode === \"42703\" || /column\\s+strategic_configs\\./i.test(message);\n    if (isMissingTable || isMissingColumns) {\n      console.warn(\"[strategic-config] schema unavailable; falling back to env state\", { error: message || errorCode });\n      return null;\n    }\n    throw error;\n  }\n\n  if (!data) {\n    return null;\n  }\n\n  return mapRowToState(data as StrategicConfigRow);\n}\n\nfunction storeState(key: string, state: StrategicConfigState, ttlMs: number): void {\n  const entry = ensureCacheEntry(key);\n  entry.state = { ...state };\n  entry.expiresAt = Date.now() + ttlMs;\n}\n\nexport function getDemandProfileConfigPath(): string {\n  if (testDemandProfilePath) {\n    return testDemandProfilePath;\n  }\n  return resolveConfigPath(env.strategic.demandProfilePath);\n}\n\nexport function getStrategicConfigSnapshot(options: StrategicConfigSnapshotOptions = {}): StrategicConfigState {\n  const key = computeCacheKey(options.restaurantId ?? null);\n  const entry = ensureCacheEntry(key);\n  return applyTestOverrides({ ...entry.state });\n}\n\nexport function getStrategicScarcityWeight(options: StrategicConfigSnapshotOptions = {}): number {\n  const snapshot = getStrategicConfigSnapshot(options);\n  return clamp(snapshot.scarcityWeight ?? DEFAULT_SCARCITY_WEIGHT, MIN_SCARCITY_WEIGHT, MAX_SCARCITY_WEIGHT);\n}\n\nexport async function loadStrategicConfig(options: StrategicConfigLoadOptions = {}): Promise<StrategicConfigState> {\n  const { restaurantId = null, client, force = false } = options;\n  const key = computeCacheKey(restaurantId);\n  const entry = ensureCacheEntry(key);\n  const now = Date.now();\n\n  if (!force && entry.expiresAt > now) {\n    return getStrategicConfigSnapshot({ restaurantId });\n  }\n\n  const supabase = client ?? getServiceSupabaseClient();\n\n  let loadedState: StrategicConfigState | null = null;\n\n  try {\n    if (restaurantId) {\n      loadedState = await fetchStrategicConfigFromDb(supabase, restaurantId);\n    }\n\n    if (!loadedState) {\n      loadedState = await fetchStrategicConfigFromDb(supabase, null);\n      if (loadedState) {\n        storeState(GLOBAL_CACHE_KEY, loadedState, CACHE_TTL_MS);\n      }\n    }\n  } catch (error) {\n    entry.expiresAt = now + CACHE_TTL_MS;\n    throw error;\n  }\n\n  if (!loadedState) {\n    loadedState = createEnvState();\n  }\n\n  storeState(key, loadedState, CACHE_TTL_MS);\n  return getStrategicConfigSnapshot({ restaurantId });\n}\n\nexport function applyStrategicConfigOverride(override: StrategicConfigOverride): void {\n  const key = computeCacheKey(override.restaurantId ?? null);\n  const entry = ensureCacheEntry(key);\n  const next: StrategicConfigState = {\n    ...entry.state,\n    ...override,\n    source: override.source ?? entry.state.source,\n    scarcityWeight: clamp(\n      typeof override.scarcityWeight === \"number\" ? override.scarcityWeight : entry.state.scarcityWeight,\n      MIN_SCARCITY_WEIGHT,\n      MAX_SCARCITY_WEIGHT,\n    ),\n  };\n\n  entry.state = next;\n  entry.expiresAt = Date.now() + CACHE_TTL_MS;\n}\n\nexport function invalidateStrategicConfigCache(restaurantId?: string | null): void {\n  if (typeof restaurantId === \"undefined\") {\n    configCache.clear();\n    return;\n  }\n  const key = computeCacheKey(restaurantId);\n  configCache.delete(key);\n}\n\nexport function setStrategicScarcityWeightForTests(weight?: number | null): void {\n  testScarcityWeight = typeof weight === \"number\" ? weight : null;\n}\n\nexport function setDemandProfileConfigPathForTests(overridePath?: string | null): void {\n  testDemandProfilePath = overridePath && overridePath.length > 0 ? overridePath : null;\n}\n\nexport function setStrategicConfigForTests(override: Partial<StrategicConfigState> | null): void {\n  testConfigOverride = override;\n}\n\nexport function resetStrategicConfigTestOverrides(): void {\n  testScarcityWeight = null;\n  testDemandProfilePath = null;\n  testConfigOverride = null;\n  configCache.clear();\n}\n"
    },
    {
      "path": "server/capacity/strategic-maintenance.ts",
      "content": "import { clearAllDemandProfileCaches } from \"./demand-profiles\";\nimport { invalidateStrategicConfigCache } from \"./strategic-config\";\nimport { clearScarcityCache } from \"./scarcity\";\n\n/**\n * Clears all in-memory caches used by strategic scoring (scarcity + demand profiles).\n * Invoke after updating configuration files or Supabase data to ensure the planner\n * observes new weights without a process restart.\n */\nexport function clearStrategicCaches(): void {\n  clearScarcityCache();\n  clearAllDemandProfileCaches();\n  invalidateStrategicConfigCache();\n}\n"
    },
    {
      "path": "server/capacity/v2/index.ts",
      "content": "export * from \"./types\";\nexport * from \"./repository\";\nexport * from \"./planner\";\nexport * from \"./orchestrator\";\nexport * from \"./errors\";\nexport * from \"./supabase-repository\";\nexport * from \"./utils\";\n"
    },
    {
      "path": "server/capacity/v2/types.ts",
      "content": "import type { CandidateSummary } from \"../telemetry\";\n\nexport type AssignmentSource = \"manual\" | \"auto\";\n\nexport type AssignmentPlan = {\n  /** Deterministic hash representing the candidate plan (tables + window + constraints). */\n  signature: string;\n  tableIds: string[];\n  startAt: string;\n  endAt: string;\n  metadata?: Record<string, unknown>;\n  candidate?: CandidateSummary;\n};\n\nexport type AssignmentContext = {\n  bookingId: string;\n  restaurantId: string;\n  partySize: number;\n  zoneId?: string | null;\n  serviceDate?: string | null;\n  window?: {\n    startAt: string;\n    endAt: string;\n  };\n  holdId?: string | null;\n};\n\nexport type AssignmentRecord = {\n  tableId: string;\n  startAt: string;\n  endAt: string;\n  mergeGroupId: string | null;\n  assignmentId?: string;\n};\n\nexport type AssignmentCommitRequest = {\n  context: AssignmentContext;\n  plan: AssignmentPlan;\n  source: AssignmentSource;\n  idempotencyKey: string;\n  actorId?: string | null;\n  metadata?: Record<string, unknown>;\n  shadow?: boolean;\n  requireAdjacency?: boolean;\n};\n\nexport type AssignmentCommitResponse = {\n  attemptId: string;\n  assignments: AssignmentRecord[];\n  mergeGroupId?: string | null;\n  telemetryId?: string;\n  shadow?: boolean;\n};\n\nexport type AssignmentAttemptDiagnostics = {\n  planSignature: string;\n  candidateCount: number;\n  generatedAt: string;\n  skipped?: number;\n  conflictDetails?: Record<string, unknown>;\n};\n"
    },
    {
      "path": "server/capacity/v2/repository.ts",
      "content": "import type { AssignmentCommitRequest, AssignmentCommitResponse } from \"./types\";\n\nexport interface AssignmentRepository {\n  commitAssignment(request: AssignmentCommitRequest): Promise<AssignmentCommitResponse>;\n}\n"
    },
    {
      "path": "server/capacity/v2/planner.ts",
      "content": "import { buildScoredTablePlans, type BuildCandidatesResult } from \"../selector\";\nimport type { Table } from \"../tables\";\nimport type { SelectorScoringConfig } from \"../policy\";\n\nexport type PlannerInput = {\n  tables: Table[];\n  partySize: number;\n  adjacency: Map<string, Set<string>>;\n  config: SelectorScoringConfig;\n  enableCombinations: boolean;\n  kMax: number;\n  requireAdjacency: boolean;\n  maxPlansPerSlack?: number;\n  maxCombinationEvaluations?: number;\n  demandMultiplier?: number;\n  tableScarcityScores?: Map<string, number>;\n};\n\nexport type PlannerResult = BuildCandidatesResult;\n\nexport function generateCandidatePlans(input: PlannerInput): PlannerResult {\n  return buildScoredTablePlans({\n    tables: input.tables,\n    partySize: input.partySize,\n    adjacency: input.adjacency,\n    config: input.config,\n    enableCombinations: input.enableCombinations,\n    kMax: input.kMax,\n    requireAdjacency: input.requireAdjacency,\n    maxPlansPerSlack: input.maxPlansPerSlack,\n    maxCombinationEvaluations: input.maxCombinationEvaluations,\n    demandMultiplier: input.demandMultiplier,\n    tableScarcityScores: input.tableScarcityScores,\n  });\n}\n"
    },
    {
      "path": "server/capacity/v2/orchestrator.ts",
      "content": "import { isAllocatorV2Enabled, isAllocatorV2ShadowMode, isAllocatorV2ForceLegacy } from \"@/server/feature-flags\";\n\nimport { AssignmentRepository } from \"./repository\";\nimport {\n  AssignmentConflictError,\n  AssignmentRepositoryError,\n  AssignmentValidationError,\n} from \"./errors\";\nimport { NoopAssignmentRepository } from \"./supabase-repository\";\nimport type {\n  AssignmentCommitRequest,\n  AssignmentCommitResponse,\n  AssignmentContext,\n  AssignmentPlan,\n  AssignmentSource,\n} from \"./types\";\n\nexport type CommitPlanOptions = {\n  source: AssignmentSource;\n  idempotencyKey: string;\n  actorId?: string | null;\n  metadata?: Record<string, unknown>;\n  shadow?: boolean;\n  requireAdjacency?: boolean;\n};\n\nexport class AssignmentOrchestrator {\n  constructor(\n    private readonly repository: AssignmentRepository,\n    private readonly shadowRepository: AssignmentRepository = new NoopAssignmentRepository(),\n  ) {}\n\n  async commitPlan(\n    context: AssignmentContext,\n    plan: AssignmentPlan,\n    options: CommitPlanOptions,\n  ): Promise<AssignmentCommitResponse> {\n    const allocatorDisabled = !isAllocatorV2Enabled();\n    const shadowMode = options.shadow ?? isAllocatorV2ShadowMode();\n\n    if (isAllocatorV2ForceLegacy() && !shadowMode) {\n      throw new AssignmentRepositoryError(\"Allocator v2 force-legacy mode is active; cannot commit plan.\");\n    }\n\n    if (allocatorDisabled && !shadowMode) {\n      throw new AssignmentRepositoryError(\"Allocator v2 is disabled. Enable shadow or commit mode before invoking orchestrator.\");\n    }\n\n    const request: AssignmentCommitRequest = {\n      context,\n      plan,\n      source: options.source,\n      idempotencyKey: options.idempotencyKey,\n      actorId: options.actorId,\n      metadata: options.metadata,\n      shadow: shadowMode,\n      requireAdjacency: options.requireAdjacency,\n    };\n\n    const targetRepository = shadowMode && allocatorDisabled ? this.shadowRepository : this.repository;\n\n    try {\n      return await targetRepository.commitAssignment(request);\n    } catch (error) {\n      if (error instanceof AssignmentConflictError || error instanceof AssignmentValidationError) {\n        throw error;\n      }\n      throw new AssignmentRepositoryError(\"Allocator v2 repository failure\", error);\n    }\n  }\n}\n"
    },
    {
      "path": "server/capacity/v2/errors.ts",
      "content": "export type ConflictDetails = {\n  tableIds: string[];\n  blockingBookingId?: string;\n  window?: { start: string; end: string };\n  hint?: string | null;\n  raw?: unknown;\n};\n\nexport class AssignmentConflictError extends Error {\n  constructor(message: string, public readonly details?: ConflictDetails) {\n    super(message);\n    this.name = \"AssignmentConflictError\";\n  }\n}\n\nexport class AssignmentValidationError extends Error {\n  constructor(message: string, public readonly details?: Record<string, unknown>) {\n    super(message);\n    this.name = \"AssignmentValidationError\";\n  }\n}\n\nexport class AssignmentRepositoryError extends Error {\n  constructor(message: string, public readonly cause?: unknown) {\n    super(message);\n    this.name = \"AssignmentRepositoryError\";\n  }\n}\n"
    },
    {
      "path": "server/capacity/v2/supabase-repository.ts",
      "content": "import { getServiceSupabaseClient } from \"@/server/supabase\";\nimport type { SupabaseClient } from \"@supabase/supabase-js\";\n\nimport type { AssignmentRepository } from \"./repository\";\nimport { AssignmentConflictError, AssignmentRepositoryError, AssignmentValidationError } from \"./errors\";\nimport type {\n  AssignmentCommitRequest,\n  AssignmentCommitResponse,\n  AssignmentRecord,\n} from \"./types\";\n\ntype PostgrestError = {\n  code?: string;\n  message?: string;\n  details?: string | null;\n  hint?: string | null;\n};\n\nfunction extractUuids(value: string | null | undefined): string[] {\n  if (!value) return [];\n  const matches = value.match(/[0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12}/gi);\n  return matches ? matches.map((entry) => entry.toLowerCase()) : [];\n}\n\nfunction parseBlockingBookingId(message: string, details: string | null | undefined): string | undefined {\n  const sources = [message, details ?? \"\"];\n  for (const source of sources) {\n    const match = source.match(/booking\\s+([0-9a-f]{8}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{4}-[0-9a-f]{12})/i);\n    if (match) {\n      return match[1].toLowerCase();\n    }\n  }\n  return undefined;\n}\n\nfunction buildConflictError(params: {\n  error: PostgrestError;\n  request: AssignmentCommitRequest;\n}): AssignmentConflictError {\n  const { error, request } = params;\n  const conflictTables = new Set<string>();\n  for (const tableId of request.plan.tableIds) {\n    conflictTables.add(tableId.toLowerCase());\n  }\n  for (const uuid of extractUuids(error.message)) {\n    conflictTables.add(uuid);\n  }\n  for (const uuid of extractUuids(error.details)) {\n    conflictTables.add(uuid);\n  }\n\n  const blockingBookingId = parseBlockingBookingId(error.message ?? \"\", error.details);\n\n  return new AssignmentConflictError(error.message ?? \"Assignment conflict\", {\n    tableIds: Array.from(conflictTables),\n    blockingBookingId,\n    window: {\n      start: request.plan.startAt,\n      end: request.plan.endAt,\n    },\n    hint: error.hint ?? undefined,\n    raw: {\n      code: error.code,\n      details: error.details,\n      metadata: request.metadata ?? null,\n    },\n  });\n}\n\nfunction buildValidationError(params: {\n  error: PostgrestError;\n  request: AssignmentCommitRequest;\n}): AssignmentValidationError {\n  const { error, request } = params;\n  return new AssignmentValidationError(error.message ?? \"Assignment validation failed\", {\n    code: error.code,\n    details: error.details,\n    hint: error.hint,\n    plan: {\n      tableIds: request.plan.tableIds,\n      startAt: request.plan.startAt,\n      endAt: request.plan.endAt,\n    },\n    context: {\n      bookingId: request.context.bookingId,\n      restaurantId: request.context.restaurantId,\n    },\n  });\n}\n\nfunction translateSupabaseError(params: {\n  error: PostgrestError;\n  request: AssignmentCommitRequest;\n}): never {\n  const { error, request } = params;\n  const code = (error.code ?? \"\").toUpperCase();\n  const message = error.message ?? \"assign_tables_atomic_v2 failed\";\n  const normalized = message.toLowerCase();\n\n  if (\n    code === \"23505\" ||\n    code === \"P0001\" ||\n    normalized.includes(\"duplicate\") ||\n    normalized.includes(\"overlap\") ||\n    normalized.includes(\"conflict\")\n  ) {\n    throw buildConflictError({ error, request });\n  }\n\n  if (\n    code === \"23514\" ||\n    code === \"23503\" ||\n    code === \"23502\" ||\n    code === \"22023\" ||\n    code === \"22000\" ||\n    code === \"P0002\" ||\n    code === \"P0003\" ||\n    normalized.includes(\"requires at least one\") ||\n    normalized.includes(\"not assigned\") ||\n    normalized.includes(\"missing\") ||\n    normalized.includes(\"invalid\")\n  ) {\n    throw buildValidationError({ error, request });\n  }\n\n  throw new AssignmentRepositoryError(message, error);\n}\n\nexport class SupabaseAssignmentRepository implements AssignmentRepository {\n  constructor(private readonly client: SupabaseClient = getServiceSupabaseClient()) {}\n\n  async commitAssignment(request: AssignmentCommitRequest): Promise<AssignmentCommitResponse> {\n    const { context, plan, idempotencyKey, source, actorId, shadow } = request;\n    const supabase = this.client;\n\n    if (!context.window) {\n      throw new AssignmentValidationError(\"Assignment window not provided in context\", { context });\n    }\n\n    const requireAdjacency = request.requireAdjacency ?? true;\n\n    const payload = {\n      p_booking_id: context.bookingId,\n      p_table_ids: plan.tableIds,\n      p_idempotency_key: idempotencyKey,\n      p_require_adjacency: requireAdjacency,\n      p_assigned_by: actorId ?? null,\n      p_start_at: plan.startAt,\n      p_end_at: plan.endAt,\n    };\n\n    const { data, error } = await supabase.rpc(\"assign_tables_atomic_v2\", payload);\n\n    if (error) {\n      translateSupabaseError({ error, request });\n    }\n\n    const assignments: AssignmentRecord[] = (Array.isArray(data) ? data : []).map((row: any) => ({\n      tableId: row.table_id,\n      startAt: row.start_at,\n      endAt: row.end_at,\n      mergeGroupId: row.merge_group_id ?? null,\n      assignmentId: row.assignment_id ?? undefined,\n    }));\n\n    return {\n      attemptId: `rpc-${plan.signature}`,\n      assignments,\n      mergeGroupId: assignments[0]?.mergeGroupId ?? null,\n      shadow: shadow ?? false,\n    };\n  }\n}\n\nexport class NoopAssignmentRepository implements AssignmentRepository {\n  async commitAssignment(_request: AssignmentCommitRequest): Promise<AssignmentCommitResponse> {\n    return {\n      attemptId: \"noop\",\n      assignments: [],\n      mergeGroupId: null,\n      shadow: true,\n    };\n  }\n}\n"
    },
    {
      "path": "server/capacity/v2/utils.ts",
      "content": "import { createHash } from \"node:crypto\";\n\n/**\n * Returns a lexicographically sorted array of unique table ids.\n */\nexport function normalizeTableIds(tableIds: string[]): string[] {\n  return Array.from(new Set(tableIds)).sort((a, b) => a.localeCompare(b));\n}\n\ntype PlanSignatureInput = {\n  bookingId: string;\n  tableIds: string[];\n  startAt: string;\n  endAt: string;\n  salt?: string;\n};\n\n/**\n * Deterministically derives a short signature for a plan based on booking scope\n * and assignment window. Used for idempotency and telemetry correlation.\n */\nexport function createPlanSignature(input: PlanSignatureInput): string {\n  const normalizedTableIds = normalizeTableIds(input.tableIds);\n  const hash = createHash(\"sha256\");\n\n  hash.update(input.bookingId);\n  hash.update(\"|\");\n  hash.update(normalizedTableIds.join(\",\"));\n  hash.update(\"|\");\n  hash.update(input.startAt);\n  hash.update(\"|\");\n  hash.update(input.endAt);\n\n  if (input.salt) {\n    hash.update(\"|\");\n    hash.update(input.salt);\n  }\n\n  return hash.digest(\"hex\").slice(0, 16);\n}\n"
    },
    {
      "path": "config/demand-profiles.json",
      "content": "{\n  \"default\": [\n    {\n      \"label\": \"weekday-lunch\",\n      \"serviceWindow\": \"lunch\",\n      \"days\": [\"MONDAY\", \"TUESDAY\", \"WEDNESDAY\", \"THURSDAY\", \"FRIDAY\"],\n      \"start\": \"11:30\",\n      \"end\": \"14:30\",\n      \"multiplier\": 0.85\n    },\n    {\n      \"label\": \"weekday-dinner\",\n      \"serviceWindow\": \"dinner\",\n      \"days\": [\"MONDAY\", \"TUESDAY\", \"WEDNESDAY\", \"THURSDAY\"],\n      \"start\": \"17:30\",\n      \"end\": \"21:30\",\n      \"multiplier\": 1.15\n    },\n    {\n      \"label\": \"weekend-dinner-peak\",\n      \"serviceWindow\": \"dinner\",\n      \"days\": [\"FRIDAY\", \"SATURDAY\"],\n      \"start\": \"18:00\",\n      \"end\": \"22:30\",\n      \"multiplier\": 1.35\n    },\n    {\n      \"label\": \"weekend-brunch\",\n      \"serviceWindow\": \"lunch\",\n      \"days\": [\"SATURDAY\", \"SUNDAY\"],\n      \"start\": \"10:00\",\n      \"end\": \"13:00\",\n      \"multiplier\": 1.10\n    }\n  ],\n  \"restaurants\": {}\n}\n"
    },
    {
      "path": "supabase/migrations/20251019102432_consolidated_schema.sql",
      "content": "\n\nSET statement_timeout = 0;\nSET lock_timeout = 0;\nSET idle_in_transaction_session_timeout = 0;\nSET client_encoding = 'UTF8';\nSET standard_conforming_strings = on;\nSELECT pg_catalog.set_config('search_path', '', false);\nSET check_function_bodies = false;\nSET xmloption = content;\nSET client_min_messages = warning;\nSET row_security = off;\n\n\n\n\nALTER SCHEMA \"public\" OWNER TO \"postgres\";\n\n\nCOMMENT ON SCHEMA \"public\" IS 'standard public schema';\n\n\n\nCREATE EXTENSION IF NOT EXISTS \"btree_gist\" WITH SCHEMA \"public\";\n\n\n\n\n\n\nCREATE EXTENSION IF NOT EXISTS \"pg_graphql\" WITH SCHEMA \"graphql\";\n\n\n\n\n\n\nCREATE EXTENSION IF NOT EXISTS \"pg_stat_statements\" WITH SCHEMA \"extensions\";\n\n\n\n\n\n\nCREATE EXTENSION IF NOT EXISTS \"pgcrypto\" WITH SCHEMA \"extensions\";\n\n\n\n\n\n\nCREATE EXTENSION IF NOT EXISTS \"supabase_vault\" WITH SCHEMA \"vault\";\n\n\n\n\n\n\nCREATE EXTENSION IF NOT EXISTS \"uuid-ossp\" WITH SCHEMA \"extensions\";\n\n\n\n\n\n\nCREATE TYPE \"public\".\"analytics_event_type\" AS ENUM (\n    'booking.created',\n    'booking.cancelled',\n    'booking.allocated',\n    'booking.waitlisted'\n);\n\n\nALTER TYPE \"public\".\"analytics_event_type\" OWNER TO \"postgres\";\n\n\nCREATE TYPE \"public\".\"booking_change_type\" AS ENUM (\n    'created',\n    'updated',\n    'cancelled',\n    'deleted'\n);\n\n\nALTER TYPE \"public\".\"booking_change_type\" OWNER TO \"postgres\";\n\n\nCREATE TYPE \"public\".\"booking_status\" AS ENUM (\n    'confirmed',\n    'pending',\n    'cancelled',\n    'completed',\n    'no_show',\n    'pending_allocation',\n    'checked_in'\n);\n\n\nALTER TYPE \"public\".\"booking_status\" OWNER TO \"postgres\";\n\n\nCOMMENT ON TYPE \"public\".\"booking_status\" IS 'Lifecycle status of a booking (pending, confirmed, checked_in, completed, cancelled, no_show, etc).';\n\n\n\nCREATE TYPE \"public\".\"booking_type\" AS ENUM (\n    'breakfast',\n    'lunch',\n    'dinner',\n    'drinks'\n);\n\n\nALTER TYPE \"public\".\"booking_type\" OWNER TO \"postgres\";\n\n\nCREATE TYPE \"public\".\"capacity_override_type\" AS ENUM (\n    'holiday',\n    'event',\n    'manual',\n    'emergency'\n);\n\n\nALTER TYPE \"public\".\"capacity_override_type\" OWNER TO \"postgres\";\n\n\nCREATE TYPE \"public\".\"loyalty_tier\" AS ENUM (\n    'bronze',\n    'silver',\n    'gold',\n    'platinum'\n);\n\n\nALTER TYPE \"public\".\"loyalty_tier\" OWNER TO \"postgres\";\n\n\nCREATE TYPE \"public\".\"seating_preference_type\" AS ENUM (\n    'any',\n    'indoor',\n    'outdoor',\n    'bar',\n    'window',\n    'quiet',\n    'booth'\n);\n\n\nALTER TYPE \"public\".\"seating_preference_type\" OWNER TO \"postgres\";\n\n\nCREATE TYPE \"public\".\"table_category\" AS ENUM (\n    'bar',\n    'dining',\n    'lounge',\n    'patio',\n    'private'\n);\n\n\nALTER TYPE \"public\".\"table_category\" OWNER TO \"postgres\";\n\n\nCREATE TYPE \"public\".\"table_mobility\" AS ENUM (\n    'movable',\n    'fixed'\n);\n\n\nALTER TYPE \"public\".\"table_mobility\" OWNER TO \"postgres\";\n\n\nCREATE TYPE \"public\".\"table_seating_type\" AS ENUM (\n    'standard',\n    'sofa',\n    'booth',\n    'high_top'\n);\n\n\nALTER TYPE \"public\".\"table_seating_type\" OWNER TO \"postgres\";\n\n\nCREATE TYPE \"public\".\"table_status\" AS ENUM (\n    'available',\n    'reserved',\n    'occupied',\n    'out_of_service'\n);\n\n\nALTER TYPE \"public\".\"table_status\" OWNER TO \"postgres\";\n\n\nCOMMENT ON TYPE \"public\".\"table_status\" IS 'Status of a restaurant table: available, reserved (booked), occupied (guests seated), out_of_service (maintenance)';\n\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"allocations_overlap\"(\"a\" \"tstzrange\", \"b\" \"tstzrange\") RETURNS boolean\n    LANGUAGE \"sql\" IMMUTABLE\n    AS $$\n  SELECT COALESCE(a && b, false);\n$$;\n\n\nALTER FUNCTION \"public\".\"allocations_overlap\"(\"a\" \"tstzrange\", \"b\" \"tstzrange\") OWNER TO \"postgres\";\n\n\nCOMMENT ON FUNCTION \"public\".\"allocations_overlap\"(\"a\" \"tstzrange\", \"b\" \"tstzrange\") IS 'Returns true when two timestamptz ranges overlap (half-open [start,end) semantics).';\n\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"allowed_capacities_set_updated_at\"() RETURNS \"trigger\"\n    LANGUAGE \"plpgsql\"\n    AS $$\nBEGIN\n  NEW.updated_at := timezone('utc', now());\n  RETURN NEW;\nEND;\n$$;\n\n\nALTER FUNCTION \"public\".\"allowed_capacities_set_updated_at\"() OWNER TO \"postgres\";\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"apply_booking_state_transition\"(\"p_booking_id\" \"uuid\", \"p_status\" \"public\".\"booking_status\", \"p_checked_in_at\" timestamp with time zone, \"p_checked_out_at\" timestamp with time zone, \"p_updated_at\" timestamp with time zone, \"p_history_from\" \"public\".\"booking_status\", \"p_history_to\" \"public\".\"booking_status\", \"p_history_changed_by\" \"uuid\", \"p_history_changed_at\" timestamp with time zone, \"p_history_reason\" \"text\", \"p_history_metadata\" \"jsonb\" DEFAULT '{}'::\"jsonb\") RETURNS TABLE(\"status\" \"public\".\"booking_status\", \"checked_in_at\" timestamp with time zone, \"checked_out_at\" timestamp with time zone, \"updated_at\" timestamp with time zone)\n    LANGUAGE \"plpgsql\" SECURITY DEFINER\n    AS $$\nDECLARE\n    v_updated public.bookings%ROWTYPE;\nBEGIN\n    UPDATE public.bookings\n    SET\n        status = p_status,\n        checked_in_at = p_checked_in_at,\n        checked_out_at = p_checked_out_at,\n        updated_at = p_updated_at\n    WHERE id = p_booking_id\n    RETURNING * INTO v_updated;\n\n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Booking % not found', p_booking_id;\n    END IF;\n\n    INSERT INTO public.booking_state_history (\n        booking_id,\n        from_status,\n        to_status,\n        changed_by,\n        changed_at,\n        reason,\n        metadata\n    )\n    VALUES (\n        p_booking_id,\n        p_history_from,\n        p_history_to,\n        p_history_changed_by,\n        p_history_changed_at,\n        p_history_reason,\n        COALESCE(p_history_metadata, '{}'::jsonb)\n    );\n\n    RETURN QUERY\n    SELECT\n        v_updated.status,\n        v_updated.checked_in_at,\n        v_updated.checked_out_at,\n        v_updated.updated_at;\nEND;\n$$;\n\n\nALTER FUNCTION \"public\".\"apply_booking_state_transition\"(\"p_booking_id\" \"uuid\", \"p_status\" \"public\".\"booking_status\", \"p_checked_in_at\" timestamp with time zone, \"p_checked_out_at\" timestamp with time zone, \"p_updated_at\" timestamp with time zone, \"p_history_from\" \"public\".\"booking_status\", \"p_history_to\" \"public\".\"booking_status\", \"p_history_changed_by\" \"uuid\", \"p_history_changed_at\" timestamp with time zone, \"p_history_reason\" \"text\", \"p_history_metadata\" \"jsonb\") OWNER TO \"postgres\";\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"are_tables_connected\"(\"table_ids\" \"uuid\"[]) RETURNS boolean\n    LANGUAGE \"plpgsql\"\n    AS $$\nDECLARE\n  unique_tables uuid[];\n  start_table uuid;\n  total_count integer;\n  connected_count integer;\nBEGIN\n  SELECT array_agg(DISTINCT id)\n  INTO unique_tables\n  FROM unnest(table_ids) AS id\n  WHERE id IS NOT NULL;\n\n  total_count := array_length(unique_tables, 1);\n\n  IF total_count IS NULL OR total_count = 0 THEN\n    RETURN false;\n  END IF;\n\n  IF total_count = 1 THEN\n    RETURN true;\n  END IF;\n\n  start_table := unique_tables[1];\n\n  WITH RECURSIVE connected AS (\n    SELECT start_table AS table_id\n    UNION\n    SELECT adj.table_b\n    FROM connected\n    JOIN public.table_adjacencies adj\n      ON adj.table_a = connected.table_id\n    WHERE adj.table_b = ANY(unique_tables)\n  )\n  SELECT COUNT(DISTINCT table_id)\n  INTO connected_count\n  FROM connected;\n\n  RETURN connected_count = total_count;\nEND;\n$$;\n\n\nALTER FUNCTION \"public\".\"are_tables_connected\"(\"table_ids\" \"uuid\"[]) OWNER TO \"postgres\";\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"assign_table_to_booking\"(\"p_booking_id\" \"uuid\", \"p_table_id\" \"uuid\", \"p_assigned_by\" \"uuid\" DEFAULT NULL::\"uuid\", \"p_notes\" \"text\" DEFAULT NULL::\"text\") RETURNS \"uuid\"\n    LANGUAGE \"plpgsql\" SECURITY DEFINER\n    AS $$\nDECLARE\n    v_assignment_id uuid;\n    v_restaurant_id uuid;\n    v_booking_date date;\n    v_start_time time;\n    v_slot_id uuid;\nBEGIN\n    -- Verify booking exists and get details\n    SELECT restaurant_id, booking_date, start_time \n    INTO v_restaurant_id, v_booking_date, v_start_time\n    FROM bookings\n    WHERE id = p_booking_id;\n    \n    IF NOT FOUND THEN\n        RAISE EXCEPTION 'Booking not found: %', p_booking_id;\n    END IF;\n    \n    -- Verify table exists and belongs to same restaurant\n    IF NOT EXISTS (\n        SELECT 1 FROM table_inventory\n        WHERE id = p_table_id AND restaurant_id = v_restaurant_id\n    ) THEN\n        RAISE EXCEPTION 'Table not found or belongs to different restaurant: %', p_table_id;\n    END IF;\n    \n    -- Get or create booking slot\n    SELECT id INTO v_slot_id\n    FROM booking_slots\n    WHERE restaurant_id = v_restaurant_id\n        AND slot_date = v_booking_date\n        AND slot_time = v_start_time;\n    \n    -- Create assignment\n    INSERT INTO booking_table_assignments (\n        booking_id,\n        table_id,\n        slot_id,\n        assigned_by,\n        notes\n    ) VALUES (\n        p_booking_id,\n        p_table_id,\n        v_slot_id,\n        p_assigned_by,\n        p_notes\n    )\n    ON CONFLICT (booking_id, table_id) DO UPDATE\n    SET assigned_by = EXCLUDED.assigned_by,\n        notes = EXCLUDED.notes,\n        assigned_at = now()\n    RETURNING id INTO v_assignment_id;\n    \n    -- Update table status to reserved\n    UPDATE table_inventory\n    SET status = 'reserved'::table_status\n    WHERE id = p_table_id;\n    \n    RETURN v_assignment_id;\nEND;\n$$;\n\n\nALTER FUNCTION \"public\".\"assign_table_to_booking\"(\"p_booking_id\" \"uuid\", \"p_table_id\" \"uuid\", \"p_assigned_by\" \"uuid\", \"p_notes\" \"text\") OWNER TO \"postgres\";\n\n\nCOMMENT ON FUNCTION \"public\".\"assign_table_to_booking\"(\"p_booking_id\" \"uuid\", \"p_table_id\" \"uuid\", \"p_assigned_by\" \"uuid\", \"p_notes\" \"text\") IS 'Assign a table to a booking. Updates table status to reserved. Returns assignment ID.';\n\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"assign_tables_atomic\"(\"p_booking_id\" \"uuid\", \"p_table_ids\" \"uuid\"[], \"p_window\" \"tstzrange\", \"p_assigned_by\" \"uuid\" DEFAULT NULL::\"uuid\", \"p_idempotency_key\" \"text\" DEFAULT NULL::\"text\") RETURNS TABLE(\"table_id\" \"uuid\", \"assignment_id\" \"uuid\", \"merge_group_id\" \"uuid\")\n    LANGUAGE \"plpgsql\" SECURITY DEFINER\n    AS $$\n    DECLARE\n      v_booking RECORD;\n      v_restaurant_id uuid;\n      v_target_tables uuid[];\n      v_requested_tables uuid[];\n      v_existing_tables uuid[];\n      v_table RECORD;\n      v_total_capacity integer := 0;\n      v_first_zone uuid := NULL;\n      v_merge_group_id uuid := NULL;\n      v_slot_id uuid := NULL;\n      v_now timestamptz := now();\n      v_window tstzrange := p_window;\n      v_assignment_id uuid;\n      v_loaded_count integer := 0;\n      v_table_id uuid;\n      v_lock_restaurant int4;\n      v_lock_date int4;\n    BEGIN\n      IF p_table_ids IS NULL OR array_length(p_table_ids, 1) = 0 THEN\n        RAISE EXCEPTION 'assign_tables_atomic requires at least one table id'\n          USING ERRCODE = '23514';\n      END IF;\n\n      SELECT array_agg(DISTINCT table_id)\n      INTO v_target_tables\n      FROM unnest(p_table_ids) AS t(table_id);\n\n      IF v_target_tables IS NULL OR array_length(v_target_tables, 1) = 0 THEN\n        RAISE EXCEPTION 'assign_tables_atomic requires at least one valid table id'\n          USING ERRCODE = '23514';\n      END IF;\n\n      SELECT *\n      INTO v_booking\n      FROM public.bookings\n      WHERE id = p_booking_id\n      FOR UPDATE;\n\n      IF NOT FOUND THEN\n        RAISE EXCEPTION 'Booking % not found', p_booking_id\n          USING ERRCODE = 'P0002';\n      END IF;\n\n      v_restaurant_id := v_booking.restaurant_id;\n\n      v_lock_restaurant := hashtext(v_restaurant_id::text);\n      v_lock_date := COALESCE((v_booking.booking_date - DATE '2000-01-01')::int, 0);\n      PERFORM pg_advisory_xact_lock(v_lock_restaurant, v_lock_date);\n\n      IF v_window IS NULL THEN\n        v_window := tstzrange(v_booking.start_at, v_booking.end_at, '[)');\n      END IF;\n\n      IF v_window IS NULL OR lower(v_window) IS NULL OR upper(v_window) IS NULL OR lower(v_window) >= upper(v_window) THEN\n        RAISE EXCEPTION 'Invalid assignment window for booking %', p_booking_id\n          USING ERRCODE = '22000';\n      END IF;\n\n      IF p_idempotency_key IS NOT NULL THEN\n        SELECT array_agg(bta.table_id ORDER BY bta.table_id)\n        INTO v_existing_tables\n        FROM public.booking_table_assignments bta\n        WHERE bta.booking_id = p_booking_id\n          AND bta.idempotency_key = p_idempotency_key;\n\n        IF v_existing_tables IS NOT NULL THEN\n          SELECT array_agg(table_id ORDER BY table_id)\n          INTO v_requested_tables\n          FROM unnest(v_target_tables) AS t(table_id);\n\n          IF v_requested_tables IS NULL OR v_requested_tables <> v_existing_tables THEN\n            RAISE EXCEPTION 'assign_tables_atomic idempotency key mismatch'\n              USING ERRCODE = 'P0003',\n                    DETAIL = 'Idempotency key reuse detected with a different table set';\n          END IF;\n\n          RETURN QUERY\n            SELECT\n              bta.table_id,\n              bta.id AS assignment_id,\n              bta.merge_group_id\n            FROM public.booking_table_assignments bta\n            WHERE bta.booking_id = p_booking_id\n              AND bta.idempotency_key = p_idempotency_key;\n\n          RETURN;\n        END IF;\n      END IF;\n\n      FOR v_table IN\n        SELECT id, restaurant_id, zone_id, capacity\n        FROM public.table_inventory\n        WHERE id = ANY (v_target_tables)\n        ORDER BY id\n        FOR UPDATE\n      LOOP\n        IF v_table.restaurant_id <> v_restaurant_id THEN\n          RAISE EXCEPTION 'Table % belongs to a different restaurant', v_table.id;\n        END IF;\n\n        IF v_table.zone_id IS NULL THEN\n          RAISE EXCEPTION 'Table % is not assigned to a zone', v_table.id;\n        END IF;\n\n        IF v_first_zone IS NULL THEN\n          v_first_zone := v_table.zone_id;\n        ELSIF v_first_zone <> v_table.zone_id THEN\n          RAISE EXCEPTION 'All tables must belong to the same zone';\n        END IF;\n\n        v_total_capacity := v_total_capacity + COALESCE(v_table.capacity, 0);\n        v_loaded_count := v_loaded_count + 1;\n      END LOOP;\n\n      IF v_loaded_count <> array_length(v_target_tables, 1) THEN\n        RAISE EXCEPTION 'Unable to load all requested tables';\n      END IF;\n\n      IF array_length(v_target_tables, 1) > 1 THEN\n        INSERT INTO public.merge_groups (capacity, created_at)\n        VALUES (NULLIF(v_total_capacity, 0), v_now)\n        RETURNING id INTO v_merge_group_id;\n\n        INSERT INTO public.merge_group_members (merge_group_id, table_id)\n        SELECT v_merge_group_id, unnest(v_target_tables)\n        ON CONFLICT DO NOTHING;\n      END IF;\n\n      IF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL THEN\n        SELECT id\n        INTO v_slot_id\n        FROM public.booking_slots\n        WHERE restaurant_id = v_restaurant_id\n          AND slot_date = v_booking.booking_date\n          AND slot_time = v_booking.start_time\n        LIMIT 1;\n\n        IF v_slot_id IS NULL THEN\n          SELECT public.get_or_create_booking_slot(v_restaurant_id, v_booking.booking_date, v_booking.start_time, 999)\n          INTO v_slot_id;\n        END IF;\n      END IF;\n\n      FOREACH v_table_id IN ARRAY v_target_tables LOOP\n        INSERT INTO public.booking_table_assignments (\n          booking_id,\n          table_id,\n          slot_id,\n          assigned_by,\n          idempotency_key,\n          merge_group_id\n        ) VALUES (\n          p_booking_id,\n          v_table_id,\n          v_slot_id,\n          p_assigned_by,\n          p_idempotency_key,\n          v_merge_group_id\n        )\n        ON CONFLICT (booking_id, table_id) DO UPDATE\n        SET assigned_by = EXCLUDED.assigned_by,\n            assigned_at = v_now,\n            idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n            merge_group_id = COALESCE(EXCLUDED.merge_group_id, public.booking_table_assignments.merge_group_id)\n        RETURNING id INTO v_assignment_id;\n\n        BEGIN\n          INSERT INTO public.allocations (\n            booking_id,\n            restaurant_id,\n            resource_type,\n            resource_id,\n            \"window\",\n            created_by,\n            shadow,\n            created_at,\n            updated_at\n          ) VALUES (\n            p_booking_id,\n            v_restaurant_id,\n            'table',\n            v_table_id,\n            v_window,\n            p_assigned_by,\n            false,\n            v_now,\n            v_now\n          )\n          ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n          SET \"window\" = EXCLUDED.\"window\",\n              created_by = EXCLUDED.created_by,\n              updated_at = v_now;\n        EXCEPTION\n          WHEN unique_violation OR exclusion_violation THEN\n            RAISE EXCEPTION 'allocations_no_overlap'\n              USING ERRCODE = 'P0001',\n                    DETAIL = format('Resource %s overlaps requested window for booking %s', v_table_id, p_booking_id);\n        END;\n\n        UPDATE public.table_inventory\n        SET status = 'reserved'::public.table_status\n        WHERE id = v_table_id;\n\n        table_id := v_table_id;\n        assignment_id := v_assignment_id;\n        merge_group_id := v_merge_group_id;\n        RETURN NEXT;\n      END LOOP;\n\n      IF v_merge_group_id IS NOT NULL THEN\n        BEGIN\n          INSERT INTO public.allocations (\n            booking_id,\n            restaurant_id,\n            resource_type,\n            resource_id,\n            \"window\",\n            created_by,\n            shadow,\n            created_at,\n            updated_at\n          ) VALUES (\n            p_booking_id,\n            v_restaurant_id,\n            'merge_group',\n            v_merge_group_id,\n            v_window,\n            p_assigned_by,\n            false,\n            v_now,\n            v_now\n          )\n          ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n          SET \"window\" = EXCLUDED.\"window\",\n              created_by = EXCLUDED.created_by,\n              updated_at = v_now;\n        EXCEPTION\n          WHEN unique_violation OR exclusion_violation THEN\n            RAISE EXCEPTION 'allocations_no_overlap'\n              USING ERRCODE = 'P0001',\n                    DETAIL = format('Merge group %s overlaps requested window for booking %s', v_merge_group_id, p_booking_id);\n        END;\n      END IF;\n\n      RETURN;\n    END;\n    $$;\n\n\nALTER FUNCTION \"public\".\"assign_tables_atomic\"(\"p_booking_id\" \"uuid\", \"p_table_ids\" \"uuid\"[], \"p_window\" \"tstzrange\", \"p_assigned_by\" \"uuid\", \"p_idempotency_key\" \"text\") OWNER TO \"postgres\";\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"booking_status_summary\"(\"p_restaurant_id\" \"uuid\", \"p_start_date\" \"date\" DEFAULT NULL::\"date\", \"p_end_date\" \"date\" DEFAULT NULL::\"date\", \"p_status_filter\" \"public\".\"booking_status\"[] DEFAULT NULL::\"public\".\"booking_status\"[]) RETURNS TABLE(\"status\" \"public\".\"booking_status\", \"total\" bigint)\n    LANGUAGE \"sql\"\n    AS $$\n    SELECT\n        b.status,\n        COUNT(*)::bigint AS total\n    FROM public.bookings b\n    WHERE b.restaurant_id = p_restaurant_id\n      AND (p_start_date IS NULL OR b.booking_date >= p_start_date)\n      AND (p_end_date IS NULL OR b.booking_date <= p_end_date)\n      AND (p_status_filter IS NULL OR b.status = ANY(p_status_filter))\n    GROUP BY b.status\n    ORDER BY b.status;\n$$;\n\n\nALTER FUNCTION \"public\".\"booking_status_summary\"(\"p_restaurant_id\" \"uuid\", \"p_start_date\" \"date\", \"p_end_date\" \"date\", \"p_status_filter\" \"public\".\"booking_status\"[]) OWNER TO \"postgres\";\n\n\nCOMMENT ON FUNCTION \"public\".\"booking_status_summary\"(\"p_restaurant_id\" \"uuid\", \"p_start_date\" \"date\", \"p_end_date\" \"date\", \"p_status_filter\" \"public\".\"booking_status\"[]) IS 'Returns aggregated booking counts by status for a restaurant across an optional date range and status filter.';\n\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"capacity_metrics_hourly_updated_at\"() RETURNS \"trigger\"\n    LANGUAGE \"plpgsql\"\n    AS $$\nBEGIN\n  NEW.updated_at := timezone('utc', now());\n  RETURN NEW;\nEND;\n$$;\n\n\nALTER FUNCTION \"public\".\"capacity_metrics_hourly_updated_at\"() OWNER TO \"postgres\";\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"create_booking_with_capacity_check\"(\"p_restaurant_id\" \"uuid\", \"p_customer_id\" \"uuid\", \"p_booking_date\" \"date\", \"p_start_time\" time without time zone, \"p_end_time\" time without time zone, \"p_party_size\" integer, \"p_booking_type\" \"text\", \"p_customer_name\" \"text\", \"p_customer_email\" \"text\", \"p_customer_phone\" \"text\", \"p_seating_preference\" \"text\", \"p_notes\" \"text\" DEFAULT NULL::\"text\", \"p_marketing_opt_in\" boolean DEFAULT false, \"p_idempotency_key\" \"text\" DEFAULT NULL::\"text\", \"p_source\" \"text\" DEFAULT 'api'::\"text\", \"p_auth_user_id\" \"uuid\" DEFAULT NULL::\"uuid\", \"p_client_request_id\" \"text\" DEFAULT NULL::\"text\", \"p_details\" \"jsonb\" DEFAULT '{}'::\"jsonb\", \"p_loyalty_points_awarded\" integer DEFAULT 0) RETURNS \"jsonb\"\n    LANGUAGE \"plpgsql\" SECURITY DEFINER\n    SET \"search_path\" TO 'public'\n    AS $$\n    DECLARE\n        v_service_period_id uuid;\n        v_service_period_name text;\n        v_max_covers integer;\n        v_max_parties integer;\n        v_booked_covers integer;\n        v_booked_parties integer;\n        v_booking_id uuid;\n        v_booking_record jsonb;\n        v_reference text;\n        v_start_at timestamptz;\n        v_end_at timestamptz;\n        v_timezone text;\n        v_timezone_raw text;\n    BEGIN\n        -- =====================================================\n        -- STEP 1: Idempotency Check\n        -- =====================================================\n        IF p_idempotency_key IS NOT NULL THEN\n            SELECT id INTO v_booking_id \n            FROM bookings \n            WHERE restaurant_id = p_restaurant_id \n                AND idempotency_key = p_idempotency_key\n            LIMIT 1;\n            \n            IF FOUND THEN\n                SELECT to_jsonb(b.*) INTO v_booking_record\n                FROM bookings b \n                WHERE id = v_booking_id;\n                \n                RETURN jsonb_build_object(\n                    'success', true,\n                    'duplicate', true,\n                    'booking', v_booking_record,\n                    'message', 'Booking already exists (idempotency)'\n                );\n            END IF;\n        END IF;\n        \n        -- =====================================================\n        -- STEP 2: Find Applicable Service Period\n        -- =====================================================\n        SELECT sp.id, sp.name INTO v_service_period_id, v_service_period_name\n        FROM restaurant_service_periods sp\n        WHERE sp.restaurant_id = p_restaurant_id\n            AND (sp.day_of_week IS NULL OR sp.day_of_week = EXTRACT(DOW FROM p_booking_date)::smallint)\n            AND p_start_time >= sp.start_time\n            AND p_start_time < sp.end_time\n        ORDER BY \n            sp.day_of_week DESC NULLS LAST,\n            sp.start_time ASC\n        LIMIT 1;\n        \n        -- =====================================================\n        -- STEP 3: Get Capacity Rules with Row-Level Lock\n        -- =====================================================\n        SELECT \n            COALESCE(cr.max_covers, 999999) as max_covers,\n            COALESCE(cr.max_parties, 999999) as max_parties\n        INTO v_max_covers, v_max_parties\n        FROM restaurant_capacity_rules cr\n        WHERE cr.restaurant_id = p_restaurant_id\n            AND (cr.service_period_id IS NULL OR cr.service_period_id = v_service_period_id)\n            AND (cr.day_of_week IS NULL OR cr.day_of_week = EXTRACT(DOW FROM p_booking_date)::smallint)\n            AND (cr.effective_date IS NULL OR cr.effective_date <= p_booking_date)\n        ORDER BY \n            cr.effective_date DESC NULLS LAST,\n            cr.day_of_week DESC NULLS LAST,\n            cr.service_period_id DESC NULLS LAST\n        LIMIT 1\n        FOR UPDATE NOWAIT;\n        \n        v_max_covers := COALESCE(v_max_covers, 999999);\n        v_max_parties := COALESCE(v_max_parties, 999999);\n        \n        -- =====================================================\n        -- STEP 4: Count Existing Bookings in Same Period\n        -- =====================================================\n        SELECT \n            COALESCE(SUM(b.party_size), 0) as total_covers,\n            COUNT(*) as total_parties\n        INTO v_booked_covers, v_booked_parties\n        FROM bookings b\n        WHERE b.restaurant_id = p_restaurant_id\n            AND b.booking_date = p_booking_date\n            AND b.status NOT IN ('cancelled', 'no_show')\n            AND (\n                v_service_period_id IS NULL\n                OR b.start_time >= (\n                    SELECT start_time FROM restaurant_service_periods WHERE id = v_service_period_id\n                )\n                AND b.start_time < (\n                    SELECT end_time FROM restaurant_service_periods WHERE id = v_service_period_id\n                )\n            );\n        \n        -- =====================================================\n        -- STEP 5: Capacity Validation\n        -- =====================================================\n        IF v_booked_covers + p_party_size > v_max_covers THEN\n            RETURN jsonb_build_object(\n                'success', false,\n                'error', 'CAPACITY_EXCEEDED',\n                'message', format('Maximum capacity of %s covers exceeded. Currently booked: %s, Requested: %s',\n                    v_max_covers, v_booked_covers, p_party_size),\n                'details', jsonb_build_object(\n                    'maxCovers', v_max_covers,\n                    'bookedCovers', v_booked_covers,\n                    'requestedCovers', p_party_size,\n                    'availableCovers', v_max_covers - v_booked_covers,\n                    'servicePeriod', v_service_period_name\n                )\n            );\n        END IF;\n        \n        IF v_booked_parties + 1 > v_max_parties THEN\n            RETURN jsonb_build_object(\n                'success', false,\n                'error', 'CAPACITY_EXCEEDED',\n                'message', format('Maximum of %s bookings exceeded for this period. Currently booked: %s',\n                    v_max_parties, v_booked_parties),\n                'details', jsonb_build_object(\n                    'maxParties', v_max_parties,\n                    'bookedParties', v_booked_parties,\n                    'availableParties', v_max_parties - v_booked_parties,\n                    'servicePeriod', v_service_period_name\n                )\n            );\n        END IF;\n        \n        v_reference := public.generate_booking_reference();\n        \n        SELECT timezone INTO v_timezone_raw\n        FROM restaurants\n        WHERE id = p_restaurant_id;\n\n        v_timezone_raw := COALESCE(BTRIM(v_timezone_raw), '');\n\n        IF v_timezone_raw = '' THEN\n            v_timezone := 'Europe/London';\n        ELSE\n            SELECT name INTO v_timezone\n            FROM pg_timezone_names\n            WHERE lower(name) = lower(v_timezone_raw)\n            LIMIT 1;\n\n            IF NOT FOUND OR v_timezone IS NULL THEN\n                v_timezone := 'Europe/London';\n            END IF;\n        END IF;\n        \n        v_start_at := make_timestamptz(\n            EXTRACT(YEAR FROM p_booking_date)::int,\n            EXTRACT(MONTH FROM p_booking_date)::int,\n            EXTRACT(DAY FROM p_booking_date)::int,\n            EXTRACT(HOUR FROM p_start_time)::int,\n            EXTRACT(MINUTE FROM p_start_time)::int,\n            EXTRACT(SECOND FROM p_start_time),\n            v_timezone\n        );\n        \n        v_end_at := make_timestamptz(\n            EXTRACT(YEAR FROM p_booking_date)::int,\n            EXTRACT(MONTH FROM p_booking_date)::int,\n            EXTRACT(DAY FROM p_booking_date)::int,\n            EXTRACT(HOUR FROM p_end_time)::int,\n            EXTRACT(MINUTE FROM p_end_time)::int,\n            EXTRACT(SECOND FROM p_end_time),\n            v_timezone\n        );\n        \n        INSERT INTO bookings (\n            restaurant_id,\n            customer_id,\n            booking_date,\n            start_time,\n            end_time,\n            start_at,\n            end_at,\n            party_size,\n            booking_type,\n            seating_preference,\n            status,\n            reference,\n            customer_name,\n            customer_email,\n            customer_phone,\n            notes,\n            marketing_opt_in,\n            loyalty_points_awarded,\n            source,\n            auth_user_id,\n            idempotency_key,\n            details\n        ) VALUES (\n            p_restaurant_id,\n            p_customer_id,\n            p_booking_date,\n            p_start_time,\n            p_end_time,\n            v_start_at,\n            v_end_at,\n            p_party_size,\n            p_booking_type::booking_type,\n            p_seating_preference::seating_preference_type,\n            'confirmed'::booking_status,\n            v_reference,\n            p_customer_name,\n            p_customer_email,\n            p_customer_phone,\n            p_notes,\n            p_marketing_opt_in,\n            p_loyalty_points_awarded,\n            p_source,\n            p_auth_user_id,\n            p_idempotency_key,\n            jsonb_build_object(\n                'channel', 'api.capacity_safe',\n                'client_request_id', p_client_request_id,\n                'capacity_check', jsonb_build_object(\n                    'service_period_id', v_service_period_id,\n                    'max_covers', v_max_covers,\n                    'booked_covers_before', v_booked_covers,\n                    'booked_covers_after', v_booked_covers + p_party_size\n                ),\n                'timezone', v_timezone,\n                'original_timezone', NULLIF(v_timezone_raw, '')\n            ) || COALESCE(p_details, '{}'::jsonb)\n        )\n        RETURNING id, to_jsonb(bookings.*) INTO v_booking_id, v_booking_record;\n        \n        RETURN jsonb_build_object(\n            'success', true,\n            'duplicate', false,\n            'booking', v_booking_record,\n            'capacity', jsonb_build_object(\n                'servicePeriod', v_service_period_name,\n                'maxCovers', v_max_covers,\n                'bookedCovers', v_booked_covers + p_party_size,\n                'availableCovers', v_max_covers - (v_booked_covers + p_party_size),\n                'utilizationPercent', ROUND(((v_booked_covers + p_party_size)::numeric / v_max_covers) * 100, 1)\n            ),\n            'message', 'Booking created successfully'\n        );\n        \n    EXCEPTION\n        WHEN serialization_failure THEN\n            RETURN jsonb_build_object(\n                'success', false,\n                'error', 'BOOKING_CONFLICT',\n                'message', 'Concurrent booking conflict detected. Please retry.',\n                'retryable', true\n            );\n        \n        WHEN deadlock_detected THEN\n            RETURN jsonb_build_object(\n                'success', false,\n                'error', 'BOOKING_CONFLICT',\n                'message', 'Database deadlock detected. Please retry.',\n                'retryable', true\n            );\n        \n        WHEN lock_not_available THEN\n            RETURN jsonb_build_object(\n                'success', false,\n                'error', 'BOOKING_CONFLICT',\n                'message', 'Capacity rule is currently locked by another transaction. Please retry.',\n                'retryable', true\n            );\n        \n        WHEN OTHERS THEN\n            RAISE WARNING 'Unexpected error in create_booking_with_capacity_check: % %', SQLERRM, SQLSTATE;\n            RETURN jsonb_build_object(\n                'success', false,\n                'error', 'INTERNAL_ERROR',\n                'message', 'An unexpected error occurred while creating the booking',\n                'retryable', false,\n                'sqlstate', SQLSTATE,\n                'sqlerrm', SQLERRM,\n                'timezone', v_timezone,\n                'original_timezone', NULLIF(v_timezone_raw, '')\n            );\n    END;\n    $$;\n\n\nALTER FUNCTION \"public\".\"create_booking_with_capacity_check\"(\"p_restaurant_id\" \"uuid\", \"p_customer_id\" \"uuid\", \"p_booking_date\" \"date\", \"p_start_time\" time without time zone, \"p_end_time\" time without time zone, \"p_party_size\" integer, \"p_booking_type\" \"text\", \"p_customer_name\" \"text\", \"p_customer_email\" \"text\", \"p_customer_phone\" \"text\", \"p_seating_preference\" \"text\", \"p_notes\" \"text\", \"p_marketing_opt_in\" boolean, \"p_idempotency_key\" \"text\", \"p_source\" \"text\", \"p_auth_user_id\" \"uuid\", \"p_client_request_id\" \"text\", \"p_details\" \"jsonb\", \"p_loyalty_points_awarded\" integer) OWNER TO \"postgres\";\n\n\nCOMMENT ON FUNCTION \"public\".\"create_booking_with_capacity_check\"(\"p_restaurant_id\" \"uuid\", \"p_customer_id\" \"uuid\", \"p_booking_date\" \"date\", \"p_start_time\" time without time zone, \"p_end_time\" time without time zone, \"p_party_size\" integer, \"p_booking_type\" \"text\", \"p_customer_name\" \"text\", \"p_customer_email\" \"text\", \"p_customer_phone\" \"text\", \"p_seating_preference\" \"text\", \"p_notes\" \"text\", \"p_marketing_opt_in\" boolean, \"p_idempotency_key\" \"text\", \"p_source\" \"text\", \"p_auth_user_id\" \"uuid\", \"p_client_request_id\" \"text\", \"p_details\" \"jsonb\", \"p_loyalty_points_awarded\" integer) IS 'Race-safe booking creation with capacity enforcement. Uses SERIALIZABLE isolation and row-level locking to prevent overbooking. Returns JSONB with success/error/booking/capacity data.';\n\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"generate_booking_reference\"() RETURNS \"text\"\n    LANGUAGE \"plpgsql\"\n    AS $$\nDECLARE\n  chars text := 'ABCDEFGHJKLMNPQRSTUVWXYZ23456789'; -- excludes 0/O/1/I\n  result text := '';\n  i integer;\nBEGIN\n  FOR i IN 1..10 LOOP\n    result := result || substr(chars, floor(random() * length(chars) + 1)::int, 1);\n  END LOOP;\n  RETURN result;\nEND;\n$$;\n\n\nALTER FUNCTION \"public\".\"generate_booking_reference\"() OWNER TO \"postgres\";\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"get_or_create_booking_slot\"(\"p_restaurant_id\" \"uuid\", \"p_slot_date\" \"date\", \"p_slot_time\" time without time zone, \"p_default_capacity\" integer DEFAULT 999) RETURNS \"uuid\"\n    LANGUAGE \"plpgsql\" SECURITY DEFINER\n    AS $$\nDECLARE\n    v_slot_id uuid;\n    v_service_period_id uuid;\n    v_capacity integer;\nBEGIN\n    -- Try to find existing slot\n    SELECT id INTO v_slot_id\n    FROM booking_slots\n    WHERE restaurant_id = p_restaurant_id\n        AND slot_date = p_slot_date\n        AND slot_time = p_slot_time;\n    \n    IF FOUND THEN\n        RETURN v_slot_id;\n    END IF;\n    \n    -- Find applicable service period\n    SELECT id INTO v_service_period_id\n    FROM restaurant_service_periods\n    WHERE restaurant_id = p_restaurant_id\n        AND (day_of_week IS NULL OR day_of_week = EXTRACT(DOW FROM p_slot_date)::smallint)\n        AND p_slot_time >= start_time\n        AND p_slot_time < end_time\n    ORDER BY day_of_week DESC NULLS LAST\n    LIMIT 1;\n    \n    -- Get capacity from rules (if exists)\n    SELECT COALESCE(max_covers, p_default_capacity) INTO v_capacity\n    FROM restaurant_capacity_rules\n    WHERE restaurant_id = p_restaurant_id\n        AND (service_period_id IS NULL OR service_period_id = v_service_period_id)\n        AND (day_of_week IS NULL OR day_of_week = EXTRACT(DOW FROM p_slot_date)::smallint)\n        AND (effective_date IS NULL OR effective_date <= p_slot_date)\n    ORDER BY \n        effective_date DESC NULLS LAST,\n        day_of_week DESC NULLS LAST,\n        service_period_id DESC NULLS LAST\n    LIMIT 1;\n    \n    -- Default capacity if no rule found\n    v_capacity := COALESCE(v_capacity, p_default_capacity);\n    \n    -- Create new slot\n    INSERT INTO booking_slots (\n        restaurant_id,\n        slot_date,\n        slot_time,\n        service_period_id,\n        available_capacity,\n        reserved_count\n    ) VALUES (\n        p_restaurant_id,\n        p_slot_date,\n        p_slot_time,\n        v_service_period_id,\n        v_capacity,\n        0\n    )\n    RETURNING id INTO v_slot_id;\n    \n    RETURN v_slot_id;\nEND;\n$$;\n\n\nALTER FUNCTION \"public\".\"get_or_create_booking_slot\"(\"p_restaurant_id\" \"uuid\", \"p_slot_date\" \"date\", \"p_slot_time\" time without time zone, \"p_default_capacity\" integer) OWNER TO \"postgres\";\n\n\nCOMMENT ON FUNCTION \"public\".\"get_or_create_booking_slot\"(\"p_restaurant_id\" \"uuid\", \"p_slot_date\" \"date\", \"p_slot_time\" time without time zone, \"p_default_capacity\" integer) IS 'Get existing slot or create new one with capacity derived from rules. Used for lazy slot creation.';\n\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"increment_booking_slot_version\"() RETURNS \"trigger\"\n    LANGUAGE \"plpgsql\"\n    AS $$\nBEGIN\n    -- Only increment version if reserved_count changed\n    IF OLD.reserved_count IS DISTINCT FROM NEW.reserved_count THEN\n        NEW.version := OLD.version + 1;\n    END IF;\n    RETURN NEW;\nEND;\n$$;\n\n\nALTER FUNCTION \"public\".\"increment_booking_slot_version\"() OWNER TO \"postgres\";\n\n\nCOMMENT ON FUNCTION \"public\".\"increment_booking_slot_version\"() IS 'Automatically increment version column when reserved_count changes (optimistic concurrency control)';\n\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"increment_capacity_metrics\"(\"p_restaurant_id\" \"uuid\", \"p_window_start\" timestamp with time zone, \"p_success_delta\" integer DEFAULT 0, \"p_conflict_delta\" integer DEFAULT 0, \"p_capacity_exceeded_delta\" integer DEFAULT 0) RETURNS \"void\"\n    LANGUAGE \"plpgsql\"\n    AS $$\nBEGIN\n  INSERT INTO public.capacity_metrics_hourly (\n    restaurant_id,\n    window_start,\n    success_count,\n    conflict_count,\n    capacity_exceeded_count\n  )\n  VALUES (\n    p_restaurant_id,\n    date_trunc('hour', p_window_start),\n    GREATEST(p_success_delta, 0),\n    GREATEST(p_conflict_delta, 0),\n    GREATEST(p_capacity_exceeded_delta, 0)\n  )\n  ON CONFLICT (restaurant_id, window_start)\n  DO UPDATE SET\n    success_count = public.capacity_metrics_hourly.success_count + GREATEST(p_success_delta, 0),\n    conflict_count = public.capacity_metrics_hourly.conflict_count + GREATEST(p_conflict_delta, 0),\n    capacity_exceeded_count = public.capacity_metrics_hourly.capacity_exceeded_count + GREATEST(p_capacity_exceeded_delta, 0),\n    updated_at = timezone('utc', now());\nEND;\n$$;\n\n\nALTER FUNCTION \"public\".\"increment_capacity_metrics\"(\"p_restaurant_id\" \"uuid\", \"p_window_start\" timestamp with time zone, \"p_success_delta\" integer, \"p_conflict_delta\" integer, \"p_capacity_exceeded_delta\" integer) OWNER TO \"postgres\";\n\n\nCOMMENT ON FUNCTION \"public\".\"increment_capacity_metrics\"(\"p_restaurant_id\" \"uuid\", \"p_window_start\" timestamp with time zone, \"p_success_delta\" integer, \"p_conflict_delta\" integer, \"p_capacity_exceeded_delta\" integer) IS 'Increment hourly capacity metrics counters with atomic upsert.';\n\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"log_table_assignment_change\"() RETURNS \"trigger\"\n    LANGUAGE \"plpgsql\" SECURITY DEFINER\n    AS $$\nBEGIN\n    -- Log to audit_logs table if it exists\n    IF TG_OP = 'INSERT' THEN\n        INSERT INTO audit_logs (entity, entity_id, action, actor, metadata)\n        VALUES (\n            'booking_table_assignment',\n            NEW.id::text,\n            'assigned',\n            NEW.assigned_by::text,\n            jsonb_build_object(\n                'booking_id', NEW.booking_id,\n                'table_id', NEW.table_id,\n                'slot_id', NEW.slot_id\n            )\n        );\n    ELSIF TG_OP = 'DELETE' THEN\n        INSERT INTO audit_logs (entity, entity_id, action, actor, metadata)\n        VALUES (\n            'booking_table_assignment',\n            OLD.id::text,\n            'unassigned',\n            OLD.assigned_by::text,\n            jsonb_build_object(\n                'booking_id', OLD.booking_id,\n                'table_id', OLD.table_id,\n                'slot_id', OLD.slot_id\n            )\n        );\n    END IF;\n    \n    RETURN COALESCE(NEW, OLD);\nEND;\n$$;\n\n\nALTER FUNCTION \"public\".\"log_table_assignment_change\"() OWNER TO \"postgres\";\n\n\nCOMMENT ON FUNCTION \"public\".\"log_table_assignment_change\"() IS 'Audit trail for table assignment changes (who assigned what table to which booking)';\n\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"on_allocations_refresh\"() RETURNS \"trigger\"\n    LANGUAGE \"plpgsql\" SECURITY DEFINER\n    AS $$\n    DECLARE\n      v_table uuid;\n    BEGIN\n      IF TG_OP = 'DELETE' THEN\n        IF OLD.resource_type = 'table' THEN\n          PERFORM public.refresh_table_status(OLD.resource_id);\n        END IF;\n      ELSE\n        IF NEW.resource_type = 'table' THEN\n          PERFORM public.refresh_table_status(NEW.resource_id);\n        END IF;\n      END IF;\n      RETURN NULL;\n    END;\n    $$;\n\n\nALTER FUNCTION \"public\".\"on_allocations_refresh\"() OWNER TO \"postgres\";\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"on_booking_status_refresh\"() RETURNS \"trigger\"\n    LANGUAGE \"plpgsql\" SECURITY DEFINER\n    AS $$\n    DECLARE\n      v_table_id uuid;\n    BEGIN\n      IF TG_OP <> 'UPDATE' OR NEW.status = OLD.status THEN\n        RETURN NEW;\n      END IF;\n\n      FOR v_table_id IN\n        SELECT table_id\n        FROM public.booking_table_assignments\n        WHERE booking_id = NEW.id\n      LOOP\n        PERFORM public.refresh_table_status(v_table_id);\n      END LOOP;\n\n      RETURN NEW;\n    END;\n    $$;\n\n\nALTER FUNCTION \"public\".\"on_booking_status_refresh\"() OWNER TO \"postgres\";\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"refresh_table_status\"(\"p_table_id\" \"uuid\") RETURNS \"void\"\n    LANGUAGE \"plpgsql\" SECURITY DEFINER\n    AS $$\n    DECLARE\n      v_has_checked_in boolean;\n      v_has_future_or_current boolean;\n    BEGIN\n      IF p_table_id IS NULL THEN\n        RETURN;\n      END IF;\n\n      IF EXISTS (\n        SELECT 1\n        FROM public.allocations a\n        WHERE a.resource_type = 'table'\n          AND a.resource_id = p_table_id\n          AND a.is_maintenance\n          AND a.\"window\" @> now()\n      ) THEN\n        UPDATE public.table_inventory\n        SET status = 'out_of_service'\n        WHERE id = p_table_id;\n        RETURN;\n      END IF;\n\n      SELECT EXISTS (\n        SELECT 1\n        FROM public.allocations a\n        JOIN public.bookings b ON b.id = a.booking_id\n        WHERE a.resource_type = 'table'\n          AND a.resource_id = p_table_id\n          AND b.status = 'checked_in'\n          AND a.\"window\" @> now()\n      ) INTO v_has_checked_in;\n\n      IF v_has_checked_in THEN\n        UPDATE public.table_inventory\n        SET status = 'occupied'\n        WHERE id = p_table_id\n          AND status <> 'out_of_service';\n        RETURN;\n      END IF;\n\n      SELECT EXISTS (\n        SELECT 1\n        FROM public.allocations a\n        WHERE a.resource_type = 'table'\n          AND a.resource_id = p_table_id\n          AND upper(a.\"window\") > now()\n      ) INTO v_has_future_or_current;\n\n      IF v_has_future_or_current THEN\n        UPDATE public.table_inventory\n        SET status = 'reserved'\n        WHERE id = p_table_id\n          AND status NOT IN ('occupied', 'out_of_service');\n      ELSE\n        UPDATE public.table_inventory\n        SET status = 'available'\n        WHERE id = p_table_id\n          AND status <> 'out_of_service';\n      END IF;\n    END;\n    $$;\n\n\nALTER FUNCTION \"public\".\"refresh_table_status\"(\"p_table_id\" \"uuid\") OWNER TO \"postgres\";\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"set_booking_instants\"() RETURNS \"trigger\"\n    LANGUAGE \"plpgsql\"\n    AS $$\nDECLARE\n  tz text;\n  sh int; sm int; ss double precision;\n  eh int; em int; es double precision;\nBEGIN\n  SELECT timezone INTO tz FROM public.restaurants WHERE id = NEW.restaurant_id;\n\n  sh := EXTRACT(HOUR   FROM NEW.start_time)::int;\n  sm := EXTRACT(MINUTE FROM NEW.start_time)::int;\n  ss := EXTRACT(SECOND FROM NEW.start_time);\n  eh := EXTRACT(HOUR   FROM NEW.end_time)::int;\n  em := EXTRACT(MINUTE FROM NEW.end_time)::int;\n  es := EXTRACT(SECOND FROM NEW.end_time);\n\n  NEW.start_at := make_timestamptz(\n                    EXTRACT(YEAR  FROM NEW.booking_date)::int,\n                    EXTRACT(MONTH FROM NEW.booking_date)::int,\n                    EXTRACT(DAY   FROM NEW.booking_date)::int,\n                    sh, sm, ss, tz\n                  );\n\n  NEW.end_at := make_timestamptz(\n                    EXTRACT(YEAR  FROM NEW.booking_date)::int,\n                    EXTRACT(MONTH FROM NEW.booking_date)::int,\n                    EXTRACT(DAY   FROM NEW.booking_date)::int,\n                    eh, em, es, tz\n               );\n\n  RETURN NEW;\nEND;\n$$;\n\n\nALTER FUNCTION \"public\".\"set_booking_instants\"() OWNER TO \"postgres\";\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"set_booking_reference\"() RETURNS \"trigger\"\n    LANGUAGE \"plpgsql\"\n    AS $$\nDECLARE ref text;\nBEGIN\n  IF COALESCE(NEW.reference,'') = '' THEN\n    LOOP\n      ref := public.generate_booking_reference();\n      EXIT WHEN NOT EXISTS (SELECT 1 FROM public.bookings WHERE reference = ref);\n    END LOOP;\n    NEW.reference := ref;\n  END IF;\n  RETURN NEW;\nEND;\n$$;\n\n\nALTER FUNCTION \"public\".\"set_booking_reference\"() OWNER TO \"postgres\";\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"sync_table_adjacency_symmetry\"() RETURNS \"trigger\"\n    LANGUAGE \"plpgsql\"\n    AS $$\nBEGIN\n  IF TG_OP = 'INSERT' THEN\n    IF NOT EXISTS (\n      SELECT 1 FROM public.table_adjacencies\n      WHERE table_a = NEW.table_b AND table_b = NEW.table_a\n    ) THEN\n      IF NEW.table_a::text < NEW.table_b::text THEN\n        INSERT INTO public.table_adjacencies(table_a, table_b)\n        VALUES (NEW.table_b, NEW.table_a)\n        ON CONFLICT DO NOTHING;\n      END IF;\n    END IF;\n    RETURN NEW;\n  ELSIF TG_OP = 'DELETE' THEN\n    DELETE FROM public.table_adjacencies\n    WHERE table_a = OLD.table_b AND table_b = OLD.table_a;\n    RETURN OLD;\n  END IF;\n  RETURN NULL;\nEND;\n$$;\n\n\nALTER FUNCTION \"public\".\"sync_table_adjacency_symmetry\"() OWNER TO \"postgres\";\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"unassign_table_from_booking\"(\"p_booking_id\" \"uuid\", \"p_table_id\" \"uuid\") RETURNS boolean\n    LANGUAGE \"plpgsql\" SECURITY DEFINER\n    AS $$\nDECLARE\n    v_deleted boolean;\nBEGIN\n    -- Delete assignment\n    DELETE FROM booking_table_assignments\n    WHERE booking_id = p_booking_id\n        AND table_id = p_table_id;\n    \n    GET DIAGNOSTICS v_deleted = ROW_COUNT;\n    \n    IF v_deleted THEN\n        -- Update table status to available\n        UPDATE table_inventory\n        SET status = 'available'::table_status\n        WHERE id = p_table_id\n            AND NOT EXISTS (\n                -- Keep as reserved if other active bookings exist\n                SELECT 1 FROM booking_table_assignments bta\n                JOIN bookings b ON b.id = bta.booking_id\n                WHERE bta.table_id = p_table_id\n                    AND b.status NOT IN ('cancelled', 'no_show', 'completed')\n            );\n        \n        RETURN true;\n    END IF;\n    \n    RETURN false;\nEND;\n$$;\n\n\nALTER FUNCTION \"public\".\"unassign_table_from_booking\"(\"p_booking_id\" \"uuid\", \"p_table_id\" \"uuid\") OWNER TO \"postgres\";\n\n\nCOMMENT ON FUNCTION \"public\".\"unassign_table_from_booking\"(\"p_booking_id\" \"uuid\", \"p_table_id\" \"uuid\") IS 'Remove table assignment from booking. Updates table status to available if no other active bookings.';\n\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"unassign_tables_atomic\"(\"p_booking_id\" \"uuid\", \"p_table_ids\" \"uuid\"[] DEFAULT NULL::\"uuid\"[], \"p_merge_group_id\" \"uuid\" DEFAULT NULL::\"uuid\") RETURNS TABLE(\"table_id\" \"uuid\", \"merge_group_id\" \"uuid\")\n    LANGUAGE \"plpgsql\" SECURITY DEFINER\n    AS $$\n    DECLARE\n      v_target_tables uuid[] := p_table_ids;\n      v_removed RECORD;\n      v_tables_from_group uuid[];\n      v_merge_group_id uuid := p_merge_group_id;\n    BEGIN\n      IF v_target_tables IS NOT NULL THEN\n        SELECT array_agg(DISTINCT table_id)\n        INTO v_target_tables\n        FROM unnest(v_target_tables) AS t(table_id);\n      END IF;\n\n      IF (v_target_tables IS NULL OR array_length(v_target_tables, 1) = 0) THEN\n        IF v_merge_group_id IS NULL THEN\n          RAISE EXCEPTION 'Provide table_ids or merge_group_id to unassign'\n            USING ERRCODE = '23514';\n        END IF;\n\n        SELECT array_agg(table_id)\n        INTO v_tables_from_group\n        FROM public.merge_group_members\n        WHERE merge_group_id = v_merge_group_id;\n\n        v_target_tables := v_tables_from_group;\n      END IF;\n\n      IF v_target_tables IS NULL OR array_length(v_target_tables, 1) = 0 THEN\n        RETURN;\n      END IF;\n\n      FOR v_removed IN\n        DELETE FROM public.booking_table_assignments\n        WHERE booking_id = p_booking_id\n          AND table_id = ANY (v_target_tables)\n        RETURNING table_id, merge_group_id\n      LOOP\n        table_id := v_removed.table_id;\n        merge_group_id := v_removed.merge_group_id;\n        IF v_merge_group_id IS NULL THEN\n          v_merge_group_id := v_removed.merge_group_id;\n        END IF;\n\n        DELETE FROM public.allocations\n        WHERE booking_id = p_booking_id\n          AND resource_type = 'table'\n          AND resource_id = v_removed.table_id;\n\n        UPDATE public.table_inventory ti\n        SET status = 'available'::public.table_status\n        WHERE ti.id = v_removed.table_id\n          AND NOT EXISTS (\n            SELECT 1\n            FROM public.booking_table_assignments bta\n            WHERE bta.table_id = v_removed.table_id\n          );\n\n        RETURN NEXT;\n      END LOOP;\n\n      IF v_merge_group_id IS NULL THEN\n        SELECT merge_group_id\n        INTO v_merge_group_id\n        FROM public.booking_table_assignments\n        WHERE booking_id = p_booking_id\n          AND merge_group_id IS NOT NULL\n        LIMIT 1;\n      END IF;\n\n      IF v_merge_group_id IS NOT NULL THEN\n        DELETE FROM public.allocations\n        WHERE booking_id = p_booking_id\n          AND resource_type = 'merge_group'\n          AND resource_id = v_merge_group_id;\n\n        UPDATE public.merge_groups\n        SET dissolved_at = now()\n        WHERE id = v_merge_group_id\n          AND NOT EXISTS (\n            SELECT 1\n            FROM public.booking_table_assignments bta\n            WHERE bta.merge_group_id = v_merge_group_id\n          );\n\n        DELETE FROM public.merge_group_members\n        WHERE merge_group_id = v_merge_group_id\n          AND NOT EXISTS (\n            SELECT 1\n            FROM public.booking_table_assignments bta\n            WHERE bta.merge_group_id = v_merge_group_id\n          );\n      END IF;\n\n      RETURN;\n    END;\n    $$;\n\n\nALTER FUNCTION \"public\".\"unassign_tables_atomic\"(\"p_booking_id\" \"uuid\", \"p_table_ids\" \"uuid\"[], \"p_merge_group_id\" \"uuid\") OWNER TO \"postgres\";\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"update_updated_at\"() RETURNS \"trigger\"\n    LANGUAGE \"plpgsql\"\n    AS $$\nBEGIN\n  NEW.updated_at := now();\n  RETURN NEW;\nEND;\n$$;\n\n\nALTER FUNCTION \"public\".\"update_updated_at\"() OWNER TO \"postgres\";\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"user_restaurants\"() RETURNS SETOF \"uuid\"\n    LANGUAGE \"sql\" STABLE SECURITY DEFINER\n    AS $$\n  SELECT restaurant_id\n  FROM public.restaurant_memberships\n  WHERE user_id = auth.uid()\n$$;\n\n\nALTER FUNCTION \"public\".\"user_restaurants\"() OWNER TO \"postgres\";\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"user_restaurants_admin\"() RETURNS SETOF \"uuid\"\n    LANGUAGE \"sql\" STABLE SECURITY DEFINER\n    SET \"search_path\" TO 'public'\n    AS $$\n  SELECT restaurant_id\n  FROM public.restaurant_memberships\n  WHERE user_id = auth.uid()\n    AND role = ANY (ARRAY['owner'::text, 'manager'::text]);\n$$;\n\n\nALTER FUNCTION \"public\".\"user_restaurants_admin\"() OWNER TO \"postgres\";\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"validate_merge_group_members\"() RETURNS \"trigger\"\n    LANGUAGE \"plpgsql\"\n    AS $$\nDECLARE\n  table_ids uuid[];\n  distinct_zones integer;\nBEGIN\n  SELECT array_agg(mgm.table_id)\n  INTO table_ids\n  FROM public.merge_group_members mgm\n  WHERE mgm.merge_group_id = NEW.merge_group_id;\n\n  table_ids := array_append(COALESCE(table_ids, '{}'::uuid[]), NEW.table_id);\n\n  SELECT COUNT(DISTINCT ti.zone_id)\n  INTO distinct_zones\n  FROM public.table_inventory ti\n  WHERE ti.id = ANY(table_ids);\n\n  IF distinct_zones IS NULL OR distinct_zones = 0 THEN\n    RAISE EXCEPTION 'Merge group % references tables that do not exist', NEW.merge_group_id;\n  END IF;\n\n  IF distinct_zones > 1 THEN\n    RAISE EXCEPTION 'Merge group % cannot span multiple zones', NEW.merge_group_id;\n  END IF;\n\n  IF array_length(table_ids, 1) > 1 AND NOT public.are_tables_connected(table_ids) THEN\n    RAISE EXCEPTION 'Merge group % includes tables without adjacency connectivity', NEW.merge_group_id;\n  END IF;\n\n  RETURN NEW;\nEND;\n$$;\n\n\nALTER FUNCTION \"public\".\"validate_merge_group_members\"() OWNER TO \"postgres\";\n\n\nCREATE OR REPLACE FUNCTION \"public\".\"validate_table_adjacency\"() RETURNS \"trigger\"\n    LANGUAGE \"plpgsql\"\n    AS $$\nDECLARE\n  zone_a uuid;\n  zone_b uuid;\nBEGIN\n  SELECT zone_id INTO zone_a FROM public.table_inventory WHERE id = NEW.table_a;\n  SELECT zone_id INTO zone_b FROM public.table_inventory WHERE id = NEW.table_b;\n\n  IF zone_a IS NULL OR zone_b IS NULL THEN\n    RAISE EXCEPTION 'Tables must belong to zones before adjacency can be created';\n  END IF;\n\n  IF zone_a <> zone_b THEN\n    RAISE EXCEPTION 'Adjacency requires tables to be in the same zone';\n  END IF;\n\n  RETURN NEW;\nEND;\n$$;\n\n\nALTER FUNCTION \"public\".\"validate_table_adjacency\"() OWNER TO \"postgres\";\n\nSET default_tablespace = '';\n\nSET default_table_access_method = \"heap\";\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"_migrations\" (\n    \"id\" bigint NOT NULL,\n    \"name\" character varying(255) NOT NULL,\n    \"timestamp\" timestamp with time zone DEFAULT \"now\"(),\n    \"status\" character varying(50) DEFAULT 'applied'::character varying\n);\n\n\nALTER TABLE \"public\".\"_migrations\" OWNER TO \"postgres\";\n\n\nCREATE SEQUENCE IF NOT EXISTS \"public\".\"_migrations_id_seq\"\n    START WITH 1\n    INCREMENT BY 1\n    NO MINVALUE\n    NO MAXVALUE\n    CACHE 1;\n\n\nALTER SEQUENCE \"public\".\"_migrations_id_seq\" OWNER TO \"postgres\";\n\n\nALTER SEQUENCE \"public\".\"_migrations_id_seq\" OWNED BY \"public\".\"_migrations\".\"id\";\n\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"allocations\" (\n    \"id\" \"uuid\" DEFAULT \"gen_random_uuid\"() NOT NULL,\n    \"booking_id\" \"uuid\",\n    \"resource_type\" \"text\" NOT NULL,\n    \"resource_id\" \"uuid\" NOT NULL,\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"updated_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"shadow\" boolean DEFAULT false NOT NULL,\n    \"restaurant_id\" \"uuid\" NOT NULL,\n    \"window\" \"tstzrange\" NOT NULL,\n    \"created_by\" \"uuid\",\n    \"is_maintenance\" boolean DEFAULT false NOT NULL,\n    CONSTRAINT \"allocations_resource_type_check\" CHECK ((\"resource_type\" = ANY (ARRAY['table'::\"text\", 'merge_group'::\"text\"])))\n);\n\n\nALTER TABLE \"public\".\"allocations\" OWNER TO \"postgres\";\n\n\nCOMMENT ON COLUMN \"public\".\"allocations\".\"is_maintenance\" IS 'True when allocation reserves a table for maintenance/out-of-service windows rather than a booking.';\n\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"allowed_capacities\" (\n    \"restaurant_id\" \"uuid\" NOT NULL,\n    \"capacity\" smallint NOT NULL,\n    \"created_at\" timestamp with time zone DEFAULT \"timezone\"('utc'::\"text\", \"now\"()) NOT NULL,\n    \"updated_at\" timestamp with time zone DEFAULT \"timezone\"('utc'::\"text\", \"now\"()) NOT NULL,\n    CONSTRAINT \"allowed_capacities_capacity_check\" CHECK ((\"capacity\" > 0))\n);\n\n\nALTER TABLE \"public\".\"allowed_capacities\" OWNER TO \"postgres\";\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"analytics_events\" (\n    \"id\" \"uuid\" DEFAULT \"extensions\".\"uuid_generate_v4\"() NOT NULL,\n    \"event_type\" \"public\".\"analytics_event_type\" NOT NULL,\n    \"schema_version\" \"text\" NOT NULL,\n    \"restaurant_id\" \"uuid\" NOT NULL,\n    \"booking_id\" \"uuid\" NOT NULL,\n    \"customer_id\" \"uuid\",\n    \"emitted_by\" \"text\" DEFAULT 'server'::\"text\" NOT NULL,\n    \"payload\" \"jsonb\" NOT NULL,\n    \"occurred_at\" timestamp with time zone NOT NULL,\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL\n);\n\n\nALTER TABLE \"public\".\"analytics_events\" OWNER TO \"postgres\";\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"audit_logs\" (\n    \"id\" \"uuid\" DEFAULT \"extensions\".\"uuid_generate_v4\"() NOT NULL,\n    \"entity\" \"text\" NOT NULL,\n    \"entity_id\" \"text\" NOT NULL,\n    \"action\" \"text\" NOT NULL,\n    \"actor\" \"text\",\n    \"metadata\" \"jsonb\",\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL\n);\n\n\nALTER TABLE \"public\".\"audit_logs\" OWNER TO \"postgres\";\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"booking_slots\" (\n    \"id\" \"uuid\" DEFAULT \"extensions\".\"uuid_generate_v4\"() NOT NULL,\n    \"restaurant_id\" \"uuid\" NOT NULL,\n    \"slot_date\" \"date\" NOT NULL,\n    \"slot_time\" time without time zone NOT NULL,\n    \"service_period_id\" \"uuid\",\n    \"available_capacity\" integer DEFAULT 0 NOT NULL,\n    \"reserved_count\" integer DEFAULT 0 NOT NULL,\n    \"version\" integer DEFAULT 1 NOT NULL,\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"updated_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    CONSTRAINT \"booking_slots_available_capacity_positive\" CHECK ((\"available_capacity\" >= 0)),\n    CONSTRAINT \"booking_slots_capacity_valid\" CHECK (((\"reserved_count\" >= 0) AND (\"reserved_count\" <= \"available_capacity\")))\n);\n\n\nALTER TABLE \"public\".\"booking_slots\" OWNER TO \"postgres\";\n\n\nCOMMENT ON TABLE \"public\".\"booking_slots\" IS 'Pre-materialized time slots with capacity counters for fast availability checks. Created on-demand or pre-generated.';\n\n\n\nCOMMENT ON COLUMN \"public\".\"booking_slots\".\"slot_date\" IS 'Date of the slot (e.g., 2025-10-20)';\n\n\n\nCOMMENT ON COLUMN \"public\".\"booking_slots\".\"slot_time\" IS 'Time of the slot (e.g., 19:00). Typically 15/30/60 minute intervals.';\n\n\n\nCOMMENT ON COLUMN \"public\".\"booking_slots\".\"service_period_id\" IS 'Optional link to service period (lunch/dinner). Null if not applicable.';\n\n\n\nCOMMENT ON COLUMN \"public\".\"booking_slots\".\"available_capacity\" IS 'Maximum capacity for this slot (in covers/guests). Derived from capacity rules.';\n\n\n\nCOMMENT ON COLUMN \"public\".\"booking_slots\".\"reserved_count\" IS 'Number of covers/guests currently reserved for this slot.';\n\n\n\nCOMMENT ON COLUMN \"public\".\"booking_slots\".\"version\" IS 'Optimistic locking version. Incremented on each update to prevent race conditions.';\n\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"booking_state_history\" (\n    \"id\" bigint NOT NULL,\n    \"booking_id\" \"uuid\" NOT NULL,\n    \"from_status\" \"public\".\"booking_status\",\n    \"to_status\" \"public\".\"booking_status\" NOT NULL,\n    \"changed_by\" \"uuid\",\n    \"changed_at\" timestamp with time zone DEFAULT \"timezone\"('utc'::\"text\", \"now\"()) NOT NULL,\n    \"reason\" \"text\",\n    \"metadata\" \"jsonb\" DEFAULT '{}'::\"jsonb\" NOT NULL\n);\n\n\nALTER TABLE \"public\".\"booking_state_history\" OWNER TO \"postgres\";\n\n\nCOMMENT ON TABLE \"public\".\"booking_state_history\" IS 'Audit history of booking lifecycle transitions.';\n\n\n\nCOMMENT ON COLUMN \"public\".\"booking_state_history\".\"booking_id\" IS 'Booking whose status transitioned.';\n\n\n\nCOMMENT ON COLUMN \"public\".\"booking_state_history\".\"from_status\" IS 'Previous lifecycle status.';\n\n\n\nCOMMENT ON COLUMN \"public\".\"booking_state_history\".\"to_status\" IS 'New lifecycle status.';\n\n\n\nCOMMENT ON COLUMN \"public\".\"booking_state_history\".\"changed_by\" IS 'User who triggered the change (null for system operations).';\n\n\n\nCOMMENT ON COLUMN \"public\".\"booking_state_history\".\"changed_at\" IS 'UTC timestamp when the transition was recorded.';\n\n\n\nCOMMENT ON COLUMN \"public\".\"booking_state_history\".\"reason\" IS 'Optional human-readable reason for the transition.';\n\n\n\nCOMMENT ON COLUMN \"public\".\"booking_state_history\".\"metadata\" IS 'Additional structured data describing the transition.';\n\n\n\nCREATE SEQUENCE IF NOT EXISTS \"public\".\"booking_state_history_id_seq\"\n    START WITH 1\n    INCREMENT BY 1\n    NO MINVALUE\n    NO MAXVALUE\n    CACHE 1;\n\n\nALTER SEQUENCE \"public\".\"booking_state_history_id_seq\" OWNER TO \"postgres\";\n\n\nALTER SEQUENCE \"public\".\"booking_state_history_id_seq\" OWNED BY \"public\".\"booking_state_history\".\"id\";\n\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"booking_table_assignments\" (\n    \"id\" \"uuid\" DEFAULT \"extensions\".\"uuid_generate_v4\"() NOT NULL,\n    \"booking_id\" \"uuid\" NOT NULL,\n    \"table_id\" \"uuid\" NOT NULL,\n    \"slot_id\" \"uuid\",\n    \"assigned_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"assigned_by\" \"uuid\",\n    \"notes\" \"text\",\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"updated_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"idempotency_key\" \"text\",\n    \"merge_group_id\" \"uuid\"\n);\n\n\nALTER TABLE \"public\".\"booking_table_assignments\" OWNER TO \"postgres\";\n\n\nCOMMENT ON TABLE \"public\".\"booking_table_assignments\" IS 'Links bookings to physical tables. A booking can have multiple tables (e.g., party of 10 = 2x 6-tops).';\n\n\n\nCOMMENT ON COLUMN \"public\".\"booking_table_assignments\".\"booking_id\" IS 'The booking being assigned a table';\n\n\n\nCOMMENT ON COLUMN \"public\".\"booking_table_assignments\".\"table_id\" IS 'The physical table being assigned';\n\n\n\nCOMMENT ON COLUMN \"public\".\"booking_table_assignments\".\"slot_id\" IS 'Optional link to the booking slot (for slot-level tracking)';\n\n\n\nCOMMENT ON COLUMN \"public\".\"booking_table_assignments\".\"assigned_at\" IS 'When the assignment was made';\n\n\n\nCOMMENT ON COLUMN \"public\".\"booking_table_assignments\".\"assigned_by\" IS 'User who made the assignment (null for auto-assignment)';\n\n\n\nCOMMENT ON COLUMN \"public\".\"booking_table_assignments\".\"notes\" IS 'Optional notes about the assignment (e.g., \"VIP preferred seating\")';\n\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"booking_versions\" (\n    \"version_id\" \"uuid\" DEFAULT \"extensions\".\"uuid_generate_v4\"() NOT NULL,\n    \"booking_id\" \"uuid\" NOT NULL,\n    \"restaurant_id\" \"uuid\" NOT NULL,\n    \"change_type\" \"public\".\"booking_change_type\" NOT NULL,\n    \"changed_by\" \"text\",\n    \"changed_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"old_data\" \"jsonb\",\n    \"new_data\" \"jsonb\",\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL\n);\n\n\nALTER TABLE \"public\".\"booking_versions\" OWNER TO \"postgres\";\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"bookings\" (\n    \"id\" \"uuid\" DEFAULT \"extensions\".\"uuid_generate_v4\"() NOT NULL,\n    \"restaurant_id\" \"uuid\" NOT NULL,\n    \"customer_id\" \"uuid\" NOT NULL,\n    \"booking_date\" \"date\" NOT NULL,\n    \"start_time\" time without time zone NOT NULL,\n    \"end_time\" time without time zone NOT NULL,\n    \"start_at\" timestamp with time zone,\n    \"end_at\" timestamp with time zone,\n    \"party_size\" integer NOT NULL,\n    \"seating_preference\" \"public\".\"seating_preference_type\" DEFAULT 'any'::\"public\".\"seating_preference_type\" NOT NULL,\n    \"status\" \"public\".\"booking_status\" DEFAULT 'confirmed'::\"public\".\"booking_status\" NOT NULL,\n    \"customer_name\" \"text\" NOT NULL,\n    \"customer_email\" \"text\" NOT NULL,\n    \"customer_phone\" \"text\" NOT NULL,\n    \"notes\" \"text\",\n    \"reference\" \"text\" NOT NULL,\n    \"source\" \"text\" DEFAULT 'web'::\"text\" NOT NULL,\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"updated_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"booking_type\" \"public\".\"booking_type\" DEFAULT 'dinner'::\"public\".\"booking_type\" NOT NULL,\n    \"idempotency_key\" \"text\",\n    \"client_request_id\" \"text\" DEFAULT (\"gen_random_uuid\"())::\"text\" NOT NULL,\n    \"pending_ref\" \"text\",\n    \"details\" \"jsonb\",\n    \"marketing_opt_in\" boolean DEFAULT false NOT NULL,\n    \"confirmation_token\" character varying(64),\n    \"confirmation_token_expires_at\" timestamp with time zone,\n    \"confirmation_token_used_at\" timestamp with time zone,\n    \"auth_user_id\" \"uuid\",\n    \"checked_in_at\" timestamp with time zone,\n    \"checked_out_at\" timestamp with time zone,\n    \"loyalty_points_awarded\" integer DEFAULT 0 NOT NULL,\n    CONSTRAINT \"bookings_checked_out_after_checked_in\" CHECK (((\"checked_out_at\" IS NULL) OR (\"checked_in_at\" IS NULL) OR (\"checked_out_at\" >= \"checked_in_at\"))),\n    CONSTRAINT \"bookings_party_size_check\" CHECK ((\"party_size\" > 0)),\n    CONSTRAINT \"chk_time_order\" CHECK ((\"start_at\" < \"end_at\"))\n);\n\n\nALTER TABLE \"public\".\"bookings\" OWNER TO \"postgres\";\n\n\nCOMMENT ON COLUMN \"public\".\"bookings\".\"confirmation_token\" IS 'One-time cryptographic token (base64url, 64 chars) for guest confirmation page access. Expires in 1 hour.';\n\n\n\nCOMMENT ON COLUMN \"public\".\"bookings\".\"confirmation_token_expires_at\" IS 'Expiry timestamp for confirmation_token. After this time, token is invalid.';\n\n\n\nCOMMENT ON COLUMN \"public\".\"bookings\".\"confirmation_token_used_at\" IS 'Timestamp when confirmation_token was first used. Prevents token replay attacks.';\n\n\n\nCOMMENT ON COLUMN \"public\".\"bookings\".\"auth_user_id\" IS 'Optional link to the authenticated Supabase user that created or owns the booking.';\n\n\n\nCOMMENT ON COLUMN \"public\".\"bookings\".\"checked_in_at\" IS 'Timestamp when the guest was checked in by ops';\n\n\n\nCOMMENT ON COLUMN \"public\".\"bookings\".\"checked_out_at\" IS 'Timestamp when the guest was checked out by ops';\n\n\n\nCOMMENT ON CONSTRAINT \"bookings_checked_out_after_checked_in\" ON \"public\".\"bookings\" IS 'Ensures recorded check-out timestamps are chronologically after check-in.';\n\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"capacity_metrics_hourly\" (\n    \"restaurant_id\" \"uuid\" NOT NULL,\n    \"window_start\" timestamp with time zone NOT NULL,\n    \"success_count\" integer DEFAULT 0 NOT NULL,\n    \"conflict_count\" integer DEFAULT 0 NOT NULL,\n    \"capacity_exceeded_count\" integer DEFAULT 0 NOT NULL,\n    \"created_at\" timestamp with time zone DEFAULT \"timezone\"('utc'::\"text\", \"now\"()) NOT NULL,\n    \"updated_at\" timestamp with time zone DEFAULT \"timezone\"('utc'::\"text\", \"now\"()) NOT NULL\n);\n\n\nALTER TABLE \"public\".\"capacity_metrics_hourly\" OWNER TO \"postgres\";\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"customer_profiles\" (\n    \"customer_id\" \"uuid\" NOT NULL,\n    \"first_booking_at\" timestamp with time zone,\n    \"last_booking_at\" timestamp with time zone,\n    \"total_bookings\" integer DEFAULT 0 NOT NULL,\n    \"total_covers\" integer DEFAULT 0 NOT NULL,\n    \"total_cancellations\" integer DEFAULT 0 NOT NULL,\n    \"marketing_opt_in\" boolean DEFAULT false NOT NULL,\n    \"last_marketing_opt_in_at\" timestamp with time zone,\n    \"preferences\" \"jsonb\" DEFAULT '{}'::\"jsonb\" NOT NULL,\n    \"notes\" \"text\",\n    \"updated_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    CONSTRAINT \"customer_profiles_total_bookings_check\" CHECK ((\"total_bookings\" >= 0)),\n    CONSTRAINT \"customer_profiles_total_cancellations_check\" CHECK ((\"total_cancellations\" >= 0)),\n    CONSTRAINT \"customer_profiles_total_covers_check\" CHECK ((\"total_covers\" >= 0))\n);\n\n\nALTER TABLE \"public\".\"customer_profiles\" OWNER TO \"postgres\";\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"customers\" (\n    \"id\" \"uuid\" DEFAULT \"extensions\".\"uuid_generate_v4\"() NOT NULL,\n    \"restaurant_id\" \"uuid\" NOT NULL,\n    \"full_name\" \"text\" NOT NULL,\n    \"email\" \"text\" NOT NULL,\n    \"phone\" \"text\" NOT NULL,\n    \"email_normalized\" \"text\" GENERATED ALWAYS AS (\"lower\"(TRIM(BOTH FROM \"email\"))) STORED,\n    \"phone_normalized\" \"text\" GENERATED ALWAYS AS (\"regexp_replace\"(\"phone\", '[^0-9]+'::\"text\", ''::\"text\", 'g'::\"text\")) STORED,\n    \"marketing_opt_in\" boolean DEFAULT false NOT NULL,\n    \"auth_user_id\" \"uuid\",\n    \"notes\" \"text\",\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"updated_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    CONSTRAINT \"customers_email_check\" CHECK ((\"email\" = \"lower\"(\"email\"))),\n    CONSTRAINT \"customers_phone_check\" CHECK (((\"length\"(\"phone\") >= 7) AND (\"length\"(\"phone\") <= 20)))\n);\n\n\nALTER TABLE \"public\".\"customers\" OWNER TO \"postgres\";\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"loyalty_point_events\" (\n    \"id\" \"uuid\" DEFAULT \"extensions\".\"uuid_generate_v4\"() NOT NULL,\n    \"restaurant_id\" \"uuid\" NOT NULL,\n    \"customer_id\" \"uuid\" NOT NULL,\n    \"booking_id\" \"uuid\",\n    \"points_change\" integer NOT NULL,\n    \"event_type\" \"text\" NOT NULL,\n    \"schema_version\" integer DEFAULT 1 NOT NULL,\n    \"metadata\" \"jsonb\",\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL\n);\n\n\nALTER TABLE \"public\".\"loyalty_point_events\" OWNER TO \"postgres\";\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"loyalty_points\" (\n    \"id\" \"uuid\" DEFAULT \"extensions\".\"uuid_generate_v4\"() NOT NULL,\n    \"restaurant_id\" \"uuid\" NOT NULL,\n    \"customer_id\" \"uuid\" NOT NULL,\n    \"total_points\" integer DEFAULT 0 NOT NULL,\n    \"tier\" \"public\".\"loyalty_tier\" DEFAULT 'bronze'::\"public\".\"loyalty_tier\" NOT NULL,\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"updated_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL\n);\n\n\nALTER TABLE \"public\".\"loyalty_points\" OWNER TO \"postgres\";\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"loyalty_programs\" (\n    \"id\" \"uuid\" DEFAULT \"extensions\".\"uuid_generate_v4\"() NOT NULL,\n    \"restaurant_id\" \"uuid\" NOT NULL,\n    \"name\" \"text\" NOT NULL,\n    \"is_active\" boolean DEFAULT true NOT NULL,\n    \"accrual_rule\" \"jsonb\" DEFAULT '{\"type\": \"per_guest\", \"base_points\": 10, \"points_per_guest\": 5, \"minimum_party_size\": 1}'::\"jsonb\" NOT NULL,\n    \"tier_definitions\" \"jsonb\" DEFAULT '[{\"tier\": \"bronze\", \"min_points\": 0}]'::\"jsonb\" NOT NULL,\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"updated_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"pilot_only\" boolean DEFAULT false NOT NULL\n);\n\n\nALTER TABLE \"public\".\"loyalty_programs\" OWNER TO \"postgres\";\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"merge_group_members\" (\n    \"merge_group_id\" \"uuid\" NOT NULL,\n    \"table_id\" \"uuid\" NOT NULL,\n    \"added_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL\n);\n\n\nALTER TABLE \"public\".\"merge_group_members\" OWNER TO \"postgres\";\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"merge_groups\" (\n    \"id\" \"uuid\" DEFAULT \"gen_random_uuid\"() NOT NULL,\n    \"capacity\" smallint NOT NULL,\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"dissolved_at\" timestamp with time zone\n);\n\n\nALTER TABLE \"public\".\"merge_groups\" OWNER TO \"postgres\";\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"merge_rules\" (\n    \"id\" \"uuid\" DEFAULT \"gen_random_uuid\"() NOT NULL,\n    \"from_a\" smallint NOT NULL,\n    \"from_b\" smallint NOT NULL,\n    \"to_capacity\" smallint NOT NULL,\n    \"enabled\" boolean DEFAULT true NOT NULL,\n    \"require_same_zone\" boolean DEFAULT true NOT NULL,\n    \"require_adjacency\" boolean DEFAULT true NOT NULL,\n    \"cross_category_merge\" boolean DEFAULT false NOT NULL,\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"updated_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    CONSTRAINT \"merge_rules_positive\" CHECK (((\"from_a\" > 0) AND (\"from_b\" > 0) AND (\"to_capacity\" > 0)))\n);\n\n\nALTER TABLE \"public\".\"merge_rules\" OWNER TO \"postgres\";\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"profile_update_requests\" (\n    \"id\" \"uuid\" DEFAULT \"gen_random_uuid\"() NOT NULL,\n    \"profile_id\" \"uuid\" NOT NULL,\n    \"idempotency_key\" \"text\" NOT NULL,\n    \"payload_hash\" \"text\" NOT NULL,\n    \"applied_at\" timestamp with time zone DEFAULT \"timezone\"('utc'::\"text\", \"now\"()) NOT NULL\n);\n\n\nALTER TABLE \"public\".\"profile_update_requests\" OWNER TO \"postgres\";\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"profiles\" (\n    \"id\" \"uuid\" NOT NULL,\n    \"email\" \"text\",\n    \"name\" \"text\",\n    \"phone\" \"text\",\n    \"image\" \"text\",\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"updated_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"has_access\" boolean DEFAULT true NOT NULL,\n    CONSTRAINT \"profiles_email_check\" CHECK ((\"email\" = \"lower\"(\"email\")))\n);\n\n\nALTER TABLE \"public\".\"profiles\" OWNER TO \"postgres\";\n\n\nCOMMENT ON COLUMN \"public\".\"profiles\".\"has_access\" IS 'Indicates whether the profile retains active access to Ops surfaces.';\n\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"restaurant_capacity_rules\" (\n    \"id\" \"uuid\" DEFAULT \"extensions\".\"uuid_generate_v4\"() NOT NULL,\n    \"restaurant_id\" \"uuid\" NOT NULL,\n    \"service_period_id\" \"uuid\",\n    \"day_of_week\" smallint,\n    \"effective_date\" \"date\",\n    \"max_covers\" integer,\n    \"max_parties\" integer,\n    \"notes\" \"text\",\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"updated_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"label\" \"text\",\n    \"override_type\" \"public\".\"capacity_override_type\",\n    CONSTRAINT \"restaurant_capacity_rules_non_negative\" CHECK ((((\"max_covers\" IS NULL) OR (\"max_covers\" >= 0)) AND ((\"max_parties\" IS NULL) OR (\"max_parties\" >= 0)))),\n    CONSTRAINT \"restaurant_capacity_rules_scope\" CHECK (((\"service_period_id\" IS NOT NULL) OR (\"day_of_week\" IS NOT NULL) OR (\"effective_date\" IS NOT NULL)))\n);\n\n\nALTER TABLE \"public\".\"restaurant_capacity_rules\" OWNER TO \"postgres\";\n\n\nCOMMENT ON COLUMN \"public\".\"restaurant_capacity_rules\".\"label\" IS 'Human-friendly name for this capacity rule or override (e.g., Christmas Eve Dinner).';\n\n\n\nCOMMENT ON COLUMN \"public\".\"restaurant_capacity_rules\".\"override_type\" IS 'Categorizes overrides (holiday, event, manual adjustments, emergencies).';\n\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"restaurant_invites\" (\n    \"id\" \"uuid\" DEFAULT \"gen_random_uuid\"() NOT NULL,\n    \"restaurant_id\" \"uuid\" NOT NULL,\n    \"email\" \"text\" NOT NULL,\n    \"email_normalized\" \"text\" GENERATED ALWAYS AS (\"lower\"(TRIM(BOTH FROM \"email\"))) STORED,\n    \"role\" \"text\" NOT NULL,\n    \"token_hash\" \"text\" NOT NULL,\n    \"status\" \"text\" DEFAULT 'pending'::\"text\" NOT NULL,\n    \"expires_at\" timestamp with time zone NOT NULL,\n    \"invited_by\" \"uuid\",\n    \"accepted_at\" timestamp with time zone,\n    \"revoked_at\" timestamp with time zone,\n    \"created_at\" timestamp with time zone DEFAULT \"timezone\"('utc'::\"text\", \"now\"()) NOT NULL,\n    \"updated_at\" timestamp with time zone DEFAULT \"timezone\"('utc'::\"text\", \"now\"()) NOT NULL,\n    CONSTRAINT \"restaurant_invites_role_check\" CHECK ((\"role\" = ANY (ARRAY['owner'::\"text\", 'manager'::\"text\", 'host'::\"text\", 'server'::\"text\"]))),\n    CONSTRAINT \"restaurant_invites_status_check\" CHECK ((\"status\" = ANY (ARRAY['pending'::\"text\", 'accepted'::\"text\", 'revoked'::\"text\", 'expired'::\"text\"])))\n);\n\n\nALTER TABLE \"public\".\"restaurant_invites\" OWNER TO \"postgres\";\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"restaurant_memberships\" (\n    \"user_id\" \"uuid\" NOT NULL,\n    \"restaurant_id\" \"uuid\" NOT NULL,\n    \"role\" \"text\" NOT NULL,\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    CONSTRAINT \"restaurant_memberships_role_check\" CHECK ((\"role\" = ANY (ARRAY['owner'::\"text\", 'manager'::\"text\", 'host'::\"text\", 'server'::\"text\"])))\n);\n\n\nALTER TABLE \"public\".\"restaurant_memberships\" OWNER TO \"postgres\";\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"restaurant_operating_hours\" (\n    \"id\" \"uuid\" DEFAULT \"extensions\".\"uuid_generate_v4\"() NOT NULL,\n    \"restaurant_id\" \"uuid\" NOT NULL,\n    \"day_of_week\" smallint,\n    \"effective_date\" \"date\",\n    \"opens_at\" time without time zone,\n    \"closes_at\" time without time zone,\n    \"is_closed\" boolean DEFAULT false NOT NULL,\n    \"notes\" \"text\",\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"updated_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    CONSTRAINT \"restaurant_operating_hours_scope\" CHECK (((\"day_of_week\" IS NOT NULL) OR (\"effective_date\" IS NOT NULL))),\n    CONSTRAINT \"restaurant_operating_hours_time_order\" CHECK ((\"is_closed\" OR ((\"opens_at\" IS NOT NULL) AND (\"closes_at\" IS NOT NULL) AND (\"opens_at\" < \"closes_at\"))))\n);\n\n\nALTER TABLE \"public\".\"restaurant_operating_hours\" OWNER TO \"postgres\";\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"restaurant_service_periods\" (\n    \"id\" \"uuid\" DEFAULT \"extensions\".\"uuid_generate_v4\"() NOT NULL,\n    \"restaurant_id\" \"uuid\" NOT NULL,\n    \"name\" \"text\" NOT NULL,\n    \"day_of_week\" smallint,\n    \"start_time\" time without time zone NOT NULL,\n    \"end_time\" time without time zone NOT NULL,\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"updated_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"booking_option\" \"text\" DEFAULT 'drinks'::\"text\" NOT NULL,\n    CONSTRAINT \"restaurant_service_periods_booking_option_check\" CHECK ((\"booking_option\" = ANY (ARRAY['lunch'::\"text\", 'dinner'::\"text\", 'drinks'::\"text\"]))),\n    CONSTRAINT \"restaurant_service_periods_time_order\" CHECK ((\"start_time\" < \"end_time\"))\n);\n\n\nALTER TABLE \"public\".\"restaurant_service_periods\" OWNER TO \"postgres\";\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"restaurants\" (\n    \"id\" \"uuid\" DEFAULT \"extensions\".\"uuid_generate_v4\"() NOT NULL,\n    \"name\" \"text\" NOT NULL,\n    \"slug\" \"text\" NOT NULL,\n    \"timezone\" \"text\" DEFAULT 'Europe/London'::\"text\" NOT NULL,\n    \"capacity\" integer,\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"updated_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"contact_email\" \"text\",\n    \"contact_phone\" \"text\",\n    \"address\" \"text\",\n    \"booking_policy\" \"text\",\n    \"reservation_interval_minutes\" integer DEFAULT 15 NOT NULL,\n    \"reservation_default_duration_minutes\" integer DEFAULT 90 NOT NULL,\n    \"reservation_last_seating_buffer_minutes\" integer DEFAULT 120 NOT NULL,\n    \"is_active\" boolean DEFAULT true NOT NULL,\n    CONSTRAINT \"restaurants_capacity_check\" CHECK (((\"capacity\" IS NULL) OR (\"capacity\" > 0))),\n    CONSTRAINT \"restaurants_reservation_default_duration_minutes_check\" CHECK (((\"reservation_default_duration_minutes\" >= 15) AND (\"reservation_default_duration_minutes\" <= 300))),\n    CONSTRAINT \"restaurants_reservation_last_seating_buffer_minutes_check\" CHECK (((\"reservation_last_seating_buffer_minutes\" >= 15) AND (\"reservation_last_seating_buffer_minutes\" <= 300))),\n    CONSTRAINT \"restaurants_reservation_interval_minutes_check\" CHECK (((\"reservation_interval_minutes\" > 0) AND (\"reservation_interval_minutes\" <= 180))),\n    CONSTRAINT \"restaurants_slug_check\" CHECK ((\"slug\" ~ '^[a-z0-9]+(-[a-z0-9]+)*$'::\"text\"))\n);\n\n\nALTER TABLE \"public\".\"restaurants\" OWNER TO \"postgres\";\n\n\nCOMMENT ON COLUMN \"public\".\"restaurants\".\"is_active\" IS 'Indicates whether the restaurant is active and should surface in public experiences.';\n\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"service_policy\" (\n    \"id\" \"uuid\" DEFAULT \"gen_random_uuid\"() NOT NULL,\n    \"lunch_start\" time without time zone DEFAULT '12:00:00'::time without time zone NOT NULL,\n    \"lunch_end\" time without time zone DEFAULT '15:00:00'::time without time zone NOT NULL,\n    \"dinner_start\" time without time zone DEFAULT '17:00:00'::time without time zone NOT NULL,\n    \"dinner_end\" time without time zone DEFAULT '22:00:00'::time without time zone NOT NULL,\n    \"clean_buffer_minutes\" smallint DEFAULT 5 NOT NULL,\n    \"allow_after_hours\" boolean DEFAULT false NOT NULL,\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"updated_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL\n);\n\n\nALTER TABLE \"public\".\"service_policy\" OWNER TO \"postgres\";\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"stripe_events\" (\n    \"id\" \"uuid\" DEFAULT \"extensions\".\"uuid_generate_v4\"() NOT NULL,\n    \"event_id\" \"text\" NOT NULL,\n    \"event_type\" \"text\" NOT NULL,\n    \"payload\" \"jsonb\" NOT NULL,\n    \"processed\" boolean DEFAULT false NOT NULL,\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL\n);\n\n\nALTER TABLE \"public\".\"stripe_events\" OWNER TO \"postgres\";\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"table_adjacencies\" (\n    \"table_a\" \"uuid\" NOT NULL,\n    \"table_b\" \"uuid\" NOT NULL,\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    CONSTRAINT \"table_adjacencies_not_equal\" CHECK ((\"table_a\" <> \"table_b\"))\n);\n\n\nALTER TABLE \"public\".\"table_adjacencies\" OWNER TO \"postgres\";\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"table_inventory\" (\n    \"id\" \"uuid\" DEFAULT \"extensions\".\"uuid_generate_v4\"() NOT NULL,\n    \"restaurant_id\" \"uuid\" NOT NULL,\n    \"table_number\" \"text\" NOT NULL,\n    \"capacity\" integer NOT NULL,\n    \"min_party_size\" integer DEFAULT 1 NOT NULL,\n    \"max_party_size\" integer,\n    \"section\" \"text\",\n    \"status\" \"public\".\"table_status\" DEFAULT 'available'::\"public\".\"table_status\" NOT NULL,\n    \"position\" \"jsonb\",\n    \"notes\" \"text\",\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"updated_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"zone_id\" \"uuid\" NOT NULL,\n    \"category\" \"public\".\"table_category\" NOT NULL,\n    \"seating_type\" \"public\".\"table_seating_type\" DEFAULT 'standard'::\"public\".\"table_seating_type\" NOT NULL,\n    \"mobility\" \"public\".\"table_mobility\" DEFAULT 'movable'::\"public\".\"table_mobility\" NOT NULL,\n    \"active\" boolean DEFAULT true NOT NULL,\n    CONSTRAINT \"table_inventory_min_party_positive\" CHECK ((\"min_party_size\" > 0)),\n    CONSTRAINT \"table_inventory_valid_party_range\" CHECK (((\"max_party_size\" IS NULL) OR (\"max_party_size\" >= \"min_party_size\")))\n);\n\n\nALTER TABLE \"public\".\"table_inventory\" OWNER TO \"postgres\";\n\n\nCOMMENT ON TABLE \"public\".\"table_inventory\" IS 'Physical restaurant tables with capacity and seating type. Used for table assignment and floor plan visualization.';\n\n\n\nCOMMENT ON COLUMN \"public\".\"table_inventory\".\"table_number\" IS 'Display name for the table (e.g., \"T1\", \"Main-5\", \"Patio-2\")';\n\n\n\nCOMMENT ON COLUMN \"public\".\"table_inventory\".\"capacity\" IS 'Number of seats at the table';\n\n\n\nCOMMENT ON COLUMN \"public\".\"table_inventory\".\"min_party_size\" IS 'Minimum party size for this table (e.g., 2-top only for parties of 2+)';\n\n\n\nCOMMENT ON COLUMN \"public\".\"table_inventory\".\"max_party_size\" IS 'Maximum party size for this table (optional, defaults to capacity)';\n\n\n\nCOMMENT ON COLUMN \"public\".\"table_inventory\".\"section\" IS 'Section name (e.g., \"Main Floor\", \"Patio\", \"Bar Area\", \"Private Room\")';\n\n\n\nCOMMENT ON COLUMN \"public\".\"table_inventory\".\"status\" IS 'Current status: available, reserved, occupied, out_of_service';\n\n\n\nCOMMENT ON COLUMN \"public\".\"table_inventory\".\"position\" IS 'Floor plan position as JSON: {x: number, y: number, rotation?: number} for drag-and-drop UI';\n\n\n\nCREATE TABLE IF NOT EXISTS \"public\".\"zones\" (\n    \"id\" \"uuid\" DEFAULT \"gen_random_uuid\"() NOT NULL,\n    \"restaurant_id\" \"uuid\" NOT NULL,\n    \"name\" \"text\" NOT NULL,\n    \"sort_order\" smallint DEFAULT 0 NOT NULL,\n    \"created_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    \"updated_at\" timestamp with time zone DEFAULT \"now\"() NOT NULL,\n    CONSTRAINT \"zones_name_not_blank\" CHECK ((\"char_length\"(TRIM(BOTH FROM \"name\")) > 0))\n);\n\n\nALTER TABLE \"public\".\"zones\" OWNER TO \"postgres\";\n\n\nALTER TABLE ONLY \"public\".\"_migrations\" ALTER COLUMN \"id\" SET DEFAULT \"nextval\"('\"public\".\"_migrations_id_seq\"'::\"regclass\");\n\n\n\nALTER TABLE ONLY \"public\".\"booking_state_history\" ALTER COLUMN \"id\" SET DEFAULT \"nextval\"('\"public\".\"booking_state_history_id_seq\"'::\"regclass\");\n\n\n\nALTER TABLE ONLY \"public\".\"_migrations\"\n    ADD CONSTRAINT \"_migrations_name_key\" UNIQUE (\"name\");\n\n\n\nALTER TABLE ONLY \"public\".\"_migrations\"\n    ADD CONSTRAINT \"_migrations_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"allocations\"\n    ADD CONSTRAINT \"allocations_booking_resource_key\" UNIQUE (\"booking_id\", \"resource_type\", \"resource_id\");\n\n\n\nALTER TABLE ONLY \"public\".\"allocations\"\n    ADD CONSTRAINT \"allocations_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"allocations\"\n    ADD CONSTRAINT \"allocations_resource_window_excl\" EXCLUDE USING \"gist\" (\"resource_type\" WITH =, \"resource_id\" WITH =, \"window\" WITH &&) DEFERRABLE INITIALLY DEFERRED;\n\n\n\nALTER TABLE ONLY \"public\".\"allowed_capacities\"\n    ADD CONSTRAINT \"allowed_capacities_pkey\" PRIMARY KEY (\"restaurant_id\", \"capacity\");\n\n\n\nALTER TABLE ONLY \"public\".\"analytics_events\"\n    ADD CONSTRAINT \"analytics_events_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"audit_logs\"\n    ADD CONSTRAINT \"audit_logs_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"booking_slots\"\n    ADD CONSTRAINT \"booking_slots_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"booking_slots\"\n    ADD CONSTRAINT \"booking_slots_restaurant_slot_key\" UNIQUE (\"restaurant_id\", \"slot_date\", \"slot_time\");\n\n\n\nALTER TABLE ONLY \"public\".\"booking_state_history\"\n    ADD CONSTRAINT \"booking_state_history_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"booking_table_assignments\"\n    ADD CONSTRAINT \"booking_table_assignments_booking_table_key\" UNIQUE (\"booking_id\", \"table_id\");\n\n\n\nALTER TABLE ONLY \"public\".\"booking_table_assignments\"\n    ADD CONSTRAINT \"booking_table_assignments_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"booking_versions\"\n    ADD CONSTRAINT \"booking_versions_pkey\" PRIMARY KEY (\"version_id\");\n\n\n\nALTER TABLE ONLY \"public\".\"bookings\"\n    ADD CONSTRAINT \"bookings_confirmation_token_unique\" UNIQUE (\"confirmation_token\");\n\n\n\nALTER TABLE \"public\".\"bookings\"\n    ADD CONSTRAINT \"bookings_lifecycle_timestamp_consistency\" CHECK ((((\"status\" = ANY (ARRAY['pending'::\"public\".\"booking_status\", 'pending_allocation'::\"public\".\"booking_status\", 'confirmed'::\"public\".\"booking_status\"])) AND (\"checked_in_at\" IS NULL) AND (\"checked_out_at\" IS NULL)) OR ((\"status\" = 'checked_in'::\"public\".\"booking_status\") AND (\"checked_in_at\" IS NOT NULL) AND (\"checked_out_at\" IS NULL)) OR ((\"status\" = 'completed'::\"public\".\"booking_status\") AND (\"checked_in_at\" IS NOT NULL) AND (\"checked_out_at\" IS NOT NULL) AND (\"checked_out_at\" >= \"checked_in_at\")) OR (\"status\" = 'cancelled'::\"public\".\"booking_status\") OR ((\"status\" = 'no_show'::\"public\".\"booking_status\") AND (\"checked_in_at\" IS NULL) AND (\"checked_out_at\" IS NULL)))) NOT VALID;\n\n\n\nCOMMENT ON CONSTRAINT \"bookings_lifecycle_timestamp_consistency\" ON \"public\".\"bookings\" IS 'Ensures booking lifecycle timestamps align with the status (checked-in bookings must have check-in timestamps, completed bookings need both timestamps, etc).';\n\n\n\nALTER TABLE ONLY \"public\".\"bookings\"\n    ADD CONSTRAINT \"bookings_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"bookings\"\n    ADD CONSTRAINT \"bookings_reference_key\" UNIQUE (\"reference\");\n\n\n\nALTER TABLE ONLY \"public\".\"capacity_metrics_hourly\"\n    ADD CONSTRAINT \"capacity_metrics_hourly_pkey\" PRIMARY KEY (\"restaurant_id\", \"window_start\");\n\n\n\nALTER TABLE ONLY \"public\".\"customer_profiles\"\n    ADD CONSTRAINT \"customer_profiles_pkey\" PRIMARY KEY (\"customer_id\");\n\n\n\nALTER TABLE ONLY \"public\".\"customers\"\n    ADD CONSTRAINT \"customers_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"customers\"\n    ADD CONSTRAINT \"customers_restaurant_email_phone_key\" UNIQUE (\"restaurant_id\", \"email_normalized\", \"phone_normalized\");\n\n\n\nALTER TABLE ONLY \"public\".\"customers\"\n    ADD CONSTRAINT \"customers_restaurant_id_email_normalized_key\" UNIQUE (\"restaurant_id\", \"email_normalized\");\n\n\n\nALTER TABLE ONLY \"public\".\"customers\"\n    ADD CONSTRAINT \"customers_restaurant_id_phone_normalized_key\" UNIQUE (\"restaurant_id\", \"phone_normalized\");\n\n\n\nALTER TABLE ONLY \"public\".\"loyalty_point_events\"\n    ADD CONSTRAINT \"loyalty_point_events_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"loyalty_points\"\n    ADD CONSTRAINT \"loyalty_points_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"loyalty_points\"\n    ADD CONSTRAINT \"loyalty_points_restaurant_id_customer_id_key\" UNIQUE (\"restaurant_id\", \"customer_id\");\n\n\n\nALTER TABLE ONLY \"public\".\"loyalty_programs\"\n    ADD CONSTRAINT \"loyalty_programs_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"loyalty_programs\"\n    ADD CONSTRAINT \"loyalty_programs_restaurant_id_key\" UNIQUE (\"restaurant_id\");\n\n\n\nALTER TABLE ONLY \"public\".\"merge_group_members\"\n    ADD CONSTRAINT \"merge_group_members_pkey\" PRIMARY KEY (\"merge_group_id\", \"table_id\");\n\n\n\nALTER TABLE ONLY \"public\".\"merge_groups\"\n    ADD CONSTRAINT \"merge_groups_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"merge_rules\"\n    ADD CONSTRAINT \"merge_rules_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"profile_update_requests\"\n    ADD CONSTRAINT \"profile_update_requests_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"profiles\"\n    ADD CONSTRAINT \"profiles_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"restaurant_capacity_rules\"\n    ADD CONSTRAINT \"restaurant_capacity_rules_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"restaurant_invites\"\n    ADD CONSTRAINT \"restaurant_invites_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"restaurant_memberships\"\n    ADD CONSTRAINT \"restaurant_memberships_pkey\" PRIMARY KEY (\"user_id\", \"restaurant_id\");\n\n\n\nALTER TABLE ONLY \"public\".\"restaurant_operating_hours\"\n    ADD CONSTRAINT \"restaurant_operating_hours_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"restaurant_service_periods\"\n    ADD CONSTRAINT \"restaurant_service_periods_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"restaurants\"\n    ADD CONSTRAINT \"restaurants_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"restaurants\"\n    ADD CONSTRAINT \"restaurants_slug_key\" UNIQUE (\"slug\");\n\n\n\nALTER TABLE ONLY \"public\".\"service_policy\"\n    ADD CONSTRAINT \"service_policy_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"stripe_events\"\n    ADD CONSTRAINT \"stripe_events_event_id_key\" UNIQUE (\"event_id\");\n\n\n\nALTER TABLE ONLY \"public\".\"stripe_events\"\n    ADD CONSTRAINT \"stripe_events_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"table_adjacencies\"\n    ADD CONSTRAINT \"table_adjacencies_pkey\" PRIMARY KEY (\"table_a\", \"table_b\");\n\n\n\nALTER TABLE ONLY \"public\".\"table_inventory\"\n    ADD CONSTRAINT \"table_inventory_pkey\" PRIMARY KEY (\"id\");\n\n\n\nALTER TABLE ONLY \"public\".\"table_inventory\"\n    ADD CONSTRAINT \"table_inventory_restaurant_id_table_number_key\" UNIQUE (\"restaurant_id\", \"table_number\");\n\n\n\nALTER TABLE ONLY \"public\".\"zones\"\n    ADD CONSTRAINT \"zones_pkey\" PRIMARY KEY (\"id\");\n\n\n\nCREATE INDEX \"allocations_resource_window_idx\" ON \"public\".\"allocations\" USING \"gist\" (\"resource_type\", \"resource_id\", \"window\");\n\n\n\nCREATE INDEX \"allowed_capacities_restaurant_idx\" ON \"public\".\"allowed_capacities\" USING \"btree\" (\"restaurant_id\", \"capacity\");\n\n\n\nCREATE UNIQUE INDEX \"booking_table_assignments_booking_id_idempotency_key_key\" ON \"public\".\"booking_table_assignments\" USING \"btree\" (\"booking_id\", \"idempotency_key\") WHERE (\"idempotency_key\" IS NOT NULL);\n\n\n\nCREATE INDEX \"bookings_restaurant_date_status_idx\" ON \"public\".\"bookings\" USING \"btree\" (\"restaurant_id\", \"booking_date\", \"status\");\n\n\n\nCREATE INDEX \"idx_analytics_events_booking_id\" ON \"public\".\"analytics_events\" USING \"btree\" (\"booking_id\");\n\n\n\nCREATE INDEX \"idx_analytics_events_customer_id\" ON \"public\".\"analytics_events\" USING \"btree\" (\"customer_id\") WHERE (\"customer_id\" IS NOT NULL);\n\n\n\nCREATE INDEX \"idx_analytics_events_event_type\" ON \"public\".\"analytics_events\" USING \"btree\" (\"event_type\");\n\n\n\nCREATE INDEX \"idx_analytics_events_occurred_at\" ON \"public\".\"analytics_events\" USING \"btree\" (\"occurred_at\" DESC);\n\n\n\nCREATE INDEX \"idx_analytics_events_restaurant_id\" ON \"public\".\"analytics_events\" USING \"btree\" (\"restaurant_id\");\n\n\n\nCREATE INDEX \"idx_analytics_events_restaurant_occurred\" ON \"public\".\"analytics_events\" USING \"btree\" (\"restaurant_id\", \"occurred_at\" DESC);\n\n\n\nCREATE INDEX \"idx_audit_logs_action\" ON \"public\".\"audit_logs\" USING \"btree\" (\"action\");\n\n\n\nCREATE INDEX \"idx_audit_logs_created_at\" ON \"public\".\"audit_logs\" USING \"btree\" (\"created_at\" DESC);\n\n\n\nCREATE INDEX \"idx_audit_logs_entity_id\" ON \"public\".\"audit_logs\" USING \"btree\" (\"entity\", \"entity_id\");\n\n\n\nCREATE INDEX \"idx_booking_slots_date_range\" ON \"public\".\"booking_slots\" USING \"btree\" (\"restaurant_id\", \"slot_date\");\n\n\n\nCOMMENT ON INDEX \"public\".\"idx_booking_slots_date_range\" IS 'Fast queries for all slots on a given date';\n\n\n\nCREATE INDEX \"idx_booking_slots_lookup\" ON \"public\".\"booking_slots\" USING \"btree\" (\"restaurant_id\", \"slot_date\", \"slot_time\");\n\n\n\nCOMMENT ON INDEX \"public\".\"idx_booking_slots_lookup\" IS 'Fast lookup for specific slot (primary use case)';\n\n\n\nCREATE INDEX \"idx_booking_slots_service_period\" ON \"public\".\"booking_slots\" USING \"btree\" (\"service_period_id\", \"slot_date\");\n\n\n\nCOMMENT ON INDEX \"public\".\"idx_booking_slots_service_period\" IS 'Fast queries by service period (e.g., all lunch slots)';\n\n\n\nCREATE INDEX \"idx_booking_state_history_booking\" ON \"public\".\"booking_state_history\" USING \"btree\" (\"booking_id\", \"changed_at\" DESC);\n\n\n\nCOMMENT ON INDEX \"public\".\"idx_booking_state_history_booking\" IS 'Lookup transitions for a booking ordered by recency.';\n\n\n\nCREATE INDEX \"idx_booking_state_history_changed_at\" ON \"public\".\"booking_state_history\" USING \"btree\" (\"changed_at\");\n\n\n\nCOMMENT ON INDEX \"public\".\"idx_booking_state_history_changed_at\" IS 'Support chronological reporting of booking transitions.';\n\n\n\nCREATE INDEX \"idx_booking_table_assignments_booking\" ON \"public\".\"booking_table_assignments\" USING \"btree\" (\"booking_id\");\n\n\n\nCOMMENT ON INDEX \"public\".\"idx_booking_table_assignments_booking\" IS 'Fast lookup of tables assigned to a booking';\n\n\n\nCREATE INDEX \"idx_booking_table_assignments_slot\" ON \"public\".\"booking_table_assignments\" USING \"btree\" (\"slot_id\");\n\n\n\nCOMMENT ON INDEX \"public\".\"idx_booking_table_assignments_slot\" IS 'Fast lookup of assignments per slot';\n\n\n\nCREATE INDEX \"idx_booking_table_assignments_table\" ON \"public\".\"booking_table_assignments\" USING \"btree\" (\"table_id\", \"assigned_at\");\n\n\n\nCOMMENT ON INDEX \"public\".\"idx_booking_table_assignments_table\" IS 'Fast lookup of bookings using a table (for reservation timeline)';\n\n\n\nCREATE INDEX \"idx_booking_versions_booking_id\" ON \"public\".\"booking_versions\" USING \"btree\" (\"booking_id\");\n\n\n\nCREATE INDEX \"idx_booking_versions_changed_at\" ON \"public\".\"booking_versions\" USING \"btree\" (\"changed_at\" DESC);\n\n\n\nCREATE INDEX \"idx_booking_versions_restaurant_id\" ON \"public\".\"booking_versions\" USING \"btree\" (\"restaurant_id\");\n\n\n\nCREATE INDEX \"idx_bookings_auth_user\" ON \"public\".\"bookings\" USING \"btree\" (\"auth_user_id\") WHERE (\"auth_user_id\" IS NOT NULL);\n\n\n\nCREATE INDEX \"idx_bookings_client_request_id\" ON \"public\".\"bookings\" USING \"btree\" (\"client_request_id\");\n\n\n\nCREATE INDEX \"idx_bookings_confirmation_token\" ON \"public\".\"bookings\" USING \"btree\" (\"confirmation_token\") WHERE (\"confirmation_token\" IS NOT NULL);\n\n\n\nCREATE INDEX \"idx_bookings_created\" ON \"public\".\"bookings\" USING \"btree\" (\"restaurant_id\", \"created_at\" DESC);\n\n\n\nCREATE INDEX \"idx_bookings_customer\" ON \"public\".\"bookings\" USING \"btree\" (\"customer_id\");\n\n\n\nCREATE INDEX \"idx_bookings_date\" ON \"public\".\"bookings\" USING \"btree\" (\"restaurant_id\", \"booking_date\");\n\n\n\nCREATE INDEX \"idx_bookings_datetime\" ON \"public\".\"bookings\" USING \"btree\" (\"restaurant_id\", \"start_at\", \"end_at\");\n\n\n\nCREATE INDEX \"idx_bookings_idempotency_key\" ON \"public\".\"bookings\" USING \"btree\" (\"idempotency_key\") WHERE (\"idempotency_key\" IS NOT NULL);\n\n\n\nCREATE INDEX \"idx_bookings_pending_ref\" ON \"public\".\"bookings\" USING \"btree\" (\"pending_ref\") WHERE (\"pending_ref\" IS NOT NULL);\n\n\n\nCREATE INDEX \"idx_bookings_reference\" ON \"public\".\"bookings\" USING \"btree\" (\"reference\");\n\n\n\nCREATE INDEX \"idx_bookings_restaurant\" ON \"public\".\"bookings\" USING \"btree\" (\"restaurant_id\");\n\n\n\nCREATE INDEX \"idx_bookings_status\" ON \"public\".\"bookings\" USING \"btree\" (\"restaurant_id\", \"status\");\n\n\n\nCREATE INDEX \"idx_capacity_metrics_hourly_window\" ON \"public\".\"capacity_metrics_hourly\" USING \"btree\" (\"window_start\" DESC);\n\n\n\nCREATE INDEX \"idx_customer_profiles_updated_at\" ON \"public\".\"customer_profiles\" USING \"btree\" (\"updated_at\" DESC);\n\n\n\nCREATE INDEX \"idx_customers_auth_user\" ON \"public\".\"customers\" USING \"btree\" (\"auth_user_id\") WHERE (\"auth_user_id\" IS NOT NULL);\n\n\n\nCREATE INDEX \"idx_customers_email_normalized\" ON \"public\".\"customers\" USING \"btree\" (\"restaurant_id\", \"email_normalized\");\n\n\n\nCREATE INDEX \"idx_customers_phone_normalized\" ON \"public\".\"customers\" USING \"btree\" (\"restaurant_id\", \"phone_normalized\");\n\n\n\nCREATE INDEX \"idx_customers_restaurant\" ON \"public\".\"customers\" USING \"btree\" (\"restaurant_id\");\n\n\n\nCREATE INDEX \"idx_loyalty_point_events_booking\" ON \"public\".\"loyalty_point_events\" USING \"btree\" (\"booking_id\") WHERE (\"booking_id\" IS NOT NULL);\n\n\n\nCREATE INDEX \"idx_loyalty_point_events_customer\" ON \"public\".\"loyalty_point_events\" USING \"btree\" (\"customer_id\");\n\n\n\nCREATE INDEX \"idx_loyalty_points_restaurant_customer\" ON \"public\".\"loyalty_points\" USING \"btree\" (\"restaurant_id\", \"customer_id\");\n\n\n\nCREATE INDEX \"idx_loyalty_programs_restaurant\" ON \"public\".\"loyalty_programs\" USING \"btree\" (\"restaurant_id\");\n\n\n\nCREATE INDEX \"idx_memberships_restaurant\" ON \"public\".\"restaurant_memberships\" USING \"btree\" (\"restaurant_id\");\n\n\n\nCREATE INDEX \"idx_memberships_user\" ON \"public\".\"restaurant_memberships\" USING \"btree\" (\"user_id\");\n\n\n\nCREATE INDEX \"idx_profiles_email\" ON \"public\".\"profiles\" USING \"btree\" (\"email\") WHERE (\"email\" IS NOT NULL);\n\n\n\nCREATE INDEX \"idx_profiles_has_access\" ON \"public\".\"profiles\" USING \"btree\" (\"has_access\");\n\n\n\nCREATE INDEX \"idx_restaurant_capacity_rules_scope\" ON \"public\".\"restaurant_capacity_rules\" USING \"btree\" (\"restaurant_id\", COALESCE((\"day_of_week\")::integer, '-1'::integer), \"effective_date\");\n\n\n\nCREATE INDEX \"idx_restaurant_operating_hours_scope\" ON \"public\".\"restaurant_operating_hours\" USING \"btree\" (\"restaurant_id\", COALESCE((\"day_of_week\")::integer, '-1'::integer), \"effective_date\");\n\n\n\nCREATE INDEX \"idx_restaurant_service_periods_scope\" ON \"public\".\"restaurant_service_periods\" USING \"btree\" (\"restaurant_id\", COALESCE((\"day_of_week\")::integer, '-1'::integer));\n\n\n\nCREATE INDEX \"idx_restaurants_active\" ON \"public\".\"restaurants\" USING \"btree\" (\"is_active\");\n\n\n\nCREATE INDEX \"idx_restaurants_slug\" ON \"public\".\"restaurants\" USING \"btree\" (\"slug\");\n\n\n\nCREATE INDEX \"idx_stripe_events_created_at\" ON \"public\".\"stripe_events\" USING \"btree\" (\"created_at\" DESC);\n\n\n\nCREATE INDEX \"idx_stripe_events_event_id\" ON \"public\".\"stripe_events\" USING \"btree\" (\"event_id\");\n\n\n\nCREATE INDEX \"idx_stripe_events_event_type\" ON \"public\".\"stripe_events\" USING \"btree\" (\"event_type\");\n\n\n\nCREATE INDEX \"idx_stripe_events_processed\" ON \"public\".\"stripe_events\" USING \"btree\" (\"processed\") WHERE (\"processed\" = false);\n\n\n\nCREATE INDEX \"idx_table_inventory_lookup\" ON \"public\".\"table_inventory\" USING \"btree\" (\"restaurant_id\", \"status\", \"capacity\");\n\n\n\nCOMMENT ON INDEX \"public\".\"idx_table_inventory_lookup\" IS 'Fast lookup for available tables by restaurant and capacity';\n\n\n\nCREATE INDEX \"idx_table_inventory_section\" ON \"public\".\"table_inventory\" USING \"btree\" (\"restaurant_id\", \"section\");\n\n\n\nCOMMENT ON INDEX \"public\".\"idx_table_inventory_section\" IS 'Fast filtering by section for floor plan views';\n\n\n\nCREATE UNIQUE INDEX \"merge_rules_from_to_idx\" ON \"public\".\"merge_rules\" USING \"btree\" (\"from_a\", \"from_b\", \"to_capacity\");\n\n\n\nCREATE UNIQUE INDEX \"profile_update_requests_profile_key_idx\" ON \"public\".\"profile_update_requests\" USING \"btree\" (\"profile_id\", \"idempotency_key\");\n\n\n\nCREATE UNIQUE INDEX \"restaurant_invites_pending_unique_email\" ON \"public\".\"restaurant_invites\" USING \"btree\" (\"restaurant_id\", \"email_normalized\") WHERE (\"status\" = 'pending'::\"text\");\n\n\n\nCREATE INDEX \"restaurant_invites_restaurant_status_idx\" ON \"public\".\"restaurant_invites\" USING \"btree\" (\"restaurant_id\", \"status\", \"expires_at\" DESC);\n\n\n\nCREATE UNIQUE INDEX \"restaurant_invites_token_hash_key\" ON \"public\".\"restaurant_invites\" USING \"btree\" (\"token_hash\");\n\n\n\nCREATE INDEX \"table_adjacencies_table_b_idx\" ON \"public\".\"table_adjacencies\" USING \"btree\" (\"table_b\");\n\n\n\nCREATE INDEX \"table_inventory_zone_idx\" ON \"public\".\"table_inventory\" USING \"btree\" (\"zone_id\");\n\n\n\nCREATE UNIQUE INDEX \"zones_restaurant_name_idx\" ON \"public\".\"zones\" USING \"btree\" (\"restaurant_id\", \"lower\"(\"name\"));\n\n\n\nCREATE OR REPLACE TRIGGER \"allocations_updated_at\" BEFORE UPDATE ON \"public\".\"allocations\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"update_updated_at\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"allowed_capacities_touch_updated_at\" BEFORE UPDATE ON \"public\".\"allowed_capacities\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"allowed_capacities_set_updated_at\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"booking_slots_increment_version\" BEFORE UPDATE ON \"public\".\"booking_slots\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"increment_booking_slot_version\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"booking_slots_updated_at\" BEFORE UPDATE ON \"public\".\"booking_slots\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"update_updated_at\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"booking_table_assignments_audit\" AFTER INSERT OR DELETE ON \"public\".\"booking_table_assignments\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"log_table_assignment_change\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"booking_table_assignments_updated_at\" BEFORE UPDATE ON \"public\".\"booking_table_assignments\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"update_updated_at\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"bookings_set_instants\" BEFORE INSERT OR UPDATE OF \"booking_date\", \"start_time\", \"end_time\", \"restaurant_id\" ON \"public\".\"bookings\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"set_booking_instants\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"bookings_set_reference\" BEFORE INSERT ON \"public\".\"bookings\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"set_booking_reference\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"bookings_updated_at\" BEFORE UPDATE ON \"public\".\"bookings\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"update_updated_at\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"capacity_metrics_hourly_set_updated_at\" BEFORE UPDATE ON \"public\".\"capacity_metrics_hourly\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"capacity_metrics_hourly_updated_at\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"customers_updated_at\" BEFORE UPDATE ON \"public\".\"customers\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"update_updated_at\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"merge_group_members_validate_connectivity\" BEFORE INSERT ON \"public\".\"merge_group_members\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"validate_merge_group_members\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"merge_rules_updated_at\" BEFORE UPDATE ON \"public\".\"merge_rules\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"update_updated_at\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"restaurant_capacity_rules_updated_at\" BEFORE UPDATE ON \"public\".\"restaurant_capacity_rules\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"update_updated_at\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"restaurant_operating_hours_updated_at\" BEFORE UPDATE ON \"public\".\"restaurant_operating_hours\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"update_updated_at\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"restaurant_service_periods_updated_at\" BEFORE UPDATE ON \"public\".\"restaurant_service_periods\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"update_updated_at\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"restaurants_updated_at\" BEFORE UPDATE ON \"public\".\"restaurants\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"update_updated_at\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"service_policy_updated_at\" BEFORE UPDATE ON \"public\".\"service_policy\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"update_updated_at\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"set_restaurant_invites_updated_at\" BEFORE UPDATE ON \"public\".\"restaurant_invites\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"update_updated_at\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"table_adjacencies_sync\" AFTER INSERT OR DELETE ON \"public\".\"table_adjacencies\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"sync_table_adjacency_symmetry\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"table_adjacencies_validate\" BEFORE INSERT ON \"public\".\"table_adjacencies\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"validate_table_adjacency\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"table_inventory_updated_at\" BEFORE UPDATE ON \"public\".\"table_inventory\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"update_updated_at\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"trg_allocations_refresh\" AFTER INSERT OR DELETE OR UPDATE ON \"public\".\"allocations\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"on_allocations_refresh\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"trg_booking_status_refresh\" AFTER UPDATE OF \"status\" ON \"public\".\"bookings\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"on_booking_status_refresh\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"update_loyalty_points_updated_at\" BEFORE UPDATE ON \"public\".\"loyalty_points\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"update_updated_at\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"update_loyalty_programs_updated_at\" BEFORE UPDATE ON \"public\".\"loyalty_programs\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"update_updated_at\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"update_profiles_updated_at\" BEFORE UPDATE ON \"public\".\"profiles\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"update_updated_at\"();\n\n\n\nCREATE OR REPLACE TRIGGER \"zones_updated_at\" BEFORE UPDATE ON \"public\".\"zones\" FOR EACH ROW EXECUTE FUNCTION \"public\".\"update_updated_at\"();\n\n\n\nALTER TABLE ONLY \"public\".\"allocations\"\n    ADD CONSTRAINT \"allocations_booking_id_fkey\" FOREIGN KEY (\"booking_id\") REFERENCES \"public\".\"bookings\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"allocations\"\n    ADD CONSTRAINT \"allocations_created_by_fkey\" FOREIGN KEY (\"created_by\") REFERENCES \"auth\".\"users\"(\"id\") ON DELETE SET NULL;\n\n\n\nALTER TABLE ONLY \"public\".\"allocations\"\n    ADD CONSTRAINT \"allocations_restaurant_id_fkey\" FOREIGN KEY (\"restaurant_id\") REFERENCES \"public\".\"restaurants\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"allowed_capacities\"\n    ADD CONSTRAINT \"allowed_capacities_restaurant_id_fkey\" FOREIGN KEY (\"restaurant_id\") REFERENCES \"public\".\"restaurants\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"analytics_events\"\n    ADD CONSTRAINT \"analytics_events_booking_id_fkey\" FOREIGN KEY (\"booking_id\") REFERENCES \"public\".\"bookings\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"analytics_events\"\n    ADD CONSTRAINT \"analytics_events_customer_id_fkey\" FOREIGN KEY (\"customer_id\") REFERENCES \"public\".\"customers\"(\"id\") ON DELETE SET NULL;\n\n\n\nALTER TABLE ONLY \"public\".\"analytics_events\"\n    ADD CONSTRAINT \"analytics_events_restaurant_id_fkey\" FOREIGN KEY (\"restaurant_id\") REFERENCES \"public\".\"restaurants\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"booking_slots\"\n    ADD CONSTRAINT \"booking_slots_restaurant_id_fkey\" FOREIGN KEY (\"restaurant_id\") REFERENCES \"public\".\"restaurants\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"booking_slots\"\n    ADD CONSTRAINT \"booking_slots_service_period_id_fkey\" FOREIGN KEY (\"service_period_id\") REFERENCES \"public\".\"restaurant_service_periods\"(\"id\") ON DELETE SET NULL;\n\n\n\nALTER TABLE ONLY \"public\".\"booking_state_history\"\n    ADD CONSTRAINT \"booking_state_history_booking_id_fkey\" FOREIGN KEY (\"booking_id\") REFERENCES \"public\".\"bookings\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"booking_state_history\"\n    ADD CONSTRAINT \"booking_state_history_changed_by_fkey\" FOREIGN KEY (\"changed_by\") REFERENCES \"auth\".\"users\"(\"id\") ON DELETE SET NULL;\n\n\n\nALTER TABLE ONLY \"public\".\"booking_table_assignments\"\n    ADD CONSTRAINT \"booking_table_assignments_assigned_by_fkey\" FOREIGN KEY (\"assigned_by\") REFERENCES \"auth\".\"users\"(\"id\") ON DELETE SET NULL;\n\n\n\nALTER TABLE ONLY \"public\".\"booking_table_assignments\"\n    ADD CONSTRAINT \"booking_table_assignments_booking_id_fkey\" FOREIGN KEY (\"booking_id\") REFERENCES \"public\".\"bookings\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"booking_table_assignments\"\n    ADD CONSTRAINT \"booking_table_assignments_merge_group_id_fkey\" FOREIGN KEY (\"merge_group_id\") REFERENCES \"public\".\"merge_groups\"(\"id\") ON DELETE SET NULL;\n\n\n\nALTER TABLE ONLY \"public\".\"booking_table_assignments\"\n    ADD CONSTRAINT \"booking_table_assignments_slot_id_fkey\" FOREIGN KEY (\"slot_id\") REFERENCES \"public\".\"booking_slots\"(\"id\") ON DELETE SET NULL;\n\n\n\nALTER TABLE ONLY \"public\".\"booking_table_assignments\"\n    ADD CONSTRAINT \"booking_table_assignments_table_id_fkey\" FOREIGN KEY (\"table_id\") REFERENCES \"public\".\"table_inventory\"(\"id\") ON DELETE RESTRICT;\n\n\n\nALTER TABLE ONLY \"public\".\"booking_versions\"\n    ADD CONSTRAINT \"booking_versions_booking_id_fkey\" FOREIGN KEY (\"booking_id\") REFERENCES \"public\".\"bookings\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"booking_versions\"\n    ADD CONSTRAINT \"booking_versions_restaurant_id_fkey\" FOREIGN KEY (\"restaurant_id\") REFERENCES \"public\".\"restaurants\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"bookings\"\n    ADD CONSTRAINT \"bookings_customer_id_fkey\" FOREIGN KEY (\"customer_id\") REFERENCES \"public\".\"customers\"(\"id\") ON DELETE RESTRICT;\n\n\n\nALTER TABLE ONLY \"public\".\"bookings\"\n    ADD CONSTRAINT \"bookings_restaurant_id_fkey\" FOREIGN KEY (\"restaurant_id\") REFERENCES \"public\".\"restaurants\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"capacity_metrics_hourly\"\n    ADD CONSTRAINT \"capacity_metrics_hourly_restaurant_id_fkey\" FOREIGN KEY (\"restaurant_id\") REFERENCES \"public\".\"restaurants\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"customer_profiles\"\n    ADD CONSTRAINT \"customer_profiles_customer_id_fkey\" FOREIGN KEY (\"customer_id\") REFERENCES \"public\".\"customers\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"customers\"\n    ADD CONSTRAINT \"customers_restaurant_id_fkey\" FOREIGN KEY (\"restaurant_id\") REFERENCES \"public\".\"restaurants\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"loyalty_point_events\"\n    ADD CONSTRAINT \"loyalty_point_events_booking_id_fkey\" FOREIGN KEY (\"booking_id\") REFERENCES \"public\".\"bookings\"(\"id\") ON DELETE SET NULL;\n\n\n\nALTER TABLE ONLY \"public\".\"loyalty_point_events\"\n    ADD CONSTRAINT \"loyalty_point_events_customer_id_fkey\" FOREIGN KEY (\"customer_id\") REFERENCES \"public\".\"customers\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"loyalty_point_events\"\n    ADD CONSTRAINT \"loyalty_point_events_restaurant_id_fkey\" FOREIGN KEY (\"restaurant_id\") REFERENCES \"public\".\"restaurants\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"loyalty_points\"\n    ADD CONSTRAINT \"loyalty_points_customer_id_fkey\" FOREIGN KEY (\"customer_id\") REFERENCES \"public\".\"customers\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"loyalty_points\"\n    ADD CONSTRAINT \"loyalty_points_restaurant_id_fkey\" FOREIGN KEY (\"restaurant_id\") REFERENCES \"public\".\"restaurants\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"loyalty_programs\"\n    ADD CONSTRAINT \"loyalty_programs_restaurant_id_fkey\" FOREIGN KEY (\"restaurant_id\") REFERENCES \"public\".\"restaurants\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"merge_group_members\"\n    ADD CONSTRAINT \"merge_group_members_merge_group_id_fkey\" FOREIGN KEY (\"merge_group_id\") REFERENCES \"public\".\"merge_groups\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"merge_group_members\"\n    ADD CONSTRAINT \"merge_group_members_table_id_fkey\" FOREIGN KEY (\"table_id\") REFERENCES \"public\".\"table_inventory\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"profile_update_requests\"\n    ADD CONSTRAINT \"profile_update_requests_profile_id_fkey\" FOREIGN KEY (\"profile_id\") REFERENCES \"public\".\"profiles\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"profiles\"\n    ADD CONSTRAINT \"profiles_id_fkey\" FOREIGN KEY (\"id\") REFERENCES \"auth\".\"users\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"restaurant_capacity_rules\"\n    ADD CONSTRAINT \"restaurant_capacity_rules_restaurant_id_fkey\" FOREIGN KEY (\"restaurant_id\") REFERENCES \"public\".\"restaurants\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"restaurant_capacity_rules\"\n    ADD CONSTRAINT \"restaurant_capacity_rules_service_period_id_fkey\" FOREIGN KEY (\"service_period_id\") REFERENCES \"public\".\"restaurant_service_periods\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"restaurant_invites\"\n    ADD CONSTRAINT \"restaurant_invites_invited_by_fkey\" FOREIGN KEY (\"invited_by\") REFERENCES \"public\".\"profiles\"(\"id\") ON DELETE SET NULL;\n\n\n\nALTER TABLE ONLY \"public\".\"restaurant_invites\"\n    ADD CONSTRAINT \"restaurant_invites_restaurant_id_fkey\" FOREIGN KEY (\"restaurant_id\") REFERENCES \"public\".\"restaurants\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"restaurant_memberships\"\n    ADD CONSTRAINT \"restaurant_memberships_restaurant_id_fkey\" FOREIGN KEY (\"restaurant_id\") REFERENCES \"public\".\"restaurants\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"restaurant_operating_hours\"\n    ADD CONSTRAINT \"restaurant_operating_hours_restaurant_id_fkey\" FOREIGN KEY (\"restaurant_id\") REFERENCES \"public\".\"restaurants\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"restaurant_service_periods\"\n    ADD CONSTRAINT \"restaurant_service_periods_restaurant_id_fkey\" FOREIGN KEY (\"restaurant_id\") REFERENCES \"public\".\"restaurants\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"table_adjacencies\"\n    ADD CONSTRAINT \"table_adjacencies_table_a_fkey\" FOREIGN KEY (\"table_a\") REFERENCES \"public\".\"table_inventory\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"table_adjacencies\"\n    ADD CONSTRAINT \"table_adjacencies_table_b_fkey\" FOREIGN KEY (\"table_b\") REFERENCES \"public\".\"table_inventory\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"table_inventory\"\n    ADD CONSTRAINT \"table_inventory_allowed_capacity_fkey\" FOREIGN KEY (\"restaurant_id\", \"capacity\") REFERENCES \"public\".\"allowed_capacities\"(\"restaurant_id\", \"capacity\") ON UPDATE CASCADE ON DELETE RESTRICT;\n\n\n\nALTER TABLE ONLY \"public\".\"table_inventory\"\n    ADD CONSTRAINT \"table_inventory_restaurant_id_fkey\" FOREIGN KEY (\"restaurant_id\") REFERENCES \"public\".\"restaurants\"(\"id\") ON DELETE CASCADE;\n\n\n\nALTER TABLE ONLY \"public\".\"table_inventory\"\n    ADD CONSTRAINT \"table_inventory_zone_id_fkey\" FOREIGN KEY (\"zone_id\") REFERENCES \"public\".\"zones\"(\"id\") ON DELETE RESTRICT;\n\n\n\nALTER TABLE ONLY \"public\".\"zones\"\n    ADD CONSTRAINT \"zones_restaurant_id_fkey\" FOREIGN KEY (\"restaurant_id\") REFERENCES \"public\".\"restaurants\"(\"id\") ON DELETE CASCADE;\n\n\n\nCREATE POLICY \"Admins and owners can delete bookings\" ON \"public\".\"bookings\" FOR DELETE USING ((\"restaurant_id\" IN ( SELECT \"rm\".\"restaurant_id\"\n   FROM \"public\".\"restaurant_memberships\" \"rm\"\n  WHERE ((\"rm\".\"user_id\" = \"auth\".\"uid\"()) AND (\"rm\".\"role\" = ANY (ARRAY['owner'::\"text\", 'manager'::\"text\"]))))));\n\n\n\nCREATE POLICY \"Admins and owners can delete customers\" ON \"public\".\"customers\" FOR DELETE USING ((\"restaurant_id\" IN ( SELECT \"rm\".\"restaurant_id\"\n   FROM \"public\".\"restaurant_memberships\" \"rm\"\n  WHERE ((\"rm\".\"user_id\" = \"auth\".\"uid\"()) AND (\"rm\".\"role\" = ANY (ARRAY['owner'::\"text\", 'manager'::\"text\"]))))));\n\n\n\nCREATE POLICY \"Customers can view their table assignments\" ON \"public\".\"booking_table_assignments\" FOR SELECT USING ((EXISTS ( SELECT 1\n   FROM \"public\".\"bookings\" \"b\"\n  WHERE ((\"b\".\"id\" = \"booking_table_assignments\".\"booking_id\") AND ((\"b\".\"auth_user_id\" = \"auth\".\"uid\"()) OR (\"b\".\"customer_id\" IN ( SELECT \"customers\".\"id\"\n           FROM \"public\".\"customers\"\n          WHERE (\"customers\".\"auth_user_id\" = \"auth\".\"uid\"()))))))));\n\n\n\nCREATE POLICY \"Owners and admins can manage memberships\" ON \"public\".\"restaurant_memberships\" USING ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants_admin\"() AS \"user_restaurants_admin\"))) WITH CHECK ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants_admin\"() AS \"user_restaurants_admin\")));\n\n\n\nCREATE POLICY \"Owners and managers manage invites\" ON \"public\".\"restaurant_invites\" USING ((\"restaurant_id\" IN ( SELECT \"rm\".\"restaurant_id\"\n   FROM \"public\".\"restaurant_memberships\" \"rm\"\n  WHERE ((\"rm\".\"user_id\" = \"auth\".\"uid\"()) AND (\"rm\".\"role\" = ANY (ARRAY['owner'::\"text\", 'manager'::\"text\"])))))) WITH CHECK ((\"restaurant_id\" IN ( SELECT \"rm\".\"restaurant_id\"\n   FROM \"public\".\"restaurant_memberships\" \"rm\"\n  WHERE ((\"rm\".\"user_id\" = \"auth\".\"uid\"()) AND (\"rm\".\"role\" = ANY (ARRAY['owner'::\"text\", 'manager'::\"text\"]))))));\n\n\n\nCREATE POLICY \"Public can view booking slots\" ON \"public\".\"booking_slots\" FOR SELECT USING ((EXISTS ( SELECT 1\n   FROM \"public\".\"restaurants\" \"r\"\n  WHERE ((\"r\".\"id\" = \"booking_slots\".\"restaurant_id\") AND (\"r\".\"is_active\" = true)))));\n\n\n\nCREATE POLICY \"Public can view table inventory\" ON \"public\".\"table_inventory\" FOR SELECT USING ((EXISTS ( SELECT 1\n   FROM \"public\".\"restaurants\" \"r\"\n  WHERE ((\"r\".\"id\" = \"table_inventory\".\"restaurant_id\") AND (\"r\".\"is_active\" = true)))));\n\n\n\nCREATE POLICY \"Restaurant staff can view analytics\" ON \"public\".\"analytics_events\" FOR SELECT USING ((EXISTS ( SELECT 1\n   FROM \"public\".\"restaurant_memberships\" \"rm\"\n  WHERE ((\"rm\".\"restaurant_id\" = \"analytics_events\".\"restaurant_id\") AND (\"rm\".\"user_id\" = \"auth\".\"uid\"())))));\n\n\n\nCREATE POLICY \"Restaurant staff can view booking versions\" ON \"public\".\"booking_versions\" FOR SELECT USING ((EXISTS ( SELECT 1\n   FROM \"public\".\"restaurant_memberships\" \"rm\"\n  WHERE ((\"rm\".\"restaurant_id\" = \"booking_versions\".\"restaurant_id\") AND (\"rm\".\"user_id\" = \"auth\".\"uid\"())))));\n\n\n\nCREATE POLICY \"Service role can manage adjacencies\" ON \"public\".\"table_adjacencies\" TO \"service_role\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Service role can manage allocations\" ON \"public\".\"allocations\" TO \"service_role\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Service role can manage allowed capacities\" ON \"public\".\"allowed_capacities\" TO \"service_role\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Service role can manage analytics events\" ON \"public\".\"analytics_events\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Service role can manage audit logs\" ON \"public\".\"audit_logs\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Service role can manage booking slots\" ON \"public\".\"booking_slots\" TO \"service_role\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Service role can manage booking versions\" ON \"public\".\"booking_versions\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Service role can manage capacity rules\" ON \"public\".\"restaurant_capacity_rules\" TO \"service_role\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Service role can manage customer profiles\" ON \"public\".\"customer_profiles\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Service role can manage loyalty events\" ON \"public\".\"loyalty_point_events\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Service role can manage loyalty points\" ON \"public\".\"loyalty_points\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Service role can manage loyalty programs\" ON \"public\".\"loyalty_programs\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Service role can manage merge group members\" ON \"public\".\"merge_group_members\" TO \"service_role\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Service role can manage merge groups\" ON \"public\".\"merge_groups\" TO \"service_role\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Service role can manage merge rules\" ON \"public\".\"merge_rules\" TO \"service_role\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Service role can manage operating hours\" ON \"public\".\"restaurant_operating_hours\" TO \"service_role\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Service role can manage profiles\" ON \"public\".\"profiles\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Service role can manage service periods\" ON \"public\".\"restaurant_service_periods\" TO \"service_role\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Service role can manage service policy\" ON \"public\".\"service_policy\" TO \"service_role\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Service role can manage stripe events\" ON \"public\".\"stripe_events\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Service role can manage table assignments\" ON \"public\".\"booking_table_assignments\" TO \"service_role\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Service role can manage table inventory\" ON \"public\".\"table_inventory\" TO \"service_role\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Service role can manage zones\" ON \"public\".\"zones\" TO \"service_role\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"Staff can create bookings\" ON \"public\".\"bookings\" FOR INSERT WITH CHECK ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\")));\n\n\n\nCREATE POLICY \"Staff can create customers\" ON \"public\".\"customers\" FOR INSERT WITH CHECK ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\")));\n\n\n\nCREATE POLICY \"Staff can manage adjacencies\" ON \"public\".\"table_adjacencies\" TO \"authenticated\" USING ((EXISTS ( SELECT 1\n   FROM \"public\".\"table_inventory\" \"ti\"\n  WHERE ((\"ti\".\"id\" = \"table_adjacencies\".\"table_a\") AND (\"ti\".\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\")))))) WITH CHECK ((EXISTS ( SELECT 1\n   FROM \"public\".\"table_inventory\" \"ti\"\n  WHERE ((\"ti\".\"id\" = \"table_adjacencies\".\"table_a\") AND (\"ti\".\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\"))))));\n\n\n\nCREATE POLICY \"Staff can manage allowed capacities\" ON \"public\".\"allowed_capacities\" TO \"authenticated\" USING ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\"))) WITH CHECK ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\")));\n\n\n\nCREATE POLICY \"Staff can manage booking slots\" ON \"public\".\"booking_slots\" USING ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\"))) WITH CHECK ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\")));\n\n\n\nCREATE POLICY \"Staff can manage capacity rules\" ON \"public\".\"restaurant_capacity_rules\" USING ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\"))) WITH CHECK ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\")));\n\n\n\nCREATE POLICY \"Staff can manage operating hours\" ON \"public\".\"restaurant_operating_hours\" USING ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\"))) WITH CHECK ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\")));\n\n\n\nCREATE POLICY \"Staff can manage service periods\" ON \"public\".\"restaurant_service_periods\" USING ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\"))) WITH CHECK ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\")));\n\n\n\nCREATE POLICY \"Staff can manage table assignments\" ON \"public\".\"booking_table_assignments\" USING ((EXISTS ( SELECT 1\n   FROM \"public\".\"bookings\" \"b\"\n  WHERE ((\"b\".\"id\" = \"booking_table_assignments\".\"booking_id\") AND (\"b\".\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\")))))) WITH CHECK ((EXISTS ( SELECT 1\n   FROM \"public\".\"bookings\" \"b\"\n  WHERE ((\"b\".\"id\" = \"booking_table_assignments\".\"booking_id\") AND (\"b\".\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\"))))));\n\n\n\nCREATE POLICY \"Staff can manage table inventory\" ON \"public\".\"table_inventory\" USING ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\"))) WITH CHECK ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\")));\n\n\n\nCREATE POLICY \"Staff can manage zones\" ON \"public\".\"zones\" TO \"authenticated\" USING ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\"))) WITH CHECK ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\")));\n\n\n\nCREATE POLICY \"Staff can update bookings\" ON \"public\".\"bookings\" FOR UPDATE USING ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\")));\n\n\n\nCREATE POLICY \"Staff can update customers\" ON \"public\".\"customers\" FOR UPDATE USING ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\")));\n\n\n\nCREATE POLICY \"Staff can view allocations for their restaurants\" ON \"public\".\"allocations\" FOR SELECT TO \"authenticated\" USING ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\")));\n\n\n\nCREATE POLICY \"Staff can view bookings\" ON \"public\".\"bookings\" FOR SELECT USING ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\")));\n\n\n\nCREATE POLICY \"Staff can view customer profiles\" ON \"public\".\"customer_profiles\" FOR SELECT USING ((EXISTS ( SELECT 1\n   FROM \"public\".\"customers\" \"c\"\n  WHERE ((\"c\".\"id\" = \"customer_profiles\".\"customer_id\") AND (\"c\".\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\"))))));\n\n\n\nCREATE POLICY \"Staff can view customers\" ON \"public\".\"customers\" FOR SELECT USING ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\")));\n\n\n\nCREATE POLICY \"Staff can view merge rules\" ON \"public\".\"merge_rules\" FOR SELECT TO \"authenticated\" USING (true);\n\n\n\nCREATE POLICY \"Staff can view service policy\" ON \"public\".\"service_policy\" FOR SELECT TO \"authenticated\" USING (true);\n\n\n\nCREATE POLICY \"Users can insert own profile\" ON \"public\".\"profiles\" FOR INSERT WITH CHECK ((\"auth\".\"uid\"() = \"id\"));\n\n\n\nCREATE POLICY \"Users can update own profile\" ON \"public\".\"profiles\" FOR UPDATE USING ((\"auth\".\"uid\"() = \"id\")) WITH CHECK ((\"auth\".\"uid\"() = \"id\"));\n\n\n\nCREATE POLICY \"Users can view memberships in their restaurants\" ON \"public\".\"restaurant_memberships\" FOR SELECT USING ((\"restaurant_id\" IN ( SELECT \"public\".\"user_restaurants\"() AS \"user_restaurants\")));\n\n\n\nCREATE POLICY \"Users can view own profile\" ON \"public\".\"profiles\" FOR SELECT USING ((\"auth\".\"uid\"() = \"id\"));\n\n\n\nALTER TABLE \"public\".\"allocations\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"allowed_capacities\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"analytics_events\" ENABLE ROW LEVEL SECURITY;\n\n\nCREATE POLICY \"anon_read_all\" ON \"public\".\"restaurants\" FOR SELECT TO \"anon\" USING (true);\n\n\n\nALTER TABLE \"public\".\"audit_logs\" ENABLE ROW LEVEL SECURITY;\n\n\nCREATE POLICY \"authenticated_can_create\" ON \"public\".\"restaurants\" FOR INSERT TO \"authenticated\" WITH CHECK ((\"auth\".\"uid\"() IS NOT NULL));\n\n\n\nCREATE POLICY \"authenticated_read_all\" ON \"public\".\"restaurants\" FOR SELECT TO \"authenticated\" USING (true);\n\n\n\nALTER TABLE \"public\".\"booking_slots\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"booking_table_assignments\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"booking_versions\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"bookings\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"customer_profiles\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"customers\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"loyalty_point_events\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"loyalty_points\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"loyalty_programs\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"merge_group_members\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"merge_groups\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"merge_rules\" ENABLE ROW LEVEL SECURITY;\n\n\nCREATE POLICY \"owners_admins_can_update\" ON \"public\".\"restaurants\" FOR UPDATE TO \"authenticated\" USING ((\"id\" IN ( SELECT \"rm\".\"restaurant_id\"\n   FROM \"public\".\"restaurant_memberships\" \"rm\"\n  WHERE ((\"rm\".\"user_id\" = \"auth\".\"uid\"()) AND (\"rm\".\"role\" = ANY (ARRAY['owner'::\"text\", 'manager'::\"text\"])))))) WITH CHECK ((\"id\" IN ( SELECT \"rm\".\"restaurant_id\"\n   FROM \"public\".\"restaurant_memberships\" \"rm\"\n  WHERE ((\"rm\".\"user_id\" = \"auth\".\"uid\"()) AND (\"rm\".\"role\" = ANY (ARRAY['owner'::\"text\", 'manager'::\"text\"]))))));\n\n\n\nCREATE POLICY \"owners_can_delete\" ON \"public\".\"restaurants\" FOR DELETE TO \"authenticated\" USING ((\"id\" IN ( SELECT \"rm\".\"restaurant_id\"\n   FROM \"public\".\"restaurant_memberships\" \"rm\"\n  WHERE ((\"rm\".\"user_id\" = \"auth\".\"uid\"()) AND (\"rm\".\"role\" = 'owner'::\"text\")))));\n\n\n\nALTER TABLE \"public\".\"profile_update_requests\" ENABLE ROW LEVEL SECURITY;\n\n\nCREATE POLICY \"profile_update_requests_delete\" ON \"public\".\"profile_update_requests\" FOR DELETE USING ((\"auth\".\"uid\"() = \"profile_id\"));\n\n\n\nCREATE POLICY \"profile_update_requests_insert\" ON \"public\".\"profile_update_requests\" FOR INSERT WITH CHECK ((\"auth\".\"uid\"() = \"profile_id\"));\n\n\n\nCREATE POLICY \"profile_update_requests_select\" ON \"public\".\"profile_update_requests\" FOR SELECT USING ((\"auth\".\"uid\"() = \"profile_id\"));\n\n\n\nCREATE POLICY \"profile_update_requests_update\" ON \"public\".\"profile_update_requests\" FOR UPDATE USING ((\"auth\".\"uid\"() = \"profile_id\")) WITH CHECK ((\"auth\".\"uid\"() = \"profile_id\"));\n\n\n\nALTER TABLE \"public\".\"profiles\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"restaurant_capacity_rules\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"restaurant_invites\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"restaurant_memberships\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"restaurant_operating_hours\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"restaurant_service_periods\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"restaurants\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"service_policy\" ENABLE ROW LEVEL SECURITY;\n\n\nCREATE POLICY \"service_role_all_access\" ON \"public\".\"restaurants\" TO \"service_role\" USING (true) WITH CHECK (true);\n\n\n\nCREATE POLICY \"service_role_read_all\" ON \"public\".\"restaurants\" FOR SELECT TO \"service_role\" USING (true);\n\n\n\nALTER TABLE \"public\".\"stripe_events\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"table_adjacencies\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"table_inventory\" ENABLE ROW LEVEL SECURITY;\n\n\nALTER TABLE \"public\".\"zones\" ENABLE ROW LEVEL SECURITY;\n\n\n\n\nALTER PUBLICATION \"supabase_realtime\" OWNER TO \"postgres\";\n\n\nREVOKE USAGE ON SCHEMA \"public\" FROM PUBLIC;\nGRANT CREATE ON SCHEMA \"public\" TO PUBLIC;\nGRANT ALL ON SCHEMA \"public\" TO \"anon\";\nGRANT ALL ON SCHEMA \"public\" TO \"authenticated\";\nGRANT ALL ON SCHEMA \"public\" TO \"service_role\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"allocations_overlap\"(\"a\" \"tstzrange\", \"b\" \"tstzrange\") TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"allowed_capacities_set_updated_at\"() TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"apply_booking_state_transition\"(\"p_booking_id\" \"uuid\", \"p_status\" \"public\".\"booking_status\", \"p_checked_in_at\" timestamp with time zone, \"p_checked_out_at\" timestamp with time zone, \"p_updated_at\" timestamp with time zone, \"p_history_from\" \"public\".\"booking_status\", \"p_history_to\" \"public\".\"booking_status\", \"p_history_changed_by\" \"uuid\", \"p_history_changed_at\" timestamp with time zone, \"p_history_reason\" \"text\", \"p_history_metadata\" \"jsonb\") TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"are_tables_connected\"(\"table_ids\" \"uuid\"[]) TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"assign_table_to_booking\"(\"p_booking_id\" \"uuid\", \"p_table_id\" \"uuid\", \"p_assigned_by\" \"uuid\", \"p_notes\" \"text\") TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"assign_tables_atomic\"(\"p_booking_id\" \"uuid\", \"p_table_ids\" \"uuid\"[], \"p_window\" \"tstzrange\", \"p_assigned_by\" \"uuid\", \"p_idempotency_key\" \"text\") TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"booking_status_summary\"(\"p_restaurant_id\" \"uuid\", \"p_start_date\" \"date\", \"p_end_date\" \"date\", \"p_status_filter\" \"public\".\"booking_status\"[]) TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"capacity_metrics_hourly_updated_at\"() TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"create_booking_with_capacity_check\"(\"p_restaurant_id\" \"uuid\", \"p_customer_id\" \"uuid\", \"p_booking_date\" \"date\", \"p_start_time\" time without time zone, \"p_end_time\" time without time zone, \"p_party_size\" integer, \"p_booking_type\" \"text\", \"p_customer_name\" \"text\", \"p_customer_email\" \"text\", \"p_customer_phone\" \"text\", \"p_seating_preference\" \"text\", \"p_notes\" \"text\", \"p_marketing_opt_in\" boolean, \"p_idempotency_key\" \"text\", \"p_source\" \"text\", \"p_auth_user_id\" \"uuid\", \"p_client_request_id\" \"text\", \"p_details\" \"jsonb\", \"p_loyalty_points_awarded\" integer) TO \"service_role\";\nGRANT ALL ON FUNCTION \"public\".\"create_booking_with_capacity_check\"(\"p_restaurant_id\" \"uuid\", \"p_customer_id\" \"uuid\", \"p_booking_date\" \"date\", \"p_start_time\" time without time zone, \"p_end_time\" time without time zone, \"p_party_size\" integer, \"p_booking_type\" \"text\", \"p_customer_name\" \"text\", \"p_customer_email\" \"text\", \"p_customer_phone\" \"text\", \"p_seating_preference\" \"text\", \"p_notes\" \"text\", \"p_marketing_opt_in\" boolean, \"p_idempotency_key\" \"text\", \"p_source\" \"text\", \"p_auth_user_id\" \"uuid\", \"p_client_request_id\" \"text\", \"p_details\" \"jsonb\", \"p_loyalty_points_awarded\" integer) TO \"authenticated\";\nGRANT ALL ON FUNCTION \"public\".\"create_booking_with_capacity_check\"(\"p_restaurant_id\" \"uuid\", \"p_customer_id\" \"uuid\", \"p_booking_date\" \"date\", \"p_start_time\" time without time zone, \"p_end_time\" time without time zone, \"p_party_size\" integer, \"p_booking_type\" \"text\", \"p_customer_name\" \"text\", \"p_customer_email\" \"text\", \"p_customer_phone\" \"text\", \"p_seating_preference\" \"text\", \"p_notes\" \"text\", \"p_marketing_opt_in\" boolean, \"p_idempotency_key\" \"text\", \"p_source\" \"text\", \"p_auth_user_id\" \"uuid\", \"p_client_request_id\" \"text\", \"p_details\" \"jsonb\", \"p_loyalty_points_awarded\" integer) TO \"anon\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"generate_booking_reference\"() TO \"authenticated\";\nGRANT ALL ON FUNCTION \"public\".\"generate_booking_reference\"() TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"get_or_create_booking_slot\"(\"p_restaurant_id\" \"uuid\", \"p_slot_date\" \"date\", \"p_slot_time\" time without time zone, \"p_default_capacity\" integer) TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"increment_booking_slot_version\"() TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"increment_capacity_metrics\"(\"p_restaurant_id\" \"uuid\", \"p_window_start\" timestamp with time zone, \"p_success_delta\" integer, \"p_conflict_delta\" integer, \"p_capacity_exceeded_delta\" integer) TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"log_table_assignment_change\"() TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"on_allocations_refresh\"() TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"on_booking_status_refresh\"() TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"refresh_table_status\"(\"p_table_id\" \"uuid\") TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"set_booking_instants\"() TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"set_booking_reference\"() TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"sync_table_adjacency_symmetry\"() TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"unassign_table_from_booking\"(\"p_booking_id\" \"uuid\", \"p_table_id\" \"uuid\") TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"unassign_tables_atomic\"(\"p_booking_id\" \"uuid\", \"p_table_ids\" \"uuid\"[], \"p_merge_group_id\" \"uuid\") TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"update_updated_at\"() TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"user_restaurants\"() TO \"authenticated\";\nGRANT ALL ON FUNCTION \"public\".\"user_restaurants\"() TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"user_restaurants_admin\"() TO \"service_role\";\nGRANT ALL ON FUNCTION \"public\".\"user_restaurants_admin\"() TO \"authenticated\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"validate_merge_group_members\"() TO \"service_role\";\n\n\n\nGRANT ALL ON FUNCTION \"public\".\"validate_table_adjacency\"() TO \"service_role\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"allocations\" TO \"service_role\";\nGRANT SELECT ON TABLE \"public\".\"allocations\" TO \"authenticated\";\nGRANT SELECT ON TABLE \"public\".\"allocations\" TO \"anon\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"allowed_capacities\" TO \"service_role\";\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"allowed_capacities\" TO \"authenticated\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"analytics_events\" TO \"service_role\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"audit_logs\" TO \"service_role\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"booking_slots\" TO \"service_role\";\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"booking_slots\" TO \"authenticated\";\nGRANT SELECT ON TABLE \"public\".\"booking_slots\" TO \"anon\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"booking_state_history\" TO \"service_role\";\n\n\n\nGRANT SELECT,USAGE ON SEQUENCE \"public\".\"booking_state_history_id_seq\" TO \"service_role\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"booking_table_assignments\" TO \"service_role\";\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"booking_table_assignments\" TO \"authenticated\";\nGRANT SELECT ON TABLE \"public\".\"booking_table_assignments\" TO \"anon\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"booking_versions\" TO \"service_role\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"bookings\" TO \"authenticated\";\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"bookings\" TO \"service_role\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"capacity_metrics_hourly\" TO \"service_role\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"customer_profiles\" TO \"service_role\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"customers\" TO \"authenticated\";\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"customers\" TO \"service_role\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"loyalty_point_events\" TO \"service_role\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"loyalty_points\" TO \"service_role\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"loyalty_programs\" TO \"service_role\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"merge_group_members\" TO \"service_role\";\nGRANT SELECT ON TABLE \"public\".\"merge_group_members\" TO \"authenticated\";\nGRANT SELECT ON TABLE \"public\".\"merge_group_members\" TO \"anon\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"merge_groups\" TO \"service_role\";\nGRANT SELECT ON TABLE \"public\".\"merge_groups\" TO \"authenticated\";\nGRANT SELECT ON TABLE \"public\".\"merge_groups\" TO \"anon\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"merge_rules\" TO \"service_role\";\nGRANT SELECT ON TABLE \"public\".\"merge_rules\" TO \"authenticated\";\nGRANT SELECT ON TABLE \"public\".\"merge_rules\" TO \"anon\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"profile_update_requests\" TO \"service_role\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"profiles\" TO \"service_role\";\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"profiles\" TO \"authenticated\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"restaurant_capacity_rules\" TO \"service_role\";\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"restaurant_capacity_rules\" TO \"authenticated\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"restaurant_invites\" TO \"service_role\";\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"restaurant_invites\" TO \"authenticated\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"restaurant_memberships\" TO \"authenticated\";\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"restaurant_memberships\" TO \"service_role\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"restaurant_operating_hours\" TO \"service_role\";\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"restaurant_operating_hours\" TO \"authenticated\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"restaurant_service_periods\" TO \"service_role\";\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"restaurant_service_periods\" TO \"authenticated\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"restaurants\" TO \"authenticated\";\nGRANT SELECT ON TABLE \"public\".\"restaurants\" TO \"anon\";\nGRANT ALL ON TABLE \"public\".\"restaurants\" TO \"service_role\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"service_policy\" TO \"service_role\";\nGRANT SELECT ON TABLE \"public\".\"service_policy\" TO \"authenticated\";\nGRANT SELECT ON TABLE \"public\".\"service_policy\" TO \"anon\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"stripe_events\" TO \"service_role\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"table_adjacencies\" TO \"service_role\";\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"table_adjacencies\" TO \"authenticated\";\nGRANT SELECT ON TABLE \"public\".\"table_adjacencies\" TO \"anon\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"table_inventory\" TO \"service_role\";\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"table_inventory\" TO \"authenticated\";\nGRANT SELECT ON TABLE \"public\".\"table_inventory\" TO \"anon\";\n\n\n\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"zones\" TO \"service_role\";\nGRANT SELECT,INSERT,DELETE,UPDATE ON TABLE \"public\".\"zones\" TO \"authenticated\";\nGRANT SELECT ON TABLE \"public\".\"zones\" TO \"anon\";\n\n\n\n\n\n\n\n\n\nALTER DEFAULT PRIVILEGES FOR ROLE \"postgres\" IN SCHEMA \"public\" GRANT SELECT,USAGE ON SEQUENCES TO \"service_role\";\n\n\n\nALTER DEFAULT PRIVILEGES FOR ROLE \"postgres\" IN SCHEMA \"public\" GRANT ALL ON FUNCTIONS TO \"service_role\";\n\n\n\nALTER DEFAULT PRIVILEGES FOR ROLE \"postgres\" IN SCHEMA \"public\" GRANT SELECT,INSERT,DELETE,UPDATE ON TABLES TO \"service_role\";\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nRESET ALL;\n"
    },
    {
      "path": "supabase/migrations/20251021094500_drop_merge_tables.sql",
      "content": "DROP TRIGGER IF EXISTS merge_group_members_validate_connectivity ON public.merge_group_members;\nDROP TRIGGER IF EXISTS merge_rules_updated_at ON public.merge_rules;\nDROP FUNCTION IF EXISTS public.validate_merge_group_members();\n"
    },
    {
      "path": "supabase/migrations/20251021094501_drop_assign_tables_atomic.sql",
      "content": "DROP FUNCTION IF EXISTS public.assign_tables_atomic(uuid, uuid[], tstzrange, uuid, text);\n"
    },
    {
      "path": "supabase/migrations/20251021094502_drop_unassign_tables_atomic.sql",
      "content": "DROP FUNCTION IF EXISTS public.unassign_tables_atomic(uuid, uuid[], uuid);\n"
    },
    {
      "path": "supabase/migrations/20251021094503_cleanup_merge_data.sql",
      "content": "DELETE FROM public.allocations WHERE resource_type = 'merge_group';\n\nALTER TABLE public.booking_table_assignments\n  DROP CONSTRAINT IF EXISTS booking_table_assignments_merge_group_id_fkey;\n\nALTER TABLE public.booking_table_assignments\n  DROP COLUMN IF EXISTS merge_group_id;\n\nDROP TABLE IF EXISTS public.merge_group_members CASCADE;\nDROP TABLE IF EXISTS public.merge_groups CASCADE;\nDROP TABLE IF EXISTS public.merge_rules CASCADE;\n"
    },
    {
      "path": "supabase/migrations/20251021094504_recreate_assign_tables_atomic.sql",
      "content": "DO $migration$\nBEGIN\n  EXECUTE $create$\n    CREATE FUNCTION public.assign_tables_atomic(\n      p_booking_id uuid,\n      p_table_ids uuid[],\n      p_window tstzrange,\n      p_assigned_by uuid DEFAULT NULL,\n      p_idempotency_key text DEFAULT NULL\n    ) RETURNS TABLE(table_id uuid, assignment_id uuid)\n    LANGUAGE plpgsql\n    SECURITY DEFINER\n    AS $function$\n    DECLARE\n      v_booking RECORD;\n      v_restaurant_id uuid;\n      v_target_tables uuid[];\n      v_target_table uuid;\n      v_existing_tables uuid[];\n      v_table RECORD;\n      v_slot_id uuid := NULL;\n      v_now timestamptz := now();\n      v_window tstzrange := p_window;\n      v_assignment_id uuid;\n      v_lock_restaurant int4;\n      v_lock_date int4;\n    BEGIN\n      IF p_table_ids IS NULL OR array_length(p_table_ids, 1) = 0 THEN\n        RAISE EXCEPTION 'assign_tables_atomic requires at least one table id'\n          USING ERRCODE = '23514';\n      END IF;\n\n      SELECT array_agg(DISTINCT table_id ORDER BY table_id)\n      INTO v_target_tables\n      FROM unnest(p_table_ids) AS t(table_id);\n\n      IF v_target_tables IS NULL OR array_length(v_target_tables, 1) = 0 THEN\n        RAISE EXCEPTION 'assign_tables_atomic requires at least one valid table id'\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF array_length(v_target_tables, 1) > 1 THEN\n        RAISE EXCEPTION 'assign_tables_atomic only supports a single table after merge removal'\n          USING ERRCODE = '23514';\n      END IF;\n\n      v_target_table := v_target_tables[1];\n\n      SELECT *\n      INTO v_booking\n      FROM public.bookings\n      WHERE id = p_booking_id\n      FOR UPDATE;\n\n      IF NOT FOUND THEN\n        RAISE EXCEPTION 'Booking % not found', p_booking_id\n          USING ERRCODE = 'P0002';\n      END IF;\n\n      v_restaurant_id := v_booking.restaurant_id;\n\n      v_lock_restaurant := hashtext(v_restaurant_id::text);\n      v_lock_date := COALESCE((v_booking.booking_date - DATE '2000-01-01')::int, 0);\n      PERFORM pg_advisory_xact_lock(v_lock_restaurant, v_lock_date);\n\n      IF v_window IS NULL THEN\n        v_window := tstzrange(v_booking.start_at, v_booking.end_at, '[)');\n      END IF;\n\n      IF v_window IS NULL OR lower(v_window) IS NULL OR upper(v_window) IS NULL OR lower(v_window) >= upper(v_window) THEN\n        RAISE EXCEPTION 'Invalid assignment window for booking %', p_booking_id\n          USING ERRCODE = '22000';\n      END IF;\n\n      IF p_idempotency_key IS NOT NULL THEN\n        SELECT array_agg(bta.table_id ORDER BY bta.table_id)\n        INTO v_existing_tables\n        FROM public.booking_table_assignments bta\n        WHERE bta.booking_id = p_booking_id\n          AND bta.idempotency_key = p_idempotency_key;\n\n        IF v_existing_tables IS NOT NULL THEN\n          IF v_existing_tables <> v_target_tables THEN\n            RAISE EXCEPTION 'assign_tables_atomic idempotency key mismatch'\n              USING ERRCODE = 'P0003',\n                    DETAIL = 'Idempotency key reuse detected with a different table id';\n          END IF;\n\n          RETURN QUERY\n            SELECT\n              bta.table_id,\n              bta.id AS assignment_id\n            FROM public.booking_table_assignments bta\n            WHERE bta.booking_id = p_booking_id\n              AND bta.idempotency_key = p_idempotency_key;\n\n          RETURN;\n        END IF;\n      END IF;\n\n      SELECT id, restaurant_id\n      INTO v_table\n      FROM public.table_inventory\n      WHERE id = v_target_table\n      FOR UPDATE;\n\n      IF NOT FOUND THEN\n        RAISE EXCEPTION 'Table % not found', v_target_table\n          USING ERRCODE = 'P0002';\n      END IF;\n\n      IF v_table.restaurant_id <> v_restaurant_id THEN\n        RAISE EXCEPTION 'Table % belongs to a different restaurant', v_target_table\n          USING ERRCODE = '23503';\n      END IF;\n\n      IF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL THEN\n        SELECT id\n        INTO v_slot_id\n        FROM public.booking_slots\n        WHERE restaurant_id = v_restaurant_id\n          AND slot_date = v_booking.booking_date\n          AND slot_time = v_booking.start_time\n        LIMIT 1;\n\n        IF v_slot_id IS NULL THEN\n          SELECT public.get_or_create_booking_slot(v_restaurant_id, v_booking.booking_date, v_booking.start_time, 999)\n          INTO v_slot_id;\n        END IF;\n      END IF;\n\n      INSERT INTO public.booking_table_assignments (\n        booking_id,\n        table_id,\n        slot_id,\n        assigned_by,\n        idempotency_key\n      ) VALUES (\n        p_booking_id,\n        v_target_table,\n        v_slot_id,\n        p_assigned_by,\n        p_idempotency_key\n      )\n      ON CONFLICT (booking_id, table_id) DO UPDATE\n      SET assigned_by = EXCLUDED.assigned_by,\n          assigned_at = v_now,\n          idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key)\n      RETURNING id INTO v_assignment_id;\n\n      BEGIN\n        INSERT INTO public.allocations (\n          booking_id,\n          restaurant_id,\n          resource_type,\n          resource_id,\n          \"window\",\n          created_by,\n          shadow,\n          created_at,\n          updated_at\n        ) VALUES (\n          p_booking_id,\n          v_restaurant_id,\n          'table',\n          v_target_table,\n          v_window,\n          p_assigned_by,\n          false,\n          v_now,\n          v_now\n        )\n        ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n        SET \"window\" = EXCLUDED.\"window\",\n            created_by = EXCLUDED.created_by,\n            updated_at = v_now;\n      EXCEPTION\n        WHEN unique_violation OR exclusion_violation THEN\n          RAISE EXCEPTION 'allocations_no_overlap'\n            USING ERRCODE = 'P0001',\n                  DETAIL = format('Resource %s overlaps requested window for booking %s', v_target_table, p_booking_id);\n      END;\n\n      UPDATE public.table_inventory\n      SET status = 'reserved'::public.table_status\n      WHERE id = v_target_table;\n\n      table_id := v_target_table;\n      assignment_id := v_assignment_id;\n      RETURN NEXT;\n    END;\n    $function$\n  $create$;\n\n  EXECUTE $alter$\n    ALTER FUNCTION public.assign_tables_atomic(uuid, uuid[], tstzrange, uuid, text) OWNER TO postgres\n  $alter$;\n\n  EXECUTE $grant$\n    GRANT ALL ON FUNCTION public.assign_tables_atomic(uuid, uuid[], tstzrange, uuid, text) TO service_role\n  $grant$;\nEND;\n$migration$;\n"
    },
    {
      "path": "supabase/migrations/20251021094505_recreate_unassign_tables_atomic.sql",
      "content": "DO $migration$\nBEGIN\n  EXECUTE $create$\n    CREATE FUNCTION public.unassign_tables_atomic(\n      p_booking_id uuid,\n      p_table_ids uuid[] DEFAULT NULL\n    ) RETURNS TABLE(table_id uuid)\n    LANGUAGE plpgsql\n    SECURITY DEFINER\n    AS $function$\n    DECLARE\n      v_target_tables uuid[] := p_table_ids;\n      v_removed RECORD;\n    BEGIN\n      IF v_target_tables IS NOT NULL THEN\n        SELECT array_agg(DISTINCT table_id)\n        INTO v_target_tables\n        FROM unnest(v_target_tables) AS t(table_id);\n      ELSE\n        SELECT array_agg(table_id)\n        INTO v_target_tables\n        FROM public.booking_table_assignments\n        WHERE booking_id = p_booking_id;\n      END IF;\n\n      IF v_target_tables IS NULL OR array_length(v_target_tables, 1) = 0 THEN\n        RETURN;\n      END IF;\n\n      FOR v_removed IN\n        DELETE FROM public.booking_table_assignments\n        WHERE booking_id = p_booking_id\n          AND table_id = ANY (v_target_tables)\n        RETURNING table_id\n      LOOP\n        table_id := v_removed.table_id;\n\n        DELETE FROM public.allocations\n        WHERE booking_id = p_booking_id\n          AND resource_type = 'table'\n          AND resource_id = v_removed.table_id;\n\n        UPDATE public.table_inventory ti\n        SET status = 'available'::public.table_status\n        WHERE ti.id = v_removed.table_id\n          AND NOT EXISTS (\n            SELECT 1\n            FROM public.booking_table_assignments bta\n            WHERE bta.table_id = v_removed.table_id\n          );\n\n        RETURN NEXT;\n      END LOOP;\n\n      RETURN;\n    END;\n    $function$\n  $create$;\n\n  EXECUTE $alter$\n    ALTER FUNCTION public.unassign_tables_atomic(uuid, uuid[]) OWNER TO postgres\n  $alter$;\n\n  EXECUTE $grant$\n    GRANT ALL ON FUNCTION public.unassign_tables_atomic(uuid, uuid[]) TO service_role\n  $grant$;\nEND;\n$migration$;\n"
    },
    {
      "path": "supabase/migrations/20251026104700_add_table_holds.sql",
      "content": "-- Introduce table_holds + table_hold_members to back allocator reservations.\n-- +goose Up\nDO $migration$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1\n    FROM information_schema.tables\n    WHERE table_schema = 'public'\n      AND table_name = 'table_holds'\n  ) THEN\n    EXECUTE $create_holds$\n      CREATE TABLE public.table_holds (\n        id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\n        restaurant_id uuid NOT NULL,\n        booking_id uuid,\n        zone_id uuid NOT NULL,\n        start_at timestamptz NOT NULL,\n        end_at timestamptz NOT NULL,\n        expires_at timestamptz NOT NULL,\n        created_by uuid,\n        created_at timestamptz NOT NULL DEFAULT timezone('utc'::text, now()),\n        updated_at timestamptz NOT NULL DEFAULT timezone('utc'::text, now()),\n        metadata jsonb,\n        CONSTRAINT table_holds_window_check CHECK (start_at < end_at)\n      )\n    $create_holds$;\n  END IF;\n\n  IF NOT EXISTS (\n    SELECT 1\n    FROM information_schema.constraint_column_usage\n    WHERE table_schema = 'public'\n      AND table_name = 'table_holds'\n      AND constraint_name = 'table_holds_restaurant_id_fkey'\n  ) THEN\n    EXECUTE $add_restaurant_fk$\n      ALTER TABLE public.table_holds\n        ADD CONSTRAINT table_holds_restaurant_id_fkey\n          FOREIGN KEY (restaurant_id)\n          REFERENCES public.restaurants(id)\n          ON DELETE CASCADE\n    $add_restaurant_fk$;\n  END IF;\n\n  IF NOT EXISTS (\n    SELECT 1\n    FROM information_schema.constraint_column_usage\n    WHERE table_schema = 'public'\n      AND table_name = 'table_holds'\n      AND constraint_name = 'table_holds_booking_id_fkey'\n  ) THEN\n    EXECUTE $add_booking_fk$\n      ALTER TABLE public.table_holds\n        ADD CONSTRAINT table_holds_booking_id_fkey\n          FOREIGN KEY (booking_id)\n          REFERENCES public.bookings(id)\n          ON DELETE SET NULL\n    $add_booking_fk$;\n  END IF;\n\n  IF NOT EXISTS (\n    SELECT 1\n    FROM information_schema.constraint_column_usage\n    WHERE table_schema = 'public'\n      AND table_name = 'table_holds'\n      AND constraint_name = 'table_holds_zone_id_fkey'\n  ) THEN\n    EXECUTE $add_zone_fk$\n      ALTER TABLE public.table_holds\n        ADD CONSTRAINT table_holds_zone_id_fkey\n          FOREIGN KEY (zone_id)\n          REFERENCES public.zones(id)\n          ON DELETE CASCADE\n    $add_zone_fk$;\n  END IF;\n\n  IF NOT EXISTS (\n    SELECT 1\n    FROM information_schema.constraint_column_usage\n    WHERE table_schema = 'public'\n      AND table_name = 'table_holds'\n      AND constraint_name = 'table_holds_created_by_fkey'\n  ) THEN\n    EXECUTE $add_created_by_fk$\n      ALTER TABLE public.table_holds\n        ADD CONSTRAINT table_holds_created_by_fkey\n          FOREIGN KEY (created_by)\n          REFERENCES auth.users(id)\n          ON DELETE SET NULL\n    $add_created_by_fk$;\n  END IF;\n\n  EXECUTE $comment_holds$\n    COMMENT ON TABLE public.table_holds IS\n      'Ephemeral table reservations to guard allocations during quoting/confirmation flows.'\n  $comment_holds$;\n\n  CREATE INDEX IF NOT EXISTS table_holds_expires_at_idx\n    ON public.table_holds (expires_at);\n\n  CREATE INDEX IF NOT EXISTS table_holds_zone_start_idx\n    ON public.table_holds (zone_id, start_at);\n\n  CREATE INDEX IF NOT EXISTS table_holds_booking_idx\n    ON public.table_holds (booking_id);\n\n  -- Members --------------------------------------------------------------\n  IF NOT EXISTS (\n    SELECT 1\n    FROM information_schema.tables\n    WHERE table_schema = 'public'\n      AND table_name = 'table_hold_members'\n  ) THEN\n    EXECUTE $create_members$\n      CREATE TABLE public.table_hold_members (\n        id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\n        hold_id uuid NOT NULL,\n        table_id uuid NOT NULL,\n        created_at timestamptz NOT NULL DEFAULT timezone('utc'::text, now()),\n        UNIQUE (hold_id, table_id)\n      )\n    $create_members$;\n  END IF;\n\n  IF NOT EXISTS (\n    SELECT 1\n    FROM information_schema.constraint_column_usage\n    WHERE table_schema = 'public'\n      AND table_name = 'table_hold_members'\n      AND constraint_name = 'table_hold_members_hold_id_fkey'\n  ) THEN\n    EXECUTE $add_hold_fk$\n      ALTER TABLE public.table_hold_members\n        ADD CONSTRAINT table_hold_members_hold_id_fkey\n          FOREIGN KEY (hold_id)\n          REFERENCES public.table_holds(id)\n          ON DELETE CASCADE\n    $add_hold_fk$;\n  END IF;\n\n  IF NOT EXISTS (\n    SELECT 1\n    FROM information_schema.constraint_column_usage\n    WHERE table_schema = 'public'\n      AND table_name = 'table_hold_members'\n      AND constraint_name = 'table_hold_members_table_id_fkey'\n  ) THEN\n    EXECUTE $add_table_fk$\n      ALTER TABLE public.table_hold_members\n        ADD CONSTRAINT table_hold_members_table_id_fkey\n          FOREIGN KEY (table_id)\n          REFERENCES public.table_inventory(id)\n          ON DELETE RESTRICT\n    $add_table_fk$;\n  END IF;\n\n  CREATE INDEX IF NOT EXISTS table_hold_members_table_idx\n    ON public.table_hold_members (table_id);\nEND;\n$migration$;\n\n-- +goose Down\nDO $migration$\nBEGIN\n  IF EXISTS (\n    SELECT 1\n    FROM information_schema.tables\n    WHERE table_schema = 'public'\n      AND table_name = 'table_hold_members'\n  ) THEN\n    EXECUTE 'DROP TABLE public.table_hold_members';\n  END IF;\n\n  IF EXISTS (\n    SELECT 1\n    FROM information_schema.tables\n    WHERE table_schema = 'public'\n      AND table_name = 'table_holds'\n  ) THEN\n    EXECUTE 'DROP TABLE public.table_holds';\n  END IF;\nEND;\n$migration$;\n"
    },
    {
      "path": "supabase/migrations/20251026104800_booking_table_assignments_group.sql",
      "content": "-- Reintroduce merge_group_id on booking_table_assignments linking to allocations.\n-- +goose Up\nDO $migration$\nBEGIN\n  IF NOT EXISTS (\n    SELECT 1\n    FROM information_schema.columns\n    WHERE table_schema = 'public'\n      AND table_name = 'booking_table_assignments'\n      AND column_name = 'merge_group_id'\n  ) THEN\n    EXECUTE $add_column$\n      ALTER TABLE public.booking_table_assignments\n        ADD COLUMN merge_group_id uuid\n    $add_column$;\n  END IF;\n\n  IF NOT EXISTS (\n    SELECT 1\n    FROM information_schema.constraint_column_usage\n    WHERE table_schema = 'public'\n      AND table_name = 'booking_table_assignments'\n      AND constraint_name = 'booking_table_assignments_merge_group_id_fkey'\n  ) THEN\n    EXECUTE $add_fk$\n      ALTER TABLE public.booking_table_assignments\n        ADD CONSTRAINT booking_table_assignments_merge_group_id_fkey\n          FOREIGN KEY (merge_group_id)\n          REFERENCES public.allocations(id)\n          ON DELETE SET NULL\n    $add_fk$;\n  END IF;\n\n  CREATE INDEX IF NOT EXISTS booking_table_assignments_merge_group_idx\n    ON public.booking_table_assignments (merge_group_id);\nEND;\n$migration$;\n\n-- +goose Down\nDO $migration$\nBEGIN\n  IF EXISTS (\n    SELECT 1\n    FROM pg_indexes\n    WHERE schemaname = 'public'\n      AND tablename = 'booking_table_assignments'\n      AND indexname = 'booking_table_assignments_merge_group_idx'\n  ) THEN\n    EXECUTE 'DROP INDEX public.booking_table_assignments_merge_group_idx';\n  END IF;\n\n  IF EXISTS (\n    SELECT 1\n    FROM information_schema.constraint_column_usage\n    WHERE table_schema = 'public'\n      AND table_name = 'booking_table_assignments'\n      AND constraint_name = 'booking_table_assignments_merge_group_id_fkey'\n  ) THEN\n    EXECUTE 'ALTER TABLE public.booking_table_assignments DROP CONSTRAINT booking_table_assignments_merge_group_id_fkey';\n  END IF;\n\n  IF EXISTS (\n    SELECT 1\n    FROM information_schema.columns\n    WHERE table_schema = 'public'\n      AND table_name = 'booking_table_assignments'\n      AND column_name = 'merge_group_id'\n  ) THEN\n    EXECUTE 'ALTER TABLE public.booking_table_assignments DROP COLUMN merge_group_id';\n  END IF;\nEND;\n$migration$;\n"
    },
    {
      "path": "supabase/migrations/20251026105000_assign_tables_atomic_v2.sql",
      "content": "-- Introduce assign_tables_atomic_v2 with per-zone locking, idempotency ledger, and hold awareness.\nDO $migration$\nDECLARE\nBEGIN\n  -- Create idempotency ledger if absent.\n  IF NOT EXISTS (\n    SELECT 1\n    FROM information_schema.tables\n    WHERE table_schema = 'public'\n      AND table_name = 'booking_assignment_idempotency'\n  ) THEN\n    EXECUTE $create_ledger$\n      CREATE TABLE public.booking_assignment_idempotency (\n        booking_id uuid NOT NULL,\n        idempotency_key text NOT NULL,\n        table_ids uuid[] NOT NULL,\n        assignment_window tstzrange NOT NULL,\n        merge_group_allocation_id uuid,\n        created_at timestamptz NOT NULL DEFAULT timezone('utc'::text, now()),\n        PRIMARY KEY (booking_id, idempotency_key)\n      )\n    $create_ledger$;\n\n    EXECUTE $ledger_fk_booking$\n      ALTER TABLE public.booking_assignment_idempotency\n        ADD CONSTRAINT booking_assignment_idempotency_booking_id_fkey\n          FOREIGN KEY (booking_id)\n          REFERENCES public.bookings(id)\n          ON DELETE CASCADE\n    $ledger_fk_booking$;\n\n    EXECUTE $ledger_fk_merge$\n      ALTER TABLE public.booking_assignment_idempotency\n        ADD CONSTRAINT booking_assignment_idempotency_merge_group_fkey\n          FOREIGN KEY (merge_group_allocation_id)\n          REFERENCES public.allocations(id)\n          ON DELETE SET NULL\n    $ledger_fk_merge$;\n\n    CREATE INDEX IF NOT EXISTS booking_assignment_idempotency_created_idx\n      ON public.booking_assignment_idempotency (created_at DESC);\n  END IF;\n\n  -- Replace/define RPC v2.\n  EXECUTE $drop_old$\n    DROP FUNCTION IF EXISTS public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid)\n  $drop_old$;\n\n  EXECUTE $create_rpc$\n    CREATE FUNCTION public.assign_tables_atomic_v2(\n      p_booking_id uuid,\n      p_table_ids uuid[],\n      p_idempotency_key text DEFAULT NULL,\n      p_require_adjacency boolean DEFAULT false,\n      p_assigned_by uuid DEFAULT NULL\n    ) RETURNS TABLE (\n      table_id uuid,\n      start_at timestamptz,\n      end_at timestamptz,\n      merge_group_id uuid\n    )\n    LANGUAGE plpgsql\n    SECURITY DEFINER\n    SET search_path = public\n    AS $function$\n    DECLARE\n      v_booking RECORD;\n      v_zone_id uuid;\n      v_restaurant_id uuid;\n      v_service_date date;\n      v_lock_zone int4;\n      v_lock_date int4;\n      v_now timestamptz := timezone('utc', now());\n      v_table_ids uuid[];\n      v_table_count integer;\n      v_table RECORD;\n      v_loaded_count integer := 0;\n      v_slot_id uuid := NULL;\n      v_start_at timestamptz;\n      v_end_at timestamptz;\n      v_window tstzrange;\n      v_timezone text := NULL;\n      v_hold_conflict uuid;\n      v_merge_allocation_id uuid := NULL;\n      v_table_assignment_id uuid;\n      v_existing RECORD;\n      v_adjacency_count integer;\n      v_table_id uuid;\n    BEGIN\n      IF p_table_ids IS NULL OR array_length(p_table_ids, 1) = 0 THEN\n        RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one table id'\n          USING ERRCODE = '23514';\n      END IF;\n\n      SELECT array_agg(DISTINCT table_id ORDER BY table_id)\n      INTO v_table_ids\n      FROM unnest(p_table_ids) AS t(table_id);\n\n      IF v_table_ids IS NULL OR array_length(v_table_ids, 1) = 0 THEN\n        RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one valid table id'\n          USING ERRCODE = '23514';\n      END IF;\n\n      v_table_count := array_length(v_table_ids, 1);\n\n      SELECT\n        b.*,\n        r.timezone AS restaurant_timezone\n      INTO v_booking\n      FROM public.bookings b\n      LEFT JOIN public.restaurants r ON r.id = b.restaurant_id\n      WHERE b.id = p_booking_id\n      FOR UPDATE;\n\n      IF NOT FOUND THEN\n        RAISE EXCEPTION 'Booking % not found', p_booking_id\n          USING ERRCODE = 'P0002';\n      END IF;\n\n      v_restaurant_id := v_booking.restaurant_id;\n      v_timezone := COALESCE(NULLIF(v_booking.restaurant_timezone, ''), 'UTC');\n\n      IF v_booking.start_at IS NOT NULL AND v_booking.end_at IS NOT NULL THEN\n        v_start_at := v_booking.start_at;\n        v_end_at := v_booking.end_at;\n      ELSIF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL AND v_booking.end_time IS NOT NULL THEN\n        v_start_at := make_timestamptz(\n          EXTRACT(YEAR FROM v_booking.booking_date)::int,\n          EXTRACT(MONTH FROM v_booking.booking_date)::int,\n          EXTRACT(DAY FROM v_booking.booking_date)::int,\n          EXTRACT(HOUR FROM v_booking.start_time)::int,\n          EXTRACT(MINUTE FROM v_booking.start_time)::int,\n          EXTRACT(SECOND FROM v_booking.start_time),\n          v_timezone\n        );\n        v_end_at := make_timestamptz(\n          EXTRACT(YEAR FROM v_booking.booking_date)::int,\n          EXTRACT(MONTH FROM v_booking.booking_date)::int,\n          EXTRACT(DAY FROM v_booking.booking_date)::int,\n          EXTRACT(HOUR FROM v_booking.end_time)::int,\n          EXTRACT(MINUTE FROM v_booking.end_time)::int,\n          EXTRACT(SECOND FROM v_booking.end_time),\n          v_timezone\n        );\n      ELSE\n        RAISE EXCEPTION 'Booking % missing start/end window', p_booking_id\n          USING ERRCODE = '22000';\n      END IF;\n\n      IF v_start_at >= v_end_at THEN\n        RAISE EXCEPTION 'Booking % has invalid time window', p_booking_id\n          USING ERRCODE = '22000';\n      END IF;\n\n      v_window := tstzrange(v_start_at, v_end_at, '[)');\n\n      FOR v_table IN\n        SELECT id, restaurant_id, zone_id, active, status, mobility\n        FROM public.table_inventory\n        WHERE id = ANY (v_table_ids)\n        ORDER BY id\n        FOR UPDATE\n      LOOP\n        IF v_table.restaurant_id <> v_restaurant_id THEN\n          RAISE EXCEPTION 'Table % belongs to a different restaurant', v_table.id\n            USING ERRCODE = '23503';\n        END IF;\n\n        IF v_table.zone_id IS NULL THEN\n          RAISE EXCEPTION 'Table % is not assigned to a zone', v_table.id\n            USING ERRCODE = '23514';\n        END IF;\n\n        IF v_table.active IS NOT TRUE THEN\n          RAISE EXCEPTION 'Table % is inactive', v_table.id\n            USING ERRCODE = '23514';\n        END IF;\n\n        IF v_zone_id IS NULL THEN\n          v_zone_id := v_table.zone_id;\n        ELSIF v_zone_id <> v_table.zone_id THEN\n          RAISE EXCEPTION 'All tables must belong to the same zone (found %, expected %)', v_table.zone_id, v_zone_id\n            USING ERRCODE = '23514';\n        END IF;\n\n        IF v_table_count > 1 AND v_table.mobility <> 'movable'::public.table_mobility THEN\n          RAISE EXCEPTION 'Merged assignments require movable tables (% is %)', v_table.id, v_table.mobility\n            USING ERRCODE = '23514';\n        END IF;\n\n        v_loaded_count := v_loaded_count + 1;\n      END LOOP;\n\n      IF v_loaded_count <> v_table_count THEN\n        RAISE EXCEPTION 'Unable to load all requested tables for booking %', p_booking_id\n          USING ERRCODE = 'P0002';\n      END IF;\n\n      IF p_require_adjacency AND v_table_count > 1 THEN\n        FOR v_table IN\n          SELECT id FROM unnest(v_table_ids) AS t(id)\n        LOOP\n          SELECT COUNT(*)\n          INTO v_adjacency_count\n          FROM public.table_adjacencies\n          WHERE table_a = v_table.id\n            AND table_b = ANY (v_table_ids)\n            AND table_b <> v_table.id;\n\n          IF COALESCE(v_adjacency_count, 0) = 0 THEN\n            RAISE EXCEPTION 'Table % is not adjacent to the selected set', v_table.id\n              USING ERRCODE = '23514';\n          END IF;\n        END LOOP;\n      END IF;\n\n      v_service_date := v_booking.booking_date;\n      IF v_service_date IS NULL THEN\n        v_service_date := (v_start_at AT TIME ZONE v_timezone)::date;\n      END IF;\n\n      v_lock_zone := hashtext(COALESCE(v_zone_id::text, ''));\n      v_lock_date := COALESCE((v_service_date - DATE '2000-01-01')::int, 0);\n      PERFORM pg_advisory_xact_lock(v_lock_zone, v_lock_date);\n\n      IF p_idempotency_key IS NOT NULL THEN\n        SELECT *\n        INTO v_existing\n        FROM public.booking_assignment_idempotency\n        WHERE booking_id = p_booking_id\n          AND idempotency_key = p_idempotency_key;\n\n        IF FOUND THEN\n          IF v_existing.table_ids IS NULL OR array_length(v_existing.table_ids, 1) <> v_table_count\n             OR (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_existing.table_ids) AS e(elem))\n                <> (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_table_ids) AS e(elem)) THEN\n            RAISE EXCEPTION 'assign_tables_atomic_v2 idempotency mismatch for booking %', p_booking_id\n              USING ERRCODE = 'P0003',\n                    DETAIL = 'Idempotency key reuse detected with a different table set';\n          END IF;\n\n          RETURN QUERY\n            SELECT\n              bta.table_id,\n              lower(v_existing.assignment_window) AS start_at,\n              upper(v_existing.assignment_window) AS end_at,\n              v_existing.merge_group_allocation_id\n            FROM public.booking_table_assignments bta\n            WHERE bta.booking_id = p_booking_id\n              AND bta.idempotency_key = p_idempotency_key\n              AND bta.table_id = ANY (v_table_ids)\n            ORDER BY bta.table_id;\n\n          RETURN;\n        END IF;\n      END IF;\n\n      SELECT th.id\n      INTO v_hold_conflict\n      FROM public.table_holds th\n      JOIN public.table_hold_members thm ON thm.hold_id = th.id\n      WHERE thm.table_id = ANY (v_table_ids)\n        AND th.expires_at > v_now\n        AND (th.booking_id IS NULL OR th.booking_id <> p_booking_id)\n        AND tstzrange(th.start_at, th.end_at, '[)') && v_window\n      LIMIT 1;\n\n      IF FOUND THEN\n        RAISE EXCEPTION 'Hold conflict prevents assignment for booking %', p_booking_id\n          USING ERRCODE = 'P0001',\n                DETAIL = format('Hold % overlaps requested window', v_hold_conflict),\n                HINT = 'Retry after hold expiration or confirm existing hold.';\n      END IF;\n\n      IF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL THEN\n        SELECT id\n        INTO v_slot_id\n        FROM public.booking_slots\n        WHERE restaurant_id = v_restaurant_id\n          AND slot_date = v_booking.booking_date\n          AND slot_time = v_booking.start_time\n        LIMIT 1;\n\n        IF v_slot_id IS NULL THEN\n          SELECT public.get_or_create_booking_slot(v_restaurant_id, v_booking.booking_date, v_booking.start_time, 999)\n          INTO v_slot_id;\n        END IF;\n      END IF;\n\n      IF v_table_count > 1 THEN\n        v_merge_allocation_id := gen_random_uuid();\n\n        BEGIN\n          INSERT INTO public.allocations (\n            id,\n            booking_id,\n            restaurant_id,\n            resource_type,\n            resource_id,\n            \"window\",\n            created_by,\n            shadow,\n            created_at,\n            updated_at\n          ) VALUES (\n            v_merge_allocation_id,\n            p_booking_id,\n            v_restaurant_id,\n            'merge_group',\n            v_merge_allocation_id,\n            v_window,\n            p_assigned_by,\n            false,\n            v_now,\n            v_now\n          )\n          ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n          SET \"window\" = EXCLUDED.\"window\",\n              created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n              updated_at = v_now;\n        EXCEPTION\n          WHEN unique_violation OR exclusion_violation THEN\n            RAISE EXCEPTION 'allocations_no_overlap'\n              USING ERRCODE = 'P0001',\n                    DETAIL = format('Merge group overlaps requested window for booking %s', p_booking_id);\n        END;\n      END IF;\n\n      FOREACH v_table_id IN ARRAY v_table_ids LOOP\n        BEGIN\n          INSERT INTO public.booking_table_assignments (\n            booking_id,\n            table_id,\n            slot_id,\n            assigned_by,\n            idempotency_key,\n            merge_group_id\n          ) VALUES (\n            p_booking_id,\n            v_table_id,\n            v_slot_id,\n            p_assigned_by,\n            p_idempotency_key,\n            v_merge_allocation_id\n          )\n          ON CONFLICT (booking_id, table_id) DO UPDATE\n          SET assigned_at = v_now,\n              assigned_by = COALESCE(EXCLUDED.assigned_by, public.booking_table_assignments.assigned_by),\n              idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n              merge_group_id = COALESCE(EXCLUDED.merge_group_id, public.booking_table_assignments.merge_group_id),\n              slot_id = COALESCE(EXCLUDED.slot_id, public.booking_table_assignments.slot_id)\n          RETURNING id INTO v_table_assignment_id;\n        EXCEPTION\n          WHEN unique_violation THEN\n            RAISE EXCEPTION 'assign_tables_atomic_v2 assignment duplicate for table %', v_table_id\n              USING ERRCODE = 'P0001';\n        END;\n\n        BEGIN\n          INSERT INTO public.allocations (\n            booking_id,\n            restaurant_id,\n            resource_type,\n            resource_id,\n            \"window\",\n            created_by,\n            shadow,\n            created_at,\n            updated_at\n          ) VALUES (\n            p_booking_id,\n            v_restaurant_id,\n            'table',\n            v_table_id,\n            v_window,\n            p_assigned_by,\n            false,\n            v_now,\n            v_now\n          )\n          ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n          SET \"window\" = EXCLUDED.\"window\",\n              created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n              updated_at = v_now;\n        EXCEPTION\n          WHEN unique_violation OR exclusion_violation THEN\n            RAISE EXCEPTION 'allocations_no_overlap'\n              USING ERRCODE = 'P0001',\n                    DETAIL = format('Resource %s overlaps requested window for booking %s', v_table_id, p_booking_id);\n        END;\n\n        UPDATE public.table_inventory\n        SET status = 'reserved'::public.table_status\n        WHERE id = v_table_id;\n\n        table_id := v_table_id;\n        start_at := v_start_at;\n        end_at := v_end_at;\n        merge_group_id := v_merge_allocation_id;\n        RETURN NEXT;\n      END LOOP;\n\n      IF p_idempotency_key IS NOT NULL THEN\n        INSERT INTO public.booking_assignment_idempotency (\n          booking_id,\n          idempotency_key,\n          table_ids,\n          assignment_window,\n          merge_group_allocation_id,\n          created_at\n        ) VALUES (\n          p_booking_id,\n          p_idempotency_key,\n          v_table_ids,\n          v_window,\n          v_merge_allocation_id,\n          v_now\n        )\n        ON CONFLICT (booking_id, idempotency_key) DO NOTHING;\n      END IF;\n    END;\n    $function$\n  $create_rpc$;\n\n  EXECUTE $alter_rpc$\n    ALTER FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid) OWNER TO postgres\n  $alter_rpc$;\n\n  EXECUTE $grant_rpc$\n    GRANT ALL ON FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid) TO service_role\n  $grant_rpc$;\nEND;\n$migration$;\n"
    },
    {
      "path": "supabase/migrations/20251026105100_cleanup_legacy_assign_rpc.sql",
      "content": "-- Remove legacy assign_table_to_booking RPC\n-- This migration drops the old function signature if it exists\nDO $$\nBEGIN\n  IF EXISTS (\n    SELECT 1\n    FROM pg_proc\n    WHERE proname = 'assign_table_to_booking'\n      AND pg_function_is_visible(oid)\n      AND pg_get_function_identity_arguments(oid) = 'p_booking_id uuid, p_table_id uuid, p_assigned_by uuid, p_notes text'\n  ) THEN\n    DROP FUNCTION public.assign_table_to_booking(uuid, uuid, uuid, text);\n  END IF;\nEND;\n$$;\n"
    },
    {
      "path": "supabase/migrations/20251026161309_add_table_holds_unconditional.sql",
      "content": "-- Create table_holds and table_hold_members unconditionally\n-- This migration ensures these tables exist on the remote database\n\nCREATE TABLE IF NOT EXISTS public.table_holds (\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\n  restaurant_id uuid NOT NULL REFERENCES public.restaurants(id) ON DELETE CASCADE,\n  booking_id uuid REFERENCES public.bookings(id) ON DELETE SET NULL,\n  zone_id uuid NOT NULL REFERENCES public.zones(id) ON DELETE CASCADE,\n  start_at timestamptz NOT NULL,\n  end_at timestamptz NOT NULL,\n  expires_at timestamptz NOT NULL,\n  created_by uuid REFERENCES auth.users(id) ON DELETE SET NULL,\n  created_at timestamptz NOT NULL DEFAULT timezone('utc'::text, now()),\n  updated_at timestamptz NOT NULL DEFAULT timezone('utc'::text, now()),\n  metadata jsonb,\n  CONSTRAINT table_holds_window_check CHECK (start_at < end_at)\n);\n\nCOMMENT ON TABLE public.table_holds IS\n  'Ephemeral table reservations to guard allocations during quoting/confirmation flows.';\n\nCREATE INDEX IF NOT EXISTS table_holds_expires_at_idx\n  ON public.table_holds (expires_at);\n\nCREATE INDEX IF NOT EXISTS table_holds_zone_start_idx\n  ON public.table_holds (zone_id, start_at);\n\nCREATE INDEX IF NOT EXISTS table_holds_booking_idx\n  ON public.table_holds (booking_id);\n\n-- Create table_hold_members\nCREATE TABLE IF NOT EXISTS public.table_hold_members (\n  id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\n  hold_id uuid NOT NULL REFERENCES public.table_holds(id) ON DELETE CASCADE,\n  table_id uuid NOT NULL REFERENCES public.table_inventory(id) ON DELETE RESTRICT,\n  created_at timestamptz NOT NULL DEFAULT timezone('utc'::text, now()),\n  UNIQUE (hold_id, table_id)\n);\n\nCREATE INDEX IF NOT EXISTS table_hold_members_table_idx\n  ON public.table_hold_members (table_id);\n"
    },
    {
      "path": "supabase/migrations/20251026162123_allow_hold_allocations.sql",
      "content": "-- Ensure allocations.resource_type allows hold mirrors created by manual holds.\n-- +goose Up\nALTER TABLE public.allocations\n  DROP CONSTRAINT IF EXISTS allocations_resource_type_check;\n\nALTER TABLE public.allocations\n  ADD CONSTRAINT allocations_resource_type_check\n    CHECK (resource_type = ANY (ARRAY['table'::text, 'hold'::text, 'merge_group'::text]));\n\n-- +goose Down\nALTER TABLE public.allocations\n  DROP CONSTRAINT IF EXISTS allocations_resource_type_check;\n\nALTER TABLE public.allocations\n  ADD CONSTRAINT allocations_resource_type_check\n    CHECK (resource_type = ANY (ARRAY['table'::text, 'merge_group'::text]));\n"
    },
    {
      "path": "supabase/migrations/20251026163200_grant_table_hold_access.sql",
      "content": "-- Ensure staff APIs can read table holds through the authenticated role.\n-- +goose Up\nGRANT SELECT ON TABLE public.table_holds TO authenticated;\nGRANT SELECT ON TABLE public.table_hold_members TO authenticated;\n\n-- +goose Down\nREVOKE SELECT ON TABLE public.table_hold_members FROM authenticated;\nREVOKE SELECT ON TABLE public.table_holds FROM authenticated;\n"
    },
    {
      "path": "supabase/migrations/20251026164913_add_table_holds_rls.sql",
      "content": "-- Enable RLS and scoped policies for table holds and members\n-- +goose Up\nALTER TABLE public.table_holds ENABLE ROW LEVEL SECURITY;\nALTER TABLE public.table_hold_members ENABLE ROW LEVEL SECURITY;\n\nGRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.table_holds TO service_role;\nGRANT SELECT ON TABLE public.table_holds TO authenticated;\n\nGRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.table_hold_members TO service_role;\nGRANT SELECT ON TABLE public.table_hold_members TO authenticated;\n\nCREATE POLICY \"Service role can manage table holds\" ON public.table_holds\n  TO service_role\n  USING (true)\n  WITH CHECK (true);\n\nCREATE POLICY \"Staff can view table holds\" ON public.table_holds\n  FOR SELECT\n  TO authenticated\n  USING (\n    restaurant_id IN (\n      SELECT public.user_restaurants() AS user_restaurants\n    )\n  );\n\nCREATE POLICY \"Service role can manage table hold members\" ON public.table_hold_members\n  TO service_role\n  USING (true)\n  WITH CHECK (true);\n\nCREATE POLICY \"Staff can view table hold members\" ON public.table_hold_members\n  FOR SELECT\n  TO authenticated\n  USING (\n    EXISTS (\n      SELECT 1\n      FROM public.table_holds h\n      WHERE h.id = table_hold_members.hold_id\n        AND h.restaurant_id IN (\n          SELECT public.user_restaurants() AS user_restaurants\n        )\n    )\n  );\n\n-- +goose Down\nDROP POLICY IF EXISTS \"Staff can view table hold members\" ON public.table_hold_members;\nDROP POLICY IF EXISTS \"Service role can manage table hold members\" ON public.table_hold_members;\nDROP POLICY IF EXISTS \"Staff can view table holds\" ON public.table_holds;\nDROP POLICY IF EXISTS \"Service role can manage table holds\" ON public.table_holds;\n\nREVOKE SELECT ON TABLE public.table_hold_members FROM authenticated;\nREVOKE SELECT, INSERT, UPDATE, DELETE ON TABLE public.table_hold_members FROM service_role;\n\nREVOKE SELECT ON TABLE public.table_holds FROM authenticated;\nREVOKE SELECT, INSERT, UPDATE, DELETE ON TABLE public.table_holds FROM service_role;\n\nALTER TABLE public.table_hold_members DISABLE ROW LEVEL SECURITY;\nALTER TABLE public.table_holds DISABLE ROW LEVEL SECURITY;\n"
    },
    {
      "path": "supabase/migrations/20251026171000_regrant_table_holds_access.sql",
      "content": "-- Ensure table_holds and table_hold_members grant coverage is in place after earlier schema drift.\n-- +goose Up\nALTER TABLE public.table_holds ENABLE ROW LEVEL SECURITY;\nALTER TABLE public.table_hold_members ENABLE ROW LEVEL SECURITY;\n\nGRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.table_holds TO service_role;\nGRANT SELECT ON TABLE public.table_holds TO authenticated;\n\nGRANT SELECT, INSERT, UPDATE, DELETE ON TABLE public.table_hold_members TO service_role;\nGRANT SELECT ON TABLE public.table_hold_members TO authenticated;\n\nDROP POLICY IF EXISTS \"Service role can manage table holds\" ON public.table_holds;\nCREATE POLICY \"Service role can manage table holds\" ON public.table_holds\n  TO service_role\n  USING (true)\n  WITH CHECK (true);\n\nDROP POLICY IF EXISTS \"Staff can view table holds\" ON public.table_holds;\nCREATE POLICY \"Staff can view table holds\" ON public.table_holds\n  FOR SELECT\n  TO authenticated\n  USING (\n    restaurant_id IN (\n      SELECT public.user_restaurants() AS user_restaurants\n    )\n  );\n\nDROP POLICY IF EXISTS \"Service role can manage table hold members\" ON public.table_hold_members;\nCREATE POLICY \"Service role can manage table hold members\" ON public.table_hold_members\n  TO service_role\n  USING (true)\n  WITH CHECK (true);\n\nDROP POLICY IF EXISTS \"Staff can view table hold members\" ON public.table_hold_members;\nCREATE POLICY \"Staff can view table hold members\" ON public.table_hold_members\n  FOR SELECT\n  TO authenticated\n  USING (\n    EXISTS (\n      SELECT 1\n      FROM public.table_holds h\n      WHERE h.id = table_hold_members.hold_id\n        AND h.restaurant_id IN (\n          SELECT public.user_restaurants() AS user_restaurants\n        )\n    )\n  );\n\n-- +goose Down\nDROP POLICY IF EXISTS \"Staff can view table hold members\" ON public.table_hold_members;\nDROP POLICY IF EXISTS \"Service role can manage table hold members\" ON public.table_hold_members;\nDROP POLICY IF EXISTS \"Staff can view table holds\" ON public.table_holds;\nDROP POLICY IF EXISTS \"Service role can manage table holds\" ON public.table_holds;\n\nREVOKE SELECT ON TABLE public.table_hold_members FROM authenticated;\nREVOKE SELECT, INSERT, UPDATE, DELETE ON TABLE public.table_hold_members FROM service_role;\n\nREVOKE SELECT ON TABLE public.table_holds FROM authenticated;\nREVOKE SELECT, INSERT, UPDATE, DELETE ON TABLE public.table_holds FROM service_role;\n\nALTER TABLE public.table_hold_members DISABLE ROW LEVEL SECURITY;\nALTER TABLE public.table_holds DISABLE ROW LEVEL SECURITY;\n"
    },
    {
      "path": "supabase/migrations/20251026180000_fix_assign_tables_atomic_v2_table_id.sql",
      "content": "-- Fix ambiguous table_id reference in assign_tables_atomic_v2\nCREATE OR REPLACE FUNCTION public.assign_tables_atomic_v2(\n      p_booking_id uuid,\n      p_table_ids uuid[],\n      p_idempotency_key text DEFAULT NULL,\n      p_require_adjacency boolean DEFAULT false,\n      p_assigned_by uuid DEFAULT NULL\n    ) RETURNS TABLE (\n      table_id uuid,\n      start_at timestamptz,\n      end_at timestamptz,\n      merge_group_id uuid\n    )\n    LANGUAGE plpgsql\n    SECURITY DEFINER\n    SET search_path = public\n    AS $function$\n    DECLARE\n      v_booking RECORD;\n      v_zone_id uuid;\n      v_restaurant_id uuid;\n      v_service_date date;\n      v_lock_zone int4;\n      v_lock_date int4;\n      v_now timestamptz := timezone('utc', now());\n      v_table_ids uuid[];\n      v_table_count integer;\n      v_table RECORD;\n      v_loaded_count integer := 0;\n      v_slot_id uuid := NULL;\n      v_start_at timestamptz;\n      v_end_at timestamptz;\n      v_window tstzrange;\n      v_timezone text := NULL;\n      v_hold_conflict uuid;\n      v_merge_allocation_id uuid := NULL;\n      v_table_assignment_id uuid;\n      v_existing RECORD;\n      v_adjacency_count integer;\n      v_table_id uuid;\n      v_merge_group_supported boolean := false;\n    BEGIN\n      IF p_table_ids IS NULL OR array_length(p_table_ids, 1) = 0 THEN\n        RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one table id'\n          USING ERRCODE = '23514';\n      END IF;\n\n      SELECT array_agg(DISTINCT t.table_id ORDER BY t.table_id)\n      INTO v_table_ids\n      FROM unnest(p_table_ids) AS t(table_id);\n\n      IF v_table_ids IS NULL OR array_length(v_table_ids, 1) = 0 THEN\n        RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one valid table id'\n          USING ERRCODE = '23514';\n      END IF;\n\n      v_table_count := array_length(v_table_ids, 1);\n\n      SELECT\n        b.*,\n        r.timezone AS restaurant_timezone\n      INTO v_booking\n      FROM public.bookings b\n      LEFT JOIN public.restaurants r ON r.id = b.restaurant_id\n      WHERE b.id = p_booking_id\n      FOR UPDATE OF b;\n\n      IF NOT FOUND THEN\n        RAISE EXCEPTION 'Booking % not found', p_booking_id\n          USING ERRCODE = 'P0002';\n      END IF;\n\n      v_restaurant_id := v_booking.restaurant_id;\n      v_timezone := COALESCE(NULLIF(v_booking.restaurant_timezone, ''), 'UTC');\n\n      SELECT EXISTS (\n        SELECT 1\n        FROM information_schema.columns\n        WHERE table_schema = 'public'\n          AND table_name = 'booking_table_assignments'\n          AND column_name = 'merge_group_id'\n      )\n      INTO v_merge_group_supported;\n\n      IF v_booking.start_at IS NOT NULL AND v_booking.end_at IS NOT NULL THEN\n        v_start_at := v_booking.start_at;\n        v_end_at := v_booking.end_at;\n      ELSIF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL AND v_booking.end_time IS NOT NULL THEN\n        v_start_at := make_timestamptz(\n          EXTRACT(YEAR FROM v_booking.booking_date)::int,\n          EXTRACT(MONTH FROM v_booking.booking_date)::int,\n          EXTRACT(DAY FROM v_booking.booking_date)::int,\n          EXTRACT(HOUR FROM v_booking.start_time)::int,\n          EXTRACT(MINUTE FROM v_booking.start_time)::int,\n          EXTRACT(SECOND FROM v_booking.start_time),\n          v_timezone\n        );\n        v_end_at := make_timestamptz(\n          EXTRACT(YEAR FROM v_booking.booking_date)::int,\n          EXTRACT(MONTH FROM v_booking.booking_date)::int,\n          EXTRACT(DAY FROM v_booking.booking_date)::int,\n          EXTRACT(HOUR FROM v_booking.end_time)::int,\n          EXTRACT(MINUTE FROM v_booking.end_time)::int,\n          EXTRACT(SECOND FROM v_booking.end_time),\n          v_timezone\n        );\n      ELSE\n        RAISE EXCEPTION 'Booking % missing start/end window', p_booking_id\n          USING ERRCODE = '22000';\n      END IF;\n\n      IF v_start_at >= v_end_at THEN\n        RAISE EXCEPTION 'Booking % has invalid time window', p_booking_id\n          USING ERRCODE = '22000';\n      END IF;\n\n      v_window := tstzrange(v_start_at, v_end_at, '[)');\n\n      FOR v_table IN\n        SELECT id, restaurant_id, zone_id, active, status, mobility\n        FROM public.table_inventory\n        WHERE id = ANY (v_table_ids)\n        ORDER BY id\n        FOR UPDATE\n      LOOP\n        IF v_table.restaurant_id <> v_restaurant_id THEN\n          RAISE EXCEPTION 'Table % belongs to a different restaurant', v_table.id\n            USING ERRCODE = '23503';\n        END IF;\n\n        IF v_table.zone_id IS NULL THEN\n          RAISE EXCEPTION 'Table % is not assigned to a zone', v_table.id\n            USING ERRCODE = '23514';\n        END IF;\n\n        IF v_table.active IS NOT TRUE THEN\n          RAISE EXCEPTION 'Table % is inactive', v_table.id\n            USING ERRCODE = '23514';\n        END IF;\n\n        IF v_zone_id IS NULL THEN\n          v_zone_id := v_table.zone_id;\n        ELSIF v_zone_id <> v_table.zone_id THEN\n          RAISE EXCEPTION 'All tables must belong to the same zone (found %, expected %)', v_table.zone_id, v_zone_id\n            USING ERRCODE = '23514';\n        END IF;\n\n        IF v_table_count > 1 AND v_table.mobility <> 'movable'::public.table_mobility THEN\n          RAISE EXCEPTION 'Merged assignments require movable tables (% is %)', v_table.id, v_table.mobility\n            USING ERRCODE = '23514';\n        END IF;\n\n        v_loaded_count := v_loaded_count + 1;\n      END LOOP;\n\n      IF v_loaded_count <> v_table_count THEN\n        RAISE EXCEPTION 'Unable to load all requested tables for booking %', p_booking_id\n          USING ERRCODE = 'P0002';\n      END IF;\n\n      IF p_require_adjacency AND v_table_count > 1 THEN\n        FOR v_table IN\n          SELECT id FROM unnest(v_table_ids) AS t(id)\n        LOOP\n          SELECT COUNT(*)\n          INTO v_adjacency_count\n          FROM public.table_adjacencies\n          WHERE table_a = v_table.id\n            AND table_b = ANY (v_table_ids)\n            AND table_b <> v_table.id;\n\n          IF COALESCE(v_adjacency_count, 0) = 0 THEN\n            RAISE EXCEPTION 'Table % is not adjacent to the selected set', v_table.id\n              USING ERRCODE = '23514';\n          END IF;\n        END LOOP;\n      END IF;\n\n      v_service_date := v_booking.booking_date;\n      IF v_service_date IS NULL THEN\n        v_service_date := (v_start_at AT TIME ZONE v_timezone)::date;\n      END IF;\n\n      v_lock_zone := hashtext(COALESCE(v_zone_id::text, ''));\n      v_lock_date := COALESCE((v_service_date - DATE '2000-01-01')::int, 0);\n      PERFORM pg_advisory_xact_lock(v_lock_zone, v_lock_date);\n\n      IF p_idempotency_key IS NOT NULL THEN\n        SELECT *\n        INTO v_existing\n        FROM public.booking_assignment_idempotency\n        WHERE booking_id = p_booking_id\n          AND idempotency_key = p_idempotency_key;\n\n        IF FOUND THEN\n          IF v_existing.table_ids IS NULL OR array_length(v_existing.table_ids, 1) <> v_table_count\n             OR (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_existing.table_ids) AS e(elem))\n                <> (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_table_ids) AS e(elem)) THEN\n            RAISE EXCEPTION 'assign_tables_atomic_v2 idempotency mismatch for booking %', p_booking_id\n              USING ERRCODE = 'P0003',\n                    DETAIL = 'Idempotency key reuse detected with a different table set';\n          END IF;\n\n          RETURN QUERY\n            SELECT\n              bta.table_id,\n              lower(v_existing.assignment_window) AS start_at,\n              upper(v_existing.assignment_window) AS end_at,\n              v_existing.merge_group_allocation_id\n            FROM public.booking_table_assignments bta\n            WHERE bta.booking_id = p_booking_id\n              AND bta.idempotency_key = p_idempotency_key\n              AND bta.table_id = ANY (v_table_ids)\n            ORDER BY bta.table_id;\n\n          RETURN;\n        END IF;\n      END IF;\n\n      SELECT th.id\n      INTO v_hold_conflict\n      FROM public.table_holds th\n      JOIN public.table_hold_members thm ON thm.hold_id = th.id\n      WHERE thm.table_id = ANY (v_table_ids)\n        AND th.expires_at > v_now\n        AND (th.booking_id IS NULL OR th.booking_id <> p_booking_id)\n        AND tstzrange(th.start_at, th.end_at, '[)') && v_window\n      LIMIT 1;\n\n      IF FOUND THEN\n        RAISE EXCEPTION 'Hold conflict prevents assignment for booking %', p_booking_id\n          USING ERRCODE = 'P0001',\n                DETAIL = format('Hold % overlaps requested window', v_hold_conflict),\n                HINT = 'Retry after hold expiration or confirm existing hold.';\n      END IF;\n\n      IF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL THEN\n        SELECT id\n        INTO v_slot_id\n        FROM public.booking_slots\n        WHERE restaurant_id = v_restaurant_id\n          AND slot_date = v_booking.booking_date\n          AND slot_time = v_booking.start_time\n        LIMIT 1;\n\n        IF v_slot_id IS NULL THEN\n          SELECT public.get_or_create_booking_slot(v_restaurant_id, v_booking.booking_date, v_booking.start_time, 999)\n          INTO v_slot_id;\n        END IF;\n      END IF;\n\n      IF v_merge_group_supported AND v_table_count > 1 THEN\n        v_merge_allocation_id := gen_random_uuid();\n\n        BEGIN\n          INSERT INTO public.allocations (\n            id,\n            booking_id,\n            restaurant_id,\n            resource_type,\n            resource_id,\n            \"window\",\n            created_by,\n            shadow,\n            created_at,\n            updated_at\n          ) VALUES (\n            v_merge_allocation_id,\n            p_booking_id,\n            v_restaurant_id,\n            'merge_group',\n            v_merge_allocation_id,\n            v_window,\n            p_assigned_by,\n            false,\n            v_now,\n            v_now\n          )\n          ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n          SET \"window\" = EXCLUDED.\"window\",\n              created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n              updated_at = v_now;\n        EXCEPTION\n          WHEN unique_violation OR exclusion_violation THEN\n            RAISE EXCEPTION 'allocations_no_overlap'\n              USING ERRCODE = 'P0001',\n                    DETAIL = format('Merge group overlaps requested window for booking %s', p_booking_id);\n        END;\n      END IF;\n\n      FOREACH v_table_id IN ARRAY v_table_ids LOOP\n        IF v_merge_group_supported THEN\n          BEGIN\n            INSERT INTO public.booking_table_assignments (\n              booking_id,\n              table_id,\n              slot_id,\n              assigned_by,\n              idempotency_key,\n              merge_group_id\n            ) VALUES (\n              p_booking_id,\n              v_table_id,\n              v_slot_id,\n              p_assigned_by,\n              p_idempotency_key,\n              v_merge_allocation_id\n            )\n            ON CONFLICT ON CONSTRAINT booking_table_assignments_booking_table_key DO UPDATE\n            SET assigned_at = v_now,\n                assigned_by = COALESCE(EXCLUDED.assigned_by, public.booking_table_assignments.assigned_by),\n                idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n                merge_group_id = COALESCE(EXCLUDED.merge_group_id, public.booking_table_assignments.merge_group_id),\n                slot_id = COALESCE(EXCLUDED.slot_id, public.booking_table_assignments.slot_id)\n            RETURNING id INTO v_table_assignment_id;\n          EXCEPTION\n            WHEN unique_violation THEN\n              RAISE EXCEPTION 'assign_tables_atomic_v2 assignment duplicate for table %', v_table_id\n                USING ERRCODE = 'P0001';\n          END;\n        ELSE\n          BEGIN\n            INSERT INTO public.booking_table_assignments (\n              booking_id,\n              table_id,\n              slot_id,\n              assigned_by,\n              idempotency_key\n            ) VALUES (\n              p_booking_id,\n              v_table_id,\n              v_slot_id,\n              p_assigned_by,\n              p_idempotency_key\n            )\n            ON CONFLICT ON CONSTRAINT booking_table_assignments_booking_table_key DO UPDATE\n            SET assigned_at = v_now,\n                assigned_by = COALESCE(EXCLUDED.assigned_by, public.booking_table_assignments.assigned_by),\n                idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n                slot_id = COALESCE(EXCLUDED.slot_id, public.booking_table_assignments.slot_id)\n            RETURNING id INTO v_table_assignment_id;\n          EXCEPTION\n            WHEN unique_violation THEN\n              RAISE EXCEPTION 'assign_tables_atomic_v2 assignment duplicate for table %', v_table_id\n                USING ERRCODE = 'P0001';\n          END;\n        END IF;\n\n        BEGIN\n          INSERT INTO public.allocations (\n            booking_id,\n            restaurant_id,\n            resource_type,\n            resource_id,\n            \"window\",\n            created_by,\n            shadow,\n            created_at,\n            updated_at\n          ) VALUES (\n            p_booking_id,\n            v_restaurant_id,\n            'table',\n            v_table_id,\n            v_window,\n            p_assigned_by,\n            false,\n            v_now,\n            v_now\n          )\n          ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n          SET \"window\" = EXCLUDED.\"window\",\n              created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n              updated_at = v_now;\n        EXCEPTION\n          WHEN unique_violation OR exclusion_violation THEN\n            RAISE EXCEPTION 'allocations_no_overlap'\n              USING ERRCODE = 'P0001',\n                    DETAIL = format('Resource %s overlaps requested window for booking %s', v_table_id, p_booking_id);\n        END;\n\n        UPDATE public.table_inventory\n        SET status = 'reserved'::public.table_status\n        WHERE id = v_table_id;\n\n        table_id := v_table_id;\n        start_at := v_start_at;\n        end_at := v_end_at;\n        merge_group_id := CASE WHEN v_merge_group_supported THEN v_merge_allocation_id ELSE NULL END;\n        RETURN NEXT;\n      END LOOP;\n\n      IF p_idempotency_key IS NOT NULL THEN\n        INSERT INTO public.booking_assignment_idempotency (\n          booking_id,\n          idempotency_key,\n          table_ids,\n          assignment_window,\n          merge_group_allocation_id,\n          created_at\n        ) VALUES (\n          p_booking_id,\n          p_idempotency_key,\n          v_table_ids,\n          v_window,\n          v_merge_allocation_id,\n          v_now\n        )\n        ON CONFLICT (booking_id, idempotency_key) DO NOTHING;\n      END IF;\n    END;\n$function$;\n\nALTER FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid) OWNER TO postgres;\n\nGRANT ALL ON FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid) TO service_role;\n\n-- Ensure booking slot helper tolerates missing capacity rules table.\n\nCREATE OR REPLACE FUNCTION public.get_or_create_booking_slot(\n  p_restaurant_id uuid,\n  p_slot_date date,\n  p_slot_time time without time zone,\n  p_default_capacity integer DEFAULT 999\n) RETURNS uuid\nLANGUAGE plpgsql\nSECURITY DEFINER\nAS $function$\nDECLARE\n  v_slot_id uuid;\n  v_service_period_id uuid;\n  v_capacity integer;\n  v_rules_exist boolean := to_regclass('public.restaurant_capacity_rules') IS NOT NULL;\nBEGIN\n  SELECT id\n  INTO v_slot_id\n  FROM public.booking_slots\n  WHERE restaurant_id = p_restaurant_id\n    AND slot_date = p_slot_date\n    AND slot_time = p_slot_time;\n\n  IF FOUND THEN\n    RETURN v_slot_id;\n  END IF;\n\n  SELECT id\n  INTO v_service_period_id\n  FROM public.restaurant_service_periods\n  WHERE restaurant_id = p_restaurant_id\n    AND (day_of_week IS NULL OR day_of_week = EXTRACT(DOW FROM p_slot_date)::smallint)\n    AND p_slot_time >= start_time\n    AND p_slot_time < end_time\n  ORDER BY day_of_week DESC NULLS LAST\n  LIMIT 1;\n\n  v_capacity := NULL;\n\n  IF v_rules_exist THEN\n    SELECT COALESCE(max_covers, p_default_capacity)\n    INTO v_capacity\n    FROM public.restaurant_capacity_rules\n    WHERE restaurant_id = p_restaurant_id\n      AND (service_period_id IS NULL OR service_period_id = v_service_period_id)\n      AND (day_of_week IS NULL OR day_of_week = EXTRACT(DOW FROM p_slot_date)::smallint)\n      AND (effective_date IS NULL OR effective_date <= p_slot_date)\n    ORDER BY\n      effective_date DESC NULLS LAST,\n      day_of_week DESC NULLS LAST,\n      service_period_id DESC NULLS LAST\n    LIMIT 1;\n  END IF;\n\n  v_capacity := COALESCE(v_capacity, p_default_capacity);\n\n  INSERT INTO public.booking_slots (\n    restaurant_id,\n    slot_date,\n    slot_time,\n    service_period_id,\n    available_capacity,\n    reserved_count\n  ) VALUES (\n    p_restaurant_id,\n    p_slot_date,\n    p_slot_time,\n    v_service_period_id,\n    v_capacity,\n    0\n  )\n  RETURNING id INTO v_slot_id;\n\n  RETURN v_slot_id;\nEND;\n$function$;\n\nALTER FUNCTION public.get_or_create_booking_slot(uuid, date, time without time zone, integer) OWNER TO postgres;\n\nGRANT ALL ON FUNCTION public.get_or_create_booking_slot(uuid, date, time without time zone, integer) TO service_role;\n\nCOMMENT ON FUNCTION public.get_or_create_booking_slot(uuid, date, time without time zone, integer)\n  IS 'Get existing slot or create new one with capacity override fallback (works even if restaurant_capacity_rules is absent).';\n"
    },
    {
      "path": "supabase/migrations/20251027000001_fix_assign_tables_atomic_v2_table_id_v2.sql",
      "content": "-- Fix ambiguous table_id reference in assign_tables_atomic_v2\nDO $$\nBEGIN\n  -- Drop and recreate the function with proper table_id handling\n  CREATE OR REPLACE FUNCTION public.assign_tables_atomic_v2(\n    p_booking_id uuid,\n    p_table_ids uuid[],\n    p_idempotency_key text DEFAULT NULL,\n    p_require_adjacency boolean DEFAULT false,\n    p_assigned_by uuid DEFAULT NULL\n  ) RETURNS TABLE (\n    table_id uuid,\n    start_at timestamptz,\n    end_at timestamptz,\n    merge_group_id uuid\n  )\n  LANGUAGE plpgsql\n  SECURITY DEFINER\n  SET search_path = public\n  AS $function$\n  DECLARE\n    v_booking RECORD;\n    v_zone_id uuid;\n    v_restaurant_id uuid;\n    v_service_date date;\n    v_lock_zone int4;\n    v_lock_date int4;\n    v_now timestamptz := timezone('utc', now());\n    v_table_ids uuid[];\n    v_table_count integer;\n    v_table RECORD;\n    v_loaded_count integer := 0;\n    v_slot_id uuid := NULL;\n    v_start_at timestamptz;\n    v_end_at timestamptz;\n    v_window tstzrange;\n    v_timezone text := NULL;\n    v_hold_conflict uuid;\n    v_merge_allocation_id uuid := NULL;\n    v_table_assignment_id uuid;\n    v_existing RECORD;\n    v_adjacency_count integer;\n    v_table_id uuid;\n    v_merge_group_supported boolean := false;\n  BEGIN\n    IF p_table_ids IS NULL OR array_length(p_table_ids, 1) = 0 THEN\n      RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one table id'\n        USING ERRCODE = '23514';\n    END IF;\n\n    SELECT array_agg(DISTINCT t.table_id ORDER BY t.table_id)\n    INTO v_table_ids\n    FROM unnest(p_table_ids) AS t(table_id);\n\n    IF v_table_ids IS NULL OR array_length(v_table_ids, 1) = 0 THEN\n      RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one valid table id'\n        USING ERRCODE = '23514';\n    END IF;\n\n    v_table_count := array_length(v_table_ids, 1);\n\n    SELECT\n      b.*,\n      r.timezone AS restaurant_timezone\n    INTO v_booking\n    FROM public.bookings b\n    LEFT JOIN public.restaurants r ON r.id = b.restaurant_id\n    WHERE b.id = p_booking_id\n    FOR UPDATE OF b;\n\n    IF NOT FOUND THEN\n      RAISE EXCEPTION 'Booking % not found', p_booking_id\n        USING ERRCODE = 'P0002';\n    END IF;\n\n    v_restaurant_id := v_booking.restaurant_id;\n    v_timezone := COALESCE(NULLIF(v_booking.restaurant_timezone, ''), 'UTC');\n\n    SELECT EXISTS (\n      SELECT 1\n      FROM information_schema.columns\n      WHERE table_schema = 'public'\n        AND table_name = 'booking_table_assignments'\n        AND column_name = 'merge_group_id'\n    )\n    INTO v_merge_group_supported;\n\n    IF v_booking.start_at IS NOT NULL AND v_booking.end_at IS NOT NULL THEN\n      v_start_at := v_booking.start_at;\n      v_end_at := v_booking.end_at;\n    ELSIF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL AND v_booking.end_time IS NOT NULL THEN\n      v_start_at := make_timestamptz(\n        EXTRACT(YEAR FROM v_booking.booking_date)::int,\n        EXTRACT(MONTH FROM v_booking.booking_date)::int,\n        EXTRACT(DAY FROM v_booking.booking_date)::int,\n        EXTRACT(HOUR FROM v_booking.start_time)::int,\n        EXTRACT(MINUTE FROM v_booking.start_time)::int,\n        EXTRACT(SECOND FROM v_booking.start_time),\n        v_timezone\n      );\n      v_end_at := make_timestamptz(\n        EXTRACT(YEAR FROM v_booking.booking_date)::int,\n        EXTRACT(MONTH FROM v_booking.booking_date)::int,\n        EXTRACT(DAY FROM v_booking.booking_date)::int,\n        EXTRACT(HOUR FROM v_booking.end_time)::int,\n        EXTRACT(MINUTE FROM v_booking.end_time)::int,\n        EXTRACT(SECOND FROM v_booking.end_time),\n        v_timezone\n      );\n    ELSE\n      RAISE EXCEPTION 'Booking % missing start/end window', p_booking_id\n        USING ERRCODE = '22000';\n    END IF;\n\n    IF v_start_at >= v_end_at THEN\n      RAISE EXCEPTION 'Booking % has invalid time window', p_booking_id\n        USING ERRCODE = '22000';\n    END IF;\n\n    v_window := tstzrange(v_start_at, v_end_at, '[)');\n\n    FOR v_table IN\n      SELECT id, restaurant_id, zone_id, active, status, mobility\n      FROM public.table_inventory\n      WHERE id = ANY (v_table_ids)\n      ORDER BY id\n      FOR UPDATE\n    LOOP\n      IF v_table.restaurant_id <> v_restaurant_id THEN\n        RAISE EXCEPTION 'Table % belongs to a different restaurant', v_table.id\n          USING ERRCODE = '23503';\n      END IF;\n\n      IF v_table.zone_id IS NULL THEN\n        RAISE EXCEPTION 'Table % is not assigned to a zone', v_table.id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_table.active IS NOT TRUE THEN\n        RAISE EXCEPTION 'Table % is inactive', v_table.id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_zone_id IS NULL THEN\n        v_zone_id := v_table.zone_id;\n      ELSIF v_zone_id <> v_table.zone_id THEN\n        RAISE EXCEPTION 'All tables must belong to the same zone (found %, expected %)', v_table.zone_id, v_zone_id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_table_count > 1 AND v_table.mobility <> 'movable'::public.table_mobility THEN\n        RAISE EXCEPTION 'Merged assignments require movable tables (% is %)', v_table.id, v_table.mobility\n          USING ERRCODE = '23514';\n      END IF;\n\n      v_loaded_count := v_loaded_count + 1;\n    END LOOP;\n\n    IF v_loaded_count <> v_table_count THEN\n      RAISE EXCEPTION 'Unable to load all requested tables for booking %', p_booking_id\n        USING ERRCODE = 'P0002';\n    END IF;\n\n    IF p_require_adjacency AND v_table_count > 1 THEN\n      FOR v_table IN\n        SELECT id FROM unnest(v_table_ids) AS t(id)\n      LOOP\n        SELECT COUNT(*)\n        INTO v_adjacency_count\n        FROM public.table_adjacencies\n        WHERE table_a = v_table.id\n          AND table_b = ANY (v_table_ids)\n          AND table_b <> v_table.id;\n\n        IF COALESCE(v_adjacency_count, 0) = 0 THEN\n          RAISE EXCEPTION 'Table % is not adjacent to the selected set', v_table.id\n            USING ERRCODE = '23514';\n        END IF;\n      END LOOP;\n    END IF;\n\n    v_service_date := v_booking.booking_date;\n    IF v_service_date IS NULL THEN\n      v_service_date := (v_start_at AT TIME ZONE v_timezone)::date;\n    END IF;\n\n    v_lock_zone := hashtext(COALESCE(v_zone_id::text, ''));\n    v_lock_date := COALESCE((v_service_date - DATE '2000-01-01')::int, 0);\n    PERFORM pg_advisory_xact_lock(v_lock_zone, v_lock_date);\n\n    IF p_idempotency_key IS NOT NULL THEN\n      SELECT *\n      INTO v_existing\n      FROM public.booking_assignment_idempotency\n      WHERE booking_id = p_booking_id\n        AND idempotency_key = p_idempotency_key;\n\n      IF FOUND THEN\n        IF v_existing.table_ids IS NULL OR array_length(v_existing.table_ids, 1) <> v_table_count\n           OR (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_existing.table_ids) AS e(elem))\n              <> (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_table_ids) AS e(elem)) THEN\n          RAISE EXCEPTION 'assign_tables_atomic_v2 idempotency mismatch for booking %', p_booking_id\n            USING ERRCODE = 'P0003',\n                  DETAIL = 'Idempotency key reuse detected with a different table set';\n        END IF;\n\n        RETURN QUERY\n          SELECT\n            bta.table_id,\n            lower(v_existing.assignment_window) AS start_at,\n            upper(v_existing.assignment_window) AS end_at,\n            v_existing.merge_group_allocation_id\n          FROM public.booking_table_assignments bta\n          WHERE bta.booking_id = p_booking_id\n            AND bta.idempotency_key = p_idempotency_key\n            AND bta.table_id = ANY (v_table_ids)\n          ORDER BY bta.table_id;\n\n        RETURN;\n      END IF;\n    END IF;\n\n    SELECT th.id\n    INTO v_hold_conflict\n    FROM public.table_holds th\n    JOIN public.table_hold_members thm ON thm.hold_id = th.id\n    WHERE thm.table_id = ANY (v_table_ids)\n      AND th.expires_at > v_now\n      AND (th.booking_id IS NULL OR th.booking_id <> p_booking_id)\n      AND tstzrange(th.start_at, th.end_at, '[)') && v_window\n    LIMIT 1;\n\n    IF FOUND THEN\n      RAISE EXCEPTION 'Hold conflict prevents assignment for booking %', p_booking_id\n        USING ERRCODE = 'P0001',\n              DETAIL = format('Hold % overlaps requested window', v_hold_conflict),\n              HINT = 'Retry after hold expiration or confirm existing hold.';\n    END IF;\n\n    IF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL THEN\n      SELECT id\n      INTO v_slot_id\n      FROM public.booking_slots\n      WHERE restaurant_id = v_restaurant_id\n        AND slot_date = v_booking.booking_date\n        AND slot_time = v_booking.start_time\n      LIMIT 1;\n\n      IF v_slot_id IS NULL THEN\n        SELECT public.get_or_create_booking_slot(v_restaurant_id, v_booking.booking_date, v_booking.start_time, 999)\n        INTO v_slot_id;\n      END IF;\n    END IF;\n\n    IF v_merge_group_supported AND v_table_count > 1 THEN\n      v_merge_allocation_id := gen_random_uuid();\n\n      BEGIN\n        INSERT INTO public.allocations (\n          id,\n          booking_id,\n          restaurant_id,\n          resource_type,\n          resource_id,\n          \"window\",\n          created_by,\n          shadow,\n          created_at,\n          updated_at\n        ) VALUES (\n          v_merge_allocation_id,\n          p_booking_id,\n          v_restaurant_id,\n          'merge_group',\n          v_merge_allocation_id,\n          v_window,\n          p_assigned_by,\n          false,\n          v_now,\n          v_now\n        )\n        ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n        SET \"window\" = EXCLUDED.\"window\",\n            created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n            updated_at = v_now;\n      EXCEPTION\n        WHEN unique_violation OR exclusion_violation THEN\n          RAISE EXCEPTION 'allocations_no_overlap'\n            USING ERRCODE = 'P0001',\n                  DETAIL = format('Merge group overlaps requested window for booking %s', p_booking_id);\n      END;\n    END IF;\n\n    FOREACH v_table_id IN ARRAY v_table_ids LOOP\n      IF v_merge_group_supported THEN\n        BEGIN\n          INSERT INTO public.booking_table_assignments (\n            booking_id,\n            table_id,\n            slot_id,\n            assigned_by,\n            idempotency_key,\n            merge_group_id\n          ) VALUES (\n            p_booking_id,\n            v_table_id,\n            v_slot_id,\n            p_assigned_by,\n            p_idempotency_key,\n            v_merge_allocation_id\n          )\n          ON CONFLICT ON CONSTRAINT booking_table_assignments_booking_table_key DO UPDATE\n          SET assigned_at = v_now,\n              assigned_by = COALESCE(EXCLUDED.assigned_by, public.booking_table_assignments.assigned_by),\n              idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n              merge_group_id = COALESCE(EXCLUDED.merge_group_id, public.booking_table_assignments.merge_group_id),\n              slot_id = COALESCE(EXCLUDED.slot_id, public.booking_table_assignments.slot_id)\n          RETURNING id INTO v_table_assignment_id;\n        EXCEPTION\n          WHEN unique_violation THEN\n            RAISE EXCEPTION 'assign_tables_atomic_v2 assignment duplicate for table %', v_table_id\n              USING ERRCODE = 'P0001';\n        END;\n      ELSE\n        BEGIN\n          INSERT INTO public.booking_table_assignments (\n            booking_id,\n            table_id,\n            slot_id,\n            assigned_by,\n            idempotency_key\n          ) VALUES (\n            p_booking_id,\n            v_table_id,\n            v_slot_id,\n            p_assigned_by,\n            p_idempotency_key\n          )\n          ON CONFLICT ON CONSTRAINT booking_table_assignments_booking_table_key DO UPDATE\n          SET assigned_at = v_now,\n              assigned_by = COALESCE(EXCLUDED.assigned_by, public.booking_table_assignments.assigned_by),\n              idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n              slot_id = COALESCE(EXCLUDED.slot_id, public.booking_table_assignments.slot_id)\n          RETURNING id INTO v_table_assignment_id;\n        EXCEPTION\n          WHEN unique_violation THEN\n            RAISE EXCEPTION 'assign_tables_atomic_v2 assignment duplicate for table %', v_table_id\n              USING ERRCODE = 'P0001';\n        END;\n      END IF;\n\n      BEGIN\n        INSERT INTO public.allocations (\n          booking_id,\n          restaurant_id,\n          resource_type,\n          resource_id,\n          \"window\",\n          created_by,\n          shadow,\n          created_at,\n          updated_at\n        ) VALUES (\n          p_booking_id,\n          v_restaurant_id,\n          'table',\n          v_table_id,\n          v_window,\n          p_assigned_by,\n          false,\n          v_now,\n          v_now\n        )\n        ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n        SET \"window\" = EXCLUDED.\"window\",\n            created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n            updated_at = v_now;\n      EXCEPTION\n        WHEN unique_violation OR exclusion_violation THEN\n          RAISE EXCEPTION 'allocations_no_overlap'\n            USING ERRCODE = 'P0001',\n                  DETAIL = format('Resource %s overlaps requested window for booking %s', v_table_id, p_booking_id);\n      END;\n\n      PERFORM public.refresh_table_status(v_table_id);\n\n      table_id := v_table_id;\n      start_at := v_start_at;\n      end_at := v_end_at;\n      merge_group_id := CASE WHEN v_merge_group_supported THEN v_merge_allocation_id ELSE NULL END;\n      RETURN NEXT;\n    END LOOP;\n\n    IF p_idempotency_key IS NOT NULL THEN\n      INSERT INTO public.booking_assignment_idempotency (\n        booking_id,\n        idempotency_key,\n        table_ids,\n        assignment_window,\n        merge_group_allocation_id,\n        created_at\n      ) VALUES (\n        p_booking_id,\n        p_idempotency_key,\n        v_table_ids,\n        v_window,\n        v_merge_allocation_id,\n        v_now\n      )\n      ON CONFLICT (booking_id, idempotency_key) DO NOTHING;\n    END IF;\n  END;\n  $function$;\n\n  ALTER FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid) OWNER TO postgres;\n  GRANT ALL ON FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid) TO service_role;\n\n  -- Also update get_or_create_booking_slot\n  CREATE OR REPLACE FUNCTION public.get_or_create_booking_slot(\n    p_restaurant_id uuid,\n    p_slot_date date,\n    p_slot_time time without time zone,\n    p_default_capacity integer DEFAULT 999\n  ) RETURNS uuid\n  LANGUAGE plpgsql\n  SECURITY DEFINER\n  AS $function$\n  DECLARE\n    v_slot_id uuid;\n    v_service_period_id uuid;\n    v_capacity integer;\n    v_rules_exist boolean := to_regclass('public.restaurant_capacity_rules') IS NOT NULL;\n  BEGIN\n    SELECT id\n    INTO v_slot_id\n    FROM public.booking_slots\n    WHERE restaurant_id = p_restaurant_id\n      AND slot_date = p_slot_date\n      AND slot_time = p_slot_time;\n\n    IF FOUND THEN\n      RETURN v_slot_id;\n    END IF;\n\n    SELECT id\n    INTO v_service_period_id\n    FROM public.restaurant_service_periods\n    WHERE restaurant_id = p_restaurant_id\n      AND (day_of_week IS NULL OR day_of_week = EXTRACT(DOW FROM p_slot_date)::smallint)\n      AND p_slot_time >= start_time\n      AND p_slot_time < end_time\n    ORDER BY day_of_week DESC NULLS LAST\n    LIMIT 1;\n\n    v_capacity := NULL;\n\n    IF v_rules_exist THEN\n      SELECT COALESCE(max_covers, p_default_capacity)\n      INTO v_capacity\n      FROM public.restaurant_capacity_rules\n      WHERE restaurant_id = p_restaurant_id\n        AND (service_period_id IS NULL OR service_period_id = v_service_period_id)\n        AND (day_of_week IS NULL OR day_of_week = EXTRACT(DOW FROM p_slot_date)::smallint)\n        AND (effective_date IS NULL OR effective_date <= p_slot_date)\n      ORDER BY\n        effective_date DESC NULLS LAST,\n        day_of_week DESC NULLS LAST,\n        service_period_id DESC NULLS LAST\n      LIMIT 1;\n    END IF;\n\n    v_capacity := COALESCE(v_capacity, p_default_capacity);\n\n    INSERT INTO public.booking_slots (\n      restaurant_id,\n      slot_date,\n      slot_time,\n      service_period_id,\n      available_capacity,\n      reserved_count\n    ) VALUES (\n      p_restaurant_id,\n      p_slot_date,\n      p_slot_time,\n      v_service_period_id,\n      v_capacity,\n      0\n    )\n    RETURNING id INTO v_slot_id;\n\n    RETURN v_slot_id;\n  END;\n  $function$;\n\n  ALTER FUNCTION public.get_or_create_booking_slot(uuid, date, time without time zone, integer) OWNER TO postgres;\n  GRANT ALL ON FUNCTION public.get_or_create_booking_slot(uuid, date, time without time zone, integer) TO service_role;\n  COMMENT ON FUNCTION public.get_or_create_booking_slot(uuid, date, time without time zone, integer)\n    IS 'Get existing slot or create new one with capacity override fallback (works even if restaurant_capacity_rules is absent).';\nEND;\n$$;\n"
    },
    {
      "path": "supabase/migrations/20251027115900_check_duplicate_table_slot_assignments.sql",
      "content": "-- Pre-migration check: Identify duplicate table-slot assignments\n-- This is a read-only check that logs warnings if duplicates exist\n\nDO $$\nDECLARE\n    duplicate_count INTEGER;\nBEGIN\n    -- Count duplicates\n    SELECT COUNT(*) INTO duplicate_count\n    FROM (\n        SELECT table_id, slot_id\n        FROM public.booking_table_assignments\n        WHERE slot_id IS NOT NULL\n        GROUP BY table_id, slot_id\n        HAVING COUNT(*) > 1\n    ) dup;\n    \n    -- Log the results\n    IF duplicate_count > 0 THEN\n        RAISE WARNING 'Found % duplicate table-slot assignments. Manual cleanup may be required.', duplicate_count;\n    ELSE\n        RAISE NOTICE 'No duplicate table-slot assignments found. Safe to proceed.';\n    END IF;\nEND $$;\n"
    },
    {
      "path": "supabase/migrations/20251027120000_add_unique_constraint_to_booking_table_assignments.sql",
      "content": "-- Add unique constraint to prevent duplicate table assignments per slot\n-- This enforces that a table can only be assigned to a specific slot once\n\n-- Add the unique constraint\nALTER TABLE public.booking_table_assignments\nADD CONSTRAINT booking_table_assignments_table_id_slot_id_key \nUNIQUE (table_id, slot_id);\n\n-- Create an index to support the constraint (automatically created by UNIQUE)\n-- Note: PostgreSQL automatically creates an index for UNIQUE constraints\n"
    },
    {
      "path": "supabase/migrations/20251027164000_precise_assign_tables_atomic_v2.sql",
      "content": "-- Ensure table assignments use precise time windows and enforce overlap constraints.\nCREATE EXTENSION IF NOT EXISTS btree_gist;\n\nALTER TABLE public.booking_table_assignments\n  ADD COLUMN IF NOT EXISTS start_at timestamptz,\n  ADD COLUMN IF NOT EXISTS end_at timestamptz;\n\nALTER TABLE public.booking_table_assignments\n  DROP CONSTRAINT IF EXISTS no_overlapping_table_assignments;\n\nALTER TABLE public.booking_table_assignments\n  ADD CONSTRAINT no_overlapping_table_assignments\n  EXCLUDE USING gist (\n    table_id WITH =,\n    tstzrange(start_at, end_at, '[)') WITH &&\n  )\n  WHERE (start_at IS NOT NULL AND end_at IS NOT NULL);\n\n-- Recreate assign_tables_atomic_v2 with precise window handling.\nDO $$\nBEGIN\n  -- Drop and recreate the function with precise window handling\n  CREATE OR REPLACE FUNCTION public.assign_tables_atomic_v2(\n    p_booking_id uuid,\n    p_table_ids uuid[],\n    p_idempotency_key text DEFAULT NULL,\n    p_require_adjacency boolean DEFAULT false,\n    p_assigned_by uuid DEFAULT NULL,\n    p_start_at timestamptz DEFAULT NULL,\n    p_end_at timestamptz DEFAULT NULL\n  ) RETURNS TABLE (\n    table_id uuid,\n    start_at timestamptz,\n    end_at timestamptz,\n    merge_group_id uuid\n  )\n  LANGUAGE plpgsql\n  SECURITY DEFINER\n  SET search_path = public\n  AS $function$\n  DECLARE\n    v_booking RECORD;\n    v_zone_id uuid;\n    v_restaurant_id uuid;\n    v_service_date date;\n    v_lock_zone int4;\n    v_lock_date int4;\n    v_now timestamptz := timezone('utc', now());\n    v_table_ids uuid[];\n    v_table_count integer;\n    v_table RECORD;\n    v_loaded_count integer := 0;\n    v_slot_id uuid := NULL;\n    v_start_at timestamptz;\n    v_end_at timestamptz;\n    v_window tstzrange;\n    v_timezone text := NULL;\n    v_hold_conflict uuid;\n    v_merge_allocation_id uuid := NULL;\n    v_table_assignment_id uuid;\n    v_existing RECORD;\n    v_adjacency_count integer;\n    v_table_id uuid;\n    v_merge_group_supported boolean := false;\n    v_conflict RECORD;\n  BEGIN\n    IF p_table_ids IS NULL OR array_length(p_table_ids, 1) = 0 THEN\n      RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one table id'\n        USING ERRCODE = '23514';\n    END IF;\n\n    SELECT array_agg(DISTINCT t.table_id ORDER BY t.table_id)\n    INTO v_table_ids\n    FROM unnest(p_table_ids) AS t(table_id);\n\n    IF v_table_ids IS NULL OR array_length(v_table_ids, 1) = 0 THEN\n      RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one valid table id'\n        USING ERRCODE = '23514';\n    END IF;\n\n    v_table_count := array_length(v_table_ids, 1);\n\n    SELECT\n      b.*,\n      r.timezone AS restaurant_timezone\n    INTO v_booking\n    FROM public.bookings b\n    LEFT JOIN public.restaurants r ON r.id = b.restaurant_id\n    WHERE b.id = p_booking_id\n    FOR UPDATE OF b;\n\n    IF NOT FOUND THEN\n      RAISE EXCEPTION 'Booking % not found', p_booking_id\n        USING ERRCODE = 'P0002';\n    END IF;\n\n    v_restaurant_id := v_booking.restaurant_id;\n    v_timezone := COALESCE(NULLIF(v_booking.restaurant_timezone, ''), 'UTC');\n\n    SELECT EXISTS (\n      SELECT 1\n      FROM information_schema.columns\n      WHERE table_schema = 'public'\n        AND table_name = 'booking_table_assignments'\n        AND column_name = 'merge_group_id'\n    )\n    INTO v_merge_group_supported;\n\n    IF (p_start_at IS NULL) <> (p_end_at IS NULL) THEN\n      RAISE EXCEPTION 'assign_tables_atomic_v2 requires both start and end when providing custom window'\n        USING ERRCODE = '22023';\n    END IF;\n\n    IF p_start_at IS NOT NULL AND p_end_at IS NOT NULL THEN\n      v_start_at := p_start_at;\n      v_end_at := p_end_at;\n    ELSIF v_booking.start_at IS NOT NULL AND v_booking.end_at IS NOT NULL THEN\n      v_start_at := v_booking.start_at;\n      v_end_at := v_booking.end_at;\n    ELSIF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL AND v_booking.end_time IS NOT NULL THEN\n      v_start_at := make_timestamptz(\n        EXTRACT(YEAR FROM v_booking.booking_date)::int,\n        EXTRACT(MONTH FROM v_booking.booking_date)::int,\n        EXTRACT(DAY FROM v_booking.booking_date)::int,\n        EXTRACT(HOUR FROM v_booking.start_time)::int,\n        EXTRACT(MINUTE FROM v_booking.start_time)::int,\n        EXTRACT(SECOND FROM v_booking.start_time),\n        v_timezone\n      );\n      v_end_at := make_timestamptz(\n        EXTRACT(YEAR FROM v_booking.booking_date)::int,\n        EXTRACT(MONTH FROM v_booking.booking_date)::int,\n        EXTRACT(DAY FROM v_booking.booking_date)::int,\n        EXTRACT(HOUR FROM v_booking.end_time)::int,\n        EXTRACT(MINUTE FROM v_booking.end_time)::int,\n        EXTRACT(SECOND FROM v_booking.end_time),\n        v_timezone\n      );\n    ELSE\n      RAISE EXCEPTION 'Booking % missing start/end window', p_booking_id\n        USING ERRCODE = '22000';\n    END IF;\n\n    IF v_start_at >= v_end_at THEN\n      RAISE EXCEPTION 'Booking % has invalid time window', p_booking_id\n        USING ERRCODE = '22000';\n    END IF;\n\n    v_window := tstzrange(v_start_at, v_end_at, '[)');\n\n    FOR v_table IN\n      SELECT id, restaurant_id, zone_id, active, status, mobility\n      FROM public.table_inventory\n      WHERE id = ANY (v_table_ids)\n      ORDER BY id\n      FOR UPDATE\n    LOOP\n      IF v_table.restaurant_id <> v_restaurant_id THEN\n        RAISE EXCEPTION 'Table % belongs to a different restaurant', v_table.id\n          USING ERRCODE = '23503';\n      END IF;\n\n      IF v_table.zone_id IS NULL THEN\n        RAISE EXCEPTION 'Table % is not assigned to a zone', v_table.id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_table.active IS NOT TRUE THEN\n        RAISE EXCEPTION 'Table % is inactive', v_table.id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_zone_id IS NULL THEN\n        v_zone_id := v_table.zone_id;\n      ELSIF v_zone_id <> v_table.zone_id THEN\n        RAISE EXCEPTION 'All tables must belong to the same zone (found %, expected %)', v_table.zone_id, v_zone_id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_table_count > 1 AND v_table.mobility <> 'movable'::public.table_mobility THEN\n        RAISE EXCEPTION 'Merged assignments require movable tables (% is %)', v_table.id, v_table.mobility\n          USING ERRCODE = '23514';\n      END IF;\n\n      v_loaded_count := v_loaded_count + 1;\n    END LOOP;\n\n    IF v_loaded_count <> v_table_count THEN\n      RAISE EXCEPTION 'Unable to load all requested tables for booking %', p_booking_id\n        USING ERRCODE = 'P0002';\n    END IF;\n\n    IF p_require_adjacency AND v_table_count > 1 THEN\n      FOR v_table IN\n        SELECT id FROM unnest(v_table_ids) AS t(id)\n      LOOP\n        SELECT COUNT(*)\n        INTO v_adjacency_count\n        FROM public.table_adjacencies\n        WHERE table_a = v_table.id\n          AND table_b = ANY (v_table_ids)\n          AND table_b <> v_table.id;\n\n        IF COALESCE(v_adjacency_count, 0) = 0 THEN\n          RAISE EXCEPTION 'Table % is not adjacent to the selected set', v_table.id\n            USING ERRCODE = '23514';\n        END IF;\n      END LOOP;\n    END IF;\n\n    v_service_date := (v_start_at AT TIME ZONE v_timezone)::date;\n\n    v_lock_zone := hashtext(COALESCE(v_zone_id::text, ''));\n    v_lock_date := COALESCE((v_service_date - DATE '2000-01-01')::int, 0);\n    PERFORM pg_advisory_xact_lock(v_lock_zone, v_lock_date);\n\n    IF p_idempotency_key IS NOT NULL THEN\n      SELECT *\n      INTO v_existing\n      FROM public.booking_assignment_idempotency\n      WHERE booking_id = p_booking_id\n        AND idempotency_key = p_idempotency_key;\n\n      IF FOUND THEN\n        IF v_existing.table_ids IS NULL OR array_length(v_existing.table_ids, 1) <> v_table_count\n           OR (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_existing.table_ids) AS e(elem))\n              <> (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_table_ids) AS e(elem)) THEN\n          RAISE EXCEPTION 'assign_tables_atomic_v2 idempotency mismatch for booking %', p_booking_id\n            USING ERRCODE = 'P0003',\n                  DETAIL = 'Idempotency key reuse detected with a different table set';\n        END IF;\n\n        RETURN QUERY\n          SELECT\n            bta.table_id,\n            COALESCE(bta.start_at, lower(v_existing.assignment_window)) AS start_at,\n            COALESCE(bta.end_at, upper(v_existing.assignment_window)) AS end_at,\n            v_existing.merge_group_allocation_id\n          FROM public.booking_table_assignments bta\n          WHERE bta.booking_id = p_booking_id\n            AND bta.idempotency_key = p_idempotency_key\n            AND bta.table_id = ANY (v_table_ids)\n          ORDER BY bta.table_id;\n\n        RETURN;\n      END IF;\n    END IF;\n\n    SELECT th.id\n    INTO v_hold_conflict\n    FROM public.table_holds th\n    JOIN public.table_hold_members thm ON thm.hold_id = th.id\n    WHERE thm.table_id = ANY (v_table_ids)\n      AND th.expires_at > v_now\n      AND (th.booking_id IS NULL OR th.booking_id <> p_booking_id)\n      AND tstzrange(th.start_at, th.end_at, '[)') && v_window\n    LIMIT 1;\n\n    IF FOUND THEN\n      RAISE EXCEPTION 'Hold conflict prevents assignment for booking %', p_booking_id\n        USING ERRCODE = 'P0001',\n              DETAIL = format('Hold % overlaps requested window', v_hold_conflict),\n              HINT = 'Retry after hold expiration or confirm existing hold.';\n    END IF;\n\n    IF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL THEN\n      SELECT id\n      INTO v_slot_id\n      FROM public.booking_slots\n      WHERE restaurant_id = v_restaurant_id\n        AND slot_date = v_booking.booking_date\n        AND slot_time = v_booking.start_time\n      LIMIT 1;\n\n      IF v_slot_id IS NULL THEN\n        SELECT public.get_or_create_booking_slot(v_restaurant_id, v_booking.booking_date, v_booking.start_time, 999)\n        INTO v_slot_id;\n      END IF;\n    END IF;\n\n    IF v_merge_group_supported AND v_table_count > 1 THEN\n      v_merge_allocation_id := gen_random_uuid();\n\n      BEGIN\n        INSERT INTO public.allocations (\n          id,\n          booking_id,\n          restaurant_id,\n          resource_type,\n          resource_id,\n          \"window\",\n          created_by,\n          shadow,\n          created_at,\n          updated_at\n        ) VALUES (\n          v_merge_allocation_id,\n          p_booking_id,\n          v_restaurant_id,\n          'merge_group',\n          v_merge_allocation_id,\n          v_window,\n          p_assigned_by,\n          false,\n          v_now,\n          v_now\n        )\n        ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n        SET \"window\" = EXCLUDED.\"window\",\n            created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n            updated_at = v_now;\n      EXCEPTION\n        WHEN unique_violation OR exclusion_violation THEN\n          RAISE EXCEPTION 'allocations_no_overlap'\n            USING ERRCODE = 'P0001',\n                  DETAIL = format('Merge group overlaps requested window for booking %s', p_booking_id);\n      END;\n    END IF;\n\n    FOREACH v_table_id IN ARRAY v_table_ids LOOP\n      SELECT\n        existing.booking_id,\n        existing.start_at,\n        existing.end_at\n      INTO v_conflict\n      FROM public.booking_table_assignments existing\n      WHERE existing.table_id = v_table_id\n        AND existing.booking_id <> p_booking_id\n        AND existing.start_at IS NOT NULL\n        AND existing.end_at IS NOT NULL\n        AND tstzrange(existing.start_at, existing.end_at, '[)') && v_window\n      LIMIT 1;\n\n      IF FOUND THEN\n        RAISE EXCEPTION 'assign_tables_atomic_v2 assignment overlap for table %', v_table_id\n          USING ERRCODE = 'P0001',\n                DETAIL = format('Existing booking %s occupies %s from %s to %s', v_conflict.booking_id, v_table_id, v_conflict.start_at, v_conflict.end_at),\n                HINT = 'Adjust assignment window or release the conflicting table.';\n      END IF;\n\n      v_conflict := NULL;\n\n      IF v_merge_group_supported THEN\n        BEGIN\n          INSERT INTO public.booking_table_assignments (\n            booking_id,\n            table_id,\n            slot_id,\n            assigned_by,\n            idempotency_key,\n            merge_group_id,\n            start_at,\n            end_at\n          ) VALUES (\n            p_booking_id,\n            v_table_id,\n            v_slot_id,\n            p_assigned_by,\n            p_idempotency_key,\n            v_merge_allocation_id,\n            v_start_at,\n            v_end_at\n          )\n          ON CONFLICT ON CONSTRAINT booking_table_assignments_booking_table_key DO UPDATE\n          SET assigned_at = v_now,\n              assigned_by = COALESCE(EXCLUDED.assigned_by, public.booking_table_assignments.assigned_by),\n              idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n              merge_group_id = COALESCE(EXCLUDED.merge_group_id, public.booking_table_assignments.merge_group_id),\n              slot_id = COALESCE(EXCLUDED.slot_id, public.booking_table_assignments.slot_id),\n              start_at = EXCLUDED.start_at,\n              end_at = EXCLUDED.end_at,\n              updated_at = v_now\n          RETURNING id INTO v_table_assignment_id;\n        EXCEPTION\n          WHEN unique_violation THEN\n            RAISE EXCEPTION 'assign_tables_atomic_v2 assignment duplicate for table %', v_table_id\n              USING ERRCODE = 'P0001';\n        END;\n      ELSE\n        BEGIN\n          INSERT INTO public.booking_table_assignments (\n            booking_id,\n            table_id,\n            slot_id,\n            assigned_by,\n            idempotency_key,\n            start_at,\n            end_at\n          ) VALUES (\n            p_booking_id,\n            v_table_id,\n            v_slot_id,\n            p_assigned_by,\n            p_idempotency_key,\n            v_start_at,\n            v_end_at\n          )\n          ON CONFLICT ON CONSTRAINT booking_table_assignments_booking_table_key DO UPDATE\n          SET assigned_at = v_now,\n              assigned_by = COALESCE(EXCLUDED.assigned_by, public.booking_table_assignments.assigned_by),\n              idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n              slot_id = COALESCE(EXCLUDED.slot_id, public.booking_table_assignments.slot_id),\n              start_at = EXCLUDED.start_at,\n              end_at = EXCLUDED.end_at,\n              updated_at = v_now\n          RETURNING id INTO v_table_assignment_id;\n        EXCEPTION\n          WHEN unique_violation THEN\n            RAISE EXCEPTION 'assign_tables_atomic_v2 assignment duplicate for table %', v_table_id\n              USING ERRCODE = 'P0001';\n        END;\n      END IF;\n\n      BEGIN\n        INSERT INTO public.allocations (\n          booking_id,\n          restaurant_id,\n          resource_type,\n          resource_id,\n          \"window\",\n          created_by,\n          shadow,\n          created_at,\n          updated_at\n        ) VALUES (\n          p_booking_id,\n          v_restaurant_id,\n          'table',\n          v_table_id,\n          v_window,\n          p_assigned_by,\n          false,\n          v_now,\n          v_now\n        )\n        ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n        SET \"window\" = EXCLUDED.\"window\",\n            created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n            updated_at = v_now;\n      EXCEPTION\n        WHEN unique_violation OR exclusion_violation THEN\n          RAISE EXCEPTION 'allocations_no_overlap'\n            USING ERRCODE = 'P0001',\n                  DETAIL = format('Resource %s overlaps requested window for booking %s', v_table_id, p_booking_id);\n      END;\n\n      PERFORM public.refresh_table_status(v_table_id);\n\n      table_id := v_table_id;\n      start_at := v_start_at;\n      end_at := v_end_at;\n      merge_group_id := CASE WHEN v_merge_group_supported THEN v_merge_allocation_id ELSE NULL END;\n      RETURN NEXT;\n    END LOOP;\n\n    IF p_idempotency_key IS NOT NULL THEN\n      INSERT INTO public.booking_assignment_idempotency (\n        booking_id,\n        idempotency_key,\n        table_ids,\n        assignment_window,\n        merge_group_allocation_id,\n        created_at\n      ) VALUES (\n        p_booking_id,\n        p_idempotency_key,\n        v_table_ids,\n        v_window,\n        v_merge_allocation_id,\n        v_now\n      )\n      ON CONFLICT (booking_id, idempotency_key) DO NOTHING;\n    END IF;\n  END;\n  $function$;\n\n  ALTER FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid, timestamptz, timestamptz) OWNER TO postgres;\n  GRANT ALL ON FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid, timestamptz, timestamptz) TO service_role;\n\nEND;\n$$;\n"
    },
    {
      "path": "supabase/migrations/20251027211000_assign_tables_atomic_v2_undirected.sql",
      "content": "-- Ensure table assignments use precise time windows and treat adjacency edges as undirected.\nCREATE EXTENSION IF NOT EXISTS btree_gist;\n\nALTER TABLE public.booking_table_assignments\n  ADD COLUMN IF NOT EXISTS start_at timestamptz,\n  ADD COLUMN IF NOT EXISTS end_at timestamptz;\n\nALTER TABLE public.booking_table_assignments\n  DROP CONSTRAINT IF EXISTS no_overlapping_table_assignments;\n\nALTER TABLE public.booking_table_assignments\n  ADD CONSTRAINT no_overlapping_table_assignments\n  EXCLUDE USING gist (\n    table_id WITH =,\n    tstzrange(start_at, end_at, '[)') WITH &&\n  )\n  WHERE (start_at IS NOT NULL AND end_at IS NOT NULL);\n\n-- Recreate assign_tables_atomic_v2 with precise window handling.\nDO $$\nBEGIN\n  -- Drop and recreate the function with precise window handling\n  CREATE OR REPLACE FUNCTION public.assign_tables_atomic_v2(\n    p_booking_id uuid,\n    p_table_ids uuid[],\n    p_idempotency_key text DEFAULT NULL,\n    p_require_adjacency boolean DEFAULT false,\n    p_assigned_by uuid DEFAULT NULL,\n    p_start_at timestamptz DEFAULT NULL,\n    p_end_at timestamptz DEFAULT NULL\n  ) RETURNS TABLE (\n    table_id uuid,\n    start_at timestamptz,\n    end_at timestamptz,\n    merge_group_id uuid\n  )\n  LANGUAGE plpgsql\n  SECURITY DEFINER\n  SET search_path = public\n  AS $function$\n  DECLARE\n    v_booking RECORD;\n    v_zone_id uuid;\n    v_restaurant_id uuid;\n    v_service_date date;\n    v_lock_zone int4;\n    v_lock_date int4;\n    v_now timestamptz := timezone('utc', now());\n    v_table_ids uuid[];\n    v_table_count integer;\n    v_table RECORD;\n    v_loaded_count integer := 0;\n    v_slot_id uuid := NULL;\n    v_start_at timestamptz;\n    v_end_at timestamptz;\n    v_window tstzrange;\n    v_timezone text := NULL;\n    v_hold_conflict uuid;\n    v_merge_allocation_id uuid := NULL;\n    v_table_assignment_id uuid;\n    v_existing RECORD;\n    v_adjacency_count integer;\n    v_table_id uuid;\n    v_merge_group_supported boolean := false;\n    v_conflict RECORD;\n  BEGIN\n    IF p_table_ids IS NULL OR array_length(p_table_ids, 1) = 0 THEN\n      RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one table id'\n        USING ERRCODE = '23514';\n    END IF;\n\n    SELECT array_agg(DISTINCT t.table_id ORDER BY t.table_id)\n    INTO v_table_ids\n    FROM unnest(p_table_ids) AS t(table_id);\n\n    IF v_table_ids IS NULL OR array_length(v_table_ids, 1) = 0 THEN\n      RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one valid table id'\n        USING ERRCODE = '23514';\n    END IF;\n\n    v_table_count := array_length(v_table_ids, 1);\n\n    SELECT\n      b.*,\n      r.timezone AS restaurant_timezone\n    INTO v_booking\n    FROM public.bookings b\n    LEFT JOIN public.restaurants r ON r.id = b.restaurant_id\n    WHERE b.id = p_booking_id\n    FOR UPDATE OF b;\n\n    IF NOT FOUND THEN\n      RAISE EXCEPTION 'Booking % not found', p_booking_id\n        USING ERRCODE = 'P0002';\n    END IF;\n\n    v_restaurant_id := v_booking.restaurant_id;\n    v_timezone := COALESCE(NULLIF(v_booking.restaurant_timezone, ''), 'UTC');\n\n    SELECT EXISTS (\n      SELECT 1\n      FROM information_schema.columns\n      WHERE table_schema = 'public'\n        AND table_name = 'booking_table_assignments'\n        AND column_name = 'merge_group_id'\n    )\n    INTO v_merge_group_supported;\n\n    IF (p_start_at IS NULL) <> (p_end_at IS NULL) THEN\n      RAISE EXCEPTION 'assign_tables_atomic_v2 requires both start and end when providing custom window'\n        USING ERRCODE = '22023';\n    END IF;\n\n    IF p_start_at IS NOT NULL AND p_end_at IS NOT NULL THEN\n      v_start_at := p_start_at;\n      v_end_at := p_end_at;\n    ELSIF v_booking.start_at IS NOT NULL AND v_booking.end_at IS NOT NULL THEN\n      v_start_at := v_booking.start_at;\n      v_end_at := v_booking.end_at;\n    ELSIF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL AND v_booking.end_time IS NOT NULL THEN\n      v_start_at := make_timestamptz(\n        EXTRACT(YEAR FROM v_booking.booking_date)::int,\n        EXTRACT(MONTH FROM v_booking.booking_date)::int,\n        EXTRACT(DAY FROM v_booking.booking_date)::int,\n        EXTRACT(HOUR FROM v_booking.start_time)::int,\n        EXTRACT(MINUTE FROM v_booking.start_time)::int,\n        EXTRACT(SECOND FROM v_booking.start_time),\n        v_timezone\n      );\n      v_end_at := make_timestamptz(\n        EXTRACT(YEAR FROM v_booking.booking_date)::int,\n        EXTRACT(MONTH FROM v_booking.booking_date)::int,\n        EXTRACT(DAY FROM v_booking.booking_date)::int,\n        EXTRACT(HOUR FROM v_booking.end_time)::int,\n        EXTRACT(MINUTE FROM v_booking.end_time)::int,\n        EXTRACT(SECOND FROM v_booking.end_time),\n        v_timezone\n      );\n    ELSE\n      RAISE EXCEPTION 'Booking % missing start/end window', p_booking_id\n        USING ERRCODE = '22000';\n    END IF;\n\n    IF v_start_at >= v_end_at THEN\n      RAISE EXCEPTION 'Booking % has invalid time window', p_booking_id\n        USING ERRCODE = '22000';\n    END IF;\n\n    v_window := tstzrange(v_start_at, v_end_at, '[)');\n\n    FOR v_table IN\n      SELECT id, restaurant_id, zone_id, active, status, mobility\n      FROM public.table_inventory\n      WHERE id = ANY (v_table_ids)\n      ORDER BY id\n      FOR UPDATE\n    LOOP\n      IF v_table.restaurant_id <> v_restaurant_id THEN\n        RAISE EXCEPTION 'Table % belongs to a different restaurant', v_table.id\n          USING ERRCODE = '23503';\n      END IF;\n\n      IF v_table.zone_id IS NULL THEN\n        RAISE EXCEPTION 'Table % is not assigned to a zone', v_table.id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_table.active IS NOT TRUE THEN\n        RAISE EXCEPTION 'Table % is inactive', v_table.id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_zone_id IS NULL THEN\n        v_zone_id := v_table.zone_id;\n      ELSIF v_zone_id <> v_table.zone_id THEN\n        RAISE EXCEPTION 'All tables must belong to the same zone (found %, expected %)', v_table.zone_id, v_zone_id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_table_count > 1 AND v_table.mobility <> 'movable'::public.table_mobility THEN\n        RAISE EXCEPTION 'Merged assignments require movable tables (% is %)', v_table.id, v_table.mobility\n          USING ERRCODE = '23514';\n      END IF;\n\n      v_loaded_count := v_loaded_count + 1;\n    END LOOP;\n\n    IF v_loaded_count <> v_table_count THEN\n      RAISE EXCEPTION 'Unable to load all requested tables for booking %', p_booking_id\n        USING ERRCODE = 'P0002';\n    END IF;\n\n    IF p_require_adjacency AND v_table_count > 1 THEN\n      FOR v_table IN\n        SELECT id FROM unnest(v_table_ids) AS t(id)\n      LOOP\n        SELECT COUNT(*)\n        INTO v_adjacency_count\n        FROM public.table_adjacencies\n        WHERE (\n            table_a = v_table.id\n            AND table_b = ANY (v_table_ids)\n            AND table_b <> v_table.id\n          )\n          OR (\n            table_b = v_table.id\n            AND table_a = ANY (v_table_ids)\n            AND table_a <> v_table.id\n          );\n\n        IF COALESCE(v_adjacency_count, 0) = 0 THEN\n          RAISE EXCEPTION 'Table % is not adjacent to the selected set', v_table.id\n            USING ERRCODE = '23514';\n        END IF;\n      END LOOP;\n    END IF;\n\n    v_service_date := (v_start_at AT TIME ZONE v_timezone)::date;\n\n    v_lock_zone := hashtext(COALESCE(v_zone_id::text, ''));\n    v_lock_date := COALESCE((v_service_date - DATE '2000-01-01')::int, 0);\n    PERFORM pg_advisory_xact_lock(v_lock_zone, v_lock_date);\n\n    IF p_idempotency_key IS NOT NULL THEN\n      SELECT *\n      INTO v_existing\n      FROM public.booking_assignment_idempotency\n      WHERE booking_id = p_booking_id\n        AND idempotency_key = p_idempotency_key;\n\n      IF FOUND THEN\n        IF v_existing.table_ids IS NULL OR array_length(v_existing.table_ids, 1) <> v_table_count\n           OR (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_existing.table_ids) AS e(elem))\n              <> (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_table_ids) AS e(elem)) THEN\n          RAISE EXCEPTION 'assign_tables_atomic_v2 idempotency mismatch for booking %', p_booking_id\n            USING ERRCODE = 'P0003',\n                  DETAIL = 'Idempotency key reuse detected with a different table set';\n        END IF;\n\n        RETURN QUERY\n          SELECT\n            bta.table_id,\n            COALESCE(bta.start_at, lower(v_existing.assignment_window)) AS start_at,\n            COALESCE(bta.end_at, upper(v_existing.assignment_window)) AS end_at,\n            v_existing.merge_group_allocation_id\n          FROM public.booking_table_assignments bta\n          WHERE bta.booking_id = p_booking_id\n            AND bta.idempotency_key = p_idempotency_key\n            AND bta.table_id = ANY (v_table_ids)\n          ORDER BY bta.table_id;\n\n        RETURN;\n      END IF;\n    END IF;\n\n    SELECT th.id\n    INTO v_hold_conflict\n    FROM public.table_holds th\n    JOIN public.table_hold_members thm ON thm.hold_id = th.id\n    WHERE thm.table_id = ANY (v_table_ids)\n      AND th.expires_at > v_now\n      AND (th.booking_id IS NULL OR th.booking_id <> p_booking_id)\n      AND tstzrange(th.start_at, th.end_at, '[)') && v_window\n    LIMIT 1;\n\n    IF FOUND THEN\n      RAISE EXCEPTION 'Hold conflict prevents assignment for booking %', p_booking_id\n        USING ERRCODE = 'P0001',\n              DETAIL = format('Hold % overlaps requested window', v_hold_conflict),\n              HINT = 'Retry after hold expiration or confirm existing hold.';\n    END IF;\n\n    IF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL THEN\n      SELECT id\n      INTO v_slot_id\n      FROM public.booking_slots\n      WHERE restaurant_id = v_restaurant_id\n        AND slot_date = v_booking.booking_date\n        AND slot_time = v_booking.start_time\n      LIMIT 1;\n\n      IF v_slot_id IS NULL THEN\n        SELECT public.get_or_create_booking_slot(v_restaurant_id, v_booking.booking_date, v_booking.start_time, 999)\n        INTO v_slot_id;\n      END IF;\n    END IF;\n\n    IF v_merge_group_supported AND v_table_count > 1 THEN\n      v_merge_allocation_id := gen_random_uuid();\n\n      BEGIN\n        INSERT INTO public.allocations (\n          id,\n          booking_id,\n          restaurant_id,\n          resource_type,\n          resource_id,\n          \"window\",\n          created_by,\n          shadow,\n          created_at,\n          updated_at\n        ) VALUES (\n          v_merge_allocation_id,\n          p_booking_id,\n          v_restaurant_id,\n          'merge_group',\n          v_merge_allocation_id,\n          v_window,\n          p_assigned_by,\n          false,\n          v_now,\n          v_now\n        )\n        ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n        SET \"window\" = EXCLUDED.\"window\",\n            created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n            updated_at = v_now;\n      EXCEPTION\n        WHEN unique_violation OR exclusion_violation THEN\n          RAISE EXCEPTION 'allocations_no_overlap'\n            USING ERRCODE = 'P0001',\n                  DETAIL = format('Merge group overlaps requested window for booking %s', p_booking_id);\n      END;\n    END IF;\n\n    FOREACH v_table_id IN ARRAY v_table_ids LOOP\n      SELECT\n        existing.booking_id,\n        existing.start_at,\n        existing.end_at\n      INTO v_conflict\n      FROM public.booking_table_assignments existing\n      WHERE existing.table_id = v_table_id\n        AND existing.booking_id <> p_booking_id\n        AND existing.start_at IS NOT NULL\n        AND existing.end_at IS NOT NULL\n        AND tstzrange(existing.start_at, existing.end_at, '[)') && v_window\n      LIMIT 1;\n\n      IF FOUND THEN\n        RAISE EXCEPTION 'assign_tables_atomic_v2 assignment overlap for table %', v_table_id\n          USING ERRCODE = 'P0001',\n                DETAIL = format('Existing booking %s occupies %s from %s to %s', v_conflict.booking_id, v_table_id, v_conflict.start_at, v_conflict.end_at),\n                HINT = 'Adjust assignment window or release the conflicting table.';\n      END IF;\n\n      v_conflict := NULL;\n\n      IF v_merge_group_supported THEN\n        BEGIN\n          INSERT INTO public.booking_table_assignments (\n            booking_id,\n            table_id,\n            slot_id,\n            assigned_by,\n            idempotency_key,\n            merge_group_id,\n            start_at,\n            end_at\n          ) VALUES (\n            p_booking_id,\n            v_table_id,\n            v_slot_id,\n            p_assigned_by,\n            p_idempotency_key,\n            v_merge_allocation_id,\n            v_start_at,\n            v_end_at\n          )\n        ON CONFLICT ON CONSTRAINT booking_table_assignments_booking_table_key DO UPDATE\n          SET assigned_at = v_now,\n              assigned_by = COALESCE(EXCLUDED.assigned_by, public.booking_table_assignments.assigned_by),\n              idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n              merge_group_id = COALESCE(EXCLUDED.merge_group_id, public.booking_table_assignments.merge_group_id),\n              slot_id = COALESCE(EXCLUDED.slot_id, public.booking_table_assignments.slot_id),\n              start_at = EXCLUDED.start_at,\n              end_at = EXCLUDED.end_at,\n              updated_at = v_now\n          RETURNING id INTO v_table_assignment_id;\n        EXCEPTION\n          WHEN unique_violation THEN\n            UPDATE public.booking_table_assignments AS bta\n              SET assigned_at = v_now,\n                  assigned_by = COALESCE(p_assigned_by, bta.assigned_by),\n                  idempotency_key = COALESCE(p_idempotency_key, bta.idempotency_key),\n                  merge_group_id = COALESCE(v_merge_allocation_id, bta.merge_group_id),\n                  slot_id = COALESCE(v_slot_id, bta.slot_id),\n                  start_at = v_start_at,\n                  end_at = v_end_at,\n                  updated_at = v_now\n            WHERE bta.booking_id = p_booking_id\n              AND bta.table_id = v_table_id\n            RETURNING bta.id INTO v_table_assignment_id;\n\n            IF NOT FOUND THEN\n              RAISE EXCEPTION 'assign_tables_atomic_v2 assignment duplicate for table %', v_table_id\n                USING ERRCODE = 'P0001';\n            END IF;\n        END;\n      ELSE\n        BEGIN\n          INSERT INTO public.booking_table_assignments (\n            booking_id,\n            table_id,\n            slot_id,\n            assigned_by,\n            idempotency_key,\n            start_at,\n            end_at\n          ) VALUES (\n            p_booking_id,\n            v_table_id,\n            v_slot_id,\n            p_assigned_by,\n            p_idempotency_key,\n            v_start_at,\n            v_end_at\n          )\n          ON CONFLICT ON CONSTRAINT booking_table_assignments_booking_table_key DO UPDATE\n          SET assigned_at = v_now,\n              assigned_by = COALESCE(EXCLUDED.assigned_by, public.booking_table_assignments.assigned_by),\n              idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n              slot_id = COALESCE(EXCLUDED.slot_id, public.booking_table_assignments.slot_id),\n              start_at = EXCLUDED.start_at,\n              end_at = EXCLUDED.end_at,\n              updated_at = v_now\n          RETURNING id INTO v_table_assignment_id;\n        EXCEPTION\n          WHEN unique_violation THEN\n            UPDATE public.booking_table_assignments AS bta\n              SET assigned_at = v_now,\n                  assigned_by = COALESCE(p_assigned_by, bta.assigned_by),\n                  idempotency_key = COALESCE(p_idempotency_key, bta.idempotency_key),\n                  slot_id = COALESCE(v_slot_id, bta.slot_id),\n                  start_at = v_start_at,\n                  end_at = v_end_at,\n                  updated_at = v_now\n            WHERE bta.booking_id = p_booking_id\n              AND bta.table_id = v_table_id\n            RETURNING bta.id INTO v_table_assignment_id;\n\n            IF NOT FOUND THEN\n              RAISE EXCEPTION 'assign_tables_atomic_v2 assignment duplicate for table %', v_table_id\n                USING ERRCODE = 'P0001';\n            END IF;\n        END;\n      END IF;\n\n      BEGIN\n        INSERT INTO public.allocations (\n          booking_id,\n          restaurant_id,\n          resource_type,\n          resource_id,\n          \"window\",\n          created_by,\n          shadow,\n          created_at,\n          updated_at\n        ) VALUES (\n          p_booking_id,\n          v_restaurant_id,\n          'table',\n          v_table_id,\n          v_window,\n          p_assigned_by,\n          false,\n          v_now,\n          v_now\n        )\n        ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n        SET \"window\" = EXCLUDED.\"window\",\n            created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n            updated_at = v_now;\n      EXCEPTION\n        WHEN unique_violation OR exclusion_violation THEN\n          RAISE EXCEPTION 'allocations_no_overlap'\n            USING ERRCODE = 'P0001',\n                  DETAIL = format('Resource %s overlaps requested window for booking %s', v_table_id, p_booking_id);\n      END;\n\n      PERFORM public.refresh_table_status(v_table_id);\n\n      table_id := v_table_id;\n      start_at := v_start_at;\n      end_at := v_end_at;\n      merge_group_id := CASE WHEN v_merge_group_supported THEN v_merge_allocation_id ELSE NULL END;\n      RETURN NEXT;\n    END LOOP;\n\n    IF p_idempotency_key IS NOT NULL THEN\n      INSERT INTO public.booking_assignment_idempotency (\n        booking_id,\n        idempotency_key,\n        table_ids,\n        assignment_window,\n        merge_group_allocation_id,\n        created_at\n      ) VALUES (\n        p_booking_id,\n        p_idempotency_key,\n        v_table_ids,\n        v_window,\n        v_merge_allocation_id,\n        v_now\n      )\n      ON CONFLICT (booking_id, idempotency_key) DO NOTHING;\n    END IF;\n  END;\n  $function$;\n\n  ALTER FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid, timestamptz, timestamptz) OWNER TO postgres;\n  GRANT ALL ON FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid, timestamptz, timestamptz) TO service_role;\n\nEND;\n$$;\n"
    },
    {
      "path": "supabase/migrations/20251028034500_assign_tables_atomic_v2_alias_fix.sql",
      "content": "-- Ensure assign_tables_atomic_v2 uses qualified columns to avoid ambiguous references.\nDO $$\nBEGIN\n  CREATE OR REPLACE FUNCTION public.assign_tables_atomic_v2(\n    p_booking_id uuid,\n    p_table_ids uuid[],\n    p_idempotency_key text DEFAULT NULL,\n    p_require_adjacency boolean DEFAULT false,\n    p_assigned_by uuid DEFAULT NULL,\n    p_start_at timestamptz DEFAULT NULL,\n    p_end_at timestamptz DEFAULT NULL\n  ) RETURNS TABLE (\n    table_id uuid,\n    start_at timestamptz,\n    end_at timestamptz,\n    merge_group_id uuid\n  )\n  LANGUAGE plpgsql\n  SECURITY DEFINER\n  SET search_path = public\n  AS $function$\n  DECLARE\n    v_booking RECORD;\n    v_zone_id uuid;\n    v_restaurant_id uuid;\n    v_service_date date;\n    v_lock_zone int4;\n    v_lock_date int4;\n    v_now timestamptz := timezone('utc', now());\n    v_table_ids uuid[];\n    v_table_count integer;\n    v_table RECORD;\n    v_loaded_count integer := 0;\n    v_slot_id uuid := NULL;\n    v_start_at timestamptz;\n    v_end_at timestamptz;\n    v_window tstzrange;\n    v_timezone text := NULL;\n    v_hold_conflict uuid;\n    v_merge_allocation_id uuid := NULL;\n    v_table_assignment_id uuid;\n    v_existing RECORD;\n    v_adjacency_count integer;\n    v_table_id uuid;\n    v_merge_group_supported boolean := false;\n    v_conflict RECORD;\n  BEGIN\n    IF p_table_ids IS NULL OR array_length(p_table_ids, 1) = 0 THEN\n      RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one table id'\n        USING ERRCODE = '23514';\n    END IF;\n\n    SELECT array_agg(DISTINCT t.table_id ORDER BY t.table_id)\n    INTO v_table_ids\n    FROM unnest(p_table_ids) AS t(table_id);\n\n    IF v_table_ids IS NULL OR array_length(v_table_ids, 1) = 0 THEN\n      RAISE EXCEPTION 'assign_tables_atomic_v2 requires at least one valid table id'\n        USING ERRCODE = '23514';\n    END IF;\n\n    v_table_count := array_length(v_table_ids, 1);\n\n    SELECT\n      b.*,\n      r.timezone AS restaurant_timezone\n    INTO v_booking\n    FROM public.bookings b\n    LEFT JOIN public.restaurants r ON r.id = b.restaurant_id\n    WHERE b.id = p_booking_id\n    FOR UPDATE OF b;\n\n    IF NOT FOUND THEN\n      RAISE EXCEPTION 'Booking % not found', p_booking_id\n        USING ERRCODE = 'P0002';\n    END IF;\n\n    v_restaurant_id := v_booking.restaurant_id;\n    v_timezone := COALESCE(NULLIF(v_booking.restaurant_timezone, ''), 'UTC');\n\n    SELECT EXISTS (\n      SELECT 1\n      FROM information_schema.columns\n      WHERE table_schema = 'public'\n        AND table_name = 'booking_table_assignments'\n        AND column_name = 'merge_group_id'\n    )\n    INTO v_merge_group_supported;\n\n    IF (p_start_at IS NULL) <> (p_end_at IS NULL) THEN\n      RAISE EXCEPTION 'assign_tables_atomic_v2 requires both start and end when providing custom window'\n        USING ERRCODE = '22023';\n    END IF;\n\n    IF p_start_at IS NOT NULL AND p_end_at IS NOT NULL THEN\n      v_start_at := p_start_at;\n      v_end_at := p_end_at;\n    ELSIF v_booking.start_at IS NOT NULL AND v_booking.end_at IS NOT NULL THEN\n      v_start_at := v_booking.start_at;\n      v_end_at := v_booking.end_at;\n    ELSIF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL AND v_booking.end_time IS NOT NULL THEN\n      v_start_at := make_timestamptz(\n        EXTRACT(YEAR FROM v_booking.booking_date)::int,\n        EXTRACT(MONTH FROM v_booking.booking_date)::int,\n        EXTRACT(DAY FROM v_booking.booking_date)::int,\n        EXTRACT(HOUR FROM v_booking.start_time)::int,\n        EXTRACT(MINUTE FROM v_booking.start_time)::int,\n        EXTRACT(SECOND FROM v_booking.start_time),\n        v_timezone\n      );\n      v_end_at := make_timestamptz(\n        EXTRACT(YEAR FROM v_booking.booking_date)::int,\n        EXTRACT(MONTH FROM v_booking.booking_date)::int,\n        EXTRACT(DAY FROM v_booking.booking_date)::int,\n        EXTRACT(HOUR FROM v_booking.end_time)::int,\n        EXTRACT(MINUTE FROM v_booking.end_time)::int,\n        EXTRACT(SECOND FROM v_booking.end_time),\n        v_timezone\n      );\n    ELSE\n      RAISE EXCEPTION 'Booking % missing start/end window', p_booking_id\n        USING ERRCODE = '22000';\n    END IF;\n\n    IF v_start_at >= v_end_at THEN\n      RAISE EXCEPTION 'Booking % has invalid time window', p_booking_id\n        USING ERRCODE = '22000';\n    END IF;\n\n    v_window := tstzrange(v_start_at, v_end_at, '[)');\n\n    FOR v_table IN\n      SELECT id, restaurant_id, zone_id, active, status, mobility\n      FROM public.table_inventory\n      WHERE id = ANY (v_table_ids)\n      ORDER BY id\n      FOR UPDATE\n    LOOP\n      IF v_table.restaurant_id <> v_restaurant_id THEN\n        RAISE EXCEPTION 'Table % belongs to a different restaurant', v_table.id\n          USING ERRCODE = '23503';\n      END IF;\n\n      IF v_table.zone_id IS NULL THEN\n        RAISE EXCEPTION 'Table % is not assigned to a zone', v_table.id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_table.active IS NOT TRUE THEN\n        RAISE EXCEPTION 'Table % is inactive', v_table.id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_zone_id IS NULL THEN\n        v_zone_id := v_table.zone_id;\n      ELSIF v_zone_id <> v_table.zone_id THEN\n        RAISE EXCEPTION 'All tables must belong to the same zone (found %, expected %)', v_table.zone_id, v_zone_id\n          USING ERRCODE = '23514';\n      END IF;\n\n      IF v_table_count > 1 AND v_table.mobility <> 'movable'::public.table_mobility THEN\n        RAISE EXCEPTION 'Merged assignments require movable tables (% is %)', v_table.id, v_table.mobility\n          USING ERRCODE = '23514';\n      END IF;\n\n      v_loaded_count := v_loaded_count + 1;\n    END LOOP;\n\n    IF v_loaded_count <> v_table_count THEN\n      RAISE EXCEPTION 'Unable to load all requested tables for booking %', p_booking_id\n        USING ERRCODE = 'P0002';\n    END IF;\n\n    IF p_require_adjacency AND v_table_count > 1 THEN\n      FOR v_table IN\n        SELECT id FROM unnest(v_table_ids) AS t(id)\n      LOOP\n        SELECT COUNT(*)\n        INTO v_adjacency_count\n        FROM public.table_adjacencies\n        WHERE (\n            table_a = v_table.id\n            AND table_b = ANY (v_table_ids)\n            AND table_b <> v_table.id\n          )\n          OR (\n            table_b = v_table.id\n            AND table_a = ANY (v_table_ids)\n            AND table_a <> v_table.id\n          );\n\n        IF COALESCE(v_adjacency_count, 0) = 0 THEN\n          RAISE EXCEPTION 'Table % is not adjacent to the selected set', v_table.id\n            USING ERRCODE = '23514';\n        END IF;\n      END LOOP;\n    END IF;\n\n    v_service_date := (v_start_at AT TIME ZONE v_timezone)::date;\n\n    v_lock_zone := hashtext(COALESCE(v_zone_id::text, ''));\n    v_lock_date := COALESCE((v_service_date - DATE '2000-01-01')::int, 0);\n    PERFORM pg_advisory_xact_lock(v_lock_zone, v_lock_date);\n\n    IF p_idempotency_key IS NOT NULL THEN\n      SELECT *\n      INTO v_existing\n      FROM public.booking_assignment_idempotency\n      WHERE booking_id = p_booking_id\n        AND idempotency_key = p_idempotency_key;\n\n      IF FOUND THEN\n        IF v_existing.table_ids IS NULL OR array_length(v_existing.table_ids, 1) <> v_table_count\n           OR (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_existing.table_ids) AS e(elem))\n              <> (SELECT array_agg(elem ORDER BY elem) FROM unnest(v_table_ids) AS e(elem)) THEN\n          RAISE EXCEPTION 'assign_tables_atomic_v2 idempotency mismatch for booking %', p_booking_id\n            USING ERRCODE = 'P0003',\n                  DETAIL = 'Idempotency key reuse detected with a different table set';\n        END IF;\n\n        RETURN QUERY\n          SELECT\n            bta.table_id,\n            COALESCE(bta.start_at, lower(v_existing.assignment_window)) AS start_at,\n            COALESCE(bta.end_at, upper(v_existing.assignment_window)) AS end_at,\n            v_existing.merge_group_allocation_id\n          FROM public.booking_table_assignments bta\n          WHERE bta.booking_id = p_booking_id\n            AND bta.idempotency_key = p_idempotency_key\n            AND bta.table_id = ANY (v_table_ids)\n          ORDER BY bta.table_id;\n\n        RETURN;\n      END IF;\n    END IF;\n\n    SELECT th.id\n    INTO v_hold_conflict\n    FROM public.table_holds th\n    JOIN public.table_hold_members thm ON thm.hold_id = th.id\n    WHERE thm.table_id = ANY (v_table_ids)\n      AND th.expires_at > v_now\n      AND (th.booking_id IS NULL OR th.booking_id <> p_booking_id)\n      AND tstzrange(th.start_at, th.end_at, '[)') && v_window\n    LIMIT 1;\n\n    IF FOUND THEN\n      RAISE EXCEPTION 'Hold conflict prevents assignment for booking %', p_booking_id\n        USING ERRCODE = 'P0001',\n              DETAIL = format('Hold % overlaps requested window', v_hold_conflict),\n              HINT = 'Retry after hold expiration or confirm existing hold.';\n    END IF;\n\n    IF v_booking.booking_date IS NOT NULL AND v_booking.start_time IS NOT NULL THEN\n      SELECT id\n      INTO v_slot_id\n      FROM public.booking_slots\n      WHERE restaurant_id = v_restaurant_id\n        AND slot_date = v_booking.booking_date\n        AND slot_time = v_booking.start_time\n      LIMIT 1;\n\n      IF v_slot_id IS NULL THEN\n        SELECT public.get_or_create_booking_slot(v_restaurant_id, v_booking.booking_date, v_booking.start_time, 999)\n        INTO v_slot_id;\n      END IF;\n    END IF;\n\n    IF v_merge_group_supported AND v_table_count > 1 THEN\n      v_merge_allocation_id := gen_random_uuid();\n\n      BEGIN\n        INSERT INTO public.allocations (\n          id,\n          booking_id,\n          restaurant_id,\n          resource_type,\n          resource_id,\n          \"window\",\n          created_by,\n          shadow,\n          created_at,\n          updated_at\n        ) VALUES (\n          v_merge_allocation_id,\n          p_booking_id,\n          v_restaurant_id,\n          'merge_group',\n          v_merge_allocation_id,\n          v_window,\n          p_assigned_by,\n          false,\n          v_now,\n          v_now\n        )\n        ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n        SET \"window\" = EXCLUDED.\"window\",\n            created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n            updated_at = v_now;\n      EXCEPTION\n        WHEN unique_violation OR exclusion_violation THEN\n          RAISE EXCEPTION 'allocations_no_overlap'\n            USING ERRCODE = 'P0001',\n                  DETAIL = format('Merge group overlaps requested window for booking %s', p_booking_id);\n      END;\n    END IF;\n\n    FOREACH v_table_id IN ARRAY v_table_ids LOOP\n      SELECT\n        existing.booking_id,\n        existing.start_at,\n        existing.end_at\n      INTO v_conflict\n      FROM public.booking_table_assignments existing\n      WHERE existing.table_id = v_table_id\n        AND existing.booking_id <> p_booking_id\n        AND existing.start_at IS NOT NULL\n        AND existing.end_at IS NOT NULL\n        AND tstzrange(existing.start_at, existing.end_at, '[)') && v_window\n      LIMIT 1;\n\n      IF FOUND THEN\n        RAISE EXCEPTION 'assign_tables_atomic_v2 assignment overlap for table %', v_table_id\n          USING ERRCODE = 'P0001',\n                DETAIL = format('Existing booking %s occupies %s from %s to %s', v_conflict.booking_id, v_table_id, v_conflict.start_at, v_conflict.end_at),\n                HINT = 'Adjust assignment window or release the conflicting table.';\n      END IF;\n\n      v_conflict := NULL;\n\n      IF v_merge_group_supported THEN\n        BEGIN\n          INSERT INTO public.booking_table_assignments (\n            booking_id,\n            table_id,\n            slot_id,\n            assigned_by,\n            idempotency_key,\n            merge_group_id,\n            start_at,\n            end_at\n          ) VALUES (\n            p_booking_id,\n            v_table_id,\n            v_slot_id,\n            p_assigned_by,\n            p_idempotency_key,\n            v_merge_allocation_id,\n            v_start_at,\n            v_end_at\n          )\n        ON CONFLICT ON CONSTRAINT booking_table_assignments_booking_table_key DO UPDATE\n          SET assigned_at = v_now,\n              assigned_by = COALESCE(EXCLUDED.assigned_by, public.booking_table_assignments.assigned_by),\n              idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n              merge_group_id = COALESCE(EXCLUDED.merge_group_id, public.booking_table_assignments.merge_group_id),\n              slot_id = COALESCE(EXCLUDED.slot_id, public.booking_table_assignments.slot_id),\n              start_at = EXCLUDED.start_at,\n              end_at = EXCLUDED.end_at,\n              updated_at = v_now\n          RETURNING id INTO v_table_assignment_id;\n        EXCEPTION\n          WHEN unique_violation THEN\n            UPDATE public.booking_table_assignments AS bta\n              SET assigned_at = v_now,\n                  assigned_by = COALESCE(p_assigned_by, bta.assigned_by),\n                  idempotency_key = COALESCE(p_idempotency_key, bta.idempotency_key),\n                  merge_group_id = COALESCE(v_merge_allocation_id, bta.merge_group_id),\n                  slot_id = COALESCE(v_slot_id, bta.slot_id),\n                  start_at = v_start_at,\n                  end_at = v_end_at,\n                  updated_at = v_now\n            WHERE bta.booking_id = p_booking_id\n              AND bta.table_id = v_table_id\n            RETURNING bta.id INTO v_table_assignment_id;\n\n            IF NOT FOUND THEN\n              RAISE EXCEPTION 'assign_tables_atomic_v2 assignment duplicate for table %', v_table_id\n                USING ERRCODE = 'P0001';\n            END IF;\n        END;\n      ELSE\n        BEGIN\n          INSERT INTO public.booking_table_assignments (\n            booking_id,\n            table_id,\n            slot_id,\n            assigned_by,\n            idempotency_key,\n            start_at,\n            end_at\n          ) VALUES (\n            p_booking_id,\n            v_table_id,\n            v_slot_id,\n            p_assigned_by,\n            p_idempotency_key,\n            v_start_at,\n            v_end_at\n          )\n          ON CONFLICT ON CONSTRAINT booking_table_assignments_booking_table_key DO UPDATE\n          SET assigned_at = v_now,\n              assigned_by = COALESCE(EXCLUDED.assigned_by, public.booking_table_assignments.assigned_by),\n              idempotency_key = COALESCE(EXCLUDED.idempotency_key, public.booking_table_assignments.idempotency_key),\n              slot_id = COALESCE(EXCLUDED.slot_id, public.booking_table_assignments.slot_id),\n              start_at = EXCLUDED.start_at,\n              end_at = EXCLUDED.end_at,\n              updated_at = v_now\n          RETURNING id INTO v_table_assignment_id;\n        EXCEPTION\n          WHEN unique_violation THEN\n            UPDATE public.booking_table_assignments AS bta\n              SET assigned_at = v_now,\n                  assigned_by = COALESCE(p_assigned_by, bta.assigned_by),\n                  idempotency_key = COALESCE(p_idempotency_key, bta.idempotency_key),\n                  slot_id = COALESCE(v_slot_id, bta.slot_id),\n                  start_at = v_start_at,\n                  end_at = v_end_at,\n                  updated_at = v_now\n            WHERE bta.booking_id = p_booking_id\n              AND bta.table_id = v_table_id\n            RETURNING bta.id INTO v_table_assignment_id;\n\n            IF NOT FOUND THEN\n              RAISE EXCEPTION 'assign_tables_atomic_v2 assignment duplicate for table %', v_table_id\n                USING ERRCODE = 'P0001';\n            END IF;\n        END;\n      END IF;\n\n      BEGIN\n        INSERT INTO public.allocations (\n          booking_id,\n          restaurant_id,\n          resource_type,\n          resource_id,\n          \"window\",\n          created_by,\n          shadow,\n          created_at,\n          updated_at\n        ) VALUES (\n          p_booking_id,\n          v_restaurant_id,\n          'table',\n          v_table_id,\n          v_window,\n          p_assigned_by,\n          false,\n          v_now,\n          v_now\n        )\n        ON CONFLICT ON CONSTRAINT allocations_booking_resource_key DO UPDATE\n        SET \"window\" = EXCLUDED.\"window\",\n            created_by = COALESCE(EXCLUDED.created_by, public.allocations.created_by),\n            updated_at = v_now;\n      EXCEPTION\n        WHEN unique_violation OR exclusion_violation THEN\n          RAISE EXCEPTION 'allocations_no_overlap'\n            USING ERRCODE = 'P0001',\n                  DETAIL = format('Resource %s overlaps requested window for booking %s', v_table_id, p_booking_id);\n      END;\n\n      PERFORM public.refresh_table_status(v_table_id);\n\n      table_id := v_table_id;\n      start_at := v_start_at;\n      end_at := v_end_at;\n      merge_group_id := CASE WHEN v_merge_group_supported THEN v_merge_allocation_id ELSE NULL END;\n      RETURN NEXT;\n    END LOOP;\n\n    IF p_idempotency_key IS NOT NULL THEN\n      INSERT INTO public.booking_assignment_idempotency (\n        booking_id,\n        idempotency_key,\n        table_ids,\n        assignment_window,\n        merge_group_allocation_id,\n        created_at\n      ) VALUES (\n        p_booking_id,\n        p_idempotency_key,\n        v_table_ids,\n        v_window,\n        v_merge_allocation_id,\n        v_now\n      )\n      ON CONFLICT (booking_id, idempotency_key) DO NOTHING;\n    END IF;\n  END;\n  $function$;\n\n  ALTER FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid, timestamptz, timestamptz) OWNER TO postgres;\n  GRANT ALL ON FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid, timestamptz, timestamptz) TO service_role;\nEND;\n$$;\n"
    },
    {
      "path": "supabase/migrations/20251028064000_drop_booking_id_idempotency_unique.sql",
      "content": "-- Drop the partial unique index that prevents multi-table assignments sharing the same idempotency key.\n-- The allocator relies on booking_assignment_idempotency for dedupe; enforcing uniqueness here causes\n-- assign_tables_atomic_v2 to explode when inserting multiple records per booking/key.\nDO $$\nBEGIN\n  IF EXISTS (\n    SELECT 1\n    FROM pg_indexes\n    WHERE schemaname = 'public'\n      AND indexname = 'booking_table_assignments_booking_id_idempotency_key_key'\n  ) THEN\n    EXECUTE 'DROP INDEX public.booking_table_assignments_booking_id_idempotency_key_key';\n  END IF;\nEND;\n$$;\n"
    },
    {
      "path": "supabase/migrations/20251029183500_hold_windows_and_availability.sql",
      "content": "-- Enable necessary extensions\nCREATE EXTENSION IF NOT EXISTS btree_gist;\n\n-- Create table to track hold windows per table\nCREATE TABLE IF NOT EXISTS public.table_hold_windows (\n  hold_id uuid NOT NULL,\n  table_id uuid NOT NULL,\n  restaurant_id uuid NOT NULL,\n  booking_id uuid,\n  start_at timestamptz NOT NULL,\n  end_at timestamptz NOT NULL,\n  expires_at timestamptz NOT NULL,\n  hold_window tstzrange GENERATED ALWAYS AS (tstzrange(start_at, end_at, '[)')) STORED,\n  CONSTRAINT table_hold_windows_pkey PRIMARY KEY (hold_id, table_id)\n);\n\nALTER TABLE public.table_hold_windows\n  ADD CONSTRAINT table_hold_windows_hold_id_fkey\n  FOREIGN KEY (hold_id) REFERENCES public.table_holds(id) ON DELETE CASCADE;\n\nALTER TABLE public.table_hold_windows\n  ADD CONSTRAINT table_hold_windows_table_id_fkey\n  FOREIGN KEY (table_id) REFERENCES public.table_inventory(id) ON DELETE CASCADE;\n\nCREATE INDEX IF NOT EXISTS table_hold_windows_table_idx\n  ON public.table_hold_windows (table_id);\n\nCREATE INDEX IF NOT EXISTS table_hold_windows_restaurant_idx\n  ON public.table_hold_windows (restaurant_id);\n\nALTER TABLE public.table_hold_windows\n  ADD CONSTRAINT table_hold_windows_no_overlap\n  EXCLUDE USING gist (\n    table_id WITH =,\n    hold_window WITH &&\n  );\n\nCREATE OR REPLACE FUNCTION public.is_holds_strict_conflicts_enabled()\nRETURNS boolean\nLANGUAGE plpgsql\nAS $$\nDECLARE\n  setting text;\nBEGIN\n  BEGIN\n    setting := current_setting('app.holds.strict_conflicts.enabled', true);\n  EXCEPTION\n    WHEN others THEN\n      setting := NULL;\n  END;\n\n  IF setting IS NULL THEN\n    RETURN FALSE;\n  END IF;\n\n  RETURN lower(setting) IN ('1', 't', 'true', 'on', 'enabled');\nEND;\n$$;\n\nCREATE OR REPLACE FUNCTION public.set_hold_conflict_enforcement(enabled boolean)\nRETURNS boolean\nLANGUAGE plpgsql\nAS $$\nBEGIN\n  PERFORM set_config(\n    'app.holds.strict_conflicts.enabled',\n    CASE WHEN enabled THEN 'on' ELSE 'off' END,\n    true\n  );\n  RETURN enabled;\nEND;\n$$;\n\n-- Trigger helpers to keep table in sync\nCREATE OR REPLACE FUNCTION public.sync_table_hold_windows()\nRETURNS trigger\nLANGUAGE plpgsql\nAS $$\nBEGIN\n  IF TG_OP = 'DELETE' THEN\n    DELETE FROM public.table_hold_windows\n    WHERE hold_id = OLD.hold_id AND table_id = OLD.table_id;\n    RETURN OLD;\n  END IF;\n\n  IF NOT public.is_holds_strict_conflicts_enabled() THEN\n    RETURN NEW;\n  END IF;\n\n  IF TG_OP = 'INSERT' THEN\n    INSERT INTO public.table_hold_windows (hold_id, table_id, restaurant_id, booking_id, start_at, end_at, expires_at)\n    SELECT NEW.hold_id, NEW.table_id, h.restaurant_id, h.booking_id, h.start_at, h.end_at, h.expires_at\n    FROM public.table_holds h\n    WHERE h.id = NEW.hold_id\n    ON CONFLICT (hold_id, table_id) DO UPDATE\n      SET start_at = EXCLUDED.start_at,\n          end_at = EXCLUDED.end_at,\n          expires_at = EXCLUDED.expires_at,\n          restaurant_id = EXCLUDED.restaurant_id,\n          booking_id = EXCLUDED.booking_id;\n    RETURN NEW;\n  END IF;\n  RETURN NEW;\nEND;\n$$;\n\nCREATE OR REPLACE FUNCTION public.update_table_hold_windows()\nRETURNS trigger\nLANGUAGE plpgsql\nAS $$\nBEGIN\n  IF NOT public.is_holds_strict_conflicts_enabled() THEN\n    RETURN NEW;\n  END IF;\n\n  UPDATE public.table_hold_windows\n  SET start_at = NEW.start_at,\n      end_at = NEW.end_at,\n      expires_at = NEW.expires_at,\n      restaurant_id = NEW.restaurant_id,\n      booking_id = NEW.booking_id\n  WHERE hold_id = NEW.id;\n  RETURN NEW;\nEND;\n$$;\n\nDROP TRIGGER IF EXISTS table_hold_members_sync_insert ON public.table_hold_members;\nDROP TRIGGER IF EXISTS table_hold_members_sync_delete ON public.table_hold_members;\nDROP TRIGGER IF EXISTS table_holds_sync_update ON public.table_holds;\n\nCREATE TRIGGER table_hold_members_sync_insert\nAFTER INSERT ON public.table_hold_members\nFOR EACH ROW EXECUTE FUNCTION public.sync_table_hold_windows();\n\nCREATE TRIGGER table_hold_members_sync_delete\nAFTER DELETE ON public.table_hold_members\nFOR EACH ROW EXECUTE FUNCTION public.sync_table_hold_windows();\n\nCREATE TRIGGER table_holds_sync_update\nAFTER UPDATE OF start_at, end_at, expires_at, restaurant_id, booking_id ON public.table_holds\nFOR EACH ROW EXECUTE FUNCTION public.update_table_hold_windows();\n\n-- SQL helper to evaluate availability in the database\nCREATE OR REPLACE FUNCTION public.is_table_available_v2(\n  p_table_id uuid,\n  p_start_at timestamptz,\n  p_end_at timestamptz,\n  p_exclude_booking_id uuid DEFAULT NULL\n) RETURNS boolean\nLANGUAGE sql\nSTABLE\nAS $$\nSELECT NOT EXISTS (\n  SELECT 1\n  FROM public.booking_table_assignments bta\n  JOIN public.bookings b ON b.id = bta.booking_id\n  WHERE bta.table_id = p_table_id\n    AND tstzrange(bta.start_at, bta.end_at, '[)') && tstzrange(p_start_at, p_end_at, '[)')\n    AND (p_exclude_booking_id IS NULL OR b.id <> p_exclude_booking_id)\n    AND b.status IN ('pending', 'confirmed', 'checked_in')\n);\n$$;\n"
    },
    {
      "path": "supabase/migrations/20251030142300_add_yield_management_tables.sql",
      "content": "-- Migration: Add demand profiles and table scarcity metrics for yield management\n-- Created: 2025-10-30 14:23 UTC\n\nBEGIN;\n\n-- Create the update_updated_at_column function if it doesn't exist\nCREATE OR REPLACE FUNCTION public.update_updated_at_column()\nRETURNS TRIGGER AS $$\nBEGIN\n    NEW.updated_at = now();\n    RETURN NEW;\nEND;\n$$ language 'plpgsql';\n\n-- Create demand_profiles table\nCREATE TABLE public.demand_profiles (\n    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\n    restaurant_id uuid NOT NULL REFERENCES public.restaurants(id) ON DELETE CASCADE,\n    day_of_week smallint NOT NULL CHECK (day_of_week BETWEEN 0 AND 6), -- 0=Sunday, 6=Saturday\n    service_window text NOT NULL CHECK (service_window IN ('lunch', 'drinks', 'dinner', 'christmas_party', 'curry_and_carols')),\n    multiplier numeric(3,2) NOT NULL DEFAULT 1.0 CHECK (multiplier >= 0.1 AND multiplier <= 10.0),\n    created_at timestamptz NOT NULL DEFAULT now(),\n    updated_at timestamptz NOT NULL DEFAULT now()\n);\n\n-- Indexes for demand_profiles\nCREATE INDEX idx_demand_profiles_restaurant_day_window ON public.demand_profiles(restaurant_id, day_of_week, service_window);\nCREATE INDEX idx_demand_profiles_updated_at ON public.demand_profiles(updated_at);\n\n-- RLS for demand_profiles\nALTER TABLE public.demand_profiles ENABLE ROW LEVEL SECURITY;\n\n-- Policy: Allow authenticated users to read demand profiles for their restaurants\nCREATE POLICY \"Users can view demand profiles for their restaurants\" ON public.demand_profiles\n    FOR SELECT USING (\n        EXISTS (\n            SELECT 1 FROM public.restaurant_memberships rm\n            WHERE rm.restaurant_id = demand_profiles.restaurant_id\n            AND rm.user_id = auth.uid()\n        )\n    );\n\n-- Policy: Allow owners/managers to manage demand profiles\nCREATE POLICY \"Owners and managers can manage demand profiles\" ON public.demand_profiles\n    FOR ALL USING (\n        EXISTS (\n            SELECT 1 FROM public.restaurant_memberships rm\n            WHERE rm.restaurant_id = demand_profiles.restaurant_id\n            AND rm.user_id = auth.uid()\n            AND rm.role IN ('owner', 'manager')\n        )\n    );\n\n-- Create table_scarcity_metrics table\nCREATE TABLE public.table_scarcity_metrics (\n    id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\n    restaurant_id uuid NOT NULL REFERENCES public.restaurants(id) ON DELETE CASCADE,\n    table_type text NOT NULL, -- e.g., '2-seater', 'booth', 'patio', 'private'\n    scarcity_score numeric(5,4) NOT NULL CHECK (scarcity_score >= 0 AND scarcity_score <= 1),\n    computed_at timestamptz NOT NULL DEFAULT now()\n);\n\n-- Unique constraint on restaurant_id + table_type\nALTER TABLE public.table_scarcity_metrics ADD CONSTRAINT unique_restaurant_table_type UNIQUE (restaurant_id, table_type);\n\n-- Indexes for table_scarcity_metrics\nCREATE INDEX idx_table_scarcity_metrics_restaurant_type ON public.table_scarcity_metrics(restaurant_id, table_type);\nCREATE INDEX idx_table_scarcity_metrics_computed_at ON public.table_scarcity_metrics(computed_at);\n\n-- RLS for table_scarcity_metrics\nALTER TABLE public.table_scarcity_metrics ENABLE ROW LEVEL SECURITY;\n\n-- Policy: Allow authenticated users to read scarcity metrics for their restaurants\nCREATE POLICY \"Users can view scarcity metrics for their restaurants\" ON public.table_scarcity_metrics\n    FOR SELECT USING (\n        EXISTS (\n            SELECT 1 FROM public.restaurant_memberships rm\n            WHERE rm.restaurant_id = table_scarcity_metrics.restaurant_id\n            AND rm.user_id = auth.uid()\n        )\n    );\n\n-- Policy: Allow owners/managers to manage scarcity metrics\nCREATE POLICY \"Owners and managers can manage scarcity metrics\" ON public.table_scarcity_metrics\n    FOR ALL USING (\n        EXISTS (\n            SELECT 1 FROM public.restaurant_memberships rm\n            WHERE rm.restaurant_id = table_scarcity_metrics.restaurant_id\n            AND rm.user_id = auth.uid()\n            AND rm.role IN ('owner', 'manager')\n        )\n    );\n\n-- Grant permissions\nGRANT SELECT, INSERT, UPDATE, DELETE ON public.demand_profiles TO authenticated;\nGRANT SELECT, INSERT, UPDATE, DELETE ON public.table_scarcity_metrics TO authenticated;\n\n-- Update updated_at trigger for demand_profiles\nCREATE TRIGGER update_demand_profiles_updated_at\n    BEFORE UPDATE ON public.demand_profiles\n    FOR EACH ROW EXECUTE FUNCTION public.update_updated_at_column();\n\nCOMMIT;"
    },
    {
      "path": "supabase/migrations/20251101093000_create_strategic_configs.sql",
      "content": "-- Placeholder migration for strategic configuration storage.\n-- NOTE: Per AGENTS.md, apply remotely via Supabase CLI; do not run locally.\n\n-- Strategic configs allow per-restaurant overrides for scarcity weights and related penalties.\n-- Schema:\n--   id UUID primary key (default gen_random_uuid())\n--   restaurant_id UUID nullable references public.restaurants(id) on delete cascade\n--   scarcity_weight NUMERIC(8,2) not null default 22\n--   demand_multiplier_override NUMERIC(8,3)\n--   future_conflict_penalty NUMERIC(10,2)\n--   updated_at TIMESTAMPTZ not null default timezone('utc', now())\n--   updated_by UUID null references auth.users(id)\n-- Constraints:\n--   UNIQUE partial index on restaurant_id when not null\n--   Optional global row (restaurant_id null)\n\n-- RLS policies should limit updates to restaurant admins via service role.\n\n-- Example DDL (apply remotely):\n-- CREATE TABLE public.strategic_configs (\n--   id uuid PRIMARY KEY DEFAULT gen_random_uuid(),\n--   restaurant_id uuid REFERENCES public.restaurants(id) ON DELETE CASCADE,\n--   scarcity_weight numeric(8,2) NOT NULL DEFAULT 22,\n--   demand_multiplier_override numeric(8,3),\n--   future_conflict_penalty numeric(10,2),\n--   updated_at timestamptz NOT NULL DEFAULT timezone('utc', now()),\n--   updated_by uuid\n-- );\n--\n-- CREATE INDEX strategic_configs_restaurant_id_idx\n--   ON public.strategic_configs(restaurant_id)\n--   WHERE restaurant_id IS NOT NULL;\n--\n-- ALTER TABLE public.strategic_configs ENABLE ROW LEVEL SECURITY;\n"
    },
    {
      "path": "supabase/migrations/20251103090400_refactor_assignment_procedures.sql",
      "content": "-- MIGRATION 20251103090400: CONSOLIDATE TABLE ASSIGNMENT PROCEDURES\n-- Provides explicit single-/multi-table assignment entrypoints and documents legacy RPC deprecation.\n\nSET search_path TO public;\n\n-- Explicit single-table wrapper with clear intent.\nCREATE OR REPLACE FUNCTION public.assign_single_table(\n  p_booking_id uuid,\n  p_table_id uuid,\n  p_assigned_by uuid DEFAULT NULL,\n  p_idempotency_key text DEFAULT NULL\n) RETURNS void\nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path TO public\nAS $$\nBEGIN\n  IF p_table_id IS NULL THEN\n    RAISE EXCEPTION 'assign_single_table requires a table id.';\n  END IF;\n\n  PERFORM public.assign_tables_atomic_v2(\n    p_booking_id := p_booking_id,\n    p_table_ids := ARRAY[p_table_id],\n    p_idempotency_key := p_idempotency_key,\n    p_require_adjacency := false,\n    p_assigned_by := p_assigned_by\n  );\nEND;\n$$;\n\nCOMMENT ON FUNCTION public.assign_single_table(uuid, uuid, uuid, text)\n  IS 'Atomically assigns a single table to a booking; preferred entrypoint for standard seating.';\n\n-- Explicit merged-table wrapper for large parties.\nCREATE OR REPLACE FUNCTION public.assign_merged_tables(\n  p_booking_id uuid,\n  p_table_ids uuid[],\n  p_require_adjacency boolean DEFAULT true,\n  p_assigned_by uuid DEFAULT NULL,\n  p_idempotency_key text DEFAULT NULL\n) RETURNS void\nLANGUAGE plpgsql\nSECURITY DEFINER\nSET search_path TO public\nAS $$\nDECLARE\n  v_table_count integer;\nBEGIN\n  v_table_count := COALESCE(array_length(p_table_ids, 1), 0);\n\n  IF v_table_count < 2 THEN\n    RAISE EXCEPTION 'assign_merged_tables requires at least two table ids.';\n  END IF;\n\n  PERFORM public.assign_tables_atomic_v2(\n    p_booking_id := p_booking_id,\n    p_table_ids := p_table_ids,\n    p_idempotency_key := p_idempotency_key,\n    p_require_adjacency := p_require_adjacency,\n    p_assigned_by := p_assigned_by\n  );\nEND;\n$$;\n\nCOMMENT ON FUNCTION public.assign_merged_tables(uuid, uuid[], boolean, uuid, text)\n  IS 'Atomically assigns multiple tables to a booking with optional adjacency enforcement.';\n\n-- Document legacy entrypoints as deprecated without altering behaviour.\nDO $$\nBEGIN\n  EXECUTE 'COMMENT ON FUNCTION public.assign_tables_atomic(uuid, uuid[], tstzrange, uuid, text) IS ''DEPRECATED: prefer assign_single_table() or assign_merged_tables().''';\n  EXECUTE 'COMMENT ON FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid) IS ''DEPRECATED: prefer assign_single_table() or assign_merged_tables().''';\n  EXECUTE 'COMMENT ON FUNCTION public.assign_tables_atomic_v2(uuid, uuid[], text, boolean, uuid, timestamp with time zone, timestamp with time zone) IS ''DEPRECATED: prefer assign_single_table() or assign_merged_tables().''';\nEND $$;\n"
    }
  ]
}
